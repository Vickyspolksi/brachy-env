Mortran 3.2 Tue Aug 19 16:00:01 2025
               0  %L                                                                     ;
1              0  %E
               0  %I4                                                                    ;
               0  !INDENT F2;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  "#############################################################################"
               0  "                                                                             "
               0  " EGSnrc machine dependent macro file for linux                               "
               0  "                                                                             "
               0  " Created by configure version 2.0 on mar 19 ago 2025 15:59:50 -03            "
               0  "                                                                             "
               0  " You may add your own machine dependent macros to this file,                 "
               0  " but be carefull to not overwrite it if you re-run configure.                "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0  REPLACE {$MACHINE} WITH
               0  {,'linux',};
               0  REPLACE {$HEN_HOUSE} WITH
               0  {'/home/usuario/EGSnrc_CLRP/HEN_HOUSE/'};
               0  REPLACE {$CANONICAL_SYSTEM} WITH
               0  {'x86_64-unknown-linux-gnu'};
               0  REPLACE {$CONFIGURATION_NAME} WITH
               0  {'linux'};
               0  REPLACE {$EGS_CONFIG} WITH
               0  {'/home/usuario/EGSnrc_CLRP/HEN_HOUSE/specs/linux.conf'};
               0
               0  REPLACE {$CONFIG_TIME} WITH
               0  {'2025-08-19 18:59:50 UTC'};
               0
               0  " System dependent stuff "
               0  "========================================"
               0  " Unfortunately, there appears to be no reliable way of copying files "
               0  " under Fortran => we use a system call for this"
               0  REPLACE {$copy_file} WITH {'cp '};
               0
               0  " Although one can move files using Fortran's intrinsic rename, "
               0  " we don't know whether the user has not created additional files in "
               0  " the temporary working directory => it is easiest to use a system call "
               0  " to move all files from the temporary working directory to the user-code "
               0  " directory. "
               0  REPLACE {$move_file} WITH {'mv -f '};
               0
               0  " There appears to be no way of removing a directory from Fortran "
               0  " => we use a system call for this. "
               0  REPLACE {$remove_directory} WITH {'rm -rf '};
               0
               0  " The directory separator "
               0  REPLACE {$file_sep} WITH {'/'};
               0
               0  REPLACE {$LONG_INT} WITH { integer*8 };
               0  REPLACE {$SHORT_INT} WITH { integer*2 };
               0  "$MAX_INT SET TO 2^63-1 in egsnrc.macros"
               0  "The machine byte order"
               0  REPLACE {$BYTE_ORDER} WITH {'1234'};
               0  ;
               0  REPLACE {$RECL-FACTOR} WITH {4};
               0  ;
               0  REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
               0  ;
               0  " If you want your user-code to return an exit status, use the "
               0  " following macro to terminate execution"
               0  REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
               0  ;
               0  " mortran3 gets confused by the # char => we need to pass it as an "
               0  " argument to the macro. "
               0  REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
               0  ;
               0  REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc statdose utility source code                                        "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Jiangshen Sun, 1991                                       "
               0  "                   Bruce Faddegon, 1991                                      "
               0  "                   H.C.E. McGowan, 1992                                      "
               0  "                                                                             "
               0  "  Contributors:    Charlie Ma                                                "
               0  "                   Blake Walters                                             "
               0  "                   Dave Rogers                                               "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %L                                                                             ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  %I4                                                                            ;
               0  !INDENT F2;
               0  !INDENT M2;
               0  "==============================================================================
               0  "                              statdose.mortran
               0  "                              ****************
               0  "
               0  "    A programme to read 3-d dose data from DOSXYZ and plot using XVGR
               0  "    This version is finalized after many chages in the scripts 'statdose',
               0  "    'compile_statdose', and Fortran source file plot_xvgr    C-M Ma
               0  "==============================================================================
               0  "
               0  "    Version 1.0    J. Sun and B. Faddegon,  H.C.E. McGowan and B. Faddegon
               0  "    Version 2.0    Apr. 1995    CMa   This working version
               0  "    Version 2.1    Oct. 1996    B Walters
               0  "
               0  "==============================================================================
               0
               0  " History:
               0  "
               0  " PLOTDOSE:  Routine to plot dose bounds calculated by XYZDOS
               0  " and output to .egs4plot file.
               0  " J. Sun and B. Faddegon, Nov. 1991.
               0
               0  " STATDOSE: Program with options:
               0  " Read, Statistical Analysis, Normalization, Rebinning, Plot and Save
               0  " for dose distributions generated by DOSXYZ
               0
               0  " H.C.E. McGowan and B.A. Faddegon, May/June/July 1992.
               0
               0  " C.M. Ma April 1995 modifications to work on the SGI, SUN and other machines,
               0  " necessary changes for the new SGI operating system and file system, and
               0  " completion of statdose directory which includes all the files and programmes
               0  " required and a brief introduction.
               0  "
               0  " B Walters, Oct. 1996: modified so that the code uses the generic
               0  " XVGRPLOT subroutine along with a subroutine called XVGR_SCRIPT to
               0  " write data in a format readable by xvgr/xmgr and then call xvgr/xmgr.
               0  " Formerly, the subroutine PLOT_XVGR used to do this.  In doing so,
               0  " X,Y,ERRY became 1-D arrays from 2-D, and CURVE_SPECS (not currently
               0  " used with this mod), CURVE_LABELS, and NPOINTS became single variables
               0  " from 1-D arrays.
               0  " Dec 1997 DWOR  Made dimensions in x,y,z independently variable
               0  "   so can handle large arrays.
               0  "
               0  " INPUT DATA NEEDED: DOSE(X,Y,Z), ERRDOSE(X,Y,Z)
               0  "----------------------------------------------------------------------
               0  "----------------------------------------------------------------------
               0  " THE READING OF THE RULES (MACRO DEFINITIONS)
               0  "----------------------------------------------------------------------
               0  " COMMON BLOCK MACROS
               0  " COMMON BLOCK #1 - DATA1 - essential variables used in all subroutines
               0  " CALLED FROM: MAINMENU,READDOSE,REBINNING,PLOTMENU,PLOTDOSE,COMPAREPLOT,SAVE
               0  ;
               0
               0  "We need the $REAL, $INTEGER and $LOGICAL macros "
               0  REPLACE {$REAL} WITH {real*4}
               0  REPLACE {$INTEGER} WITH {integer*4}
               0  REPLACE {$LOGICAL} WITH {logical}
               0
               0  "REPLACE{$DEBUG}WITH{.true.};
               0  REPLACE{$DEBUG}WITH{.false.};
               0
               0  REPLACE {$COMIN1/DATA/} WITH {
            {  0  "=============================="
            {  0  COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY;
            {  0  INTEGER N,NDIST1_FLAG($NDIST1_MAX),NFLAG,NUMCHAR;
            {  0  CHARACTER*1 REPLY;
            {  0  };
               0
               0  " COMMON BLOCK #2 - DATA2 - variables which are not necessary in the
               0  " menu routines, but are essential in the actual subroutines executing
               0  " the various headings found in the menus
               0  " CALLED FROM: READDOSE,REBINNING,PLOTDOSE,COMPAREPLOT,SAVE
               0
               0  REPLACE {$COMIN2/DATA/} WITH {
            {  0  "=============================="
            {  0  COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX,
            {  0  ICOUNT,INTX,INTY,INTZ,ISTR,JSTR,LA_AXIS,LTOT,
            {  0  MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR,NPOINTS,IOPTION,NTYPE_SYMBOL,
            {  0  NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBIN_DIFF,DOSE,ERRDOSE,ERRY,
            {  0  FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR,TOTALNORM,
            {  0  XCOORD,YCOORD,ZCOORD,
            {  0  XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_MEAS,
            {  0  CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
            {  0  OUTFILE;
            {  0
            {  0  INTEGER I,J,K,L,M;
            {  0  INTEGER I0, J0, K0;
            {  0  INTEGER IMAX($NDIST1_MAX),JMAX($NDIST1_MAX),KMAX($NDIST1_MAX);
            {  0  INTEGER ICOUNT;
            {  0  INTEGER INTX,INTY,INTZ;
            {  0  INTEGER ISTR,JSTR;
            {  0  INTEGER LA_AXIS;
            {  0  INTEGER LTOT;
            {  0  INTEGER MAX_CURVE, NCURVE;
            {  0  INTEGER NDIST1,NDIST2;
            {  0  INTEGER NUM_ARR(10);
            {  0  INTEGER NPOINTS,IOPTION(4);
            {  0  INTEGER NTYPE_SYMBOL,NTYPE_CURVE;
            {  0
            {  0  REAL AXISDOSE($NDIST1_MAX,$MAXVOXEL);
            {  0  REAL DDBIN_CHI;
            {  0  REAL DDBIN_DIFF;
            {  0  REAL DOSE($NDIST1_MAX,$MAXVOXX,$MAXVOXY,$MAXVOXZ);
            {  0  REAL ERRDOSE($NDIST1_MAX,$MAXVOXX,$MAXVOXY,$MAXVOXZ);
            {  0  REAL ERRY($MAXPOINTS);
            {  0  REAL FREQ_CHI($MAXPOINTS);
            {  0  REAL FREQ_DIFF($MAXPOINTS);
            {  0  REAL PROFILEDOSE($MAXVOXEL+1),PROFILERR($MAXVOXEL+1);
            {  0  REAL TOTALNORM($NDIST1_MAX);
            {  0  REAL XCOORD, YCOORD, ZCOORD;
            {  0  REAL XBOUND($NDIST1_MAX,$MAXVOXX+1),YBOUND($NDIST1_MAX,$MAXVOXY+1),
            {  0  ZBOUND($NDIST1_MAX,$MAXVOXZ+1);
            {  0  REAL X($MAXPOINTS),Y($MAXPOINTS);
            {  0  REAL VOXEL_MEAS;
            {  0
            {  0  CHARACTER*60 CURVE_LABELS;
            {  0  CHARACTER*2 CURVE_SPECS;
            {  0  CHARACTER*70 FILEIN($NDIST1_MAX);
            {  0  CHARACTER*($MAXCURVE) THE_STRING;
            {  0  CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE;
            {  0  };
               0
               0  " PARAMETER MACROS
               0
               0  " - maximum number of data sets which can be stored in the program arrays
               0  " - note that 5 is about the largest number of curves able to be stored
               0  " without sending the array size out of this world
               0
               0  REPLACE {$NDIST1_MAX} WITH {15};  "Was 5  DR "
               0
               0  " - maximum number of curves which can be plotted
               0  " - this doesn't have to correspond to $NDIST1_MAX because
               0  " theoretically, one can plot 20 curves from one data set
               0  REPLACE {$MAXCURVE} WITH {10};
               0
               0  " - maximum number of points in one curve I think which can be plotted
               0  REPLACE {$MAXPOINTS} WITH {400};
               0
               0  " - maximum number of voxels in each direction which can be used
               0  REPLACE {$MAXVOXX} WITH {128};
               0  REPLACE {$MAXVOXY} WITH {128};
               0  REPLACE {$MAXVOXZ} WITH {128};
               0  REPLACE {$MAXVOXEL} WITH {128};  "Note: MAXVOLXEL must be the greatest of "
               0  "the above 3 values!!"
               0  "Note the main arrays are dimensioned $NDIST1_MAX*$MAXVOXX*$MAXVOXY*$MAXVOXZ"
               0  "2 x 128 x 128 x64 compiles under linux at NRC, but NOT SGI with 80MByte"
               0
               0  " - maximum number of files which can be accessed (limit set simply for memory
               0  " allocation purposes, if necessary this can be bigger)
               0  REPLACE {$MAXFILE} WITH {40};
               0
               0
               0  " $OUT_THE_BOUNDS prints out the boundary values of the 3ddose array
               0  " in the desired direction
               0  " CALLED FROM: READDOSE,REBINNING
               0
               0  REPLACE {$OUT_THE_BOUNDS(#,#,#);} WITH {;
            {  0  "=========================================="
            {  0
            {  0  OUTPUT {P2}BOUND({P3},1),{P2}BOUND({P3},{P1}MAX({P3})+1);
            {  0  (1X,'Voxel-boundary values in {P2}-direction: ' ,F10.2,2X,'-',F7.2);
            {  0  };
               0
               0  " $CHECK_BOUNDS checks the binning structures for two distributions
               0  " - if the binning structures are not alike, it prompts the user to select
               0  " two different files
               0
               0  " - if the binning structures are alike, it allows the program to continue
               0  "CALLED FROM: STATS
               0
               0  REPLACE {$CHECK_BOUNDS(#,#);} WITH {;
            {  0  "======================================"
            {  0
            {  0  " - check that the distributions have an identical number of voxels "
            {  0  IF {P1}MAX(NDIST1).NE.{P1}MAX(NDIST2) [
            {  0  OUTPUT ;(1X, 'BINNING STRUCTURES INCOMPATIBLE, PLEASE SELECT AGAIN.');
            {  0  " - prompt the user to select two different files "
            {  0  GOTO :SELECT9:;
            {  0  ]
            {  0  " - check that the boundaries for each distribution are the same "
            {  0  DO {P1}=1,{P1}MAX(NDIST1) [
            {  0  IF {P2}BOUND(NDIST1,{P1}).NE.{P2}BOUND(NDIST2,{P1}) [
            {  0  OUTPUT ;(' BINNING STRUCTURES INCOMPATIBLE, PLEASE SELECT AGAIN.');
            {  0  " - prompt the user to select two different files "
            {  0  GOTO :SELECT9:;
            {  0  ]
            {  0  ]
            {  0  " - continue on in STATS if they are the same "
            {  0  };
               0
               0  " $GET_AXISDOSE calculates the maximum dose on the central axis of a
               0  " distribution
               0  " - it checks the distribution to determine the properties of the central
               0  " axis, and decides whether it needs to average values, or just read
               0  " the appropriate data from the distribution
               0  " - if the central axis is obvious, no averaging occurs
               0  " CALLED FROM: STATS
               0
               0  REPLACE {$GET_AXISDOSE(#);} WITH {;
            {  0  "===================================="
            {  0
            {  0  " if there are an even number of voxels in the x direction, set the "
            {  0  " voxel limits for averaging the two central most voxels "
            {  0  IF (MOD(IMAX({P1}),2)) = 0 [ILO = IMAX({P1})/2; IHI = IMAX({P1})/2+1;]
            {  0
            {  0  " otherwise, take only the central voxel into account "
            {  0  ELSE [ILO = IMAX({P1})/2+1; IHI = IMAX({P1})/2+1;]
            {  0
            {  0  " if there are an even number of voxels in the y direction, set the "
            {  0  " voxel lims for averaging the two centralmost voxels "
            {  0  IF (MOD(JMAX({P1}),2)) = 0 [JLO = JMAX({P1})/2;JHI = JMAX({P1})/2+1;]
            {  0
            {  0  " otherwise, take only the central voxel into account "
            {  0  ELSE [JLO = JMAX({P1})/2+1;  JHI = JMAX({P1})/2+1;]
            {  0
            {  0  " find the average dose, using the above voxel limits, at the k-th level "
            {  0  " in the voxel grid "
            {  0  DO K = 1,KMAX({P1}) [
            {  0  " must set to 0 for the each k-th voxel "
            {  0  DOSE_STORE = 0;
            {  0  DO I = ILO,IHI [
            {  0  DO J = JLO,JHI [
            {  0  " store dose in a cumulative sum "
            {  0  DOSE_STORE = DOSE({P1},I,J,K)+DOSE_STORE;
            {  0  ]
            {  0  ]
            {  0  " divide cumulative dose at the k-th level by the number of voxels "
            {  0  " averaged "
            {  0  DOSE_STORE = DOSE_STORE/((IHI-ILO+1)*(JHI-JLO+1));
            {  0  AXISDOSE({P1},K) = DOSE_STORE;
            {  0  ]
            {  0  };    "end of $GET_AXISDOSE"
               0
               0  " $FIND_LIMS finds the upper and lower bin numbers for the calculation
               0  " of the appropriate average dose for a specific voxel
               0  " - it does this for each axis
               0  " - if the coordinate being checked is within 1/100th of a cm of the
               0  " voxel boundary in either direction, the next voxel in that direction
               0  " will be considered when calculating the average
               0  " - the average is calculated in the calling routine
               0  " CALLED FROM: SPECVOXEL
               0  "the logic in the following used to fail for {P2}COORD={P2}BOUND(NDIST1,{P1}0)"
               0  "It was only catestrophic if it was 1st bin in which case {P1}LO came back"
               0  "as zero which caused a segmentation fault"
               0
               0  REPLACE {$FIND_LIMS(#,#);} WITH {;
            {  0  "=================================="
            {  0  " set defaults "
            {  0  {P1}LO = {P1}0;
            {  0  {P1}HI = {P1}0;
            {  0  " check upper voxel "
            {  0  IF ({P2}BOUND(NDIST1,{P1}0+1)-{P2}COORD)<.01 [{P1}HI={P1}0+1;]
            {  0  " check lower voxel "
            {  0  IF ({P2}COORD-{P2}BOUND(NDIST1,{P1}0))< 0.01 [{P1}LO={P1}0-1;]
            {  0  IF({P1}LO = 0)[{P1}LO=1;]
            {  0  };
               0
               0  " $INIT_GRAPH initializes some of the graph variables to default settings
               0  " which are then passed to the routine plot_xvgr
               0  " - the variables initialized are: xaxis, yaxis and the ioption array
               0  " - xaxis, yaxis are axis labels
               0  " - ioption stores various graph settings options
               0  " - more information about the graph settings options can be found in
               0  " plot_xvgr or plotin
               0  " CALLED FROM: PLOTDOSE,COMPAREPLOT
               0
               0  " - these settings are completely arbitrary, and have simply been
               0  " assigned as such in order to provide generic defaults in an effort to
               0  " avoid having to plague the user with annoying questions
               0  " these values can be changed here, or left as defaults and changed once
               0  " the graph has been popped onto the screen
               0
               0  REPLACE {$INIT_GRAPH(#);} WITH {;
            {  0  "=================================="
            {  0  XAXIS = '{P1} axis/cm';
            {  0  YAXIS = 'dose /Gy';
            {  0  DO L = 1,4   [ IOPTION(L) = 0; ]
            {  0  };
               0
               0  " $PRINT_CURVEINFO prints the number and name of the current 3ddose
               0  " distribution
               0  " CALLED FROM: PLOTDOSE,COMPAREPLOT
               0
               0  REPLACE {$PRINT_CURVEINFO;} WITH {;
            {  0  "==================================="
            {  0
            {  0  OUTPUT NDIST1,FILEIN(NDIST1)(1:NUMCHAR);
            {  0  (/1X,'3D-dose distribution ',I2,': ',A);
            {  0  };
               0
               0  " $FIND_BIN calculates the voxel position corresponding to each axis
               0  " coordinate
               0  " - the voxel position is denoted by {P1}0
               0  " - it loops through the bounds array from the second voxel to the last
               0  " voxel, checking at each to see whether the distance value stored in
               0  " the bounds array for that voxel is greater than the distance value
               0  " entered for the coordinate
               0  " - if the distance value is greater, the loop is exited
               0  " one is subtracted from the voxel position because if in the centre of the
               0  " voxel, we want to take the value of the lower boundary as the value of
               0  " the voxel
               0  " CALLED FROM: PLOTDOSE,COMPAREPLOT,SPECVOXEL
               0
               0  REPLACE {$FIND_BIN(#,#);} WITH {;
            {  0  "=================================="
            {  0
            {  0  DO {P1}0 = 2,{P1}MAX(NDIST1) [
            {  0  VOXEL_MEAS = {P2}BOUND(NDIST1,{P1}0);
            {  0  IF (VOXEL_MEAS>{P2}COORD) [EXIT;]
            {  0  ]
            {  0  {P1}0 = {P1}0-1;
            {  0  };
               0
               0  " $PROFILE finds the dose and the error in the dose
               0  " at points along a specified axis (x,y or z)
               0  " at a specific coordinate
               0  " - the index {P1}0 is used in order that the macro may be utilized for
               0  " all three axes, since it allows the macro to increment either I0,J0,K0,
               0  " depending on the variable passed to the macro
               0  " CALLED FROM: PLOTDOSE,COMPAREPLOT
               0
               0  REPLACE {$PROFILE(#,#);} WITH {;
            {  0  "================================"
            {  0
            {  0  DO {P1}0 = 1,{P1}MAX(NDIST1) [
            {  0  PROFILEDOSE({P1}0) = DOSE(NDIST1,I0,J0,K0);
            {  0  PROFILERR({P1}0) = ERRDOSE(NDIST1,I0,J0,K0);
            {  0  ]
            {  0  };
               0
               0  " $PRINT_BOUNDS prints the number of voxels in the x,y,z directions
               0  " on the screen (along with a message),the voxel grid boundary values (in cm)
               0  " in all three directions for the data set specified
               0
               0  " - the macro also prints the dose and error in dose for points along
               0  " the selected axis at the coordinate specified
               0  " ie) it prints out the points being plotted
               0  " CALLED FROM: PLOTDOSE, COMPAREPLOT
               0
               0  REPLACE {$PRINT_BOUNDS(#,#,#,#);} WITH {;
            {  0  "=========================================="
            {  0
            {  0  OUTPUT;(/' Following is PRINT_BOUNDS output');
            {  0  OUTPUT {P3}0,{P4}0;(1X,'Profile along {P2}-axis at voxel :',2I3);
            {  0  OUTPUT IMAX(NDIST1),JMAX(NDIST1),KMAX(NDIST1);
            {  0  (/1X,'Number of voxels in x,y,z directions: ',3I10);
            {  0
            {  0  OUTPUT XBOUND(NDIST1,1),XBOUND(NDIST1,IMAX(NDIST1)+1);
            {  0  (1X,'Voxel-boundary values in x-direction: ',F10.2,2X,'-',F7.2);
            {  0
            {  0  OUTPUT YBOUND(NDIST1,1),YBOUND(NDIST1,JMAX(NDIST1)+1);
            {  0  (1X,'Voxel-boundary values in y-direction: ',F10.2,2X,'-',F7.2);
            {  0
            {  0  OUTPUT ZBOUND(NDIST1,1),ZBOUND(NDIST1,KMAX(NDIST1)+1);
            {  0  (1X,'Voxel-boundary values in z-direction: ',F10.2,2X,'-',F7.2);
            {  0
            {  0  " - this part will be removed when the program is complete, however, "
            {  0  " it has been left in at present in order to aid in debugging and QA "
            {  0
            {  0  " - prints the dose and error in dose for points along the axis at "
            {  0  " the coordinate specified "
            {  0
            {  0  OUTPUT ;(' ');
            {  0  DO {P1}0 = 1,{P1}MAX(NDIST1) [
            {  0  OUTPUT (({P2}BOUND(NDIST1,{P1}0)+{P2}BOUND(NDIST1,{P1}0+1))/2),
            {  0  PROFILEDOSE({P1}0),PROFILERR({P1}0);
            {  0  (1X,'{P2}','BOUND=',E15.5,1X,'DOSE=',E12.5,1X,'ERRDOSE=',E12.5);
            {  0  ]
            {  0  OUTPUT ;(' ');
            {  0  };
               0
               0  " $THE_SPECS1,2 fill the arrays of data to be passed to the plot_xvgr
               0  " routine
               0  " - the horizontal axis contains the voxel positions (in cm, as taken
               0  " from the BOUNDS arrays) and the vertical axis contains the corresponding
               0  " dose
               0  " - default settings are assigned to the symbol variables which are also
               0  " passed to plot_xvgr and set the symbol settings.
               0
               0  " 1 -
               0  " - the routine also finds a character string which corresponding to
               0  " the coordinate given by the user
               0  " (ie) the routine calls $FIND_STRING2)
               0  " - this is assigned to a variable which
               0  " is passed to plot_xvgr and used as a data identifier on the graph
               0
               0  " 2 -
               0  " - the routine assigns the filename to the data identifier variable
               0  " instead
               0
               0  " - for more information on the symbol settings, see the beginning of
               0  " plotin or plot_xvgr
               0  " - the two routines are essentially identical, except for the assignment
               0  " of different strings to the curve_labels variable
               0  " - the first routine is specific to the needs of PLOTDOSE, while
               0  " the second routine is specific to the needs of COMPAREPLOT in assigning a
               0  " default string to the title variable
               0  " CALLED FROM: PLOTDOSE
               0
               0  REPLACE {$THE_SPECS1(#,#,#);} WITH {;
            {  0  "======================================"
            {  0
            {  0  NPOINTS = {P1}MAX(NDIST1);
            {  0
            {  0  " - if the option for automatic offset has been selected, the x array is "
            {  0  " filled while adding 1/10th, 2/10th, 3/10ths, etc of the (cm) distance "
            {  0  " between voxels for each consecutive curve being plotted "
            {  0  IF (REPLY='y') [
            {  0  DO {P1}0=1,{P1}MAX(NDIST1) [
            {  0
            {  0  " - the x values plotted are the averages of the two x distances "
            {  0  " which denote the particular voxel "
            {  0
            {  0  X({P1}0)=(({P2}BOUND(NDIST1,{P1}0)+
            {  0  {P2}BOUND(NDIST1,{P1}0+1))/2)+(.1*({P3}-1)*
            {  0  ({P2}BOUND(NDIST1,{P1}0+1)-{P2}BOUND(NDIST1,{P1}0)));
            {  0
            {  0  " - the y values are the dose values for each voxel "
            {  0
            {  0  Y({P1}0)=PROFILEDOSE({P1}0);
            {  0  ERRY({P1}0)=PROFILERR({P1}0);
            {  0  ]
            {  0  ]
            {  0
            {  0  " - otherwise, the x array is filled with no additions "
            {  0
            {  0  ELSE [
            {  0  DO {P1}0=1,{P1}MAX(NDIST1) [
            {  0
            {  0  " - the x values plotted are the averages of the two x distances "
            {  0  " which denote the particular voxel "
            {  0
            {  0  X({P1}0)=(({P2}BOUND(NDIST1,{P1}0)+
            {  0  {P2}BOUND(NDIST1,{P1}0+1))/2);
            {  0
            {  0  " - the y values are the dose values for each voxel "
            {  0
            {  0  Y({P1}0)=PROFILEDOSE({P1}0);
            {  0  ERRY({P1}0)=PROFILERR({P1}0);
            {  0  ]
            {  0  ]
            {  0
            {  0  IF LA_AXIS=1 [$FIND_STRING2(Y,Z,J0,K0);]
            {  0  ELSEIF LA_AXIS=2 [$FIND_STRING2(X,Z,I0,K0);]
            {  0  ELSEIF LA_AXIS=3 [$FIND_STRING2(X,Y,I0,J0);]
            {  0
            {  0  " -the title label is set to the coordinate string "
            {  0
            {  0  CURVE_LABELS=THE_STRING;
            {  0
            {  0  " -use mod to make a pseudo random assignment of possible combinations "
            {  0  " of default values for symbol type and curve type in order to "
            {  0  " ensure that multiple curves are distinct automatically, without "
            {  0  " having to have the user input stuff which they would have to "
            {  0  " think about "
            {  0
            {  0  NTYPE_SYMBOL = MOD({P3},9)+1;
            {  0  NTYPE_CURVE = MOD({P3},5)+1;
            {  0
            {  0  CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48);
            {  0  };
               0
               0  " CALLED FROM: COMPAREPLOT
               0
               0  REPLACE {$THE_SPECS2(#,#,#);} WITH {;
            {  0  "======================================"
            {  0
            {  0  NPOINTS = {P1}MAX(NDIST1);
            {  0
            {  0  " if the option for automatic offset has been selected, the x array is "
            {  0  " filled while adding 1/20th, 2/20th, 3/20ths, etc of the (cm) distance "
            {  0  " between voxels for each consecutive curve being plotted "
            {  0
            {  0  "        IF ((REPLY='y').OR.(REPLY=CHAR(32))) [ changed by CM"
            {  0  IF (REPLY='y') [
            {  0  DO {P1}0=1,{P1}MAX(NDIST1) [
            {  0
            {  0  " the x values plotted are the averages of the two x distances which "
            {  0  " denote the particular voxel "
            {  0
            {  0  X({P1}0)=(({P2}BOUND(NDIST1,{P1}0)+
            {  0  {P2}BOUND(NDIST1,{P1}0+1))/2)+(.05*({P3}-1)*
            {  0  ({P2}BOUND(NDIST1,{P1}0+1)-{P2}BOUND(NDIST1,{P1}0)));
            {  0
            {  0  " the y values are the dose values for each voxel "
            {  0
            {  0  Y({P1}0)=PROFILEDOSE({P1}0);
            {  0  ERRY({P1}0)=PROFILERR({P1}0);
            {  0  ]
            {  0  ]
            {  0  ELSE [
            {  0  DO {P1}0=1,{P1}MAX(NDIST1) [
            {  0
            {  0  " the x values plotted are the averages of the two x distances which "
            {  0  " denote the particular voxel "
            {  0
            {  0  X({P1}0)=(({P2}BOUND(NDIST1,{P1}0)+
            {  0  {P2}BOUND(NDIST1,{P1}0+1))/2);
            {  0
            {  0  " the y values are the dose values for each voxel "
            {  0
            {  0  Y({P1}0)=PROFILEDOSE({P1}0);
            {  0  ERRY({P1}0)=PROFILERR({P1}0);
            {  0  ]
            {  0  ]
            {  0
            {  0  "added by CM to properly transfer the labels"
            {  0  CALL LETTERCOUNT(FILEIN(NDIST1),J);
            {  0  CURVE_LABELS='                    ';
            {  0  CURVE_LABELS=FILEIN(NDIST1)(1:J);
            {  0
            {  0  " -use mod to make a pseudo random assignment of possible combinations "
            {  0  " of default values for symbol type and curve type in order to "
            {  0  " ensure that multiple curves are distinct automatically, without "
            {  0  " having to have the user input stuff which they would have to "
            {  0  " think about "
            {  0
            {  0  NTYPE_SYMBOL = MOD({P3},9)+1;
            {  0  NTYPE_CURVE = MOD({P3},5)+1;
            {  0
            {  0  CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48);
            {  0  };
               0
               0  " $TRANSFER_BOUNDS assigns values to a BOUNDS array denoted by number
               0  " by the user
               0  " - it assigns the values along one axis, which is specified by the user
               0  " - the values are taken from an existing BOUNDS array, at intervals
               0  " corresponding to a rebinning factor entered by the user
               0  " CALLED FROM: REBINNING
               0
               0  " check with bruce on this before finishing documentation
               0
               0  REPLACE {$TRANSFER_BOUNDS(#,#);} WITH {;
            {  0  "========================================"
            {  0
            {  0  " - calculate the number of full bins to be stored in the new rebinned bounds "
            {  0  " array "
            {  0
            {  0  " takes into account a possible last bin which is not a full sized bin "
            {  0
            {  0  MAX_BIN = ({P1}MAX(NDIST1)+NBIN_FACT-1)/NBIN_FACT;
            {  0
            {  0  " - calculate the width of the MAX_BIN, "
            {  0  " width of the last bin is the integer remainder of the division of "
            {  0  " the number of bins in the array being rebinned divided by the bin "
            {  0  " factor or if that is 0, it is NBIN_FACT"
            {  0
            {  0  LASTBIN_FACT = MOD({P1}MAX(NDIST1),NBIN_FACT);
            {  0  IF LASTBIN_FACT=0 [LASTBIN_FACT = NBIN_FACT;]
            {  0
            {  0  DO I=1,MAX_BIN [
            {  0
            {  0  " - assign rebinned array the contents of the array being rebinned at "
            {  0  " intervals corresponding to the rebinning factor "
            {  0
            {  0  {P2}BOUND(NDIST1_BIN,I) = {P2}BOUND(NDIST1,(I-1)*NBIN_FACT+1);
            {  0  ]
            {  0
            {  0  {P2}BOUND(NDIST1_BIN,MAX_BIN+1) = {P2}BOUND(NDIST1,{P1}MAX(NDIST1)+1);
            {  0
            {  0  " - the number of voxels of the rebinned array is the same as the maximum "
            {  0  " number of bins in the rebinned array "
            {  0
            {  0  {P1}MAX(NDIST1_BIN) = MAX_BIN;
            {  0  };
               0
               0  " $KEEP_BOUNDS assigns values to a BOUNDS array denoted by number by
               0  " the user
               0  " - it assigns the values along one axis, which is specified by the user
               0  " - the values are taken from an existing BOUNDS array and are simply
               0  " copied from array to array, along the specified axes
               0  " - this routine fills the array for the axes not being rebinned and
               0  " merely reassigns the values directly with no change
               0  " CALLED FROM: REBINNING
               0
               0  REPLACE {$KEEP_BOUNDS(#,#);} WITH {;
            {  0  "===================================="
            {  0  DO I=1,({P1}MAX(NDIST1)+1) [
            {  0
            {  0  " the array values are simply reassigned, no changes are made "
            {  0
            {  0  {P2}BOUND(NDIST1_BIN,I) = {P2}BOUND(NDIST1,I);
            {  0  ]
            {  0  {P1}MAX(NDIST1_BIN) = {P1}MAX(NDIST1);
            {  0  };
               0
               0  " $REBIN_AXIS rebins the dose and errdose arrays along one axis
               0  " by a factor which was entered by the user
               0  " CALLED FROM: REBINNING
               0
               0  REPLACE {$REBIN_AXIS(#,#,#);} WITH {;
            {  0  "======================================"
            {  0
            {  0  " - to each voxel in the rebinning direction of the new distribution "
            {  0  " ( there are MAX_BIN voxels in this direction) "
            {  0
            {  0  DO {P1}=1,MAX_BIN [
            {  0
            {  0  " at the last bin, the number doses being averaged is the number "
            {  0  " of old bins in the bin...this is not necessarily nbin_fact "
            {  0
            {  0  IF {P1}=MAX_BIN [JEND=LASTBIN_FACT;]
            {  0
            {  0  " - to each voxel in the other two directions "
            {  0  " ( there are JMAX(NDIST1_BIN) and KMAX(NDIST1_BIN) voxels in these "
            {  0  " directions "
            {  0
            {  0  DO {P2}=1,{P2}MAX(NDIST1_BIN) [
            {  0  DO {P3}=1,{P3}MAX(NDIST1_BIN) [
            {  0
            {  0  " - assign the dose and errdose in the new distribution "
            {  0  " - loop a number of times corresponding to the number of bins being "
            {  0  " averaged "
            {  0
            {  0  DO L=1,JEND [
            {  0
            {  0  " set values so that the multiplication factor is used for the "
            {  0  " appropriate variable, depending upon which axis was selected "
            {  0
            {  0  {P1}0=({P1}-1)*NBIN_FACT+L;
            {  0  {P2}0={P2};
            {  0  {P3}0={P3};
            {  0
            {  0  " - assign the dose in a voxel in the new distribution by summing the "
            {  0  " doses in the corresponding JEND voxels of the old distribution "
            {  0
            {  0  DOSE(NDIST1_BIN,I,J,K)=DOSE(NDIST1_BIN,I,J,K)+
            {  0  DOSE(NDIST1,I0,J0,K0);
            {  0
            {  0  " - assign the errdose in a voxel in the new distribution by summing the "
            {  0  " squares of the errdoses in the corresponding JEND voxels of the "
            {  0  " old distribution "
            {  0  " - this uses the standard method for propagating the errors "
            {  0
            {  0  ERRDOSE(NDIST1_BIN,I,J,K)=ERRDOSE(NDIST1_BIN,I,J,K)+
            {  0  ERRDOSE(NDIST1,I0,J0,K0)**2;
            {  0  ]
            {  0
            {  0  " - find the average dose by dividing by JEND (the number of doses "
            {  0  " which were added together "
            {  0
            {  0  DOSE(NDIST1_BIN,I,J,K)=DOSE(NDIST1_BIN,I,J,K)/JEND;
            {  0
            {  0  " - find the average errdose by dividing the root of the errdose by "
            {  0  " NBIN_FACT ( the number of squares of errdoses which were added together) "
            {  0
            {  0  ERRDOSE(NDIST1_BIN,I,J,K)=
            {  0  SQRT(ERRDOSE(NDIST1_BIN,I,J,K))/JEND;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0
            {  0  };
               0
               0  " $FIND_STRING1 takes two numbers (a coordinate point) and converts them
               0  " into a coordinate string of form (#####.#,###.#)
               0  " there is always only one digit following the decimal point
               0  " The numbers can be arbitrarily long, but the entire string, including the
               0  " brackets and comma can be no more than 20 characters in length.
               0  " CALLED FROM: COMPAREPLOT
               0
               0  REPLACE {$FIND_STRING1(#,#);} WITH {;
            {  0  "======================================"
            {  0
            {  0  ISTR=0;
            {  0  JSTR=0;
            {  0  ICOUNT = 0;
            {  0
            {  0  " takes integer value to the nearest mm "
            {  0  " add .5 in order to round up "
            {  0
            {  0  INT{P1}=INT(ABS({P1}COORD)*10+0.5);
            {  0  IF INT{P1}.NE.0 [
            {  0  LOOP [
            {  0  ISTR=ISTR+1;
            {  0  NUM_ARR(ISTR) = INT{P1}-(INT{P1}/10)*10;
            {  0  INT{P1} = INT{P1}/10;
            {  0  ]
            {  0  UNTIL INT{P1}=0;
            {  0  THE_STRING=' (';
            {  0  ICOUNT = 2;
            {  0  IF {P1}COORD<0 [
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//'-';
            {  0  ICOUNT = ICOUNT+1;
            {  0  ]
            {  0  DO N=ISTR,2,-1 [
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48);
            {  0  ICOUNT = ICOUNT+1;
            {  0  ]
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48);
            {  0  ICOUNT=ICOUNT+2;
            {  0  ]
            {  0  ELSE [THE_STRING=' (0.0'; ICOUNT = 5;]
            {  0
            {  0  INT{P2}=INT(ABS({P2}COORD)*10+0.5);
            {  0  IF INT{P2}.NE.0 [
            {  0  LOOP [
            {  0  JSTR=JSTR+1;
            {  0  NUM_ARR(JSTR) = INT{P2}-(INT{P2}/10)*10;
            {  0  INT{P2} = INT{P2}/10;
            {  0  ]
            {  0  UNTIL INT{P2}=0;
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//',';ICOUNT = ICOUNT+1;
            {  0  IF {P2}COORD<0 [
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//'-';
            {  0  ICOUNT=ICOUNT+1;
            {  0  ]
            {  0  DO M=JSTR,2,-1 [
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48);
            {  0  ICOUNT = ICOUNT+1;
            {  0  ]
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48);ICOUNT=
            {  0  ICOUNT+2;
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//')'; ICOUNT = ICOUNT+1;
            {  0  ]
            {  0  ELSE [THE_STRING=THE_STRING(1:ICOUNT)//',0.0)';ICOUNT=ICOUNT+5;]
            {  0  };
               0
               0  " $FIND_STRING2 takes two numbers (a coordinate point) and converts them
               0  " into a coordinate string of form (#####.#,###.#)
               0  " there is always only one digit following the decimal point
               0  " The numbers can be arbitrarily long, but the entire string, including the
               0  " brackets and comma can be no more than 20 characters in length.
               0  " CALLED FROM: $THE_SPECS1
               0
               0  " modified from FIND_STRING1: 92/08/12 so that it will find convert
               0  " the midpoint of the bin
               0  " rather thaN the user entered coordinate to the character string (HM)
               0  " which will be output on the legend
               0  " {P1}COORD REPLACED BY {P1}BOUND(NCURVE,{P3}) etc.
               0
               0  REPLACE {$FIND_STRING2(#,#,#,#);} WITH {;
            {  0  "=========================================="
            {  0  ISTR=0;
            {  0  JSTR=0;
            {  0  ICOUNT = 0;
            {  0
            {  0  " takes integer value to the nearest mm "
            {  0  " add .5 in order to round up "
            {  0
            {  0  INT{P1}=INT((ABS({P1}BOUND(NDIST1,{P3})+{P1}BOUND(NDIST1,{P3}+1))/2)
            {  0  *10+0.5);
            {  0  IF INT{P1}.NE.0 [
            {  0  LOOP [
            {  0  ISTR=ISTR+1;
            {  0  NUM_ARR(ISTR) = INT{P1}-(INT{P1}/10)*10;
            {  0  INT{P1} = INT{P1}/10;
            {  0  ]
            {  0  UNTIL INT{P1}=0;
            {  0  THE_STRING=' (';
            {  0  ICOUNT = 2;
            {  0  IF ({P1}BOUND(NDIST1,{P3})+{P1}BOUND(NDIST1,{P3}+1))/2<0 [
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//'-';
            {  0  ICOUNT = ICOUNT+1;
            {  0  ]
            {  0  DO N=ISTR,2,-1 [
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48);
            {  0  ICOUNT = ICOUNT+1;
            {  0  ]
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48);
            {  0  ICOUNT=ICOUNT+2;
            {  0  ]
            {  0  ELSE [THE_STRING=' (0.0'; ICOUNT = 5;]
            {  0
            {  0  INT{P2}=INT((ABS({P2}BOUND(NDIST1,{P4})+{P2}BOUND(NDIST1,{P4}+1))/2)
            {  0  *10+0.5);
            {  0  IF INT{P2}.NE.0 [
            {  0  LOOP [
            {  0  JSTR=JSTR+1;
            {  0  NUM_ARR(JSTR) = INT{P2}-(INT{P2}/10)*10;
            {  0  INT{P2} = INT{P2}/10;
            {  0  ]
            {  0  UNTIL INT{P2}=0;
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//',';ICOUNT = ICOUNT+1;
            {  0  IF ({P2}BOUND(NDIST1,{P4})+{P2}BOUND(NDIST1,{P4}+1))/2<0 [
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//'-';
            {  0  ICOUNT=ICOUNT+1;
            {  0  ]
            {  0  DO M=JSTR,2,-1 [
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48);
            {  0  ICOUNT = ICOUNT+1;
            {  0  ]
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48);ICOUNT=
            {  0  ICOUNT+2;
            {  0  THE_STRING=THE_STRING(1:ICOUNT)//')'; ICOUNT = ICOUNT+1;
            {  0  ]
            {  0  ELSE [THE_STRING=THE_STRING(1:ICOUNT)//',0.0)';ICOUNT=ICOUNT+5;]
            {  0  };
               0
               0  ;
               0
               0  "----------------------------------------------------------------------
               0  " INTRODUCTION OF THE PLAYERS - GLOBAL VARIABLE DICTIONARY
               0  "----------------------------------------------------------------------
               0  " AXISDOSE - array which holds the dose at the k-th levels along the
               0  "            central axis for a dose distribution
               0  " CURVE_LABELS - string which holds the labels for a curve
               0  " CURVE_SPECS - variable which holds the symbol/line specs for a curve
               0  " PROFILEDOSE,PROFILERR - the dose and error in dose for the points along
               0  "                      a specified line
               0  " DDBIN_CHI - the bin width for the chi-squared frequency distribution
               0  " DDBIN_DIFF - the bin width for the dose-differences frequency distribution
               0  " DOSE,ERRDOSE - arrays which hold the dose and errdose at all points
               0  "                of the grid
               0  " ERRY - 1-D array which holds the errors in the y values
               0  " FILEIN - array of names of the input files/data sets
               0  " FREQ_CHI - frequency distribution of square of dose difference over error
               0  " FREQ_DIFF - frequency distribution of dose differences
               0  " ICOUNT - the number of characters in the string
               0  " I0,J0,K0 - the coordinates of a point in the grid (in voxel units)
               0  " IMAX, JMAX, KMAX - the maximum values of coordinates on each axis
               0  " INTX,INTY,INTZ - the truncated values of the coordinates entered
               0  "                  (ie) the truncated values of xcoord, ycoord, zcoord
               0  " IOPTION - array which holds the graph format options
               0  " ISTR, JSTR - the number of characters in the first and second numbers
               0  "              after truncation
               0  " I,J,K,L,M,N - counter variables
               0  " LA_AXIS - the axis of the desired plot
               0  " LTOT - the number of bins in the frequency distribution plot
               0  " MAX_CURVE - the maximum number of curves being plotted in a run
               0  "             (entered by the user at run time)
               0  " NCURVE - the number of the curve (in the current run) to which the
               0  "          data being used/entered pertains
               0  " NDIST1 - the number of a first 3ddose distribution
               0  " NDIST2 - the number of a second 3ddose distribution
               0  " NDIST1_FLAG - array of flags of 0 or 1 which indicate whether there is data
               0  "              loaded into the NDIST1 -th array
               0  " NFLAG - a flag variable
               0  " NUMCHAR - the number of characters in the string
               0  " NPOINTS - holds the number of points which will
               0  "           be plotted for the current curve (same as the number of voxels)
               0  " NTYPE_SYMBOL,NTYPE_CURVE - plot_xvgr parameters..see plot_xvgr for
               0  "                            more info
               0  "                          - store 1-digit codes which indicate symbol
               0  "                            and curve types
               0  " NUM_ARR - an array which holds the digits pertaining to the numbers
               0  "           being converted to a string
               0  " OUTFILE - name of the output file
               0  " REPLY - character input of y or n to a question posed
               0  " TOTALNORM - array holding cumulative normalization, as applied to each
               0  "             distribution
               0  " TITLE, XAXIS, YAXIS - labels (should be obvious!)
               0  " THE_STRING - holds the coordinate of the profile after conversion
               0  "              to a character string
               0  " VOXEL_MEAS - the distance measurement corresponding to the voxel
               0  " X,Y - 1-D arrays which hold the data to be plotted on the x and y axes
               0  " XBOUND,YBOUND,ZBOUND - the boundaries of the plot grid
               0  " XCOORD, YCOORD,ZCOORD - the coordiantes of the desired plot
               0  "----------------------------------------------------------------------
               0
               0  "----------------------------------------------------------------------
               0  " LET THE GAMES BEGIN!!!
               0  "----------------------------------------------------------------------
               0
               0  "----------------------------------------------------------------------
               0  " MAIN PROGRAM
               0  "----------------------------------------------------------------------
               0  "all variables MUST be declared
               0  "IMPLICIT NONE;"
               0
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0
               0  " - initialize the array of flags (which denote whether data is present
               0  " in the arrays for a given distribution number) to zero before
               0  " execution of the program begins
               0
               0  DATA NDIST1_FLAG/$NDIST1_MAX*0/;
               0
               0  " total normalization factor array must be initialized to 1's because
               0  " it is multiplicative
               0  DATA TOTALNORM/$NDIST1_MAX*1.0/;
               0  MAX_CURVE = 0;
               0  OUTPUT ; (/'*****************************************');
               0  OUTPUT ; ('        STATDOSE.MORTRAN');
               0  OUTPUT $MAXVOXX,$MAXVOXY,$MAXVOXZ; ('        Max array dimensions:',3I4)
               0  OUTPUT $NDIST1_MAX ; ('        Max # data sets:',I3);
               0  OUTPUT ; ('*****************************************');
               0  " - display the program options
               0  CALL MAINMENU;
               0  STOP;
               0  END;
               0
               0  "-----------------------------------------------------------------------
               0  " SUBROUTINE MAINMENU
               0  "-----------------------------------------------------------------------
               0  " called from: MAIN
               0
               0  " PURPOSE: MAINMENU displays a table of options which can be selected while
               0  " running statdose
               0  " - the routine takes in numerical input from the user, and passes control
               0  "    to the routine corresponding to the option selected
               0  " - the routine will loop until appropriate input is entered or the desire
               0  "    to exit is indicated by the user
               0
               0  " VARIABLES: ISELECT - the user's selection from the list of options
               0
               0  SUBROUTINE MAINMENU;                                        "toc:"
               0  $COMIN1/DATA/;
               0  INTEGER ISELECT;
               0  SAVE;
               0  :MAINMENU:
               0  NFLAG = 0;
               0  ISELECT = 0;
               0  OUTPUT ;(/' MAIN MENU');
               0  OUTPUT ;(' --------');
               0  OUTPUT ;(' 0 - Exit');
               0  OUTPUT ;(' 1 - Read dose distributions');
               0  OUTPUT ;(' 2 - Statistical analysis');
               0  OUTPUT ;(' 3 - Normalization');
               0  OUTPUT ;(' 4 - Rebinning');
               0  OUTPUT ;(' 5 - Plot');
               0  OUTPUT ;(' 6 - Save'/);
               0  " - prompt user to make a selection from the above table
               0  OUTPUT ;(1X,'Selection: ',$); INPUT ISELECT;(I5);
               0
               0  " - if out of range, redisplay main menu
               0  IF (ISELECT < 0 | ISELECT > 6) [GOTO :MAINMENU:;]
               0  ELSEIF (ISELECT = 0) [
               1    " - confirm desire to exit
               1    OUTPUT ;(/1X,'Are you sure? (y/n) [y]: ',$);
               1    INPUT REPLY;(A);
               1    IF ((REPLY = 'y') | (REPLY = CHAR(32))) [RETURN;]
               1    ELSE [GOTO :MAINMENU:;]
               1    ]
               0  ELSEIF (ISELECT = 1) [CALL READDOSE;]
               0
               0  ELSEIF (ISELECT = 2) [ "statistical analysis"
               1    " - check to see if there is more than one distribution loaded
               1    DO N = 1,$NDIST1_MAX [ IF NDIST1_FLAG(N) = 1 [NFLAG = NFLAG+1;] ]
               1
               1    " - if there is pass control to the appropriate routine
               1    IF (NFLAG > 1) [CALL STATSMENU;]
               1    ELSE [ " - otherwise, redisplay the main menu"
               2      OUTPUT ;('Please read in more data before ',
               2      'attempting to do stats comparisons');
               2      ]
               1    ]
               0
               0  ELSEIF (ISELECT = 3) ["Normalization"
               1    " - check that some data has been read in"
               1    DO N = 1,$NDIST1_MAX [ IF NDIST1_FLAG(N) = 1 [NFLAG = 1;] ]
               1    " - if data, proceed to the appropriate subroutine
               1    IF NFLAG = 1 [CALL NORMMENU;]
               1    " - otherwise, print a message and redisplay main menu
               1    ELSE [OUTPUT ;(1X,'Please read in data before attempting normalization');]
               1    ]
               0  ELSEIF (ISELECT = 4) ["Rebinning"
               1    " - check that some data has been read in
               1    DO N = 1,$NDIST1_MAX [ IF NDIST1_FLAG(N) = 1 [NFLAG = 1;] ]
               1    " - if data, proceed to the appropriate subroutine
               1    IF NFLAG=1 [CALL REBINNING;]
               1    " - otherwise, print a message and redisplay main menu
               1    ELSE [OUTPUT ;(1X,'Please read in data before rebinning');]
               1    ]
               0  ELSEIF (ISELECT = 5) ["Plot"
               1    " - check that some data has been read in
               1    DO N = 1,$NDIST1_MAX [ IF NDIST1_FLAG(N) = 1 [NFLAG = 1;] ]
               1    " - if data, proceed to the appropriate subroutine
               1    IF NFLAG = 1 [CALL PLOTMENU;]
               1    " - otherwise, print a message and redisplay main menu
               1    ELSE [OUTPUT ;(1X,'Please read in data before plotting');]
               1    ]
               0  ELSEIF (ISELECT = 6) ["Save"
               1    " - check that some data has been read in
               1    DO N = 1,$NDIST1_MAX [ IF NDIST1_FLAG(N) = 1 [NFLAG = 1;] ]
               1    " - if data, proceed to the appropriate subroutine
               1    IF NFLAG = 1 [CALL SAVE;]
               1    " - otherwise, print a message and redisplay main menu
               1    ELSE [OUTPUT ;(1X,'Please read in data before saving');]
               1    ]
               0  " - redisplay the main menu
               0  GOTO :MAINMENU:;
               0  END;
               0
1              0  %E   "start of subroutine READDOSE"
               0  "-----------------------------------------------------------------------
               0  " SUBROUTINE READDOSE
               0  "-----------------------------------------------------------------------
               0
               0  " called from: MAINMENU
               0
               0  " PURPOSE: Readdose prompt the user for a file number and a filename
               0  " - the routine then reads data from the file (which must be of proper
               0  " format <see main documentation for this format> and end with the
               0  " extension .3ddose)
               0  " - the data from the file is stored in the appropriate arrays and
               0  " variables which correspond to the file number which was entered
               0  " - the routine will continue to read in files until the user indicates
               0  " that they are finished reading in files
               0  " - the files need not be read sequentially, one can read file number
               0  " 5, then 3, etc, and a file may be overwritten at any point
               0
               0  " VARIABLES: ICOUNT - the number of .3ddose files in the directory
               0  " NUM - the number of the .3ddose file to read in
               0  " FILENAME - array which hold the names of the .3ddose files in the pwd
               0
               0  SUBROUTINE READDOSE;                                        "toc:"
               0  "IMPLICIT NONE;"
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0
               0  INTEGER NUM,istat,egs_system;
               0  CHARACTER*70 FILENAME($MAXFILE);
               0  SAVE;
               0
               0  NUMCHAR  =  0;
               0  ICOUNT  =  0;
               0
               0  :GETDOSE:
               0
               0  "try Unix/Linux ls call first"
               0  istat=egs_system('ls *.3ddose > files');
               0  IF(istat~=0)["assume its a Windows system"
               1    OUTPUT;(/' Will assume you are running on a Windows system.'/);
               1    istat=egs_system('dir /B *.3ddose > files');
               1    ]
               0  IF(istat~=0)["do not recognize the system"
               1    OUTPUT;(//' Do not recognize the system you are running on.'/
               1    ' .3ddose files cannot be listed.'//);
               1    STOP;
               1    ]
               0  "above should create a file with list of available 3ddose distns"
               0
               0
               0  OUTPUT ;(/1X,'READ DOSE DISTRIBUTIONS');
               0  OUTPUT ;(1X,'-----------------------');
               0
               0  OPEN(UNIT = 8,FILE = 'files',STATUS = 'UNKNOWN');
               0
               0  :GETNAMES:;
               0  READ(8,'(A)',END=28) FILENAME(ICOUNT+1);
               0  FILENAME(ICOUNT+1)=FILENAME(ICOUNT+1)(:index(FILENAME(ICOUNT+1),'.3ddose')-1);
               0  ICOUNT = ICOUNT+1;
               0  IF (ICOUNT = $MAXFILE) [
               1    OUTPUT ICOUNT;
               1    (//' Have read in ',I4,' .3ddose files, which is the max. no. possible.'/
               1    ' To read in more, you must increase $MAXFILE and recompile statdose'//);
               1    GOTO 28;
               1    ]
               0  GO TO :GETNAMES:;
               0  28 IF (ICOUNT = 0) [
               1    OUTPUT;
               1    (//' no files with extension .3ddose in this directory!'//);
               1    RETURN;
               1    ]
               0  CLOSE(UNIT=8);
               0  DO I=1,ICOUNT [ OUTPUT I,FILENAME(I);(1X,I2,1X,A70); ]
               0
               0  " - prompt user for the number of the distribution which is to be read
               0  " in (so it can load the data into the appropriate array)
               0
               0  :READIN:
               0  OUTPUT ICOUNT;(/1X,'Input file number to Read in: (1-',
               0  I2,' or 0-Main Menu): ',$);
               0  INPUT NUM;(I2);
               0
               0  " - 0 returns control to the main menu module
               0
               0  IF (NUM = 0) [RETURN;]
               0  ELSEIF (NUM>ICOUNT) [
               1    " - if number entered is out of range, print an appropriate message
               1    OUTPUT ;(1X,'SORRY, THAT IS OUT OF RANGE.');
               1    GOTO :READIN:;
               1    ]
               0
               0  OUTPUT $NDIST1_MAX;(1X,'File number for temporary storage: (1-',
               0  I1,' or 0-Main Menu): ',$);
               0  INPUT NDIST1;(I2);
               0  " - 0 returns control to the main menu module
               0  IF (NDIST1=0) [RETURN;]
               0  ELSEIF (NDIST1 > $NDIST1_MAX) [
               1    " - if number entered is out of range, print an appropriate message
               1    OUTPUT $NDIST1_MAX;(1X,'Max is:',I3,' try again'); GOTO :READIN:;
               1    ]
               0
               0  " - otherwise, set a flag to indicate that a data set is present in the arrays
               0  " corresponding to the distribution number which was entered
               0  NDIST1_FLAG(NDIST1)=1;
               0
               0  CALL LETTERCOUNT(FILENAME(NUM),NUMCHAR);
               0
               0  "added by CM to initialize the variable"
               0  FILEIN(NDIST1)=
               0  '                                                                      ';
               0  FILEIN(NDIST1)(1:NUMCHAR)=FILENAME(NUM)(1:NUMCHAR);
               0  OPEN(UNIT=4,FILE=FILEIN(NDIST1)(1:NUMCHAR)//'.3ddose',STATUS='OLD');
               0  " - read maximum number of voxels for each axis and output this to the
               0  " screen
               0  READ(4,*) IMAX(NDIST1),JMAX(NDIST1),KMAX(NDIST1);
               0  OUTPUT IMAX(NDIST1),JMAX(NDIST1),KMAX(NDIST1);
               0  (/1X,'Number of voxels in X,Y,Z directions: ',3I10);
               0  IF(IMAX(NDIST1) > $MAXVOXX | JMAX(NDIST1) > $MAXVOXY |
               0  KMAX(NDIST1) > $MAXVOXZ)[
               1    OUTPUT $MAXVOXX,$MAXVOXY,$MAXVOXZ;
               1    ( ///' One of dimensions is greater than allowed',
               1    ' limits of ', 3I4// ' Adjust in statdose.mortran and recompile');
               1    STOP;
               1    ]
               0
               0  " - read the measurements (cm) at the voxel divisions for all 3 axes
               0
               0  READ(4,*) (XBOUND(NDIST1,I),I=1,IMAX(NDIST1)+1);
               0  READ(4,*) (YBOUND(NDIST1,I),I=1,JMAX(NDIST1)+1);
               0  READ(4,*) (ZBOUND(NDIST1,I),I=1,KMAX(NDIST1)+1);
               0
               0  " - display the minimum and maximum (cm) values of the 3ddose grid
               0
               0  $OUT_THE_BOUNDS(I,X,NDIST1);
               0  $OUT_THE_BOUNDS(J,Y,NDIST1);
               0  $OUT_THE_BOUNDS(K,Z,NDIST1);
               0
               0  OUTPUT ;(1X,'Reading dose distribution...');
               0  " - read dose array and determine absolute error
               0  " - read the dose in the order (1,1,1), (2,1,1), (3,1,1)...(1,2,1),(2,2,1), etc
               0  " - reads the error in the dose in the same order
               0
               0  READ(4,*)
               0  (((DOSE(NDIST1,I,J,K),I=1,IMAX(NDIST1)),J=1,JMAX(NDIST1)),K=1,KMAX(NDIST1));
               0  " - errors in .3ddose files are percentage
               0
               0  OUTPUT ; (1X,'Reading in the uncertainties on DOSE Distribution...');
               0  READ(4,*) (((ERRDOSE(NDIST1,I,J,K),I=1,IMAX(NDIST1)),J=1,JMAX(NDIST1)),
               0  K=1,KMAX(NDIST1));
               0  " - convert errors to absolute errors
               0  DO I = 1,IMAX(NDIST1)[
               1    DO J = 1,JMAX(NDIST1)[
               2      DO K = 1,KMAX(NDIST1)[
               3        ERRDOSE(NDIST1,I,J,K)=DOSE(NDIST1,I,J,K)*ERRDOSE(NDIST1,I,J,K);
               3        ]
               2      ]
               1    ]
               0  CLOSE(UNIT=4);
               0  OUTPUT ;(/1X,'Have read dose distributions');
               0  OUTPUT ;(1X,'-----------------------');
               0
               0  " - prompt the user for the number of the next file to read in
               0  DO I = 1,ICOUNT [ OUTPUT I,FILENAME(I);(1X,I2,1X,A70); ]
               0  GOTO :READIN:;
               0  END;
               0
               0  "-----------------------------------------------------------------------
               0  " SUBROUTINE STATSMENU
               0  "-----------------------------------------------------------------------
               0  " called from: MAINMENU
               0
               0  " PURPOSE: STATSMENU prints a table of statistical analysis options
               0  " which could be used by the routine
               0  " - the subroutine passes the option selected to the subroutine STATS
               0  " VARIABLES: ISELECT1 - user's selection from list of type of plots
               0  "            ISELECT2 - user's selection from list of binning types
               0
               0  SUBROUTINE STATSMENU;                                        "toc:"
               0  "IMPLICIT NONE;"
               0  $COMIN1/DATA/;
               0
               0  INTEGER ISELECT1, ISELECT2;
               0  SAVE;
               0
               0  :STATSMENU:
               0  NFLAG = 0;
               0  ISELECT1 = 0;
               0
               0  " the following are new options introduced so that the dose difference
               0  " distributions can be plotted with respect to various percentage
               0  " differences
               0
               0  OUTPUT ;(/' STATS MENU');
               0  OUTPUT ; (' ---------');
               0  OUTPUT ;(' 0 - Return to main menu');
               0  OUTPUT ;(' 1 - Plot frequency vs. D1-D2');
               0  OUTPUT ;(' 2 - Plot frequency vs. (D1-D2)/[(D1+D2)/2] * 100%');
               0  OUTPUT ;(' 3 - Plot frequency vs. (D1-D2)/max central axis dose * 100%');
               0  OUTPUT ; (' 4 - Plot frequency vs. (D1-D2)/sqrt(err1**2+err2**2)');
               0
               0  " - prompt user to make a selection from the above table
               0
               0  OUTPUT ;(/1X,'Selection: ',$);
               0  INPUT ISELECT1;(I5);
               0
               0  " - if out of range, redisplay main menu
               0
               0  IF (ISELECT1<0|ISELECT1>4) [GOTO :STATSMENU:;]
               0  ELSEIF (ISELECT1 = 0) [RETURN;]
               0
               0  :STATSOPTIONS:
               0  ISELECT2 = 0;
               0
               0  OUTPUT ;(/' STATS OPTIONS');
               0  OUTPUT ;(' -------');
               0  OUTPUT ;(' 0 - Return to STATS MENU');
               0  OUTPUT ;(' 1 - Limit frequency distribution to maximum dose difference'/
               0  '      or max % dose difference');
               0  OUTPUT ;(' 2 - Limit frequency distribution to (maximum dose)/10');
               0  OUTPUT ;(' 3 - Custom bin width');
               0
               0  " - prompt user to make a selection from the above table
               0  OUTPUT ;(/1X,'Selection: ',$); INPUT ISELECT2;(I5);
               0
               0  " - if out of range, redisplay main menu
               0  IF (ISELECT2<0|ISELECT2>3) [GOTO :STATSOPTIONS:;]
               0  ELSEIF (ISELECT2 = 0) [GOTO :STATSMENU:;]
               0  ELSEIF (ISELECT2 = 2 & ISELECT1 > 1) [
               1    OUTPUT;(' Binning with respect to max dose does not make sense '/
               1    ' when plotting frequency vs. % dose differences.'/
               1    ' Choose another binning option:'/);
               1    GOTO :STATSOPTIONS:
               1    ]
               0
               0  " - pass the selected option to the statistics routine
               0
               0  ELSE [CALL STATS(ISELECT1,ISELECT2);]
               0
               0  GOTO :STATSMENU:;
               0  END;
               0
               0  "----------------------------------------------------------------------------
               0  " SUBROUTINE STATS
               0  "----------------------------------------------------------------------------
               0
               0  " called from: STATSMENU
               0
               0  " PURPOSE: STATS - calculates the chi squared (per degree of freedom) and
               0  " the rms deviations for two distributions with the same binning structures
               0  " - the routine also finds and gives the value and location of the maximum dose
               0  " along the central axis, as well as the value and location of the maximum
               0  " dose difference in dose values of the two distributions
               0  " - routine assumes that the errors coming in are the standard deviation
               0
               0  " - as well, the routine calculates the 'chi-squared' frequencies and the
               0  " 'dose differences' frequencies for bins of width specified by the user in
               0  " the statsmenu options
               0
               0  " - it plots these frequencies on two graphs by calling the routine
               0  " plotfreq
               0
               0  " VARIABLES: CHI - chi squared deviation per degree of freedom of the two
               0  "                  distributions
               0  " DIFF - difference between the dose values
               0  " DIFFMAX - maximum difference in the dose values for the two distributions
               0  "           (LA_TYPE = 1 or 3)
               0  "         - or max value of (D1-D2)/[(D1+D2)/2] (LA_TYPE = 2)
               0  "         - or max value of (D1-D2)/SQRT(ERR1**2+ERR2**2)(LA_TYPE=4)
               0  " DIFFSQ - the square of the difference in dose values of the two distributions
               0  " DOSEMAX - the (averaged) maximum dose along the central axis
               0  " DOSES - the number of voxels which contain dose
               0  " DOSE_STORE - temporary storange of a dose value
               0  " ERRDIFFSQ - square in error in square in difference between the dose values
               0  " ILO,IHI,JLO,JHI,KLO,KHI - the voxel boundaries for averaging dose
               0  " KDMAX - the value of K at the point of maximum dose along the central axis
               0  " LA_TYPE - the type of distribution (ie as a function of d1-d2, d1-d2/davg,..)
               0  " LA_DELTA - the bin width option (for limiting the frequency distribution)
               0  " RMS - the root mean squared deviation of the two distributions
               0
               0  SUBROUTINE STATS(LA_TYPE,LA_DELTA);                            "toc:"
               0  "IMPLICIT NONE;"
               0
               0  $COMIN1/DATA/;     "Why this isn't COMIN/DATA1,DATA2/ is not clear"
               0  $COMIN2/DATA/;     "      -same effect"
               0
               0  INTEGER LA_TYPE,LA_DELTA;
               0
               0  INTEGER ILO,IHI,JLO,JHI,LL,KDMAX;
               0  REAL CHI,DIFF,DIFFMAX,DIFFSQ,DOSEMAX,DOSE_STORE,DOSES,ERRDIFFSQ,RMS,temp;
               0  SAVE;
               0
               0  :STATS:
               0
               0  " initialize variables to zero before beginning routine, as most are used
               0  " in running sums
               0
               0  CHI = 0.0;
               0  DIFFMAX = 0.0;
               0  DIFFSQ = 0.0;
               0  DOSEMAX = 0.0;
               0  DOSES = 0.0;
               0  KDMAX = 0;
               0  LL = 0;
               0  LTOT = 0;
               0  RMS = 0.0;
               0
               0  DO I = 1,$MAXPOINTS [
               1    FREQ_DIFF(I) = 0.0;
               1    FREQ_CHI(I) = 0.0;
               1    ]
               0
               0  OUTPUT ;(/1X,'STATISTICAL ANALYSIS');
               0  OUTPUT ;( 1X,'--------------------');
               0
               0  :SELECT9:
               0
               0  " - list the distributions which are currently loaded
               0
               0  OUTPUT ;(1X,'Files currently loaded:'/);
               0  DO N = 1,$NDIST1_MAX [
               1    IF NDIST1_FLAG(N) = 1 [
               2      OUTPUT N,FILEIN(N);(I2,' - ',A);
               2      ]
               1    ]
               0  OUTPUT ;(/1X,'File #1 for analysis: (0-MainMenu): ',$);
               0  INPUT NDIST1;(I2);
               0
               0  " - 0 returns control to the main menu
               0
               0  IF NDIST1 = 0 [RETURN;]
               0
               0  " - if the number is out of range, print the appropriate message
               0  " and prompt user to input another filename
               0
               0  ELSEIF (NDIST1 > $NDIST1_MAX)  [
               1    OUTPUT ;(1X,'Sorry, that is out of range.'/);
               1    GOTO :SELECT9:;
               1    ]
               0
               0
               0  OUTPUT ;(1X,'File #2 for analysis: (0-MainMenu): ',$);
               0  INPUT NDIST2;(I2);
               0
               0  " - 0 returns control to the main menu
               0
               0  IF NDIST2 = 0 [RETURN;]
               0
               0  " - if the number is out of range, print the appropriate message
               0  " and prompt user to input another filename
               0
               0  ELSEIF NDIST2>$NDIST1_MAX  [
               1    OUTPUT ;(1X,'Sorry, that is out of range.'/);
               1    GOTO :SELECT9:;
               1    ]
               0
               0  " check that the two distributions selected have the same binning structures
               0  " if they do not, the macro will bounce the routine back to :select9:
               0
               0  $CHECK_BOUNDS(I,X);
               0  $CHECK_BOUNDS(J,Y);
               0  $CHECK_BOUNDS(K,Z);
               0  OUTPUT ;(1X,'Binning structure are the same, i.e. OK. ',
               0  'Proceeding with stats routine...');
               0
               0  :GETBIN:
               0
               0  OUTPUT $MAXPOINTS;(/1X,'Maximum bins  =  ',I3);
               0  OUTPUT ;
               0  (1X,'Input number of bins in frequency distribution [default 101]: ',$);
               0  INPUT LTOT;(I3);
               0
               0  IF LTOT = 0 [LTOT = 101;]
               0  ELSEIF LTOT>$MAXPOINTS [
               1    OUTPUT ;(1X,'Too many bins. Please re-enter.');
               1    GOTO :GETBIN:;]
               0  ELSEIF MOD(LTOT,2) = 0 [
               1    OUTPUT ;(' Must have an odd # bins. Please re-enter.');
               1    GOTO :GETBIN:;
               1    ]
               0
               0  " no interactive choice of bin width for chi-square frequency distribution yet
               0  " set bin width for chi-square frequency distribution
               0
               0  DDBIN_CHI = 10./LTOT;   "i.e. plot distn to 10"
               0
               0  " find the maximum dose along the central axis for both distributions
               0
               0  $GET_AXISDOSE(NDIST1);
               0  $GET_AXISDOSE(NDIST2);
               0
               0  I0 = 0; J0 = 0; K0 = 0;
               0
               0  DO K = 1,KMAX(NDIST1) [
               1    DO I = 1,IMAX(NDIST1) [
               2      DO J = 1,JMAX(NDIST1) [
               3
               3        " calculate the difference in dose and its sq"
               3        "        at the given coordinate"
               3        DIFF = DOSE(NDIST1,I,J,K)-DOSE(NDIST2,I,J,K);
               3        DIFFSQ = DIFF*DIFF;
               3
               3        " if at least one of the voxels contains some dose, "
               3        " add one to the sum of voxels which contain dose"
               3        IF (DOSE(NDIST1,I,J,K).NE.0. .AND. DOSE(NDIST2,I,J,K).NE.0.) [
               4          DOSES = DOSES+1;
               4
               4          " keep a running sum of rms values and chi values, "
               4          RMS = DIFFSQ + RMS;
               4          CHI = CHI + DIFFSQ/
               4          (ERRDOSE(NDIST1,I,J,K)**2+ERRDOSE(NDIST2,I,J,K)**2);
               4
               4          " keep track of the maximum difference in values"
               4          " set the voxel coordinates to coordinates where maximum "
               4          "was found"
               4          IF(LA_TYPE = 1 | LA_TYPE = 3)[ "ploting D1-D2 or"
               5            "(D1-D2)/max central axis dose * 100%"
               5            "need to keep track of max difference & location"
               5            IF ABS(DIFF)>DIFFMAX [
               6              DIFFMAX = ABS(DIFF); I0 = I; J0 = J; K0 = K;
               6              ]
               5            ] "end LA_TYPE 1 or 3"
               4
               4          IF(LA_TYPE = 2)["plotting (D1-D2)/[(D1+D2)/2] * 100%"
               5            IF (ABS(DIFF*2/(DOSE(NDIST1,I,J,K)+DOSE(NDIST2,I,J,K)))
               5            >DIFFMAX)[
               6              DIFFMAX = ABS(DIFF*2/
               6              (DOSE(NDIST1,I,J,K)+DOSE(NDIST2,I,J,K)));
               6              I0 = I; J0 = J; K0 = K;
               6              ]
               5            ]
               4
               4          IF(LA_TYPE = 4)["plotting (D1-D2)/sqrt(err1**2+err2**2)   "
               5            "changed Feb 2013 DWOR to make sense"
               5            temp= ABS(DIFF)/
               5            SQRT(ERRDOSE(NDIST1,I,J,K)**2+ERRDOSE(NDIST2,I,J,K)**2);
               5            IF( temp  > DIFFMAX)[
               6              DIFFMAX = temp;
               6              I0 = I; J0 = J; K0 = K;
               6              ] "end of if block"
               5            ] "end of LA_TYPE 4"
               4          ]   "end of non-zero doses"
               3        ] "end of loop over J"
               2      ]  "end of loop over I"
               1
               1    " keep track of the maxium dose along the central axis "
               1    "(only do this in  the loop for k)"
               1    " if a maxiumum dose is found (ie) the array contains some data)"
               1    " set voxel coordinate to coordinate where maxium found"
               1
               1    IF ((AXISDOSE(NDIST1,K)+AXISDOSE(NDIST2,K))/2)>DOSEMAX  [
               2      DOSEMAX = (AXISDOSE(NDIST1,K)+AXISDOSE(NDIST2,K))/2;
               2      KDMAX = K;
               2      ] "end found new max"
               1    ] "end of loop on K"
               0
               0  " select bin width: based on option chosen in OPTION_MENU
               0  " note that dose values will be in the centre of the bins when graphed
               0
               0  " 1 = limit frequency to maximum dose difference
               0
               0  IF LA_DELTA = 1 [
               1    IF (LA_TYPE = 1 | LA_TYPE = 4)[DDBIN_DIFF = 2*DIFFMAX/LTOT;]
               1    ELSEIF (LA_TYPE = 2) [DDBIN_DIFF = 2*DIFFMAX*100./LTOT;]
               1    ELSEIF (LA_TYPE = 3) [DDBIN_DIFF = 2*DIFFMAX*100./DOSEMAX/LTOT;]
               1    ]
               0
               0  ELSEIF LA_DELTA = 2 [ "limit frequency to maximum dose"
               1    DDBIN_DIFF = DOSEMAX/INT(LTOT/2-1)*10.;
               1    ]
               0
               0  ELSEIF LA_DELTA = 3 [ " custom bin width
               1    OUTPUT ;(1X,'Bin width in dose or % dose difference units: ',$);
               1    INPUT DDBIN_DIFF;(F10.0);
               1    ]
               0
               0  " put each dose difference in the appropriate bin
               0
               0  DO I = 1,IMAX(NDIST1) [
               1    DO J = 1,JMAX(NDIST1) [
               2      DO K = 1,KMAX(NDIST1) [
               3
               3        " calculate the difference in dose at given coordinate
               3        " square of this difference and sum of squares of the
               3        " errors at given coordinate from two files being compared
               3
               3        IF (DOSE(NDIST1,I,J,K).NE.0..AND.DOSE(NDIST2,I,J,K).NE.0.) [
               4
               4          DIFF = DOSE(NDIST1,I,J,K)-DOSE(NDIST2,I,J,K);
               4          DIFFSQ = DIFF**2;
               4          ERRDIFFSQ = ERRDOSE(NDIST1,I,J,K)*ERRDOSE(NDIST1,I,J,K)+
               4          ERRDOSE(NDIST2,I,J,K)*ERRDOSE(NDIST2,I,J,K);
               4          IF(LA_TYPE  =  2)[
               5            DIFF = DIFF*2*100./(DOSE(NDIST1,I,J,K)+DOSE(NDIST2,I,J,K));
               5            ]
               4          ELSEIF(LA_TYPE  =  3)[
               5            DIFF = DIFF*100./DOSEMAX;
               5            ]
               4          ELSEIF(LA_TYPE  =  4)[
               5            DIFF = DIFF/SQRT(ERRDIFFSQ);
               5            ]
               4
               4          " if both of the values are not zero
               4
               4          " use this method to calculate the bin
               4
               4          LL = NINT(DIFF/DDBIN_DIFF)+NINT(LTOT/2.);
               4          " ensure that ll falls within the range 1 to ltot
               4          IF (LL>LTOT) [LL = LTOT;]
               4          ELSEIF (LL<1) [LL = 1;]
               4
               4          " count how many doses have been placed in each bin
               4          FREQ_DIFF(LL) = FREQ_DIFF(LL)+1;
               4          " accumulate frequency distribution for chi-square
               4          " use this method to calculate what bin it belongs in
               4          LL = INT(DIFFSQ/ERRDIFFSQ/DDBIN_CHI)+1;
               4
               4          " ensure that ll falls within the range 1 to ltot
               4          IF (LL>LTOT) [LL = LTOT;] ELSEIF (LL<1) [LL = 1;]
               4
               4          " count how many doses have been placed in each bin
               4
               4          FREQ_CHI(LL) = FREQ_CHI(LL)+1;
               4          ]"end of block non-zero doses"
               3        ]"end of loop on K"
               2      ]"end of loop on J"
               1    ]"end of loop on I"
               0
               0  " if at least one of voxels in distributions contained dose,
               0  " calculate rms and chi-squared (per degree of freedom) deviations
               0
               0  IF DOSES.NE.0 [
               1    RMS = RMS/DOSES;
               1    RMS = SQRT(RMS);
               1    CHI = CHI/DOSES;
               1
               1    " divide the number of doses in each bin by the total number of voxels
               1    " which contained dose
               1
               1    DO LL = 1,LTOT [
               2      FREQ_DIFF(LL) = FREQ_DIFF(LL)/DOSES;
               2      FREQ_CHI(LL) = FREQ_CHI(LL)/DOSES;
               2      ]
               1    ]
               0
               0  " output the results of the above calculations, so that the user can
               0  " see them
               0  " note that G format will default to real, unless the number is small or
               0  " big, in which case it will use exponential format
               0
               0
               0  OUTPUT CHI;(/1X,'Chi-squared per degree of freedom: ',G10.3);
               0  OUTPUT RMS;(1X,'RMS:                               ',G10.3);
               0  OUTPUT DOSES/(IMAX(NDIST1)*JMAX(NDIST1)*KMAX(NDIST1)),IFIX(DOSES),
               0  (IMAX(NDIST1)*JMAX(NDIST1)*KMAX(NDIST1));
               0  (/1X,'Ratio of voxels containing dose to total voxels:',G10.3/
               0  1x,'Number of voxels containing dose:             ',I12/
               0  1x,'Total number of voxels:                       ',I12);
               0
               0  IF(LA_TYPE = 1)[
               1    OUTPUT DIFFMAX;(/1X,'Maximum dose diff =  ',G10.2,' Gy * cm**2');
               1    ]
               0  ELSEIF(LA_TYPE = 2)[
               1    OUTPUT DIFFMAX * 100.;
               1    (/1X,'Maximum (D1-D2)/[(D1+D2)/2]  =  ',G10.2,' %');
               1    ]
               0  ELSEIF(LA_TYPE = 3)[
               1    OUTPUT DIFFMAX/DOSEMAX * 100.;
               1    (/1X,'Maximum (D1-D2)/max central axis dose  =  ',G10.2,' %');
               1    ]
               0  ELSEIF(LA_TYPE = 4)[
               1    OUTPUT DIFFMAX;
               1    "(/1X,'Max (D1-D2)/[(D1+D2)/2]/sqrt(err1**2+err2**2)  =  ',G10.2,' %');"
               1    (/1X,'Maximum (D1-D2)/sqrt(err1**2+err2**2)  =  ',G10.2);
               1    ]
               0
               0  IF (I0 = 0) .AND. (J0 = 0) .AND. (K0 = 0) [
               1    OUTPUT ;(1X,'No differences in any values.');
               1    ]
               0  ELSE [
               1    OUTPUT I0,J0,K0;(1X,'Occurs at voxel: ',3I9);
               1    OUTPUT XBOUND(NDIST1,I0),XBOUND(NDIST1,I0+1),YBOUND(NDIST1,J0),
               1    YBOUND(NDIST1,J0+1),ZBOUND(NDIST1,K0),ZBOUND(NDIST1,K0+1);
               1    (1X,'Coordinates:',3(2X,F5.1,',',F5.1));
               1    OUTPUT DOSE(NDIST1,I0,J0,K0),ERRDOSE(NDIST1,I0,J0,K0),
               1    DOSE(NDIST2,I0,J0,K0),ERRDOSE(NDIST2,I0,J0,K0) ;
               1    (1x,'Doses:',2(G10.3,'+-',G10.3));
               1    ]
               0
               0  OUTPUT DOSEMAX;(/1X,'Maximum dose along central axis is:',G10.2);
               0  XCOORD = 0.0;
               0  YCOORD = 0.0;
               0
               0  " find the point 0,0 in bin coordinates
               0
               0  $FIND_BIN(I,X);
               0  $FIND_BIN(J,Y);
               0
               0  OUTPUT I0,J0,KDMAX;(1X,'Occurs at voxel: ',3I9);
               0  OUTPUT XBOUND(NDIST1,I0),XBOUND(NDIST1,I0+1),
               0  YBOUND(NDIST1,J0),YBOUND(NDIST1,J0+1),ZBOUND(NDIST1,KDMAX),
               0  ZBOUND(NDIST1,KDMAX+1);(1X,'Coordinates:',3(2X,F5.1,',',F5.1));
               0  OUTPUT DOSE(NDIST1,I0,J0,KDMAX),ERRDOSE(NDIST1,I0,J0,KDMAX),
               0  DOSE(NDIST2,I0,J0,KDMAX),ERRDOSE(NDIST2,I0,J0,KDMAX) ;
               0  (1x,'Doses:',2(G10.3,'+-',G10.3));
               0
               0
               0
               0  CALL PLOTFREQ(LA_TYPE);
               0
               0  RETURN;
               0  END;
               0
               0  "-----------------------------------------------------------------------
               0  " SUBROUTINE PLOTFREQ
               0  "-----------------------------------------------------------------------
               0  " called by: STATS
               0
               0  " PURPOSE: PLOTFREQ sets the parameters for a plot of frequency distribution
               0  " as calculated in STATS, and then proceeds to call plot_xvgr for a single
               0  " curve
               0
               0  " see plotin and plot_xvgr.f for more details on the plot options
               0
               0
               0  " VARIABLES: NUM1- the number of characters in the first filename
               0  " NUM2 - the number of characters in the second filename
               0  " X_TYPE - the type of binning on the X-axis (ie absolute diff, or % diff)
               0
               0
               0  SUBROUTINE PLOTFREQ(X_TYPE);                                  "toc:"
               0  "IMPLICIT NONE;"
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0
               0  INTEGER NUM1,NUM2,X_TYPE;
               0
               0  REAL XMIN; "a dummy variable to pass to XVGRPLOT"
               0
               0  SAVE;
               0  " - find the number of letters in the file name of the desired distibution
               0
               0  CALL LETTERCOUNT(FILEIN(NDIST1),NUM1);
               0  CALL LETTERCOUNT(FILEIN(NDIST2),NUM2);
               0
               0  " - default value is as per below
               0
               0  TITLE  =  'frequency distribution of '//FILEIN(NDIST1)(1:MIN(10,NUM1))//
               0  ' / '//FILEIN(NDIST2)(1:MIN(10,NUM2));
               0
               0  " set labels for the x and y axes
               0
               0  IF(X_TYPE = 1)[ XAXIS=' D1 - D2  /Gy * cm**2)';]
               0  ELSEIF(X_TYPE = 2)[ XAXIS=' (D1-D2)/[(D1+D2)/2] * 100%';]
               0  ELSEIF(X_TYPE = 3)[ XAXIS=' (D1-D2)/DsmaxN * 100%';]
               0  ELSEIF(X_TYPE = 4)[ XAXIS=' (D1-D2)/sqrt(err1**2+err2**2)';]
               0  YAXIS=' normalized frequency distribution';
               0
               0  " set some plot options
               0  DO L = 1,4 [ IOPTION(L) = 0;]
               0
               0  " get data specific to the dose diff frequencies plot
               0  " - prompt the user for the output filename
               0  OUTPUT ;(/1X,'Output Filename (default=freqdist1): ',$);
               0  INPUT OUTFILE; (A);
               0
               0  " - default value is freqdist1
               0  IF OUTFILE = ' ' [OUTFILE = 'freqdist1';]
               0  outfile=outfile(1:lnblnk1(outfile))//'.agr';
               0  OPEN(UNIT=7,STATUS='UNKNOWN',FILE=outfile);
               0
               0  " set label for the curve
               0  IF(X_TYPE = 1)[CURVE_LABELS='dose difference';]
               0  IF(X_TYPE = 2|X_TYPE = 3)[ CURVE_LABELS='% dose difference'; ]
               0  ELSEIF(X_TYPE = 4)[
               1    CURVE_LABELS='dose difference/sqrt(err1**2+err**2)';
               1    ]
               0
               0  " set symbol and curve type
               0  NTYPE_SYMBOL = 1;
               0  NTYPE_CURVE = 1;
               0  CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48);
               0  " set the number of points and the number of curves
               0  NPOINTS = LTOT;
               0  NCURVE = 1;
               0
               0  " set the x coordinates to the value of the dose in each bin
               0  " set the y coordinates to the frequency with which that dose occurs
               0  " set the error in y to zero
               0
               0  DO L = 1,LTOT [ " frequency distribution of dose differences
               1    X(L) = DDBIN_DIFF*(L-(LTOT/2)-1);
               1    Y(L) = FREQ_DIFF(L);
               1    ERRY(L) = 0.0;
               1    ]
               0
               0  " plot the dose diff frequency graph
               0  SUBTITLE=' ';
               0
               0  XMIN=0.;
               0  CALL XVGRPLOT(X,Y,ERRY,NPOINTS,NCURVE-1,CURVE_LABELS,
               0  XAXIS,YAXIS,TITLE,SUBTITLE,7,IOPTION(1),XMIN,IOPTION(2));
               0
               0  " - pass all the information to the xvgr_script routine, which plots
               0  " the data
               0  OUTPUT ;(/1X,'Calling xmgrace...please be patient! ');
               0  CLOSE(7);
               0  CALL XVGR_SCRIPT;
               0
               0  " - get graphing parameters specific to the chi-squared frequency plot
               0  " - prompt the user for the output filename
               0  OUTPUT ;(/1X,'Output Filename (default = freqdist2): ',$);
               0  INPUT OUTFILE; (A);
               0
               0  " - default value is freqdist2
               0  IF OUTFILE = ' ' [OUTFILE = 'freqdist2';]
               0  outfile=outfile(1:lnblnk1(outfile))//'.agr';
               0  OPEN(UNIT=7,STATUS='UNKNOWN',FILE=outfile);
               0
               0  " - reset the x axis label
               0  XAXIS=' chi-squared';
               0
               0  " set label for the curve
               0  CURVE_LABELS='square of difference over error';
               0
               0  " set symbol and curve type
               0  NTYPE_SYMBOL = 1;
               0  NTYPE_CURVE = 1;
               0  CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48);
               0
               0  " set the number of points and the number of curves
               0  NPOINTS = LTOT;
               0  NCURVE = 1;
               0  " set the x coordinates to the value of the dose in each bin
               0  " set the y coordinates to the frequency with which that dose occurs
               0  " set the error in y to zero
               0
               0  DO L = 1,LTOT [ " frequency distribution of 'chi-squares'
               1    X(L) = DDBIN_CHI*(L-0.5);
               1    Y(L) = FREQ_CHI(L);
               1    ERRY(L) = 0.0;
               1    ]
               0
               0  " - plot the chi-squared frequency graph
               0  SUBTITLE=' ';
               0
               0  XMIN=0.;
               0  CALL XVGRPLOT(X,Y,ERRY,NPOINTS,NCURVE-1,CURVE_LABELS,
               0  XAXIS,YAXIS,TITLE,SUBTITLE,7,IOPTION(1),XMIN,IOPTION(2));
               0
               0  " - call the xvgr_script routine, which plots
               0  " the data
               0
               0  OUTPUT ;(/1X,'Calling xmgrace...please be patient! ');
               0
               0  CLOSE(7);
               0  CALL XVGR_SCRIPT;
               0
               0  " - prompt the user for an axis for more plot profiles
               0  RETURN;
               0  END;
               0
               0  "--------------------------------------------------------------------------
               0  " SUBROUTINE NORMMENU
               0  "--------------------------------------------------------------------------
               0  " called from: MAINMENU
               0
               0  " PURPOSE: NORMMENU displays a table of normalizing options
               0  " - the routine accepts numerical input and passes control to a subroutine
               0  " corresponding to the option chosen
               0
               0  " VARIABLES: ISELECT - holds the option selected by the user
               0
               0  SUBROUTINE NORMMENU;                                "toc:"
               0  "IMPLICIT NONE;"
               0  $COMIN1/DATA/;
               0
               0  INTEGER ISELECT;
               0  SAVE;
               0  EXTERNAL SCALE;
               0  :NORMMENU:
               0  NFLAG = 0;
               0  ISELECT = 0;
               0
               0  OUTPUT ;(/1X,'NORM MENU');
               0  OUTPUT ;(1X,'--------');
               0  OUTPUT ;(1X,'0 - Main menu');
               0  OUTPUT ;(1X,'1 - Apply scaling factor');
               0  OUTPUT ;(1X,'2 - Normalize to average dose');
               0  OUTPUT ;(1X,'3 - Normalize to maximum dose along central axis');
               0  OUTPUT ;(1X,'4 - Normalize to dose in specific voxel');
               0  OUTPUT ;(1X,'5 - Denormalize');
               0
               0  " - prompt the user to input the option desired
               0
               0  OUTPUT ;(/1X,'Selection: ',$);
               0  INPUT ISELECT;(I5);
               0
               0  " - if out of range, redisplay plot menu
               0
               0  IF (ISELECT<0|ISELECT>5) [GOTO :NORMMENU:;]
               0
               0  " - 0 returns control to the main menu
               0
               0  ELSEIF (ISELECT = 0) [RETURN;]
               0  ELSEIF (ISELECT = 1) [CALL SCALE;]
               0  ELSEIF (ISELECT = 2) [CALL AVERAGEDOSE;]
               0  ELSEIF (ISELECT = 3) [CALL CENTRALMAX;]
               0  ELSEIF (ISELECT = 4) [CALL SPECVOXEL;]
               0  ELSEIF (ISELECT = 5) [CALL DENORMALIZE;]
               0
               0  " - redisplay norm menu-
               0
               0  GOTO :NORMMENU:;
               0  END;
               0
               0  "----------------------------------------------------------------------------
               0  " SUBROUTINE SCALE
               0  "----------------------------------------------------------------------------
               0
               0  " called from: NORMMENU
               0
               0  " PURPOSE: SCALE prompts the user for a rescaling factor and applies it
               0  " to both the dose and errdose arrays
               0  " - the routine also keeps track of the overall scaling factor applied to
               0  " each array
               0
               0  " VARIABLES: SCALE - the rescaling factor
               0
               0  SUBROUTINE SCALE;                                         "toc:"
               0  "IMPLICIT NONE;"
               0
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0
               0  REAL SCALEFACT;
               0  SAVE;
               0  :SCALE:
               0  SCALEFACT = 0;
               0  OUTPUT ;(/1X,'Rescaling');
               0  OUTPUT ;(1X,'---------');
               0
               0  :SELECT4:
               0
               0  " - list the distributions which are currently loaded
               0
               0  OUTPUT ;(1X,'Files currently loaded:'/);
               0  DO N = 1,$NDIST1_MAX [
               1    IF NDIST1_FLAG(N) = 1 [
               2      OUTPUT N,FILEIN(N);(I2,' - ',A);
               2      ]
               1    ]
               0  OUTPUT ;(/1X,'Number of file to Rescale (0-MainMenu): ',$);
               0  INPUT NDIST1;(I2);
               0
               0  " - 0 returns control to the main menu
               0
               0  IF NDIST1 = 0 [RETURN;]
               0
               0  " - if the number is out of range, print the appropriate message
               0  " and prompt user to input another filename
               0
               0  ELSEIF NDIST1>$NDIST1_MAX  [
               1    OUTPUT ;(1X,'SORRY, THAT IS OUT OF RANGE.'/);
               1    GOTO :SELECT4:;
               1    ]
               0
               0  " - get scaling factor
               0
               0  :GETSCALE:
               0  OUTPUT ;(1X,'Scaling factor (0-Normmenu): ',$);
               0  INPUT SCALEFACT;(F10.0);
               0
               0  " - message if the value is out of range, and prompts the user to enter
               0  " the scale factor again
               0
               0  IF SCALEFACT<0 [
               1    OUTPUT ;(1X,'SORRY, THAT IS OUT OF RANGE.'/);
               1    GOTO :GETSCALE:;
               1    ]
               0
               0  " - a factor of zero defaults to the norm menu
               0
               0  ELSEIF SCALEFACT = 0 [RETURN;]
               0
               0  OUTPUT ;(1X,'RESCALING ARRAY...');
               0
               0  " multiply cumulative scale factor for the distribution by the scale factor
               0
               0  TOTALNORM(NDIST1) = SCALEFACT*TOTALNORM(NDIST1);
               0
               0  " scale the dose and errdose arrays by the factor
               0
               0  DO I = 1,IMAX(NDIST1) [
               1    DO J = 1,JMAX(NDIST1) [
               2      DO K = 1,KMAX(NDIST1) [
               3        DOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)*SCALEFACT;
               3        ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)*SCALEFACT;
               3        ]
               2      ]
               1    ]
               0
               0  " prompt the user to scale another distribution
               0
               0  GOTO :SCALE:;
               0  END;
               0
               0  "----------------------------------------------------------------------------
               0  " SUBROUTINE AVERAGEDOSE
               0  "----------------------------------------------------------------------------
               0
               0  " called from: NORMMENU
               0
               0  " PURPOSE: AVERAGEDOSE finds the average dose of the distribution
               0  " specified by the user
               0  " - it normalizes the distribution to this factor, and stores the
               0  " cumulative normalization factor for each distribution in an array
               0
               0  " VARIABLES: AVGDOSE - the average dose for the distribution
               0
               0  SUBROUTINE AVERAGEDOSE;                                         "toc:"
               0  "IMPLICIT NONE;"
               0
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0
               0  REAL AVGDOSE;
               0  SAVE;
               0  :AVGDOSE:
               0  AVGDOSE = 0;
               0  OUTPUT ;(/1X,'Normalize to average dose');
               0  OUTPUT ;(1X,'-------------------------');
               0
               0  :SELECT5:
               0
               0  " - list the distributions which are currently loaded
               0
               0  OUTPUT ;(1X,'Files currently loaded:'/);
               0  DO N = 1,$NDIST1_MAX [
               1    IF NDIST1_FLAG(N) = 1 [
               2      OUTPUT N,FILEIN(N);(I2,' - ',A);
               2      ]
               1    ]
               0  OUTPUT ;(/1X,'Number of file to Normalize (0-MainMenu): ',$);
               0  INPUT NDIST1;(I2);
               0
               0  " - 0 returns control to the main menu
               0
               0  IF NDIST1 = 0 [RETURN;]
               0
               0  " - if the number is out of range, print the appropriate message
               0  " and prompt user to input another filename
               0
               0  ELSEIF NDIST1>$NDIST1_MAX  [
               1    OUTPUT ;(1X,'SORRY, THAT IS OUT OF RANGE.'/);
               1    GOTO :SELECT5:;
               1    ]
               0
               0
               0  OUTPUT ;(1X,'NORMALIZING TO AVERAGE DOSE...');
               0
               0
               0  DO I = 1,IMAX(NDIST1) [
               1    DO J = 1,JMAX(NDIST1) [
               2      DO K = 1,KMAX(NDIST1) [
               3
               3        " find the sum of the doses of all the voxels in the distribution
               3
               3        AVGDOSE = DOSE(NDIST1,I,J,K)+AVGDOSE;
               3
               3        ]
               2      ]
               1    ]
               0
               0  " find the average dose for the distribution by dividing by the number
               0  " of voxels
               0
               0  AVGDOSE = AVGDOSE/(IMAX(NDIST1)*JMAX(NDIST1)*KMAX(NDIST1));
               0
               0  OUTPUT AVGDOSE;(1X,'AVERAGE DOSE: ',G10.4);
               0
               0
               0  " accumulate normalization factors for the distribution in an array
               0
               0  TOTALNORM(NDIST1)  =  TOTALNORM(NDIST1)/AVGDOSE;
               0
               0  " normalize the dose and errdose arrays to avgdose
               0  " (treats avgdose as a scaling factor in error calculation)
               0
               0  DO I = 1,IMAX(NDIST1) [
               1    DO J = 1,JMAX(NDIST1) [
               2      DO K = 1,KMAX(NDIST1) [
               3        DOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)/AVGDOSE;
               3        ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)/AVGDOSE;
               3        ]
               2      ]
               1    ]
               0
               0  " prompt the user to normalize another distribution to average dose
               0
               0  GOTO :AVGDOSE:;
               0  END;
               0
               0  "----------------------------------------------------------------------------
               0  " SUBROUTINE CENTRALMAX
               0  "----------------------------------------------------------------------------
               0
               0  " called from: NORMMENU
               0
               0  " PURPOSE: CENTRALMAX calculates the maximum dose along the central axis
               0  " of a dose distribution, and then normalizes the distribution to this
               0  " number
               0  " - the maximum dose is calculated by taking into account various
               0  " distribution grids, and averaging central data if there is not an
               0  " obvious choice of central axis
               0
               0  " VARIABLES: DOSE_STORE - temporary storage of cumulative dose
               0  " FACT_NORM - the normalization factor
               0  " ILO,IHI,JLO,JHI - the voxel boundaries for averaging dose
               0
               0  SUBROUTINE CENTRALMAX;                                         "toc:"
               0  "IMPLICIT NONE;"
               0
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0
               0  INTEGER ILO,IHI,JLO,JHI
               0  ;
               0  REAL FACT_NORM;
               0  REAL DOSE_STORE;
               0
               0  SAVE;
               0  :CENTRALMAX:
               0  FACT_NORM = 0;
               0  OUTPUT ;(/1X,'Normalize along central maximum');
               0  OUTPUT ;(1X,'-------------------------------');
               0
               0  :SELECT7:
               0
               0  " - list the distributions which are currently loaded
               0  OUTPUT ;(1X,'Files currently loaded:'/);
               0  DO N = 1,$NDIST1_MAX [
               1    IF NDIST1_FLAG(N) = 1 [
               2      OUTPUT N,FILEIN(N);(I2,' - ',A);
               2      ]
               1    ]
               0  OUTPUT ;(/1X,'Number of file to Normalize (0-MainMenu): ',$);
               0  INPUT NDIST1;(I2);
               0
               0  " - 0 returns control to the main menu
               0
               0  IF NDIST1 = 0 [RETURN;]
               0
               0  " - if the number is out of range, print the appropriate message
               0  " and prompt user to input another filename
               0
               0  ELSEIF NDIST1>$NDIST1_MAX  [
               1    OUTPUT ;(1X,'SORRY, THAT IS OUT OF RANGE.'/);
               1    GOTO :SELECT7:;
               1    ]
               0
               0  " if there are an even number of voxels in the x direction, set the
               0  " voxel lims for averaging the two centralmost voxels
               0
               0  IF (MOD(IMAX(NDIST1),2)) = 0 [
               1    ILO = IMAX(NDIST1)/2;
               1    IHI = IMAX(NDIST1)/2+1;
               1    ]
               0
               0  " otherwise, take only the central voxel into account
               0
               0  ELSE [
               1    ILO = IMAX(NDIST1)/2+1;
               1    IHI = IMAX(NDIST1)/2+1;
               1    ]
               0
               0  " if there are an even number of voxels in the y direction, set the
               0  " voxel lims for averaging the two centralmost voxels
               0
               0  IF (MOD(JMAX(NDIST1),2)) = 0 [
               1    JLO = JMAX(NDIST1)/2;
               1    JHI = JMAX(NDIST1)/2+1;
               1    ]
               0
               0  " otherwise, take only the central voxel into account
               0
               0  ELSE [
               1    JLO = JMAX(NDIST1)/2+1;
               1    JHI = JMAX(NDIST1)/2+1;
               1    ]
               0
               0  " find the average dose, using the above voxel lims, at the k-th level
               0  " in the voxel grid
               0
               0  DO K = 1,KMAX(NDIST1) [
               1
               1    " must set to 0 for the each k-th voxel
               1
               1    DOSE_STORE = 0;
               1    DO I = ILO,IHI [
               2      DO J = JLO,JHI [
               3
               3        " store dose in a cumulative sum
               3
               3        DOSE_STORE = DOSE(NDIST1,I,J,K)+DOSE_STORE;
               3        ]
               2      ]
               1
               1    " divide cumulative dose at the k-th level by the number of voxels
               1    " averaged
               1
               1    DOSE_STORE = DOSE_STORE/((IHI-ILO+1)*(JHI-JLO+1));
               1    AXISDOSE(NDIST1,K) = DOSE_STORE;
               1    ]
               0
               0  " find the maximum dose along the central axis
               0
               0  DO K = 1,KMAX(NDIST1) [FACT_NORM = MAX(FACT_NORM,AXISDOSE(NDIST1,K));]
               0
               0  " account for the normalization in the cumulative normalization global
               0  " for the distribution
               0
               0  TOTALNORM(NDIST1) = TOTALNORM(NDIST1)/FACT_NORM;
               0  OUTPUT ;(1X,'Normalizing to maximum dose along central axis...');
               0  OUTPUT (IHI-ILO+1);(1X,'Number of voxels averaged in X direction: ',I1);
               0  OUTPUT (JHI-JLO+1);(1X,'Number of voxels averaged in Y direction: ',I1);
               0  OUTPUT FACT_NORM;(1X,'Maximum dose along the axis: ',G10.2);
               0
               0  " normalize the dose and errdose arrays to fact_norm
               0  " (treats fact_norm as a scaling factor in error calculation)
               0
               0  DO I = 1,IMAX(NDIST1) [
               1    DO J = 1,JMAX(NDIST1) [
               2      DO K = 1,KMAX(NDIST1) [
               3        DOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)/FACT_NORM;
               3        ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)/FACT_NORM;
               3        ]
               2      ]
               1    ]
               0
               0  " prompt the user to normalize another distribution to dose along the
               0  " central axis
               0
               0  GOTO :CENTRALMAX:;
               0  END;
               0
               0  "----------------------------------------------------------------------------
               0  " SUBROUTINE SPECVOXEL
               0  "----------------------------------------------------------------------------
               0
               0  " called from: NORMMENU
               0
               0  " PURPOSE: SPECVOXEL normalizes the specified dose and errdose distributions
               0  " to the voxel specified
               0
               0  " VARIABLES: FACT_NORM - the normalization factor
               0  " ILO,IHI,JLO,JHI,KLO,KHI - the voxel boundaries for averaging dose
               0
               0  SUBROUTINE SPECVOXEL;                                         "toc:"
               0  "IMPLICIT NONE;"
               0
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0
               0  INTEGER ILO,IHI,JLO,JHI,KLO,KHI;
               0  REAL FACT_NORM;
               0  SAVE;
               0
               0  :SPECVOXEL:
               0  FACT_NORM = 0;
               0  OUTPUT ;(/1X,'Normalize to specific voxel');
               0  OUTPUT ;(1X,'---------------------------');
               0
               0  :SELECT6:
               0
               0  " - list the distributions which are currently loaded
               0
               0  OUTPUT ;(1X,'Files currently loaded:'/);
               0  DO N = 1,$NDIST1_MAX [
               1    IF (NDIST1_FLAG(N) = 1) [ OUTPUT N,FILEIN(N);(I2,' - ',A); ]
               1    ]
               0  OUTPUT ;(/1X,'Number of file to Normalize (0-MainMenu): ',$);
               0  INPUT NDIST1;(I2);
               0  IF NDIST1 = 0 [RETURN;]
               0
               0  "if the number is out of range, print the appropriate message
               0  " and prompt user to input another filename
               0  ELSEIF NDIST1>$NDIST1_MAX  [
               1    OUTPUT ;(1X,'SORRY, THAT IS OUT OF RANGE.'/);
               1    GOTO :SELECT6:;
               1    ]
               0
               0  OUTPUT ;(1X,'Voxel coordinates x,y,z (cm): ',$);
               0  read(5,*) XCOORD,YCOORD,ZCOORD;
               0  "INPUT XCOORD,YCOORD,ZCOORD;(3F10.0);  this didn't work??"
               0  IF($DEBUG)[OUTPUT XCOORD,YCOORD,ZCOORD;(' XCOORD,YCOORD,ZCOORD:',3F10.3);]
               0
               0  " convert the cm coordinates to bin coordinates
               0  $FIND_BIN(I,X);       $FIND_BIN(J,Y);       $FIND_BIN(K,Z);
               0  IF($DEBUG) [OUTPUT I0, J0, K0;('Post FIND_BINB: I0, J0, K0=',3I4);]
               0
               0  " find voxels to be included in a dose calculation for particular voxel"
               0  $FIND_LIMS(I,X);       $FIND_LIMS(J,Y);       $FIND_LIMS(K,Z);
               0  IF($DEBUG) [OUTPUT ILO, JLO, KLO;('Post FIND_LIMS: ILO, JLO, KLO=',3I4);]
               0
               0  DO I = ILO,IHI [
               1    DO J = JLO,JHI [
               2      DO K = KLO,KHI [
               3
               3        " sum the doses in predetermined voxels
               3        FACT_NORM = DOSE(NDIST1,I,J,K)+FACT_NORM;
               3        ]
               2      ]
               1    ]
               0  IF($DEBUG)[OUTPUT ILO,IHI,JLO,JHI,KLO,KHI,FACT_NORM;
               1    (' ILO,IHI,JLO,JHI,KLO,KHI,FACT_NORM:',6I4,3x,G10.4);
               1    ]
               0
               0  " find the average dose in the particular voxel by dividing the
               0  " sum of all the doses in the surrounding voxels by the number of
               0  " voxels considered
               0
               0  FACT_NORM = FACT_NORM/((IHI-ILO+1)*(JHI-JLO+1)*(KHI-KLO+1));
               0
               0  " account for this normalization in the total normalization for the
               0  " present distribution
               0
               0  TOTALNORM(NDIST1) = TOTALNORM(NDIST1)/FACT_NORM;
               0  OUTPUT I0,J0,K0;(1X,'Normalizing to dose in voxel ',3I3);
               0  OUTPUT (IHI-ILO+1);(1X,'Number of voxels averaged in X direction: ',I1);
               0  OUTPUT (JHI-JLO+1);(1X,'Number of voxels averaged in Y direction: ',I1);
               0  OUTPUT (KHI-KLO+1);(1X,'Number of voxels averaged in Z direction: ',I1);
               0  OUTPUT FACT_NORM;(1X,'Dose in the voxel: ',G10.2);
               0
               0  " normalize the dose and errdose arrays to fact_norm
               0  " (treats fact_norm as a scaling factor in error calculation)
               0
               0  DO I = 1,IMAX(NDIST1) [
               1    DO J = 1,JMAX(NDIST1) [
               2      DO K = 1,KMAX(NDIST1) [
               3        DOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)/FACT_NORM;
               3        ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)/FACT_NORM;
               3        ]
               2      ]
               1    ]
               0
               0  " prompt the user to normalize another distribution to dose in a
               0  " specific voxel
               0
               0  GOTO :SPECVOXEL:;
               0  END;
               0
               0  "----------------------------------------------------------------------------
               0  " SUBROUTINE DENORMALIZE
               0  "----------------------------------------------------------------------------
               0
               0  " called from: NORMMENU
               0
               0  " PURPOSE: DENORMALIZE gets rid of the effects of all normalizations on
               0  " the distribution specified
               0
               0  " VARIABLES:
               0
               0  SUBROUTINE DENORMALIZE;                                      "toc:"
               0  "IMPLICIT NONE;"
               0
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0  SAVE;
               0  :DENORMAL:
               0  OUTPUT ;(/1X,'DENORMALIZE');
               0  OUTPUT ;(1X,'-----------');
               0
               0  :SELECT8:
               0
               0  " - list the distributions which are currently loaded
               0
               0  OUTPUT ;(1X,'Files currently loaded:'/);
               0  DO N = 1,$NDIST1_MAX [
               1    IF NDIST1_FLAG(N) = 1 [
               2      OUTPUT N,FILEIN(N);(I2,' - ',A);
               2      ]
               1    ]
               0  OUTPUT ;(/1X,'Number of file to DeNormalize (0-MainMenu): ',$);
               0  INPUT NDIST1;(I2);
               0
               0  " - 0 returns control to the main menu
               0
               0  IF NDIST1 = 0 [RETURN;]
               0
               0  " - if the number is out of range, print the appropriate message
               0  " and prompt user to input another filename
               0
               0  ELSEIF NDIST1>$NDIST1_MAX  [
               1    OUTPUT ;(1X,'SORRY, THAT IS OUT OF RANGE.'/);
               1    GOTO :SELECT8:;
               1    ]
               0
               0  OUTPUT ;(1X,'DENORMALIZING DISTRIBUTION...');
               0
               0  " divide by the total normalization factor in order to eradicate the
               0  " effects of all normalizations performed on the dose and errdose
               0  " distributions
               0
               0  " if totalnorm has not changed, all this routine does is divide by one
               0
               0  DO I = 1,IMAX(NDIST1) [
               1    DO J = 1,JMAX(NDIST1) [
               2      DO K = 1,KMAX(NDIST1) [
               3        DOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)/TOTALNORM(NDIST1);
               3        ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)/TOTALNORM(NDIST1);
               3        ]
               2      ]
               1    ]
               0
               0  " prompt the user to denormalize another distribution
               0
               0  GOTO :DENORMAL:;
               0  END;
               0
               0  "------------------------------------------------------------------------
               0  " SUBROUTINE REBINNING
               0  "------------------------------------------------------------------------
               0
               0  " called from: MAINMENU
               0
               0  " PURPOSE: REBINNING creates a new distribution from an old data distribution
               0  " - the new data distribution corresponds to the old one, but has its
               0  " bins enlarged in one direction (or its sensitivity shrunk) by a factor
               0  " entered by the user
               0
               0  " VARIABLES: JEND - number of old bins per new bin
               0  " LASTBIN_FACT - number of old bins in the last bin of the new distribution
               0  " MAX_BIN - number of bins along the desired axis in the new distribution
               0  " NBIN_FACT - number of old bins for every bin in the new distribution
               0  " NDIST1_BIN - number of the new distribution
               0
               0
               0  SUBROUTINE REBINNING;                                         "toc:"
               0  "IMPLICIT NONE;"
               0
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0
               0  INTEGER JEND, LASTBIN_FACT,MAX_BIN,NBIN_FACT,NDIST1_BIN;
               0  SAVE;
               0  :REBIN:
               0  OUTPUT ;(/1X,'REBINNING');
               0  OUTPUT ;(1X,'----------');
               0
               0  :SELECT3:
               0
               0  " - list the distributions which are currently loaded
               0
               0  OUTPUT ;(1X,'Files currently loaded:'/);
               0  DO N = 1,$NDIST1_MAX [
               1    IF NDIST1_FLAG(N) = 1 [
               2      OUTPUT N,FILEIN(N);(I2,' - ',A);
               2      ]
               1    ]
               0  OUTPUT ;(/1X,'Number of file to Rebin (0-MainMenu): ',$);
               0  INPUT NDIST1;(I2);
               0
               0  " - 0 returns control to the main menu
               0
               0  IF NDIST1 = 0 [RETURN;]
               0
               0  " - if the number is out of range, print the appropriate message
               0  " and prompt user to input another filename
               0
               0  ELSEIF NDIST1>$NDIST1_MAX  [
               1    OUTPUT ;(1X,'SORRY, THAT IS OUT OF RANGE.'/);
               1    GOTO :SELECT3:;
               1    ]
               0
               0  :GETNUM:
               0  OUTPUT ;(1X,'Number of Rebinned File (1-5,0-MainMenu): ',$);
               0  INPUT NDIST1_BIN;(I2);
               0
               0  " - 0 returns control to the main menu
               0
               0  IF NDIST1_BIN = 0 [RETURN;]
               0
               0  " - if the number is out of range, print the appropriate message
               0  " and prompt user to input another filename
               0
               0  ELSEIF NDIST1_BIN>$NDIST1_MAX  [
               1    OUTPUT ;(1X,'SORRY, THAT IS OUT OF RANGE.'/);
               1    GOTO :SELECT3:;
               1    ]
               0
               0  " - the routine does not allow rewriting of the file being rebinned, as
               0  " this can cause errors
               0
               0  ELSEIF NDIST1_BIN = NDIST1 [
               1    OUTPUT ;(1X,'YOU CANNOT OVERWRITE THE FILE YOU ARE REBINNING.');
               1    GOTO :GETNUM:;
               1    ]
               0
               0  " - find the number of letters in the old filename
               0
               0  CALL LETTERCOUNT(FILEIN(NDIST1),NUMCHAR);
               0
               0  " - ask user for name of new distribution and set the new filename
               0  " default is the oldfilaname.rb
               0
               0  OUTPUT FILEIN(NDIST1)(1:NUMCHAR);
               0  (1X,'Name of rebinned file (default=',A,'.rb): ',$);
               0  INPUT FILEIN(NDIST1_BIN);(A);
               0  IF FILEIN(NDIST1_BIN) = ' ' [FILEIN(NDIST1_BIN)=FILEIN(NDIST1)(1:NUMCHAR)
               1    //'.rb';]
               0
               0  :GETAXIS:
               0  OUTPUT ;(1X,'Axis for rebinning (1-X,2-Y,3-Z): ',$);
               0  INPUT LA_AXIS; (I5);
               0  IF (LA_AXIS<1|LA_AXIS>3) [GOTO :GETAXIS:;]
               0  :GETFACT:
               0
               0  " - enter number of old bins for every new bin
               0
               0  OUTPUT ;(1X,'Rebinning factor: ',$);
               0  INPUT NBIN_FACT;(I5);
               0  IF NBIN_FACT = 0 [
               1    OUTPUT ;('REBINNING FACTOR MUST BE AN INTEGER GREATER THAN 0');
               1    GOTO :GETFACT:;
               1    ]
               0  OUTPUT ;(1X,'REBINNING......'/);
               0
               0
               0  " - ensure that the dose and errdose arrays for the new distribution are
               0  " set to 0's...this must be done since the data from an old file will
               0  " mess up the running total which is kept in the next part of the program
               0
               0  DO I = 1,IMAX(NDIST1) [
               1    DO J = 1,JMAX(NDIST1) [
               2      DO K = 1,KMAX(NDIST1) [
               3        DOSE(NDIST1_BIN,I,J,K) = 0.;
               3        ERRDOSE(NDIST1_BIN,I,J,K) = 0.;
               3        ]
               2      ]
               1    ]
               0
               0  " - must empty arrays, in case the routine is repeated
               0  " this is because the routine assumes that the initial
               0  " contents of the array are 0 when it begins calculation
               0
               0  " number of doses being averaged together is the rebinning factor
               0
               0  JEND = NBIN_FACT;
               0
               0  " only documented one of the next three options, since the only
               0  " variance in the routines is the axis along which the rebinning occurs
               0
               0  IF LA_AXIS = 1 [
               1
               1    " - for the axis being rebinned, the old voxel boundaries (cm) are transferred
               1    " to the new distribution array taking into account the rebinning factor
               1
               1    $TRANSFER_BOUNDS(I,X);
               1
               1    " - the old voxel boundaries (cm) for the other two axes are transferred from
               1    " the old distribution array to the new distribution array with no change
               1
               1    $KEEP_BOUNDS(J,Y);
               1    $KEEP_BOUNDS(K,Z);
               1
               1    "rebin the appropriate axis
               1
               1    $REBIN_AXIS(I,J,K);
               1
               1    ]
               0
               0  ELSEIF LA_AXIS = 2 [
               1    $TRANSFER_BOUNDS(J,Y);
               1    $KEEP_BOUNDS(I,X);
               1    $KEEP_BOUNDS(K,Z);
               1
               1    $REBIN_AXIS(J,I,K);
               1
               1    ]
               0  ELSEIF LA_AXIS = 3 [
               1    $TRANSFER_BOUNDS(K,Z);
               1    $KEEP_BOUNDS(I,X);
               1    $KEEP_BOUNDS(J,Y);
               1
               1    $REBIN_AXIS(K,I,J);
               1    ]
               0
               0  " - display the number of voxels in each direction for the new array
               0
               0  OUTPUT IMAX(NDIST1_BIN),JMAX(NDIST1_BIN),KMAX(NDIST1_BIN);
               0  (1X,'NUMBER OF VOXELS IN X,Y,Z DIRECTIONS: ',3I10);
               0
               0
               0  " - display the min/max dimensions of the 3d voxel grid (cm)
               0
               0  $OUT_THE_BOUNDS(I,X,NDIST1_BIN);
               0  $OUT_THE_BOUNDS(J,Y,NDIST1_BIN);
               0  $OUT_THE_BOUNDS(K,Z,NDIST1_BIN);
               0
               0  " - flag that there is now data in the new array
               0
               0  NDIST1_FLAG(NDIST1_BIN)  =  1;
               0
               0  " - prompt the user to rebin another file
               0
               0  GOTO :REBIN:;
               0
               0  "note, must check how to calculate errdose backwards, etc"
               0  " and also check on whether can just write backward...."
               0
               0  " must recreate the out_the_bounds routine, from the_bounds"
               0
               0  END;
               0
               0  "--------------------------------------------------------------------------
               0  " SUBROUTINE PLOTMENU
               0  "--------------------------------------------------------------------------
               0  " called from: MAINMENU
               0
               0  " PURPOSE: PLOTMENU displays a table of plot options
               0  " - the routine accepts numerical input and passes control to a subroutine
               0  " corresponding to the option chosen
               0
               0  " VARIABLES: ISELECT - holds the option selected by the user
               0
               0  SUBROUTINE PLOTMENU;                                           "toc:"
               0  "IMPLICIT NONE;"
               0  $COMIN1/DATA/;
               0
               0  INTEGER ISELECT;
               0  SAVE;
               0
               0  :PLOTMENU:
               0
               0  NFLAG = 0;
               0  ISELECT = 0;
               0
               0  OUTPUT ;(/1X,'PLOT MENU');
               0  OUTPUT ;(1X,'--------');
               0  OUTPUT ;(1X,'0 - Main menu');
               0  OUTPUT ;(1X,'1 - Plot profiles');
               0  OUTPUT ;(1X,'2 - Comparison plot');
               0
               0  " - prompt the user to input the option desired
               0
               0  OUTPUT ;(/1X,'Selection: ',$);
               0  INPUT ISELECT;(I5);
               0
               0  "if out of range, redisplay plot menu
               0  IF (ISELECT<0|ISELECT>2) [GOTO :PLOTMENU:;]
               0
               0  "0 returns control to the main menu
               0  ELSEIF (ISELECT = 0) [RETURN;]
               0  ELSEIF (ISELECT = 1) [CALL PLOTDOSE;]
               0  ELSEIF (ISELECT = 2) [
               1    " - check to see if there is more than one distribution loaded
               1    DO N = 1,$NDIST1_MAX [
               2      IF NDIST1_FLAG(N) = 1 [NFLAG=NFLAG+1;]
               2      ]
               1    IF($DEBUG)[OUTPUT NFLAG,(NDIST1_FLAG(N),N=1,$NDIST1_MAX);
               2      (' NFLAG=',I3,'  NDIST1_FLAG='/ (10I4));
               2      ]
               1
               1    "if there is pass control to the appropriate routine
               1    IF NFLAG>1 [CALL COMPAREPLOT;]
               1    ELSE [
               2      " - otherwise, redisplay the plot menu
               2      OUTPUT ;('Please read in more data before attempting to compare plots');
               2      ]
               1    ]
               0
               0
               0  " - redisplay plot menu-
               0
               0  GOTO :PLOTMENU:;
               0  END;
               0
               0  "-----------------------------------------------------------------------
               0  " SUBROUTINE PLOTDOSE
               0  "-----------------------------------------------------------------------
               0  " called by: PLOTMENU
               0
               0  " PURPOSE: PLOTDOSE plots plot profiles from a single dose distribution
               0  " along various axes and at various points
               0  " - it uses the graphics package xmgrace, which is accessed by calling
               0  " the routine plot_xvgr written by Barfels and Rogers
               0  " - for a single distribution, up to 20 curves can be plotted at the same
               0  " time ( however, this would make a very messy graph)
               0  " - the user selects the desired axis for the plot, and the coordinates
               0  " of the dose profiles to be plotted
               0  " - a few options can be entered, or left as default values, and in
               0  " general for simplicity, most of the values are automatically set to
               0  " default values
               0
               0  " VARIABLES:
               0
               0  SUBROUTINE PLOTDOSE;                                        "toc:"
               0  "IMPLICIT NONE;"
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0
               0  REAL XMIN; "a dummy variable to pass to XVGRPLOT"
               0  SAVE;
               0  :SELECT1:
               0  OUTPUT ;(/1X,'Data for dose plot');
               0  OUTPUT ;(1X,'------------------');
               0  OUTPUT ;(/1X,'Files currently loaded');
               0  OUTPUT ;(1X,'----------------------');
               0
               0  " - lists the distributions which are currently loaded
               0
               0  DO N = 1,$NDIST1_MAX [
               1    IF NDIST1_FLAG(N) = 1 [ OUTPUT N,FILEIN(N);(I2,' - ',A);]
               1    ]
               0
               0  " - prompt user for the number of the file to plot
               0
               0  OUTPUT ;(/1X,'Number of file to Plot (0-PlotMenu): ',$);
               0  INPUT NDIST1;(I1);
               0  IF NDIST1 = 0 [RETURN;]
               0
               0  " if number out of range, prompt user "
               0  ELSEIF NDIST1>$NDIST1_MAX  [
               1    OUTPUT ;(1X,'Sorry, that is out of range.');
               1    OUTPUT ; (' ');
               1    GOTO :SELECT1:;
               1    ]
               0
               0  MAX_CURVE  =  0;
               0
               0  :ENTER_AXIS1:
               0  IF($DEBUG)[OUTPUT;(' Starting :ENTER_AXIS1:');]
               0
               0  " prompt user for the axis of the profiles
               0
               0  OUTPUT ;(/1X,'Axis for Profile (0-PlotMenu,1-X,2-Y,3-Z): ',$);
               0  INPUT LA_AXIS; (I5);
               0  IF (LA_AXIS = 0) [RETURN;]
               0  "if out of range, prompt user "
               0  IF (LA_AXIS<1|LA_AXIS>3) [GOTO :ENTER_AXIS1:;]
               0
               0  ELSE [ " set some of the variables to default values
               1    IF LA_AXIS = 1 [$INIT_GRAPH(X);]
               1    ELSEIF LA_AXIS = 2 [$INIT_GRAPH(Y);]
               1    ELSEIF LA_AXIS = 3 [$INIT_GRAPH(Z);]
               1    ]
               0  IF($DEBUG)[OUTPUT LA_AXIS;(' Selected LA_AXIS=',I3);]
               0
               0  " - find the number of letters in the file name of the desired distibution
               0  CALL LETTERCOUNT(FILEIN(NDIST1),NUMCHAR);
               0
               0  "prompt the user for the title of the graph
               0  OUTPUT FILEIN(NDIST1)(1:NUMCHAR);(1X,'Graph Title (default=Profile for ',
               0  A,'): ',$);
               0  INPUT TITLE; (A);
               0
               0  "default value is Profile for filename
               0  IF TITLE = ' ' [TITLE = 'Profile for '//FILEIN(NDIST1)(1:NUMCHAR);]
               0  " - prompt the user for the output filename
               0  OUTPUT FILEIN(NDIST1)(1:NUMCHAR);(1X,'Output Filename (default=',A,
               0  '): ',$);
               0  INPUT OUTFILE; (A);
               0
               0  " default value is filename
               0  IF OUTFILE = ' ' [ OUTFILE = FILEIN(NDIST1)(1:NUMCHAR); ]
               0  " - ask the user for the number of curves to be plotted
               0
               0  OUTPUT ;(1X,'Number of curves to Plot: ',$);
               0  INPUT MAX_CURVE; (I5);
               0  IF MAX_CURVE = 0 [RETURN;]
               0
               0  "ask if they want multiple curves to be offset from one another
               0  IF (MAX_CURVE > 1) [
               1    OUTPUT ;(1X,'Generate Automatic Offset? (y/n) [n]: ',$);
               1    INPUT REPLY;(A);
               1    ]
               0  ELSE [REPLY='n';]
               0
               0  OUTPUT ;(' ');
               0  NCURVE = 0;
               0  outfile = outfile(1:lnblnk1(outfile))//'.agr';
               0  OPEN(UNIT=7,STATUS='UNKNOWN',FILE=outfile);
               0
               0  "get data and options and such stuff for each of the curves
               0
               0  :DEFINE_CURVE1: "loop through NCURVE curves"
               0
               0  IF($DEBUG)[OUTPUT;(' Starting :DEFINE_CURVE1: loop');]
               0
               0  "each time this part is executed, add one to a counter
               0  NCURVE = NCURVE + 1;
               0
               0  " - for desired axis, get coordinates of plot for each curve specified
               0
               0  " - once it has been determined which axis the plot is going to be along,
               0  " the coordinates of the point in the plane perpendicular to this axis
               0  " (where the plot will take place) are set to constants"
               0
               0  IF LA_AXIS = 1 [
               1    OUTPUT ;(1X,'Coordinates of Axis (y,z): ',$);
               1    "INPUT YCOORD,ZCOORD; (2F10.0);   doesnot work"
               1    READ(5,*) YCOORD,ZCOORD;
               1    IF($DEBUG)[OUTPUT YCOORD,ZCOORD;(1x,'Will plot at YCOORD,ZCOORD=',2F10.4);]
               1    ]
               0  IF LA_AXIS = 2 [
               1    OUTPUT ;(1X,'Coordinates of Axis (x,z): ',$);
               1    "INPUT XCOORD,ZCOORD; (2F10.0);   does not work"
               1    READ(5,*) XCOORD,ZCOORD;
               1    IF($DEBUG)[OUTPUT XCOORD,ZCOORD;(1x,'Will plot at XCOORD,ZCOORD=',2F10.4);]
               1    ]
               0  IF LA_AXIS = 3 [
               1    OUTPUT ;(1X,'Coordinates of Axis (x,y): ');
               1    READ(5,*) XCOORD,YCOORD;
               1    "INPUT XCOORD,YCOORD; (2F10.0);"  "This won't work for some reason"
               1    IF($DEBUG)[OUTPUT XCOORD,YCOORD;(1x,'Will plot at XCOORD,YCOORD=',2F10.4);]
               1    ]
               0
               0  " - print number and name of current dose distribution
               0  $PRINT_CURVEINFO;
               0  /I0,J0,K0/ = 0;
               0
               0  " - calculate voxel position from the coordinate entered
               0  " for the appropriate axis
               0
               0  IF LA_AXIS = 1 [ $FIND_BIN(J,Y); $FIND_BIN(K,Z); ]
               0  ELSEIF LA_AXIS = 2 [ $FIND_BIN(I,X); $FIND_BIN(K,Z); ]
               0  ELSEIF LA_AXIS = 3 [ $FIND_BIN(I,X); $FIND_BIN(J,Y); ]
               0
               0  IF LA_AXIS = 1  [
               1    " - find the dose and the error in the dose
               1    " at points along the specified axis (x,y or z)
               1    " at a the specified coordinate
               1
               1    $PROFILE(I,X);
               1
               1    " print number of voxels in x,y,z directions (along with message),
               1    " and voxel grid boundary values (in cm)
               1
               1    IF($DEBUG) [$PRINT_BOUNDS(I,X,J,K);]
               1
               1    " fill arrays of data to be passed to plot_xvgr routine
               1
               1    $THE_SPECS1(I,X,NCURVE);
               1    ]"end of LA_AXIS = 1 block"
               0
               0  "see above for documentation
               0  ELSEIF LA_AXIS = 2  [
               1    $PROFILE(J,Y);
               1    IF($DEBUG)[ $PRINT_BOUNDS(J,Y,I,K);]
               1    $THE_SPECS1(J,Y,NCURVE);
               1    ]
               0
               0  ELSEIF LA_AXIS = 3  [
               1    $PROFILE(K,Z);
               1    IF($DEBUG)[ $PRINT_BOUNDS(K,Z,I,J);]
               1    $THE_SPECS1(K,Z,NCURVE);
               1    ]
               0  ELSE   [ OUTPUT ; (1X,'ERROR, illegal data for axis'); ]
               0
               0  SUBTITLE=' ';
               0
               0  XMIN=0.;
               0  CALL XVGRPLOT(X,Y,ERRY,NPOINTS,NCURVE-1,CURVE_LABELS,
               0  XAXIS,YAXIS,TITLE,SUBTITLE,7,IOPTION(1),XMIN,IOPTION(2));
               0
               0  " if the coordinates of all the curves desired have been entered,
               0  " call xvgr_script
               0
               0  IF($DEBUG)[OUTPUT NCURVE,MAX_CURVE;
               1    ('Have prepared data for curve',I3,' of',I3);
               1    ]
               0  "prompt the user for another set of coordinates if needed
               0  IF(NCURVE < MAX_CURVE) GOTO :DEFINE_CURVE1:;
               0
               0  :PROFILE1:
               0
               0  " - pass all the information to the xvgr_script routine, which plots
               0  " the data
               0
               0  OUTPUT ;(/1X,'Calling xmgrace...Please be patient! ');
               0  CLOSE(7);
               0  CALL XVGR_SCRIPT;
               0
               0  " - prompt the user for an axis for more plot profiles
               0
               0  GOTO :ENTER_AXIS1:;
               0  END;
               0
               0  "------------------------------------------------------------------------
               0  " SUBROUTINE COMPAREPLOT
               0  "------------------------------------------------------------------------
               0
               0  " called by: PLOTMENU
               0
               0  " PURPOSE: COMPAREPLOT plots plot profiles from multiple dose distributions
               0  " along the same axis and at the same coordinates
               0  " - it uses the graphics package xvgr, which is accessed by calling
               0  " the routine plot_xvgr written by Barfels and Rogers
               0  " - for a multiple distributions, up to 5 curves can be plotted at the same
               0  " time
               0  " - the user selects the desired axis for the plot, and the coordinate
               0  " of the dose profiles to be plotted, as well as the files from which
               0  " each of the curves will be obtained
               0  " - a few options can be entered, or left as default values, and in
               0  " general for simplicity, most of the values are automatically set to
               0  " default values
               0
               0  " VARIABLES:
               0
               0  SUBROUTINE COMPAREPLOT;                                       "toc:"
               0  "IMPLICIT NONE;"
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0
               0  REAL XMIN; "a dummy variable to pass to XVGRPLOT"
               0
               0  SAVE;
               0  MAX_CURVE = 0;
               0  DO I = 1,$MAXCURVE[
               1    CURVE_LABELS='                    ';
               1    ]
               0  :ENTER_AXIS2:
               0  OUTPUT ;(/1X,'COMPARE-PLOT');
               0  OUTPUT ;(1X,'------------');
               0
               0  " - prompts the user for the axis of the compare-plots
               0
               0  OUTPUT ;(1X,'Axis for Compare-plot (0-PlotMenu,1-X,2-Y,3-Z): ',$);
               0  INPUT LA_AXIS; (I5);
               0
               0  " - if out of range, control returns to plot menu
               0
               0  IF (LA_AXIS<1|LA_AXIS>3) [RETURN;]
               0  ELSE [
               1
               1    " - set some of the variables to default values
               1
               1    IF LA_AXIS = 1 [$INIT_GRAPH(X);]
               1    ELSEIF LA_AXIS = 2 [$INIT_GRAPH(Y);]
               1    ELSEIF LA_AXIS = 3 [$INIT_GRAPH(Z);]
               1    ]
               0
               0  " - prompt user for the coordinates of the compare-plots
               0
               0  IF LA_AXIS = 1 [
               1    OUTPUT ;(1X,'Coordinates of Axis (y,z): ',$);
               1    READ(5,*) YCOORD,ZCOORD;
               1    "INPUT YCOORD,ZCOORD; (2F10.0);   didnot work??"
               1    ]
               0  IF LA_AXIS = 2 [
               1    OUTPUT ;(1X,'Coordinates of Axis (x,z): ',$);
               1    READ(5,*) XCOORD,ZCOORD;
               1    ]
               0  IF LA_AXIS = 3 [
               1    OUTPUT ;(1X,'Coordinates of Axis (x,y): ',$);
               1    READ(5,*) XCOORD,YCOORD;
               1    ]
               0
               0
               0  " - convert the coordinate into a character string, in order that
               0  " it can be concatenated to the default title string
               0
               0  IF LA_AXIS = 1 [$FIND_STRING1(Y,Z);]
               0  ELSEIF LA_AXIS = 2 [$FIND_STRING1(X,Z);]
               0  ELSEIF LA_AXIS = 3 [$FIND_STRING1(X,Y);]
               0
               0  " - prompt the user for the graph title
               0
               0  OUTPUT THE_STRING(1:ICOUNT);
               0
               0  " - default is Compareplot at (coordinate)
               0
               0  (1X,'Graph Title (default=Compareplot at ',A,'): ',$);
               0  INPUT TITLE; (A);
               0  IF TITLE = ' ' [TITLE = 'Compareplot at '//THE_STRING(1:ICOUNT);]
               0
               0  " - prompt the user for the output filename
               0
               0  OUTPUT ;(1X,'Output Filename (default=Compareplot.agr): ',$);
               0  INPUT OUTFILE; (A);
               0
               0  " - default is Compareplot
               0
               0  IF OUTFILE = ' ' [OUTFILE = 'Compareplot';]
               0
               0  " - ask the user if they want the curves offset from one another
               0
               0  OUTPUT ;(/1X,'Generate Automatic Offset? (y/n) [n]: ',$);
               0  INPUT REPLY;(A);
               0
               0  NCURVE = 0;
               0  outfile=outfile(1:lnblnk1(outfile))//'.agr';
               0  OPEN(UNIT=7,STATUS='UNKNOWN',FILE=outfile);
               0
               0  :DEFINE_CURVE2: "loop through NCURVE curves"
               0
               0  :SELECT2:
               0
               0  " - lists distributions with data in them
               0
               0  OUTPUT ;(/1X,'Files currently loaded:'/);
               0  DO N = 1,$NDIST1_MAX [
               1    IF NDIST1_FLAG(N) = 1 [OUTPUT N,FILEIN(N);(I2,' - ',A);]
               1    ]
               0
               0  " - prompt user for the number of the curve to put on the
               0  " compare-plot
               0
               0  OUTPUT ;
               0  (/1X,'Input curve # to be plotted in this graph (0=>View Graph): ',$);
               0  INPUT NDIST1;(I2);
               0
               0  " - if a 0 is entered, and if no curves have been loaded into the
               0  " graphing arrays, return to plot menu
               0
               0  IF NDIST1 = 0 [
               1    IF NCURVE = 0 [RETURN;]
               1
               1    " - if a 0 ies entered, and there are curves in the graphing arrays,
               1    " plot the graph
               1
               1    ELSE [GOTO :COMPARE_PLOT:;]
               1    ]
               0
               0  " - if out of range, return prompt the user for another curve
               0
               0  ELSEIF NDIST1>$NDIST1_MAX  [
               1    OUTPUT ;(1X,'Sorry, that is out of range.'/);
               1    GOTO :SELECT2:;
               1    ]
               0
               0  " - add one to a counter each time this part is executed
               0
               0  NCURVE  =  NCURVE + 1;
               0
               0
               0  /I0,J0,K0/ = 0;
               0
               0  " - calculate voxel position from the coordinate entered
               0  " for the appropriate axis
               0
               0  IF LA_AXIS = 1 [
               1    $FIND_BIN(J,Y);
               1    $FIND_BIN(K,Z);
               1    ]
               0  ELSEIF LA_AXIS = 2 [
               1    $FIND_BIN(I,X);
               1    $FIND_BIN(K,Z);
               1    ]
               0  ELSEIF LA_AXIS = 3 [
               1    $FIND_BIN(I,X);
               1    $FIND_BIN(J,Y);
               1    ]
               0
               0
               0  " - print number and name of current dose distribution
               0
               0  $PRINT_CURVEINFO;
               0
               0  IF LA_AXIS = 1  [
               1
               1    " - find the dose and the error in the dose
               1    " at points along the specified axis (x,y or z)
               1    " at the specified coordinate, for the specified curve
               1
               1    $PROFILE(I,X);
               1
               1    " - print the number of voxels in the x,y,z directions
               1    " on the screen (along with a message)
               1    " and the voxel grid boundary values (in cm)
               1
               1    "   $PRINT_BOUNDS(I,X,J,K);"
               1
               1    " - fill the arrays of data to be passed to the plot_xvgr routine
               1
               1    $THE_SPECS2(I,X,NCURVE);
               1    ]
               0
               0  " - see above for documentation
               0
               0  ELSEIF LA_AXIS = 2  [
               1    $PROFILE(J,Y);
               1    "  $PRINT_BOUNDS(J,Y,I,K);"
               1    $THE_SPECS2(J,Y,NCURVE);
               1    ]
               0
               0  " - see above for documentation
               0
               0  ELSEIF LA_AXIS = 3  [
               1    $PROFILE(K,Z);
               1    "   $PRINT_BOUNDS(K,Z,I,J);"
               1    $THE_SPECS2(K,Z,NCURVE);
               1    ]
               0  ELSE  [OUTPUT ; (1X,'ERROR, ILLEGAL DATA FOR AXIS');]
               0
               0  SUBTITLE=' ';
               0
               0  XMIN=0.;
               0  CALL XVGRPLOT(X,Y,ERRY,NPOINTS,NCURVE-1,CURVE_LABELS,
               0  XAXIS,YAXIS,TITLE,SUBTITLE,7,IOPTION(1),XMIN,IOPTION(2));
               0
               0  " - if the maximum number of curves have been entered, plot the
               0  " graph
               0
               0  IF (NCURVE=$MAXCURVE) [GOTO :COMPARE_PLOT:;]
               0
               0  " - otherwise get the data for the next curve
               0
               0  ELSE [GOTO :DEFINE_CURVE2:;]
               0
               0
               0  :COMPARE_PLOT:
               0
               0  " - call xvgr_script
               0  OUTPUT ;(/1X,'CALLING XMGR...PLEASE BE PATIENT! ');
               0
               0  CLOSE(7);
               0  CALL XVGR_SCRIPT;
               0
               0  " - prompt the user for an axis for another compare-plot
               0
               0  GOTO :ENTER_AXIS2:;
               0  END;
               0
               0  "------------------------------------------------------------------------
               0  " SUBROUTINE SAVE
               0  "------------------------------------------------------------------------
               0
               0  " - called from: MAINMENU
               0
               0  " PURPOSE: SAVE saves any distribution currently loaded to a file
               0  " - it is mainly a facility for storing rebinned files, although
               0  " files could be rewritten (why anyone would want to do this, i don't
               0  " quite know)
               0
               0  " VARIABLES: TEMPNAME - temporarily stores the distribution name
               0  " THERE - holds response to whether or not file currently exists
               0
               0
               0  SUBROUTINE SAVE;                                              "toc:"
               0  "IMPLICIT NONE;"
               0  $COMIN1/DATA/;
               0  $COMIN2/DATA/;
               0
               0  CHARACTER*70 TEMPNAME;
               0  LOGICAL THERE;
               0  SAVE;
               0
               0  :SAVE:
               0  OUTPUT ;(/1X,'SAVE FILES');
               0  OUTPUT ;(1X,'----------');
               0
               0  :SELECT4:
               0  OUTPUT ;(1X,'Files currently loaded:'/);
               0
               0  " - list the distributions currently loaded
               0
               0  DO N = 1,$NDIST1_MAX [
               1    IF NDIST1_FLAG(N) = 1 [OUTPUT N,FILEIN(N);(I2,' - ',A);]
               1    ]
               0
               0  " - prompt user to input the file which they want saved
               0
               0  OUTPUT ;(/1X,'Number of file to Save (0-MainMenu): ',$);
               0  INPUT NDIST1;(I2);
               0
               0  " - 0 returns control to the main menu
               0
               0  IF NDIST1=0 [RETURN;]
               0
               0  " - if out of range, prompt the user to enter another number
               0
               0  ELSEIF NDIST1>$NDIST1_MAX  [
               1    OUTPUT ;(1X,'SORRY, THAT IS OUT OF RANGE.'/);
               1    GOTO :SELECT4:;
               1    ]
               0
               0  " - store the name of the distribution in TEMPNAME
               0
               0  TEMPNAME = FILEIN(NDIST1);
               0
               0  " - calculate the number of letters in the current filename
               0
               0  CALL LETTERCOUNT(FILEIN(NDIST1),NUMCHAR);
               0
               0  " - prompt the user for name of file to be saved
               0
               0  OUTPUT FILEIN(NDIST1)(1:NUMCHAR);
               0  (1X,'Name of saved file (default=',A,'): ',$);
               0  INPUT FILEIN(NDIST1);(A);
               0
               0  " - default is current filename
               0
               0  IF FILEIN(NDIST1) = ' ' [FILEIN(NDIST1) = TEMPNAME;]
               0
               0  " - calculate number of characters in new file name
               0
               0  CALL LETTERCOUNT(FILEIN(NDIST1),NUMCHAR);
               0
               0  " - if file exists, open it
               0
               0  INQUIRE (FILE = FILEIN(NDIST1)(1:NUMCHAR)//'.3ddose',EXIST=THERE);
               0  IF THERE [OPEN(UNIT=4,FILE=FILEIN(NDIST1)(1:NUMCHAR)//
               1    '.3ddose',STATUS='OLD');]
               0
               0  " - if file doesn't exist, open it
               0
               0  ELSE [OPEN(UNIT=4,FILE=FILEIN(NDIST1)(1:NUMCHAR)//
               1    '.3ddose',STATUS='NEW');]
               0
               0  " - write the number of voxels in each direction
               0
               0  WRITE(4,*) IMAX(NDIST1),JMAX(NDIST1),KMAX(NDIST1);
               0
               0  " - write the voxel division values (cm)
               0
               0  DO I = 1,(IMAX(NDIST1)+1)  [
               1    WRITE(4,*) XBOUND(NDIST1,I);
               1    ]
               0  DO I = 1,(JMAX(NDIST1)+1)  [
               1    WRITE(4,*) YBOUND(NDIST1,I);
               1    ]
               0  DO I = 1,(KMAX(NDIST1)+1)  [
               1    WRITE(4,*) ZBOUND(NDIST1,I);
               1    ]
               0
               0  OUTPUT ;
               0  (1X,'WRITING DOSE DISTRIBUTION...');
               0
               0  " - write dose in the order (1,1,1), (2,1,1), (3,1,1),.. (1,2,1),(2,2,1)...
               0
               0  WRITE(4,*)
               0  (((DOSE(NDIST1,I,J,K),I = 1,IMAX(NDIST1)),J = 1,JMAX(NDIST1)),
               0  K = 1,KMAX(NDIST1));
               0
               0  " - convert errors back into relative errors (from absolute errors)
               0
               0  OUTPUT ;
               0  (1X,'WRITING ERROR IN DOSE DISTRIBUTION...');
               0  DO I = 1,IMAX(NDIST1)  [
               1    DO J = 1,JMAX(NDIST1)   [
               2      DO K = 1,KMAX(NDIST1)   [
               3        ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)/DOSE(NDIST1,I,J,K);
               3        ]
               2      ]
               1    ]
               0
               0  " - write errdose in the same order as dose
               0
               0  WRITE(4,*)
               0  (((ERRDOSE(NDIST1,I,J,K),I = 1,IMAX(NDIST1)),J = 1,JMAX(NDIST1)),
               0  K = 1,KMAX(NDIST1));
               0  DO I = 1,IMAX(NDIST1)   [
               1    DO J = 1,JMAX(NDIST1)   [
               2      DO K = 1,KMAX(NDIST1)   [
               3        ERRDOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)*ERRDOSE(NDIST1,I,J,K);
               3        ]
               2      ]
               1    ]
               0
               0  CLOSE(UNIT=4);
               0
               0  " - prompt the user for the number of another curve to be saved
               0
               0  GOTO :SAVE:;
               0  END;
               0
               0  "-------------------------------------------------------------------------
               0  " SUBROUTINE LETTERCOUNT
               0  "-------------------------------------------------------------------------
               0
               0  " called from: READDOSE, REBINNING, PLOTDOSE, SAVE
               0
               0  " PURPOSE: lettercount counts the actual number of characters in
               0  " a string
               0
               0  " VARIABLES: I,J - counters
               0  " FLAG - indicates whether all of the string has been counted
               0  " STRING - the string passed to the routine
               0
               0
               0  " Routine modified from Melanie Barfels' routine in plot_xvgr
               0  " NOTE: all strings fed to this routine MUST HAVE 70 characters
               0  " in their declarations, or this will not work!!!!!!! you have been
               0  " warned!
               0
               0  SUBROUTINE LETTERCOUNT(STRING,J);                          "toc:"
               0  "IMPLICIT NONE;"
               0  CHARACTER*70 STRING;
               0  INTEGER I, J;
               0  LOGICAL FLAG;
               0  SAVE;
               0
               0  " - initialization for letter counter
               0
               0  J = 0;
               0
               0  " - loop one fewer times than the length of the string
               0
               0  DO I = 1,69 [
               1
               1    " - if the next character in the string is not blank, add one to the counter
               1
               1    FLAG = STRING(I:I+1).NE.' ';
               1    IF FLAG [J = J+1];
               1    ]
               0  FLAG = STRING(70:70).NE.' ';
               0  IF FLAG [J = J+1];
               0  RETURN;
               0  END;
               0  ;
               0  ;
               0  SUBROUTINE XVGR_SCRIPT;
               0  "
               0  " This is a subroutine used by statdose to generate a script and run xmgrace.
               0  "
               0  " PROGRAMMER C-M MA--Modified by B Walters 18/10/96
               0  "
               0  "*******************************************************************************
               0  "**VARIABLES**"
               0
               0  "---Force declarations of all variables---"
               0  IMPLICIT NONE;
               0
               0  $COMIN2/DATA/;
               0
               0  CHARACTER*100 SCRIPT(4);
               0  INTEGER istat, egs_system;
               0
               0  "CREATING A SCRIPT FILE FOR xmgrace"
               0  OPEN(4,FILE='xmgr_script',FORM='FORMATTED',STATUS='UNKNOWN');
               0  SCRIPT(3)(1:8)='xmgrace ';
               0  SCRIPT(3)(9:100) =  outfile;
               0  SCRIPT(1)='#!/bin/sh';
               0  SCRIPT(2)='#xmgr_script';
               0  SCRIPT(4)='exit';
               0  WRITE (4,*)SCRIPT(1)(1:60);
               0  WRITE (4,*)SCRIPT(2)(1:60);
               0  WRITE (4,*)SCRIPT(3)(1:);
               0  WRITE (4,*)SCRIPT(4)(1:60);
               0  CLOSE(4);
               0  istat=egs_system('sh xmgr_script &');
               0  IF(istat~=0)["do not have xmgr on this machine"
               1    "currently on windows istat=0 because of the & in the command passed"
               1    "to egs_system.  That means this nice message does not get printed."
               1    OUTPUT;(//' xmgr/xmgrace is not available on this machine.'/
               1    ' Will not be called.'//);
               1    ]
               0  "executes xmgr_script file"
               0  "redirected output to null device, and runs xvgr in background"
               0  RETURN;
               0  END;
               0  ;
               0  C##############################################################################
               0  C
               0  C   This file was automatically generated by configure version 2.0
               0  C   It contains various subroutines and functions for date, time,
               0  C   CPU time, host name, etc.
               0  C
               0  C   Attention: all changes will be lost the next time you run configure!
               0  C
               0  C##############################################################################
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_system subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C egs_system(command)  runs a system command and returns the status
               0  C                      command must be null-terminated
               0  C*****************************************************************************
               0  integer function egs_system(command)
               0  character*(*) command
               0  integer system, istat
               0  istat = system(command)
               0  egs_system = istat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_isdir subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C  egs_isdir(file_name)  Returns .true., if the string file_name points to
               0  C                        an existing directory. This version uses the lstat
               0  C                        intrinsic and then tests for bit 14 being set in
               0  C                        the mode element. This works on all Unix systems
               0  C                        that I have access to (Linux, Aix, HP-UX, OSF1,
               0  C                        Solaris, IRIX)
               0  C
               0  C*****************************************************************************
               0
               0  logical function egs_isdir(file_name)
               0  implicit none
               0  character*(*) file_name
               0  integer*4 lnblnk1, res, array(13), l, lstat
               0  logical btest
               0  egs_isdir = .false.
               0  l = lnblnk1(file_name)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
               0  ! On some systems lstat only works if the string is 0-terminated
               0  res = lstat(file_name,array)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
               0  if( res.eq.0 ) then
               0  ! Amost all compilers that have the lstat intrinsic return the
               0  ! file mode in the 3rd array element. But the PGI compiler has
               0  ! its own opinion on the subject and returns it in the 5th element
               0  ! That's why the relevant element is written as 3
               0  ! here, 3 gets replaced by the appropriate element
               0  ! by the configure script.
               0  if( btest(array(3),14) ) egs_isdir = .true.
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C***************************************************************************
               0  C
               0  C   egs_fdate(out):  print a 24 char date and time string in the form
               0  C                         'Tue Mar 18 08:16:42 2003'
               0  C                    to the unit specified by out without end of line
               0  C                    i.e. the sequence
               0  C                    write(6,'(a,$)') 'Today is '
               0  C                    call egs_fdate(6)
               0  C                    write(6,'(a)') '. Have a nice date'
               0  C                    should result in something like
               0  C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
               0  C                    printed to unit 6.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_fdate(ounit)
               0  integer ounit
               0  character*24 string
               0  call fdate(string)
               0  write(ounit,'(a,$)') string
               0  end
               0
               0  C***************************************************************************
               0  C
               0  C   egs_get_fdate(string) assignes a 24 char date and time string to string
               0  C                         string must be at least 24 chars long, otherwise
               0  C                         this subroutine has no effect.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_get_fdate(string)
               0  character*(*) string
               0  if( len(string).ge.24 ) call fdate(string)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date_and_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  subroutine egs_date_and_time(vnow)
               0  integer vnow(8)
               0  character dat*8,tim*10,zon*5
               0  call date_and_time(dat,tim,zon,vnow)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*************************************************************************
               0  C
               0  C egs_date(ounit): print a 11 char string in the form
               0  C                     '18-Mar-2003'
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_date(ounit)
               0  integer ounit
               0  character string*24, dat*11
               0  call fdate(string)
               0  dat(1:2) = string(9:10)
               0  dat(3:3) = '-'
               0  dat(4:6) = string(5:7)
               0  dat(7:7) = '-'
               0  dat(8:11) = string(21:24)
               0  write(ounit,'(a,$)') dat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
               0  C*************************************************************************
               0  C
               0  C egs_time(ounit): print a 8 char string in the form hh:mm:ss
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_time(ounit)
               0  integer ounit
               0  character string*24
               0  call fdate(string)
               0  write(ounit,'(a,$)') string(12:19)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc seconds timing subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_secnds(t0): returns seconds passed since midnight minus t0
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_secnds(t0)
               0  real t0,t1
               0  character dat*8,tim*10,zon*5
               0  integer values(8)
               0  call date_and_time(dat,tim,zon,values)
               0  t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
               0  egs_secnds = t1 - t0
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_tot_time()
               0  C
               0  C   On first call returns seconds passed since 1/1/1970
               0  C   On subsequent calls returns
               0  C     - seconds since last call, if flag = 0
               0  C     - seconds since first call, else
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_tot_time(flag)
               0  integer flag
               0  character dat*8,tim*10,zon*5
               0  integer vnow(8), vlast(8),i
               0  real t,egs_time_diff,t0
               0  data vlast/1970,1,1,5*0/,t0/-1/
               0  save vlast,t0
               0  call date_and_time(dat,tim,zon,vnow)
               0  t = egs_time_diff(vlast,vnow)
               0  do i=1,8
               0  vlast(i)=vnow(i)
               0  end do
               0  if( t0.lt.0 ) then
               0  t0 = 0
               0  egs_tot_time = t
               0  else
               0  t0 = t0 + t
               0  if(flag.eq.0) then
               0  egs_tot_time = t
               0  else
               0  egs_tot_time = t0
               0  end if
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date and time subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C****************************************************************************
               0  C
               0  C Returns the time difference between vstart and vend
               0  C vstart and vend are integer arrays of dimension 8 with elements
               0  C corresponding to the specification of the data_and_time routine, i.e.
               0  C   array(1) = year
               0  C   array(2) = month of the year   (1...12)
               0  C   array(3) = day of the month    (1...31)
               0  C   array(4) = difference in minutes from UTC
               0  C   array(5) = hour of the day     (1...23)
               0  C   array(6) = minute of the hour  (1...59)
               0  C   array(7) = seconds of the minute (1...59)
               0  C   array(8) = miliseconds of the second (1...999)
               0  C
               0  C Note: this implementation ignores the time difference from UTC field
               0  C
               0  C*****************************************************************************
               0  real function egs_time_diff(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  real       egs_time_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_time_diff = -egs_time_diff_o(vend,vstart)
               0  else
               0  egs_time_diff = egs_time_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C day difference between the dates specified by the integer arrays vstart and
               0  C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
               0  C
               0  C******************************************************************************
               0  integer function egs_day_diff(vstart,vend)
               0  integer vstart(3),vend(3),egs_day_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_day_diff = -egs_day_diff_o(vend,vstart)
               0  else
               0  egs_day_diff = egs_day_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns a 3-letter abreviation of the day of the week in the string day,
               0  C given a day specified by the integer array values
               0  C   values(1)=year, values(2)=month, values(3)=day
               0  C
               0  C******************************************************************************
               0  subroutine egs_weekday(values,day)
               0  character*(*) day
               0  integer       values(3)
               0  integer       days,vtmp(3),egs_day_diff,aux
               0  character*3   wdays(7)
               0  data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
               0  vtmp(1) = 1970
               0  vtmp(2) = 1
               0  vtmp(3) = 1
               0  days = egs_day_diff(vtmp,values)
               0  aux = mod(days,7)
               0  days = 4 + aux
               0  if( days.gt.7 ) days = days - 7
               0  day(:len(day)) = ' '
               0  aux = min(len(day),3)
               0  day(:aux) = wdays(days)(:aux)
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Same as egs_day_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C*****************************************************************************
               0  integer function egs_day_diff_o(vstart,vend)
               0  integer vstart(3),vend(3)
               0  integer    days
               0  logical    next_month
               0  integer    tm,m,ty,y
               0  integer    mdays(12)
               0  data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
               0  days = 0
               0  ty = vstart(1)
               0  y  = vend(1)
               0  tm = vstart(2)
               0  m  = vend(2)
               0  next_month = .true.
               0  do while(next_month)
               0  if( tm.eq.m.and.ty.eq.y ) then
               0  next_month = .false.
               0  else
               0  days = days + mdays(tm)
               0  if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
               0  tm = tm + 1
               0  if( tm.gt.12 ) then
               0  ty = ty + 1
               0  tm = 1
               0  end if
               0  end if
               0  end do
               0  days = days + vend(3) - vstart(3)
               0  egs_day_diff_o = days
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Same as egs_time_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C******************************************************************************
               0  real function egs_time_diff_o(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  integer    days,hours,minutes,secs,msecs
               0  integer    egs_day_diff_o
               0  days = egs_day_diff_o(vstart,vend)
               0  hours = vend(5) - vstart(5)
               0  minutes = vend(6) - vstart(6)
               0  secs = vend(7) - vstart(7)
               0  msecs = vend(8) - vstart(8)
               0  egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
               0  &                  0.001*msecs
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns in month a 3-letter abreviation of the month specified by mo, if
               0  C mo is between 1 and 12, or an empty string otherwise.
               0  C
               0  C******************************************************************************
               0  subroutine egs_month(mo,month)
               0  integer mo
               0  character*(*) month
               0  integer iaux
               0  character*3   months(12)
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  iaux = min(len(month),3)
               0  month(:len(month)) = ' '
               0  if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Converts a 3-letter abreviation of a month to its corresponding integer
               0  C value, if the string month is a valid month, or -1 otherwise.
               0  C
               0  C******************************************************************************
               0  integer function egs_conver_month(month)
               0  character*3 month
               0  character*3 months(12)
               0  integer i
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  do i=1,12
               0  if( month.eq.months(i) ) then
               0  egs_conver_month = i
               0  return
               0  end if
               0  end do
               0  egs_conver_month = -1
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_etime subroutine
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_etime(): returns CPU time consumed since the start of
               0  C                            the program
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_etime()
               0  real tarray(2),etime
               0  egs_etime = etime(tarray)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc canonical system name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_canonical_system(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_canonical_system(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('x86_64-unknown-linux-gnu')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'x86_64-unknown-linux-gnu'
               0  else
               0  res(:l2) = 'x86_64-unknown-linux-gnu'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc configuration name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the configuration name as specified suring the configuration
               0  C process to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_configuration_name(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'linux'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the configuration name as specified suring the configuration
               0  C process to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_configuration_name(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('linux')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'linux'
               0  else
               0  res(:l2) = 'linux'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc hostname subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C Print the host name to the unit specified by ounit without inserting
               0  C a new line character.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_hostnm(ounit)
               0  integer ounit
               0  character*256 string
               0  integer res,hostnm,lnblnk1
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  write(ounit,'(a,$)') string(:lnblnk1(string))
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Assign the host name to the string pointed to be hname.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_get_hostnm(hname)
               0  character*(*) hname
               0  character*256 string
               0  integer res,hostnm,lnblnk1,l1,l2,l
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  l1 = lnblnk1(string)
               0  l2 = len(hname)
               0  hname(:l2) = ' '
               0  l = min(l1,l2)
               0  hname(:l) = string(:l)
               0  return
               0  end
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc xvgr plotting subroutines                                           "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Andrew Booth, 1995                                        "
               0  "                                                                             "
               0  "  Contributors:    Charlie Ma                                                "
               0  "                   Aaron Merovitz                                            "
               0  "                   Dave Rogers                                               "
               0  "                   Blake Walters                                             "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  !INDENT F2;
               0  %I4                                                                            ;
               0  %Q1                                                                            ;
               0  "************************************************************************"
               0
               0  SUBROUTINE XVGRPLOT (X, Y, ERRY, NPTS, CURVENUM, SERIESTITLE,
               0  XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               0  UNITNUM, TYPE, HISTXMIN, AXISTYPE);
               0
               0  "************************************************************************"
               0  "                                                                        "
               0  "  This subroutine is used to create an xvgr plot file that will plot    "
               0  "  Y as a function of X and include all of the pertinent information for "
               0  "  the graph.  Each time the subroutine is called it writes one series   "
               0  "  worth of data points to the unit specified.  For graphs that use      "
               0  "  several series, multiple subroutine calls are required.               "
               0  "                                                                        "
               0  "  Written  by:  Andrew Booth, August 1995                               "
               0  "  Modified by:  C-M Ma, Sept. 1995                                      "
               0  "  Modified by:  Andrew Booth, July 1996                                 "
               0  "                - introduced AXISTYPE argument to handle lin and log    "
               0  "                  axis combinations.                                    "
               0  "   Jan 98 A Merovitz/DR added xview xmin value so y axis label displayed"
               0  "   Feb 98 A Merovitz/DR if non-negative, makes zeros fudge*smalest      "
               0  "   Jun 99 BW/DWOR in Y>0 and ERRY crosses/touches 0, adjusted>0.0       "
               0  "   Jul 99 DWOR made grace/xmgr compatible and added timestamp           "
               0  "                                                                        "
               0  "  The arguments of the subroutine are described in detail below:        "
               0  "                                                                        "
               0  "     1) X - array of x values to be plotted.  Top of bin if histogram.  "
               0  "     2) Y - corresponding array of y values to be plotted.              "
               0  "     3) ERRY - array containing uncertainties in Y for the plot.        "
               0  "            If the first entry of this array is 0, it is                "
               0  "            assumed that the graph is of type XY.  If it is             "
               0  "            not 0, the graph is of type XY-DY.                          "
               0  "     4) NPTS - the number (integer) of points to be plotted. This       "
               0  "            should be the number of data points that exist in the       "
               0  "            X, Y, and ERRY arrays.                                      "
               0  "     5) CURVENUM - the number (integer) of the curve that is to be      "
               0  "            plotted. The first curve number should be 0.  If this       "
               0  "            number is not 0, then it is assumed that the plot file      "
               0  "            already exists and the subroutine call is to add an         "
               0  "            additional series to the existing graph.                    "
               0  "     6) SERIESTITLE - string (max of 60 characters) giving the          "
               0  "            series title (legend) for the data in the X and Y arrays.   "
               0  "     7) XTITLE - string (max of 60 characters) giving the x axis        "
               0  "            title.                                                      "
               0  "     8) YTITLE - string (max of 60 characters) giving the y axis        "
               0  "            title.                                                      "
               0  "     9) GRAPHTITLE - string (max of 60 characters) giving the           "
               0  "            graph title.                                                "
               0  "    10) SUBTITLE - string (max of 60 characters) giving the subtitle    "
               0  "            for the graph.                                              "
               0  "    11) UNITNUM - number (integer) specifying where the data is to      "
               0  "            be written.                                                 "
               0  "            this unit must be opened by the calling routine             "
               0  "    12) TYPE - 0 if data is to be written as normal point plot.         "
               0  "               1 if data is to be written as a histogram plot.          "
               0  "    13) HISTXMIN - used for histogram plots only.  This is a real       "
               0  "                   number with the value of lower xbin for the plot.    "
               0  "    14) AXISTYPE - 0 if linear-linear plot                              "
               0  "                   1 if log-linear plot (y = log; x = lin)              "
               0  "                   2 if linear-log plot (y = lin; x = log)              "
               0  "                   3 if log-log plot                                    "
               0  "                                                                        "
               0  "                                                                        "
               0  "************************************************************************"
               0  REPLACE{$SMALLFACTOR} WITH {1.E-5}
               0  REPLACE{$LARGEFACTOR} WITH {1.E5}
               0
               0  IMPLICIT NONE;
               0
               0  $INTEGER MAX, IDEBUG;
               0  PARAMETER (MAX = 400);  "---MAX used in defining the maximum number of---"
               0  "---points that can be plotted in one series. ---"
               0  $INTEGER NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE;
               0  $REAL X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,HISTXMIN,ERRYOLD,SMALLESTX,
               0  SMALLESTY,FUDGE;
               0  $INTEGER TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENGTH;
               0  $INTEGER LOGX, LOGY, LOGDY,ZEROYCOUNT;
               0
               0  "CHARACTER*80 SUBTITLE;"
               0  "CHARACTER*60 GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;"
               0  " IK changed the above to avoid complains from the compiler about"
               0  " inconsistent argument lists"
               0  CHARACTER*(*) SUBTITLE;
               0  CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
               0  CHARACTER*10 INDEX;
               0  CHARACTER*3  INDEXNUM;
               0
               0  $LOGICAL TESTFILE, ALLPOS;
               0  $REAL    one;
               0  parameter (one = 1);
               0
               0  FUDGE = 1.e-10;              "If a number in the gaph is zero, it is replaced"
               0  "by the (smallest number in the gaph)*(FUDGE)"
               0  IDEBUG = 0;  "set to 1 to get debug stmts active"
               0  IF (IDEBUG = 1) [
               1      write(6,'(//'' Entering xvgrplot ''/)');
               1      write(6,'('' Curve'',I3,'' to go to unit'',I3)')CURVENUM,UNITNUM;
               1      write(6,'(''SERIESTITLE: '',a60)') SERIESTITLE;
               1      write(6,'(''XTITLE:      '',a60)') XTITLE;
               1      write(6,'(''YTITLE       '',a60)') YTITLE;
               1      write(6,'(''GRAPHTILE:   '',a60)') graphtitle;
               1      write(6,'(''SUBTITLE:    '',a80)') subtitle;
               1      ]
               0  IF ( NPTS .gt. MAX) [ "Asked for too many points"
               1      OUTPUT NPTS, MAX;(//' **************************'/
               1      ' Number of points asked for =', I5,
               1      ' is greater than max allowed of', I4/
               1      ' Setting NPTS to MAX, you could adjust MAX in xvgrplot.mortran'/
               1      ' **************************'//);
               1      NPTS1 = MAX;
               1      ] ELSE [NPTS1 = NPTS;]
               0
               0  "---Check to make sure that speicified unit is open for---"
               0  "---writing to.---"
               0  INQUIRE(UNIT = UNITNUM, OPENED = TESTFILE);
               0
               0  IF (~TESTFILE) [ "---File has not been opened - print message.---"
               1      WRITE(6,:125:) UNITNUM;
               1      :125: FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------'
               1      ,/'   Unit specified (',I2,') is not open.'
               1      ,/'   Unit must be opened before using subroutine.'
               1      ,/'   Data not written to file.'
               1      ,/'  ----------------------------------------------'//);
               1      RETURN;
               1      ] "---End of error message for unopened file---"
               0
               0  "---Set defaults if arguments are left blank.---"
               0  IF (GRAPHTITLE = ' ') [
               1      GRAPHTITLE = 'Untitled Graph - No title specified in subroutine';
               1      ]
               0  IF (XTITLE = ' ') [ XTITLE = 'X-axis not titled in subroutine';  ]
               0
               0  IF (YTITLE = ' ') [ YTITLE = 'Y-axis not titled in subroutine'; ]
               0
               0  IF (SERIESTITLE = ' ') [
               1      SERIESTITLE = 'series # ';
               1      INDEX = '0123456789';
               1      INDEXNUM = INDEX(CURVENUM+1:CURVENUM+1);
               1      SERIESTITLE(9:9) = INDEXNUM;
               1      ]
               0
               0  "---Find lengths of stings for formatting purposes---"
               0  "---Initialize variable lengths---"
               0
               0  TITLELENGTH = 61;    SUBLENGTH = 61;       XAXISLENGTH = 61;
               0  YAXISLENGTH = 61;    SERIESLENGTH = 61;
               0
               0  "---Find title string length---"
               0  LOOP [
               1      TITLELENGTH = TITLELENGTH - 1;
               1      ] UNTIL (GRAPHTITLE(TITLELENGTH:TITLELENGTH) ~= ' ');
               0
               0  "---Find subtitle string length---"
               0  LOOP [
               1      SUBLENGTH = SUBLENGTH - 1;
               1      ] UNTIL (SUBTITLE(SUBLENGTH:SUBLENGTH) ~= ' ');
               0
               0  "---Find x-axis string length---"
               0  LOOP [
               1      XAXISLENGTH = XAXISLENGTH - 1;
               1      ] UNTIL (XTITLE(XAXISLENGTH:XAXISLENGTH) ~= ' ');
               0
               0  "---Find y-axis string length---"
               0  LOOP [
               1      YAXISLENGTH = YAXISLENGTH - 1;
               1      ] UNTIL (YTITLE(YAXISLENGTH:YAXISLENGTH) ~= ' ');
               0
               0  "---Find series title length---"
               0  LOOP [
               1      SERIESLENGTH = SERIESLENGTH - 1;
               1      ] UNTIL (SERIESTITLE(SERIESLENGTH:SERIESLENGTH) ~= ' ');
               0  IF( IDEBUG = 1) [
               1      OUTPUT SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH;
               1      (' SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH'/
               1      5I10)
               1      ]
               0
               0  "---Small bit of error checking here done for the purpose of warning the---"
               0  "---user if there is a problem when using a 'log' type graph.           ---"
               0  "---Possible problems are:                                              ---"
               0  "---    1.)  value on log scale < or = 0.                               ---"
               0  "---    2.)  value of error bar for xydy plot extends into the region   ---"
               0  "---                    where y < or = 0.                               ---"
               0  "---                                                                    ---"
               0  "---To keep track of these problems the flags LOGX, LOGY, and LOGDY will---"
               0  "---be set if there is the respective error.                            ---"
               0  "---(ie.  if LOGX set (=1) then there exist an X value that is <= 0 AND ---"
               0  "--- the xaxis is set to be a log scale.)                               ---"
               0  "--------------------------------------------------------------------------"
               0
               0  "---Initialize LOGX, LOGY, and LOGDY to be not set (0)---"
               0  LOGX = 0;          LOGY = 0;          LOGDY = 0;
               0
               0  "---Initialize ZEROYCOUNT to 0---"
               0  ZEROYCOUNT=0;
               0
               0  "In all cases where no negatives are concerned, fix points that are"
               0  "equal to 0.0"
               0  "Aaron Merovitz, Jan 1998"
               0  ALLPOS=.TRUE.;
               0  IF ( X(1)=0.0 ) [SMALLESTX = 0.1;] ELSE [SMALLESTX=X(1);]
               0  IF ( Y(1)=0.0 ) [SMALLESTY = 0.1;] ELSE [SMALLESTY=Y(1);]
               0  DO COUNT = 1, NPTS1 [
               1      IF ((X(COUNT) < SMALLESTX) & (X(COUNT)~=0.)) [SMALLESTX=X(COUNT);]
               1      IF ((Y(COUNT) < SMALLESTY) & (Y(COUNT)~=0.)) [SMALLESTY=Y(COUNT);]
               1      IF ((X(COUNT) < 0.)|(Y(COUNT) < 0.)) [ALLPOS=.FALSE.;]
               1      ]
               0  IF (ALLPOS) [
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT)=0.) [X(COUNT)=SMALLESTX*FUDGE;]
               2          IF (Y(COUNT)=0.) [Y(COUNT)=SMALLESTY*FUDGE;]
               2          ]
               1      ]
               0  "---Loop through data points (if any log scales set) to see if there are---"
               0  "---any  <= 0 problems that might not have been fixed---"
               0
               0  IF (AXISTYPE > 0) [  "---At least one axis is of log type---"
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT) <= 0.) [ LOGX = 1; ]
               2          IF (Y(COUNT) <= 0.) [ LOGY = 1; ]
               2          IF ((Y(COUNT)-ERRY(COUNT)) <= 0.) [ LOGDY = 1; ]
               2          ]
               1      ]
               0  ELSE[ "--fix error bars that just hit Y axis in case user wants"
               1      "to switch to linlog plot while in xmgr--"
               1      DO COUNT = 1, NPTS1 [
               2          IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT) & Y(COUNT)>0.)[
               3              ZEROYCOUNT=ZEROYCOUNT+1;
               3              IF(ZEROYCOUNT=1)[
               4                  WRITE(6,:105:);
               4                  :105: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
               4                  ,/'  Some errors give 0 value and so are adjusted so       '
               4                  ,/'  that you can switch to a log Y scale while in xmgr.   '
               4                  ,/' -------------------------------------------------------'/);
               4                  ]
               3              ERRYOLD=ERRY(COUNT);
               3              ERRY(COUNT) = 0.9999*Y(COUNT);
               3              "WRITE(6,:106:) COUNT,ERRYOLD,ERRY(COUNT);"
               3              ":106: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'"
               3              "       /'        ',1PE11.4,'.');"
               3              ]
               2          ]
               1      ]
               0
               0  "---Use this info later when writing to file---"
               0
               0  "---Now begin writing information to unit---"
               0  IF (CURVENUM = 0) [ "---Case where plot file must start from scratch---"
               1      "---Insert xvgr graph header in file.---"
               1
               1      "---Start with type of graph.  (lin-lin, log-lin, lin-log, or log-log)---"
               1      IF (AXISTYPE = 0) [ "---Graph is of type lin-lin---"
               2          WRITE(UNITNUM,:90:) 'xy';
               2          ] ELSEIF (AXISTYPE = 1) [ "---Graph is of type log-lin---"
               2          WRITE(UNITNUM,:90:) 'logy';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 2) [ "---Graph is of type lin-log---"
               2          WRITE(UNITNUM,:90:) 'logx';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 3) [ "---Graph is of type log-log---"
               2          WRITE(UNITNUM,:90:) 'logxy';
               2          WRITE(UNITNUM,:1080:);
               2          WRITE(UNITNUM,:1090:);
               2          ] ELSE [ "--anything else specified is in error--"
               2          WRITE(6,:91:) AXISTYPE;
               2          :91: FORMAT (//'  ------------Error in Subroutine XVGRPLOT-----------'
               2          ,/'   AXISTYPE specified (',I2,') is not a valid option.'
               2          ,/'  ----------------------------------------------'//);
               2          RETURN;
               2          ]
               1
               1      :90: FORMAT ('@g0 type ',A,' ');
               1      :1080: FORMAT ('@    xaxis  ticklabel format exponential');
               1      :1090: FORMAT ('@    yaxis  ticklabel format exponential');
               1
               1      "---Titles and things---"
               1      WRITE(UNITNUM,:100:) GRAPHTITLE(1:TITLELENGTH)
               1      ,SUBTITLE(1:SUBLENGTH)
               1      ,XTITLE(1:XAXISLENGTH)
               1      ,YTITLE(1:YAXISLENGTH);
               1      :100: FORMAT ('@    title "',A,'"'/
               1      ,'@    subtitle "',A,'"'/
               1      ,'@    legend on'/
               1      ,'@    legend box linestyle 0'/
               1      ,'@    legend x1 0.6'/
               1      ,'@    legend y1 0.75'/
               1      ,'@    view xmin 0.250000'/
               1      ,'@    xaxis  label "',A,'"'/
               1      ,'@    timestamp on'/
               1      ,'@    yaxis  label "',A,'"');
               1      ]  "---End CURVENUM = 0---"
               0
               0  "--XVGR has the characteristic that if the same input command is issued more---"
               0  "--than once, the last one to be read is the one that is executed.  For this---"
               0  "--situation, this is perfect.  Say the first series written to a file is of---"
               0  "--a log scale, and the second is also of log scale, but has a data point   ---"
               0  "--on the log scale that is < or = 0, then we can write the '@g0 type xy'   ---"
               0  "--to the file AFTER the previous '@g0 type logxy' and the xy type will     ---"
               0  "--prevail.  This will prevent errors when executing XVGR.  Of course the   ---"
               0  "--alteration will also be written to the display.                          ---"
               0
               0
               0  IF (AXISTYPE = 1 & LOGY = 1) [  "--LOGY error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:95:);
               1      :95: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for Y axis when one or more   '
               1      ,/'  Y data points are 0 or negative.                  '
               1      ,//'  Y axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 2 & LOGX = 1) [  "--LOGX error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:96:);
               1      :96: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for X axis when one or more   '
               1      ,/'  X data points are 0 or negative.                  '
               1      ,//'  X axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 3 & (LOGX = 1 | LOGY = 1)) [  "--LOGX or LOGY error--"
               1      IF (LOGX = 1 & LOGY = 1) [
               2          WRITE(UNITNUM,:90:) 'xy';
               2          WRITE(6,:97:);
               2          :97: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               2          ,/'  Log scale requested for X axis and Y axis when    '
               2          ,/'  one or more X and Y data points are 0 or negative.'
               2          ,//'  X and Y axes scales changed to linear.            '
               2          ,/' ---------------------------------------------------'/);
               2          ]
               1      ELSEIF (LOGX = 1) [ WRITE(UNITNUM,:90:) 'logy'; WRITE(6,:96:); ]
               1      ELSE              [ WRITE(UNITNUM,:90:) 'logx'; WRITE(6,:95:); ]
               1      ]
               0
               0  "---now make a fix for those error bars that 'dip' beneath the x-axis on---"
               0  "---log plots.                                                          ---"
               0
               0  IF (LOGDY = 1 & LOGY ~= 1 & (AXISTYPE = 3 | AXISTYPE = 1)) [
               1      "--if LOGDY problem and log scale not been already reset to linear--"
               1      "--do fudge to correct the problem--"
               1
               1      WRITE(6,:101:);
               1      :101: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
               1      ,/'  Log scale requested for Y axis, and Y value less      '
               1      ,/'  error gives 0 or negative value.                      '
               1      ,//'  Error adjusted to aviod negavite values on log scale. '
               1      ,/' -------------------------------------------------------'/);
               1
               1      DO COUNT = 1,NPTS1[
               2          IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT)) [
               3              ERRYOLD = ERRY(COUNT);
               3              ERRY(COUNT) = 0.9999*Y(COUNT);
               3              WRITE(6,:103:) COUNT,ERRYOLD,ERRY(COUNT);
               3              :103: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'
               3              /'        ',1PE11.4,'.');
               3              ]
               2          ]
               1
               1      WRITE(6,:104:);
               1      :104: FORMAT (/' -------------------------------------------------------'/);
               1
               1      ]
               0
               0  "---Include data about series for legend purposes.---"
               0  "first line needed to make it work with grace"
               0  IF (CURVENUM < 10 ) [
               1      WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM;
               1      ]
               0  ELSE [
               1      WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM;
               1      ]
               0  WRITE(UNITNUM,:150:)  CURVENUM,SERIESTITLE(1:SERIESLENGTH);
               0  :150: FORMAT ('@    legend string ',I2,' "',A,'"');
               0
               0
               0  "---Do normal plot.  ie. NOT histogram plot.---"
               0  IF (TYPE = 0) [ "---Normal point plot.---"
               1
               1      "---Check all ERRYs.  If even one is nonzero, then series is type xydy---"
               1      DO COUNT = 1, NPTS1 [
               2          IF (ERRY(COUNT) ~= 0) [ "---Data set is not of type XY---"
               3              GOTO :X-Y-DY1:;
               3              ]
               2          ]
               1
               1      "---Data set is of type XY---"
               1      WRITE(UNITNUM,:200:);
               1      :200: FORMAT ('@TYPE xy');
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1      :151: FORMAT ('@    s',I1,' errorbar length 0.000000');
               1      :152: FORMAT ('@    s',I2,' errorbar length 0.000000');
               1      :197: FORMAT ('@    s',I1,' symbol color ',I2);
               1      :198: FORMAT ('@    s',I1,' symbol color ',I1);
               1      :199: FORMAT ('@    s',I2,' symbol color ',I2);
               1
               1      "---Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [ WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT); ]
               1      :250: FORMAT (1PE15.4,1PE15.4);
               1      GOTO  :END-X-Y-DY1:;
               1
               1      "---Data set is of type XY-DY---"
               1      :X-Y-DY1:;
               1      WRITE(UNITNUM,:300:);
               1      :300: FORMAT ('@TYPE xydy');
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1
               1      "---Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [WRITE(UNITNUM,:350:) X(COUNT),Y(COUNT),ERRY(COUNT);]
               1      :350: FORMAT (1PE15.4,1PE15.4,1PE15.4);
               1      :END-X-Y-DY1:;
               1
               1      ]  "--end of point plot block--"
               0  ELSE [ "---Histogram plot---"
               1
               1      "---Must find minimum y value in the y array to    ---"
               1      "---use as scale factor for establishing y-min on  ---"
               1      "---histogram plot.  We don't use 0 here as with 0 ---"
               1      "---plot can not be made into log plot in xvgr.    ---"
               1
               1      YMIN = ABS($LARGEFACTOR * Y(1));
               1
               1      DO COUNT = 1, NPTS1 [
               2          IF (ABS(Y(COUNT)) < YMIN) [ YMIN = ABS(Y(COUNT)); ]
               2          ]  "---End loop to find smalled Y---"
               1
               1      "---Now smallest value of Y has been found.  Want to make sure that the---"
               1      "---first point used is even smaller than this and that it is of the same---"
               1      "---sign as the first Y data point in the plot.---"
               1
               1      "---Now set YMIN to even smaller value for plot and set sign.---"
               1      YMIN = SIGN(one,Y(1)) * $SMALLFACTOR * YMIN ;
               1
               1      "---Set this value in y-array as element after the---"
               1      "---element in index npts.---"
               1      Y(NPTS1+1) = YMIN;
               1
               1      IF ((AXISTYPE = 2 | AXISTYPE = 3) & HISTXMIN = 0) [
               2          IF (X(1) = (X(2)-X(1))) [ HISTXMIN = X(1)-0.5*(X(2)-X(1)); ]
               2          ELSE                    [ HISTXMIN = X(1)-(X(2)-X(1)); ]
               2
               2          WRITE(6,:306:) HISTXMIN;
               2          :306: FORMAT (/' ---------WARNING from Subroutine XVGRPLOT--------'
               2          ,/'  Minimum bin for X specified as 0 with log scale  '
               2          ,/'  on X axis.  Minimum X bin set to ',1PE10.3,'.'
               2          ,/' -------------------------------------------------'/);
               2          ]
               1
               1      DO COUNT = 1, NPTS1 [
               2          IF (ERRY(COUNT) ~= 0.) [ "---Data set is not of type XY---"
               3              GOTO :X-Y-DY:;
               3              ]
               2          ]
               1
               1      "---Data set is of type XY---"
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1      WRITE(UNITNUM,:200:);
               1
               1      "---Plot the first histogram points.---"
               1      WRITE(UNITNUM,:250:) HISTXMIN,YMIN;
               1      WRITE(UNITNUM,:250:) HISTXMIN,Y(1);
               1
               1      "--Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [
               2          WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT);
               2          WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT+1);
               2          ]
               1      GOTO :END-X-Y-DY:;
               1
               1      "---Data set is of type XY-DY---"
               1      :X-Y-DY:;
               1      "---Put error of 0 on last *made-up* point in error array.---"
               1      ERRY(NPTS1+1) = 0.0;
               1
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1      WRITE(UNITNUM,:300:);
               1
               1      "---Plot the first histogram points.---"
               1      IF (HISTXMIN = 0.0) [ "Aaron Meroivtz, Feb. 1998"
               2          HISTXMIN = SMALLESTX*FUDGE;
               2          ]
               1      WRITE(UNITNUM,:350:) HISTXMIN, YMIN, 0.;
               1      WRITE(UNITNUM,:350:) HISTXMIN, Y(1), 0.;
               1      WRITE(UNITNUM,:350:) (X(1)+HISTXMIN)/2., Y(1), ERRY(1);
               1
               1      "---Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [
               2          WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT),0.;
               2          WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT+1),0.;
               2          IF(COUNT < NPTS1)[
               3              WRITE (UNITNUM,:350:) (X(COUNT)+X(COUNT+1))/2.,Y(COUNT+1),ERRY(COUNT+1);
               3              ]
               2          ]
               1      :END-X-Y-DY:;
               1      ] "---End HIST=0 loop---"
               0
               0  "---Insert end of series indicator to file.---"
               0  WRITE(UNITNUM,'(''&'')');
               0
               0  RETURN;
               0  END; "---End of subroutine.---"
               0  ;
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc function to get index of last non-blank character in a string       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2004                                       "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  $INTEGER function lnblnk1(string);
               0
               0  "Function to return index of last non-blank character in a string"
               0  "We use this instead of lnblnk because there are compilers"
               0  "that do not have lnblnk"
               0
               0  "******************************************************************************
               0  character*(*) string;
               0  DO i=len(string),1,-1 [
               1      j = ichar(string(i:i));
               1      IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
               1      "0-terminated C-strings"
               1      IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
               2          lnblnk1 = i; return;
               2          ]
               1      ]
               0  lnblnk1 = 0; return; end;
               0
          END OF MORTRAN INPUT
  94      PERCENT RULE CAPACITY REMAINING
          NO MORTRAN ERRORS DETECTED
