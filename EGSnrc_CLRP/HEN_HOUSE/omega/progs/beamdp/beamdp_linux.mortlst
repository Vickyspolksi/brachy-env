Mortran 3.2 Tue Aug 19 15:59:55 2025
               0  %L                                                                     ;
1              0  %E
               0  %I4                                                                    ;
               0  !INDENT F2;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  "#############################################################################"
               0  "                                                                             "
               0  " EGSnrc machine dependent macro file for linux                               "
               0  "                                                                             "
               0  " Created by configure version 2.0 on mar 19 ago 2025 15:59:50 -03            "
               0  "                                                                             "
               0  " You may add your own machine dependent macros to this file,                 "
               0  " but be carefull to not overwrite it if you re-run configure.                "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0  REPLACE {$MACHINE} WITH
               0  {,'linux',};
               0  REPLACE {$HEN_HOUSE} WITH
               0  {'/home/usuario/EGSnrc_CLRP/HEN_HOUSE/'};
               0  REPLACE {$CANONICAL_SYSTEM} WITH
               0  {'x86_64-unknown-linux-gnu'};
               0  REPLACE {$CONFIGURATION_NAME} WITH
               0  {'linux'};
               0  REPLACE {$EGS_CONFIG} WITH
               0  {'/home/usuario/EGSnrc_CLRP/HEN_HOUSE/specs/linux.conf'};
               0
               0  REPLACE {$CONFIG_TIME} WITH
               0  {'2025-08-19 18:59:50 UTC'};
               0
               0  " System dependent stuff "
               0  "========================================"
               0  " Unfortunately, there appears to be no reliable way of copying files "
               0  " under Fortran => we use a system call for this"
               0  REPLACE {$copy_file} WITH {'cp '};
               0
               0  " Although one can move files using Fortran's intrinsic rename, "
               0  " we don't know whether the user has not created additional files in "
               0  " the temporary working directory => it is easiest to use a system call "
               0  " to move all files from the temporary working directory to the user-code "
               0  " directory. "
               0  REPLACE {$move_file} WITH {'mv -f '};
               0
               0  " There appears to be no way of removing a directory from Fortran "
               0  " => we use a system call for this. "
               0  REPLACE {$remove_directory} WITH {'rm -rf '};
               0
               0  " The directory separator "
               0  REPLACE {$file_sep} WITH {'/'};
               0
               0  REPLACE {$LONG_INT} WITH { integer*8 };
               0  REPLACE {$SHORT_INT} WITH { integer*2 };
               0  "$MAX_INT SET TO 2^63-1 in egsnrc.macros"
               0  "The machine byte order"
               0  REPLACE {$BYTE_ORDER} WITH {'1234'};
               0  ;
               0  REPLACE {$RECL-FACTOR} WITH {4};
               0  ;
               0  REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
               0  ;
               0  " If you want your user-code to return an exit status, use the "
               0  " following macro to terminate execution"
               0  REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
               0  ;
               0  " mortran3 gets confused by the # char => we need to pass it as an "
               0  " argument to the macro. "
               0  REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
               0  ;
               0  REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros to read and write phase space files                          "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Blake Walters, 1999                                       "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Macros required to read from and write to phase space files. These macros  "
               0  "  replace the old calls to the subroutine rw_ph_sp.mortran and any           "
               0  "  manipulations of phase space files that were hard-coded. Currently, these  "
               0  "  macros are used by BEAM, DOSXYZ, BEAMDP, and readphsp. The beam            "
               0  "  configuration script looks for this file in the following directories, in  "
               0  "  this order                                                                 "
               0  "                                                                             "
               0  "  $HOME/egs4/BEAM_accelerator                                                "
               0  "  $HOME/egs4/beam                                                            "
               0  "  $OMEGA_HOME/beam                                                           "
               0  "                                                                             "
               0  "  All other configuration or compile scripts only use the version of this    "
               0  "  file in $OMEGA_HOME/beam. These macros can be used with any code provided  "
               0  "  that this file is concatenated before any codes that use the macros.       "
               0  "  Detailed description of what each macro does is provided at the top of     "
               0  "  the macro.                                                                 "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  ;
               0  REPLACE {;COMIN/RWPHSP/;} WITH {
            {  0  "RWPHSP must be included in the common block of main in any code that uses"
            {  0  "any of these phase space macros and also in the common block of"
            {  0  "any subroutine that uses any phase space macros.  Note that the macro"
            {  0  "$MAX_SC_PLANES(=the max. number of scoring planes) must have been defined"
            {  0  "somewhere in the code before the first use of COMIN/RWPHSP.  In the case of"
            {  0  "DOSXYZ, BEAMDP and readphsp, $MAX_SC_PLANES is a dummy value, set to 1,"
            {  0  "at the beginning of main.  Note that, since, IHSTRY_PHSP is a $LONG_INT"
            {  0  "variable, you must have the macro REPLACE {$LONG_INT} WITH {INTEGER*8} at"
            {  0  "the top of any code that uses these macros.  If your compiler has trouble"
            {  0  "with INTEGER*8, use INTEGER*4 in the $LONG_INT macro."
            {  0
            {  0  ;COMMON/RWPHSP/
            {  0  STRING_TEMP_ZLAST_OUT,
            {  0  "holds output phsp data for up to 1000 particles, with ZLAST"
            {  0  STRING_TEMP_OUT, "holds output phsp data for up to 1000 particles, no ZLAST"
            {  0  IHSTRY_PHSP, "history number (from primary non-phase space source) of"
            {  0  "particle being scored"
            {  0  iaea_dummy_long, "used to store INTEGER*8 values temporarily"
            {  0  NHSTRY_DOS, "passed to NHSTRY in beam when this actually comes from"
            {  0  "dosxyznrc source 20"
            {  0  ESHORT,    "single precision E read from/written to phsp"
            {  0  WEIGHTTMP, "modified version of WT to be written to phsp"
            {  0  WT_PHSP_SHORT, "single precision wt read from phsp"
            {  0  X_PHSP_SHORT, "single precision x read from phsp"
            {  0  Y_PHSP_SHORT, "single precision y read from phsp"
            {  0  Z_PHSP_SHORT, "single precision Z--for iaea format only"
            {  0  U_PHSP_SHORT, "single precision u read from phsp"
            {  0  V_PHSP_SHORT, "single precision v read from phsp"
            {  0  W_PHSP_SHORT, "single precision w--for iaea format only"
            {  0  ZLAST_PHSP_SHORT, "single precision zlast read from phsp"
            {  0  MUIDX_PHSP_SHORT, "MU_INDEX--iaea phsp files only"
            {  0  EKMAX_PHSP_SHORT, "max ke of particles in phsp file"
            {  0  EKMINE_PHSP_SHORT, "min ke of electrons in phsp file"
            {  0  NINC_PHSP_SHORT, "no. of particles from original primary source"
            {  0  dosxyz2beam_index, "stores MU index passed to beam from dosxyz"
            {  0  iaea_extra_floats, "array of extra floats in IAEA phsp file"
            {  0  NUM_PHSP_TOT, "tot no of particles in phsp file"
            {  0  PHOT_PHSP_TOT,"no. of photons in phsp file"
            {  0  iaea_result,  "<0 if an error finding an available array index for IAEA"
            {  0  "phsp file"
            {  0  iaea_n_stat,  ">=1 if a new primary history is scoring, 0 otherwise"
            {  0  iaea_q_typ,    "array to convert from charge to IAEA type"
            {  0  iaea_typ_q,   "array to convert from IAEA type to charge"
            {  0  iaea_q_index, "array index"
            {  0  I_PHSP,    "loop counter"
            {  0  IERR_PHSP, "=0 if open/read okay ~=0 if not okay"
            {  0  LATCHTMP,  "modified version of LATCH to be written to phsp"
            {  0  WRITE_PHSP_COUNTER, "counter up to 1000 used for group write"
            {  0  WRITE_PHSP_SOFAR, "how many particles written so far to file"
            {  0  PHSP_RESTART, "set to 1 if this is a restart"
            {  0  PHSP_RECL, "the record length"
            {  0  PHSP_RECL_OLD, "saves record length"
            {  0  iaea_extra_ints, "array in which LATCH will be stored for iaea format"
            {  0  iaea_extra_int_types,iaea_extra_float_types, "returns the types of"
            {  0  "extra int and float variables in an IAEA phsp file"
            {  0  iaea_i_zlast,"index of iaea_extra_floats in which Zlast is stored for IAEA"
            {  0  "phsp files read IN"
            {  0  iaea_i_latch,"index of iaea_extra_int in which LATCH is stored for IAEA"
            {  0  "phsp files read IN"
            {  0  iaea_i_muidx,"index of iaea_extra_floats in which MU_INDEX is stored for"
            {  0  "IAEA phsp files read IN"
            {  0  iaea_n_extra_ints, "no. of extra ints stored in IAEA phsp file read IN"
            {  0  iaea_n_extra_floats, "no. of extra floats stored in IAEA phsp file read IN"
            {  0  i_iaea_open_for_write, "set to 1 if the macro IAEA_OPEN_FOR_WRITE"
            {  0  "was used"
            {  0  iaea_i_zlast_out,"index of iaea_extra_floats in which Zlast is stored for"
            {  0  " IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  iaea_i_latch_out,"index of iaea_extra_int in which LATCH is stored for IAEA"
            {  0  "phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  iaea_i_muidx_out,"index of iaea_extra_floats in which MU_INDEX is stored"
            {  0  " for IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  dosxyz2beam_izscore, "set to 1 if Z scored for each particle (IAEA only)"
            {  0  MODE_RW;   "mode of phsp file (0 with ZLAST, 2 without), writing only"
            {  0
            {  0  CHARACTER*32000 STRING_TEMP_ZLAST_OUT($MAX_SC_PLANES);
            {  0  CHARACTER*28000 STRING_TEMP_OUT($MAX_SC_PLANES);
            {  0  $LONG_INT IHSTRY_PHSP($MAX_SC_PLANES),iaea_dummy_long,NHSTRY_DOS;
            {  0  REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  Z_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHORT,
            {  0  MUIDX_PHSP_SHORT,
            {  0  EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT,dosxyz2beam_index,
            {  0  iaea_extra_floats(10);
            {  0  INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT,
            {  0  iaea_result,iaea_n_stat,iaea_q_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP,
            {  0  IERR_PHSP,LATCHTMP,
            {  0  WRITE_PHSP_COUNTER($MAX_SC_PLANES),WRITE_PHSP_SOFAR($MAX_SC_PLANES),
            {  0  PHSP_RESTART,PHSP_RECL,PHSP_RECL_OLD,iaea_extra_ints(10),
            {  0  iaea_extra_int_types(10),iaea_extra_float_types(10),iaea_i_zlast,
            {  0  iaea_i_latch,iaea_i_muidx,iaea_n_extra_ints,iaea_n_extra_floats,
            {  0  i_iaea_open_for_write,iaea_i_zlast_out,iaea_i_latch_out,
            {  0  iaea_i_muidx_out,dosxyz2beam_izscore;
            {  0  CHARACTER*5 MODE_RW;
            {  0
            {  0  "variables below are not part of the common block but are used locally"
            {  0  "by the $WRITE_PHSP, $WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros"
            {  0
            {  0  INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP;
            {  0  REAL*4 REAL_TEMP_OUT(7);
            {  0  CHARACTER*32 REC_TEMP_OUT;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$INITIALIZE_PHSP_VARIABLES;} WITH{;
            {  0  "Must be placed after the variable declarations in any subroutine"
            {  0  "where $WRITE_PHSP and/or $WRITE_PHSP_RECORD is used.  Note, though, that"
            {  0  "it does not necessarily have to be put at the top of main, unless one or"
            {  0  "both of these macros are used in main."
            {  0  "It equivalences the character string REC_TEMP_OUT with the phase space data"
            {  0  "for 1 particle. REC_TEMP_OUT is then used to fill the character array"
            {  0  "STRING_TEMP_(ZLAST_)OUT, which holds the phase space data in blocks of 1000"
            {  0  "particles before writing."
            {  0
            {  0  EQUIVALENCE(REC_TEMP_OUT(1:4),LATCH_TEMP_OUT);
            {  0  EQUIVALENCE(REC_TEMP_OUT(5:8),REAL_TEMP_OUT(1));
            {  0  EQUIVALENCE(REC_TEMP_OUT(9:12),REAL_TEMP_OUT(2));
            {  0  EQUIVALENCE(REC_TEMP_OUT(13:16),REAL_TEMP_OUT(3));
            {  0  EQUIVALENCE(REC_TEMP_OUT(17:20),REAL_TEMP_OUT(4));
            {  0  EQUIVALENCE(REC_TEMP_OUT(21:24),REAL_TEMP_OUT(5));
            {  0  EQUIVALENCE(REC_TEMP_OUT(25:28),REAL_TEMP_OUT(6));
            {  0  EQUIVALENCE(REC_TEMP_OUT(29:32),REAL_TEMP_OUT(7));
            {  0  }
               0  ;
               0
               0  REPLACE {$INIT_PHSP_COUNTERS;} WITH {;
            {  0  "This macro initializes counters and flags that are used by the"
            {  0  "$WRITE_PHSP/$WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros.  It is only"
            {  0  "used once and should be placed after the variable declarations in main."
            {  0
            {  0  DO I_PHSP=1,$MAX_SC_PLANES[
            {  0  WRITE_PHSP_COUNTER(I_PHSP)=0;
            {  0  WRITE_PHSP_SOFAR(I_PHSP)=0;
            {  0  IHSTRY_PHSP(I_PHSP)=0;
            {  0  ]
            {  0  PHSP_RESTART=0;
            {  0  PHSP_RECL_OLD=0;
            {  0
            {  0  iaea_q_typ(1)=2;iaea_q_typ(2)=1;iaea_q_typ(3)=3;
            {  0  iaea_typ_q(1)=0;iaea_typ_q(2)=-1;iaea_typ_q(3)=1;
            {  0
            {  0  iaea_n_extra_ints=0;iaea_n_extra_floats=0;
            {  0
            {  0  iaea_i_zlast=-99;iaea_i_latch=-99;iaea_i_muidx=-99;
            {  0
            {  0  i_iaea_open_for_write=0;
            {  0
            {  0  iaea_i_zlast_out=-99;iaea_i_latch_out=-99;iaea_i_muidx_out=-99;
            {  0
            {  0  }
               0  ;
               0
               0
               0  REPLACE {$GET_E_NPASS_IQ(#,#,#,#);} WITH {;
            {  0  "Macro gets NPASS, IQ from the LATCH value read in and then restores LATCH"
            {  0  "by clearing the bits that store this information.  It also puts the"
            {  0  "single precision energy, ESHORT, read in into double precision form."
            {  0  "This macro is called by $READ_PHSP."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=NPASS"
            {  0  "{P2}=IQ"
            {  0  "{P3}=LATCH"
            {  0  "{P4}=E"
            {  0
            {  0  {P4}=ESHORT;
            {  0
            {  0  IF($BTEST({P3},31)) [ {P1} = 1; {P3} = $IBCLR({P3},31); ]
            {  0  ELSE [ {P1} = 0; ]
            {  0
            {  0  IF($BTEST({P3},30)) [
            {  0  {P2} = -1;
            {  0  {P3} = $IBCLR({P3},30); {P3} = $IBCLR({P3},29);
            {  0  ]
            {  0  ELSE [
            {  0  IF($BTEST({P3},29)) [
            {  0  {P2} = 1; {P3} = $IBCLR({P3},29);
            {  0  ]
            {  0  ELSE [ {P2} = 0; ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_W_WT(#,#,#,#,#,#);} WITH {;
            {  0  "This macro calculates W, based on U and V and the sign of WT as read in from"
            {  0  "the phase space file.  Once the sign of WT is determined, WT is set equal"
            {  0  "to its absolute value, since there cannot be a negative particle weight."
            {  0  "This macro is called by $READ_PHSP."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=W"
            {  0  "{P2}=WT"
            {  0  "{P3}=X"
            {  0  "{P4}=Y"
            {  0  "{P5}=U"
            {  0  "{P6}=V"
            {  0
            {  0  {P1} = min( 1., {P5}**2 + {P6}**2);
            {  0  {P1} = sqrt(1. - {P1});
            {  0  {P1} = SIGN({P1},{P2});  "This transfers sign of WT to W"
            {  0
            {  0  {P2}=ABS({P2}); "WT is always positive"
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_PHSP_RECORD(#,#,#,#);} WITH {;
            {  0  "macro used by READ_PHSP_RECORD to put single precision x, y, u, v"
            {  0  "read from phase space file into (potentially) double precision"
            {  0  "x, y, u, v passed to READ_PHSP_RECORD macro"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=X"
            {  0  "{P2}=Y"
            {  0  "{P3}=U"
            {  0  "{P4}=V"
            {  0
            {  0  {P1}=X_PHSP_SHORT;
            {  0  {P2}=Y_PHSP_SHORT;
            {  0  {P3}=U_PHSP_SHORT;
            {  0  {P4}=V_PHSP_SHORT;
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_RECORD(#,#,#:#,#,#,#,#,#);} WITH {;
            {  0  "Note that a colon is required  ^  between the third and fourth"
            {  0  "input parameters."
            {  0  "This macro actually reads the phase space data for a single particle."
            {  0  "It is called by $READ_PHSP, but can also be used as a stand-alone macro."
            {  0  "If the energy, E, is < 0.0, then this is the first particle scored"
            {  0  "from a new primary (ie non-phsp source) history, and NHSTRY is incremented"
            {  0  "and E is set to ABS(E)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=record number"
            {  0  "{P4}=NHSTRY"
            {  0  "{P5}=ZLAST"
            {  0  "{P6}=LATCH"
            {  0  "{P7}=E"
            {  0  "{P8}=WT"
            {  0  "{P9}=X,Y,U,V"
            {  0
            {  0  IF({P1}~=0)["must read in ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT,ZLAST_PHSP_SHORT;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT;
            {  0  ]
            {  0
            {  0  IF({P3}=76695869)[
            {  0  write(*,*)' x,y,u,v,wt,eshort,latch',
            {  0  X_PHSP_SHORT,Y_PHSP_SHORT,U_PHSP_SHORT,V_PHSP_SHORT,
            {  0  WT_PHSP_SHORT,ESHORT,{P6};
            {  0  ]
            {  0
            {  0  "first particle from new primary history"
            {  0  IF(ESHORT<0.0)[
            {  0  {P4}={P4}+1;
            {  0  ESHORT=ABS(ESHORT);
            {  0  ]
            {  0
            {  0  {P7}=ESHORT;
            {  0  {P8}=WT_PHSP_SHORT;
            {  0  $PARSE_PHSP_RECORD({P9});
            {  0
            {  0  IF({P1}~=0) {P5}=ZLAST_PHSP_SHORT;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_RECORD_ENEGATIVE(#,#,#:#,#,#,#,#);} WITH {;
            {  0  "Note that a colon is required            ^  between the third and fourth"
            {  0  "input parameters."
            {  0  "This macro is the similar to $READ_PHSP_RECORD above, but it preserves"
            {  0  "the -E marker in the phase space file and does not advance NHSTRY"
            {  0  "It is only used in readphsp before byte swapping"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=record number"
            {  0  "{P4}=ZLAST"
            {  0  "{P5}=LATCH"
            {  0  "{P6}=E"
            {  0  "{P7}=WT"
            {  0  "{P8}=X,Y,U,V"
            {  0
            {  0  IF({P1}~=0)["must read in ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7},{P4};
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7};
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP(#:#,#,#,#,#,#,#,#);} WITH {;
            {  0  "Note colon          ^  required between the first and second"
            {  0  "input parameters (third and fourth input variables)"
            {  0
            {  0  "This macro reads the phase space data for a single particle.  It finds"
            {  0  "the value of IQ and NPASS from the LATCH variable read in and then"
            {  0  "restores the LATCH variable.  It calculates W from U, V and the sign"
            {  0  "of WT and then restores WT to its absolute value.  And it puts the"
            {  0  "single-precision energy, ESHORT, read in into double-precision format."
            {  0  "If ESHORT is < 0, it sets E=ABS(ESHORT) and increments NHSTRY, taking"
            {  0  "this as the first particle scored from a new primary history."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST,unit number for phase space file,record number reading from"
            {  0  "{P2}=NHSTRY"
            {  0  "{P3}=NPASS"
            {  0  "{P4}=IQ"
            {  0  "{P5}=W"
            {  0  "{P6}=ZLAST"
            {  0  "{P7}=LATCH"
            {  0  "{P8}=E"
            {  0  "{P9}=WT,X,Y,U,V"
            {  0
            {  0  $READ_PHSP_RECORD({P1}:{P2},{P6},{P7},{P8},{P9});
            {  0
            {  0  IF(IERR_PHSP=0)[
            {  0  $GET_E_NPASS_IQ({P3},{P4},{P7},{P8});
            {  0  $GET_W_WT({P5},{P9});
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_LATCHTMP_ESHORT_WEIGHTTMP(#,#,#,#,#,#);} WITH {;
            {  0  "This macro converts LATCH into LATCHTMP, which stores NPASS and IQ"
            {  0  "for a particle and is the form of LATCH written to the phase space file."
            {  0  "It puts double precision energy, E, into single precision format, ESHORT,"
            {  0  "for writing to the phase space file.  This macro is called from $READ_PHSP"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=NPASS"
            {  0  "{P2}=IQ"
            {  0  "{P3}=W"
            {  0  "{P4}=LATCH"
            {  0  "{P5}=E"
            {  0  "{P6}=WT"
            {  0
            {  0  LATCHTMP={P4};
            {  0
            {  0  IF({P1} = 0) [ LATCHTMP = $IBCLR(LATCHTMP,31); ]
            {  0  ELSE [ LATCHTMP = $IBSET(LATCHTMP,31); ]
            {  0
            {  0  IF({P2} = -1) [ LATCHTMP = $IBSET(LATCHTMP,30);]
            {  0  ELSEIF({P2} = 0) [
            {  0  LATCHTMP = $IBCLR(LATCHTMP,30);
            {  0  LATCHTMP = $IBCLR(LATCHTMP,29);
            {  0  ]
            {  0  ELSE [
            {  0  LATCHTMP = $IBCLR(LATCHTMP,30);
            {  0  LATCHTMP = $IBSET(LATCHTMP,29);
            {  0  ]
            {  0
            {  0  ESHORT={P5};
            {  0
            {  0  WEIGHTTMP=SIGN({P6},{P3});"transfer sign of W to WEIGHTTMP"
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$SET_NEGATIVE_E(#,#,#,#);} WITH {;
            {  0  "Macro to set E to -E if this is the first particle scored from a new"
            {  0  "primary (non-phsp source) history.  This macro is called from"
            {  0  "$WRITE_PHSP_RECORD."
            {  0
            {  0  "Input parameters"
            {  0  "{P1}=phase space scoring plane no."
            {  0  "{P2}=IHSTRY"
            {  0  "{P3}=E"
            {  0  "{P4}=WT,X,Y,U,V"
            {  0
            {  0  IF({P2}~=IHSTRY_PHSP({P1}))[
            {  0  {P3}=-{P3};
            {  0  IHSTRY_PHSP({P1})={P2};
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_TEMP_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
            {  0  "Macro to store the output phase space data for one particle in the"
            {  0  "variables LATCH_TEMP_OUT and REAL_TEMP_OUT.  These variables are"
            {  0  "equivalenced to the string variable REC_TEMP_OUT, which stores the"
            {  0  "phase space for one particle in string form and which, in turn, is"
            {  0  "used to transfer the data to the string variable STRING_TEMP(_ZLAST)_OUT"
            {  0  "which stores output phase space data for up to 1000 particles at a time."
            {  0  "This macro is called from $WRITE_PHSP_RECORD."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=ZLAST"
            {  0  "{P3}=LATCH"
            {  0  "{P4}=E"
            {  0  "{P5}=WT"
            {  0  "{P6}=X"
            {  0  "{P7}=Y"
            {  0  "{P8}=U"
            {  0  "{P9}=V"
            {  0
            {  0  LATCH_TEMP_OUT={P3};
            {  0  REAL_TEMP_OUT(1)={P4};
            {  0  REAL_TEMP_OUT(2)={P6};
            {  0  REAL_TEMP_OUT(3)={P7};
            {  0  REAL_TEMP_OUT(4)={P8};
            {  0  REAL_TEMP_OUT(5)={P9};
            {  0  REAL_TEMP_OUT(6)={P5};
            {  0  IF({P1}~=0) REAL_TEMP_OUT(7)={P2};
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$WRITE_PHSP_RECORD(#,#,#,#,#:#,#,#,#);} WITH {;
            {  0  "Note that a colon is required       ^  between the fifth and sixth"
            {  0  "input parameters"
            {  0
            {  0  "This macro is used to output phase space data 1000 particles at a time."
            {  0  "For every particle, the phase space data to be output is stored in"
            {  0  "the string variable STRING_TEMP(_ZLAST)_OUT.  If it is the 1000th particle"
            {  0  "STRING_TEMP(_ZLAST)_OUT is written to the phase space file.  The phase"
            {  0  "space header info is considered to occupy the space of 1 particle in the"
            {  0  "first block of 1000 particles, however, it will be overwritten with nulls."
            {  0  "This is fine since the header info should be recalculated and rewritten at"
            {  0  "the top of the file after all data has been written out anyway."
            {  0  "Also note that restarting with this writing scheme requires that any"
            {  0  "blocks of N (N<1000) particles at the end of a phase space file from"
            {  0  "the previous run must immediately be read into the first N spaces of"
            {  0  "STRING_TEMP(_ZLAST)_OUT before continuing on with outputting the data"
            {  0  "for new particles.  Finally, after all phase space data has been output,"
            {  0  "there will probably be info for M (M<1000) particles still in"
            {  0  "STRING_TEMP(_ZLAST)_OUT that has not been written to the phase space file"
            {  0  "because the write counter did not reach 1000.  These are output using"
            {  0  "the $PHSP_BUFFER_FLUSH macro described below."
            {  0
            {  0  "Group writing reduces network traffic and saves a lot of time when the"
            {  0  "one of the main CPU-intensive activities is the writing of phase space data."
            {  0  "Group reading has also been considered, but preliminary studies have shown"
            {  0  "that it does not reduce CPU time significantly."
            {  0
            {  0  "Using the macro $SET_NEGATIVE_E, $WRITE_PHSP_RECORD also takes care of setting"
            {  0  "E to -E if this is the first particle scored from a new primary"
            {  0  "(non-phsp source) history."
            {  0
            {  0  "This macro is called by $WRITE_PHSP, but can also be used as a stand-"
            {  0  "alone macro.  However, use of $WRITE_PHSP_RECORD, will always require"
            {  0  "use of $PHSP_BUFFER_FLUSH (see below)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number for phase space file"
            {  0  "{P3}=name of phase space file"
            {  0  "{P4}=record number writing to"
            {  0  "{P5}=scoring plane number"
            {  0  "{P6}=IHSTRY"
            {  0  "{P7}=ZLAST"
            {  0  "{P8}=LATCH"
            {  0  "{P9}=E,WT,X,Y,U,V"
            {  0
            {  0  IF({P4}>2 & WRITE_PHSP_COUNTER({P5})=0 & WRITE_PHSP_SOFAR({P5})=0)[
            {  0  "we have a restart or its the start of a new batch"
            {  0  IF(({P4}-1)-1000*(({P4}-1)/1000)~=0)[
            {  0  "make what was the buffer flush part of the first record of the restart"
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
            {  0  READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*(I_PHSP-1)+1:32*I_PHSP);
            {  0  ]
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
            {  0  READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
            {  0  STRING_TEMP_OUT({P5})(28*(I_PHSP-1)+1:28*I_PHSP);
            {  0  ]
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ]
            {  0  WRITE_PHSP_SOFAR({P5})=1000*INT(dble({P4}-1)/1000);
            {  0  IF(WRITE_PHSP_SOFAR({P5})>0)[
            {  0  PHSP_RESTART=1;
            {  0  WRITE_PHSP_COUNTER({P5})=({P4}-1)-1000*(({P4}-1)/1000);
            {  0  ]
            {  0  ELSE[
            {  0  WRITE_PHSP_COUNTER({P5})=({P4}-2)-1000*(({P4}-2)/1000);
            {  0  ]
            {  0  ]
            {  0
            {  0  $SET_NEGATIVE_E({P5},{P6},{P9});
            {  0
            {  0  $PARSE_TEMP_FOR_WRITE({P1},{P7},{P8},{P9});
            {  0
            {  0  IF({P4}<=1000 & PHSP_RESTART=0)["do not use first 7/8 elements"
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+33:
            {  0  32*WRITE_PHSP_COUNTER({P5})+64)=REC_TEMP_OUT(1:32);
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+29:
            {  0  28*WRITE_PHSP_COUNTER({P5})+56)=REC_TEMP_OUT(1:28);
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  IF({P1}~=0)[
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+1:
            {  0  32*WRITE_PHSP_COUNTER({P5})+32)=REC_TEMP_OUT(1:32);
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+1:
            {  0  28*WRITE_PHSP_COUNTER({P5})+28)=REC_TEMP_OUT(1:28);
            {  0  ]
            {  0  ]
            {  0
            {  0  WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
            {  0
            {  0  IF({P4}=1000|WRITE_PHSP_COUNTER({P5})=1000)[
            {  0  IF({P1}~=0 & PHSP_RECL=$RECL-FACTOR*8)[
            {  0  CLOSE({P2});
            {  0  PHSP_RECL_OLD=PHSP_RECL;
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ELSEIF({P1}=0 & PHSP_RECL=$RECL-FACTOR*7)[
            {  0  PHSP_RECL_OLD=PHSP_RECL;
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  IF({P1}~=0)[
            {  0  WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_ZLAST_OUT({P5});
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_OUT({P5});
            {  0  ]
            {  0  IF(PHSP_RECL_OLD~=0)[
            {  0  "have to do this in case the output file=input file"
            {  0  PHSP_RECL=PHSP_RECL_OLD;
            {  0  CLOSE({P2});
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  WRITE_PHSP_COUNTER({P5})=0;
            {  0  WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+1000;
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PHSP_BUFFER_FLUSH(#,#,#,#,#);} WITH {;
            {  0  "This macro outputs the data for the M (M<1000) remaining particles still"
            {  0  "stored in STRING_TEMP(_ZLAST)_OUT after all calls to $WRITE_PHSP_RECORD."
            {  0  "The macro does not flush all of the data at once, but in blocks that"
            {  0  "divide exactly into the number of particles already in the phase space"
            {  0  "file.  For each block that is flushed, the phase space file is re-opened"
            {  0  "with a record length (RECL) equal to the size of the block.  Since RECL"
            {  0  "divides exactly into the number of particles already in the file, the"
            {  0  "block to be flushed can be appended onto the data that already exists in"
            {  0  "the file with no overwrites and/or blank space."
            {  0  "The other alternative was to flush STRING_TEMP(_ZLAST)_OUT one particle at"
            {  0  "a time, which is more time-consuming."
            {  0  "$PHSP_BUFFER_FLUSH must exist in a code that uses $WRITE_PHSP or"
            {  0  "$WRITE_PHSP_RECORD.  It should be placed on its own outside the loop in which"
            {  0  "phase space data is output.  In the case of BEAM, it is placed at the end"
            {  0  "of each batch, so that, if the simulation crashes, phase space information"
            {  0  "from the last batch is not lost."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number for phase space file"
            {  0  "{P3}=file name"
            {  0  "{P4}=particle number +1"
            {  0  "{P5}=scoring plane number"
            {  0  TEMP_PHSP_COUNTER=0;
            {  0  NUM_PHSP_TOFLUSH=WRITE_PHSP_COUNTER({P5});
            {  0  IF(NUM_PHSP_TOFLUSH>0)[
            {  0  IF(WRITE_PHSP_SOFAR({P5})=0)[
            {  0  WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
            {  0  NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH+1; "account for header"
            {  0  ]
            {  0  LOOP[
            {  0  TEMP_PHSP_COUNTER=NUM_PHSP_TOFLUSH+1;
            {  0  LOOP[
            {  0  TEMP_PHSP_COUNTER=TEMP_PHSP_COUNTER-1;
            {  0  REM_PHSP=MOD(WRITE_PHSP_SOFAR({P5}),TEMP_PHSP_COUNTER);
            {  0  ]UNTIL(REM_PHSP=0);
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["write ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8*TEMP_PHSP_COUNTER;
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
            {  0  ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
            {  0  STRING_TEMP_ZLAST_OUT({P5})
            {  0  (32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
            {  0  32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7*TEMP_PHSP_COUNTER;
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
            {  0  ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
            {  0  STRING_TEMP_OUT({P5})
            {  0  (28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
            {  0  28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
            {  0  ]
            {  0  WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+TEMP_PHSP_COUNTER;
            {  0  NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH-TEMP_PHSP_COUNTER;
            {  0  ] UNTIL(NUM_PHSP_TOFLUSH=0);
            {  0  WRITE_PHSP_COUNTER({P5})=0;
            {  0  WRITE_PHSP_SOFAR({P5})=0;
            {  0  ]
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$WRITE_PHSP(#:#,#,#,#,#,#,#:#);} WITH {;
            {  0  "Note that colons     ^             ^  are required between the first and"
            {  0  "second input parameters (5th and 6th input variables) and the"
            {  0  "8th and 9th input parameters (13th and 14th input variables)"
            {  0
            {  0  "This outputs phase space data in blocks of 1000 particles at a time."
            {  0  "In preparation for output, LATCH is modified to hold NPASS and IQ,"
            {  0  "energy (E) is placed into a single precision variable, ESHORT, and"
            {  0  "weight (WT) is given the sign of W.  If this is the first particle"
            {  0  "scored from a new primary (non-phase space source) history, then"
            {  0  "ESHORT is set to -ESHORT and IHSTRY_PHSP is set to IHSTRY."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST,unit number for phase space file,name of phase space file,"
            {  0  "     record number writing to, scoring plane number"
            {  0  "{P2}=IHSTRY"
            {  0  "{P3}=NPASS"
            {  0  "{P4}=IQ"
            {  0  "{P5}=W"
            {  0  "{P6}=ZLAST"
            {  0  "{P7}=LATCH"
            {  0  "{P8}=E,WT"
            {  0  "{P9}=X,Y,U,V"
            {  0
            {  0  $GET_LATCHTMP_ESHORT_WEIGHTTMP({P3},{P4},{P5},{P7},{P8});
            {  0
            {  0  $WRITE_PHSP_RECORD({P1}:{P2},{P6},LATCHTMP,ESHORT,WEIGHTTMP,{P9});
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_HEADER(#,#,#,#,#,#,#);} WITH {;
            {  0  "This macro reads the info from the header of a phase space file."
            {  0  "It is called from $OPEN_PHSP_FILE_FOR_WRITE, but can also be used"
            {  0  "as a stand-alone macro."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=unit number"
            {  0  "{P2}=MODE0 or MODE2"
            {  0  "{P3}=total number of particles"
            {  0  "{P4}=no. of photons"
            {  0  "{P5}=max k.e. of particles"
            {  0  "{P6}=min. k.e. of electrons"
            {  0  "{P7}=no. of particles incident from original source"
            {  0
            {  0  READ({P1},REC=1,IOSTAT=IERR_PHSP){P2},NUM_PHSP_TOT,PHOT_PHSP_TOT,
            {  0  EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
            {  0  {P3}=NUM_PHSP_TOT;
            {  0  {P4}=PHOT_PHSP_TOT;
            {  0  {P5}=EKMAX_PHSP_SHORT;
            {  0  {P6}=EKMINE_PHSP_SHORT;
            {  0  {P7}=NINC_PHSP_SHORT;
            {  0
            {  0  IF(IERR_PHSP~=0)[
            {  0  OUTPUT;(//' ***ERROR READING HEADER OF PHASE SPACE FILE*** '//);
            {  0  STOP;
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$OPEN_PHSP_FOR_READ(#,#,#,#,#);} WITH {;
            {  0  "Macro to open a phase space file in preparation for reading it."
            {  0  "The macro opens the file in one of 3 modes, as a file that is known"
            {  0  "to have ZLAST (IZLAST>0), as a file that is known not to have ZLAST"
            {  0  "(IZLAST=0), or with no prior knowledge of whether the file has"
            {  0  "ZLAST or not (IZLAST<0)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE0 or MODE2"
            {  0  "{P5}=total number of particles, no. of photons, max k.e. of particles,"
            {  0  "      min. k.e. of electrons, no. of particles incident from original source"
            {  0
            {  0  IF({P1}>0)["with ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  "error above on file opening when assumed it was MODE2"
            {  0  OUTPUT;(/' ***error opening file as MODE2 ****'
            {  0  /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE2 FILE) ***'/
            {  0  /' *** WE NOW TRY TO OPEN IT AS A MODE3 FILE ***'//);
            {  0  OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
            {  0  FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
            {  0  "if on error, cannot find file/directory, then stop"
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  STOP;
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE3')[
            {  0  OUTPUT;(//' That file does not start with MODE3,',
            {  0  ' as all old compressed files (with ZLAST) must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ELSE[
            {  0  OUTPUT;(//' This is a MODE3 file! '/
            {  0  ' Please convert it into a MODE2 file using [readphsp] ',
            {  0  ' and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSEIF({P1}=0)["without ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  "$RECL-FACTOR = 4 for SUN SPARC and =1 for SILICON GRAPHICS "
            {  0  "this factor is machine-dependent and stored in machine.mortran"
            {  0  "check file is MODE0 -ie standard compressed"
            {  0  IF(IERR_PHSP~=0)[
            {  0  "come here if error opening file assumed MODE0"
            {  0  OUTPUT;(/' ***ERROR opening file as MODE0****'
            {  0  /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE0 FILE) ***'/
            {  0  /' *** WE NOW TRY TO OPEN IT AS A MODE1 FILE ***'//);
            {  0  OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
            {  0  FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
            {  0  "if on error, cannot find file/directory, then stop"
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  STOP;
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE1')[
            {  0  OUTPUT;(//' That file does not start with MODE1,',
            {  0  ' as all old compressed files must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ELSE[
            {  0  OUTPUT;(//' This is a MODE1 file! '/
            {  0  ' Please convert it into a MODE0 file using [readphsp] ',
            {  0  'and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE0')[
            {  0  OUTPUT;
            {  0  (/' Does not start with MODE0 as files without ZLAST must'/
            {  0  '  Try again!'//);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSEIF({P1}<0)["open with no assumptions about whether ZLAST is there or not"
            {  0  OUTPUT;(/' First, try to open it as a MODE0 file');
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  OUTPUT;(/' Now try to open it as a MODE2 file');
            {  0  {P1}=1;
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4}~='MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  CLOSE({P2});
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  {P1}=0;
            {  0  IF({P4}~='MODE0')[
            {  0  OUTPUT;(/' The file does not start with MODE0 as it supposed to');
            {  0  CLOSE({P2});
            {  0  OUTPUT;(/' Now try to open it as a MODE2 file');
            {  0  {P1}=1;
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE OPENED. ***');
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4}~='MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  CLOSE({P2});
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_PHSP_HEADER_FOR_WRITE(#,#,#,#,#);} WITH {;
            {  0  "Puts max ke of particles, min ke of electrons, and no. of particles"
            {  0  "incident from original source--all of which may be double precision"
            {  0  "into real*4 variables"
            {  0  "{P1}=tot. no. of particles"
            {  0  "{P2}=no. of photons"
            {  0  "{P3}=max ke of particles"
            {  0  "{P4}=min ke of electrons"
            {  0  "{P5}=no. of particles incident from primary source"
            {  0  IF({P1}>2147483647)[
            {  0  write(*,*)' Warning while writing phase space file:';
            {  0  write(*,*)' No. of particles > 2^31-1.';
            {  0  write(*,*)' Total no. of particles (and photons) written';
            {  0  write(*,*)' to header may be nonsense.';
            {  0  ]
            {  0  NUM_PHSP_TOT={P1};
            {  0  PHOT_PHSP_TOT={P2};
            {  0  EKMAX_PHSP_SHORT={P3};
            {  0  EKMINE_PHSP_SHORT={P4};
            {  0  NINC_PHSP_SHORT={P5};
            {  0  }
               0
               0  REPLACE {$WRITE_PHSP_HEADER(#,#,#,#,#);} WITH {;
            {  0  "Macro to write the header information into a phase space file."
            {  0  "Files must be closed and re-opened with record length (RECL) for"
            {  0  "a single particle in order to prevent over-writing any particle data."
            {  0  "Once the header info is written, the file is closed again and re-opened"
            {  0  "with the RECL for 1000 particles."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE0 or MODE2"
            {  0  "{P5}=total number of particles, no. of photons, max k.e. of particles,"
            {  0  "      min. k.e. of electrons, no. of particles incident from original source"
            {  0
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  $PARSE_PHSP_HEADER_FOR_WRITE({P5});
            {  0  WRITE({P2},REC=1){P4},NUM_PHSP_TOT,PHOT_PHSP_TOT,EKMAX_PHSP_SHORT,
            {  0  EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  }
               0  ;
               0
               0
               0  REPLACE {$OPEN_PHSP_FOR_WRITE(#,#,#,#);} WITH {;
            {  0  "This macro opens a phase space file for writing.  The file is opened with"
            {  0  "a record length that will hold phase space data for 1000 particles in 1"
            {  0  "record.  This is to to enable writing phase space data for 1000 particles"
            {  0  "at a time (see the $WRITE_PHSP_RECORD macro above).  The macro also uses"
            {  0  "$WRITE_PHSP_HEADER to output a dummy header to the file."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE_RW"
            {  0  IF({P1}~=0)["with ZLAST"
            {  0  {P4}='MODE2';
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  {P4}='MODE0';
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  $WRITE_PHSP_HEADER({P1},{P2},{P3},{P4},0,0,0,0,0);
            {  0  }
               0  ;
               0
               0  REPLACE {$CLOSE_PHSP(#);} WITH {;
            {  0  "Macro to close a phase space file."
            {  0
            {  0  "Input parameter:"
            {  0  "{P1}=the unit number of the phase space file"
            {  0
            {  0  CLOSE(UNIT={P1});
            {  0  }
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;
            {  0
            {  0  OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
            {  0  ' space handling macros.'//);
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;
            {  0
            {  0  OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
            {  0  ' space handling macros.'//);
            {  0  }
               0  ;
               0  REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;}
               0
               0  REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;}
               0
               0  REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;}
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$BEAM_OPEN_PHSP_FOR_WRITE;} WITH {;
            {  0  IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
            {  0  ELSE                  [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
            {  0  "AUNIT is a character variable"
            {  0  "construct phase space file name."
            {  0  "part of this--the part that determines the directory and"
            {  0  "file prefix--is done in beam"
            {  0  IF(IO_OPT=4)[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
            {  0  Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            {  0  IZLAST,0,Z_SCORE_SHORT,I_MU_PHSP,0);
            {  0  ]
            {  0  ELSE[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0  $OPEN_PHSP_FOR_WRITE(IZLAST,IOUTFLU(I),$cstring(phsp_fn),MODE_RW);
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_OPEN_PHSP_FOR_READ;} WITH {;
            {  0  OUTPUT;
            {  0  (/' Restarting after previous run, will read old data & phase-space',
            {  0  ' files');
            {  0  DO I=1,NSC_PLANES [
            {  0  OUTPUT IOUTFLU(I);(//' Checking ph-sp file on logical unit ',I4);
            {  0  :OPEN_MODE0:;
            {  0  IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
            {  0  ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
            {  0  IF(IO_OPT=4)[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
            {  0  Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            {  0  IZLAST,1,Z_SCORE_SHORT,I_MU_PHSP,0);
            {  0  ]
            {  0  ELSE[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0
            {  0  $OPEN_PHSP_FOR_READ(IZLAST,IOUTFLU(I),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
            {  0
            {  0  NPPHSP(I)=NPPHSPSP;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_WRITE_PHSP;} WITH {;
            {  0  IF(IOUTFLU(ISCORE)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(ISCORE)-43;]
            {  0  ELSE                       [WRITE(AUNIT,'(I1)') IOUTFLU(ISCORE)-43;]
            {  0
            {  0  "output directory and file prefix are defined in beam.mortran"
            {  0
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_WRITE_PHSP_RECORD(IOUTFLU(ISCORE),NPASS(NP,ISCORE),
            {  0  ISCORE,NHSTRY,LATCH(NP),IQ(NP),E(NP),WT(NP),
            {  0  X(NP),Y(NP),Z(NP),U(NP),V(NP),W(NP),ZLAST(NP),
            {  0  BEAM_MU_INDEX);
            {  0  ]
            {  0
            {  0  ELSE[
            {  0
            {  0  IF( i_parallel > 0 ) ["add an _w"
            {  0  phsp_fn=$cstring(phsp_fn)// '_w';
            {  0  call egs_itostring(phsp_fn,i_parallel,.false.);
            {  0  ]
            {  0  phsp_fn=$cstring(phsp_fn)// '.egsphsp'//AUNIT;
            {  0  $WRITE_PHSP(IZLAST,IOUTFLU(ISCORE),$cstring(phsp_fn),NPPHSP(ISCORE)+1,
            {  0  ISCORE:NHSTRY,NPASS(NP,ISCORE),IQ(NP),W(NP),ZLAST(NP),
            {  0  LATCH(NP),E(NP),WT(NP):X(NP),Y(NP),U(NP),V(NP));
            {  0  ]
            {  0  IF(IZLAST = 2)[
            {  0  WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
            {  0  JHSTRY=JHSTRY+1;
            {  0  WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) NP,IQ(NP),0,
            {  0  XLAST(NP),YLAST(NP),ZLAST(NP),0;
            {  0  :GRAPHICS_FORMAT2:FORMAT(3I4,4G15.8,I12);
            {  0  ]
            {  0  "Check only needed when actually writting to a phsp file"
            {  0  IF(NPPHSP(ISCORE)=phsp_upper_limit)[
            {  0  $egs_fatal('(//a,i19,4(a/))',
            {  0  ' *** WHILE WRITING PHASE SPACE FILE:',
            {  0  NPPHSP(ISCORE), ' particles in file.',
            {  0  ' Due to the fact that the counter for the number',
            {  0  ' of particles in the file cannot be larger than this,',
            {  0  ' no more particles will be written to the phsp file.'
            {  0  );
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_PHSP_BUFFER_FLUSH;} WITH {;
            {  0  IF(IO_OPT=4)["update no. of primary histories in header"
            {  0  DO I1=1,NSC_PLANES[
            {  0  NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
            {  0  $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(IOUTFLU(I1),NINCPHSP);
            {  0  $IAEA_UPDATE_PHSP_HEADER(IOUTFLU(I1));
            {  0  ]
            {  0  ]
            {  0  ELSE["standard BEAMnrc format"
            {  0  IF(MODE_RW='MODE0' | MODE_RW='MODE2')[
            {  0  NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
            {  0  DO I1=1,NSC_PLANES[
            {  0  NPPHSPSP=NPPHSP(I1);
            {  0  IF(IOUTFLU(I1)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I1)-43;]
            {  0  ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I1)-43;]
            {  0
            {  0  "output directory and file prefix defined in beam.mortran"
            {  0
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0  $PHSP_BUFFER_FLUSH(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),NPPHSPSP,I1);
            {  0  IF(NPPHSPSP=NPHOTPHSP(I1))[
            {  0  "no electrons"
            {  0  $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
            {  0  EKMAXPHSP(I1), 0.0, NINCPHSP);
            {  0  ]
            {  0  ELSE[
            {  0  $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
            {  0  EKMAXPHSP(I1), EKMINPHSPE(I1), NINCPHSP);
            {  0  ]
            {  0  ]
            {  0  "we store the total particle number in the 1st record of the ph-sp file"
            {  0  ]
            {  0  ]"end of standard BEAMnrc format"
            {  0  };
               0
               0  REPLACE {$BEAM_READ_PHSP_FOR_RESTART;} WITH {;
            {  0  DO I=1,NSC_PLANES[
            {  0  OUTPUT I,NPPHSP(I);
            {  0  (//' PH-SP FILE',I4,': '/
            {  0  '               TOTAL NO. OF PARTICLES =',I12);
            {  0  IF(IO_OPT=0 | IO_OPT=3)["check to see that the user has not"
            {  0  "added phase space files before restarting"
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_READ_PHSP_HEADER(IOUTFLU(I),NPPHSP(I),NPHOTPHSP(I),
            {  0  EKMAXPHSP(I),NINCPHSP,Z_SCORE,IZLAST1,I_MU_PHSP,IZSCORE);
            {  0  EKMINPHSPE(I)=99999.; "info unavailable"
            {  0  IF(IZLAST=0 & IZLAST1=1)[
            {  0  OUTPUT;
            {  0  (//' Error: Phase space file was scored with ZLAST in previous run '/
            {  0  ' but you have restarted this run with IZLAST=0.  Restart with'/
            {  0  ' IZLAST=1.'//);
            {  0  STOP;
            {  0  ]
            {  0  ELSEIF(IZLAST=1 & IZLAST1=0)[
            {  0  OUTPUT;
            {  0  (//' Error: Phase space file was scored  without ZLAST in previous run '/
            {  0  ' but you have restarted this run with IZLAST=1.  Restart with'/
            {  0  ' IZLAST=0.'//);
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER(IOUTFLU(I),MODE_RW,NPPHSPSP,
            {  0  NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
            {  0  NPPHSP(I)=NPPHSPSP;
            {  0  ]
            {  0  IF(NINCPHSP>
            {  0  NINCSRC*(NCASEO+(NRCYCL+1)*(NPASS_ph_spO+NFAT_ph_spO))/NNPHSP)[
            {  0  "files have been added"
            {  0  OUTPUT I;(//' ***ERROR:'/
            {  0  ' Phase space file',I4,' has been added to (using beamdp?) before restarting.'/
            {  0  ' The code currently does not support this.  Please add phase space'/
            {  0  ' files only after all runs, including restarts, are complete.'//);
            {  0  "STOP;"
            {  0  ]
            {  0  ]
            {  0  IF(NPPHSP(I) > 0)[
            {  0  CALL DATETIME(1);
            {  0  OUTPUT TIMEN;(/' READ PH-SP FILE AT ',$TIMEN_FORMAT);
            {  0  "Read last particles to check whether it is right"
            {  0  IF(IO_OPT=4)[
            {  0  "just check that file size=checksum"
            {  0  $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(IOUTFLU(I));
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_RECORD(IZLAST,IOUTFLU(I),NPPHSP(I)+1:
            {  0  NHSTRYM,ZLAST(1),LATCHM,EINM,WTM,XINM,YINM,UINM,VINM);
            {  0  "binary read"
            {  0  OUTPUT NPPHSP(I),LATCHM,EINM,XINM,YINM,UINM,VINM,WTM;(//
            {  0  ' (LATCHM,EINM,XINM,YINM,UINM,VINM,WTM) FOR PARTICLE No.',
            {  0  I12,' IN THIS FILE:'/' ',I12,6F12.5);
            {  0  "CALL TIME(TIMEN);"
            {  0  "OUTPUT TIMEN;"
            {  0  "(/' FINISHED READING PH-SP FILE AT ',$TIMEN_FORMAT);"
            {  0  ]
            {  0  OUTPUT; (/' FINISHED READING PH-SP FILE AT ',$);
            {  0  call egs_time(6); OUTPUT; (' ');
            {  0  ]
            {  0  ]"end of loop over planes"
            {  0  };
               0
               0  REPLACE {$BEAM_CLOSE_PHSP;} WITH {;
            {  0  IF(n_parallel=0 | ~is_finished) [
            {  0  "do not close phsp files that have already been closed"
            {  0  "after individual parallel jobs have ended"
            {  0  IF (IO_OPT =  0)|((IO_OPT =  3)&(IHSTRY <= 100000))|(IO_OPT=4) [
            {  0  "phase-space output"
            {  0  DO I=1,NSC_PLANES [
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_DESTROY_PHSP_FILE(IOUTFLU(I));
            {  0  ]
            {  0  ELSE[
            {  0  CLOSE(IOUTFLU(I));
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$DOSXYZ_OPEN_PHSP_FOR_WRITE;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps."
            {  0  "Some mods by BW."
            {  0  IF(IRESTART=0) [
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            {  0  0,0,z_score_tmp,i_muidx_out,1);
            {  0  ]
            {  0  ELSEIF(IRESTART=1) [
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            {  0  0,1,z_score_tmp,i_muidx_out,1);
            {  0  ]
            {  0  };
               0
               0  REPLACE {$DOSXYZ_WRITE_PHSP;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps"
            {  0  $IAEA_WRITE_PHSP_RECORD(i_unit_out,0,
            {  0  1,nhist,latch(np),iq(np),e(np),
            {  0  wt(np), x(np),y(np),z(np),u(np),v(np),w(np),zlast_tmp,
            {  0  frMU_indx); "added MU index (JL 2013)"
            {  0  "zlast not used in dosxyz so this is a dummy variable"
            {  0
            {  0  };
               0
               0  REPLACE {$DOSXYZ_SET_OUT_PHSP_HEADER;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps"
            {  0  IF(isource = 0 |  isource = 1 | isource = 3 | isource = 7)[
            {  0  ainflu=dble(IHSTRY+ncaseold-nsmiss-nmissm);
            {  0  ]
            {  0  ELSEIF(isource = 2 | isource = 8 )[
            {  0  ainflu=dble(IHSTRY+ncaseold+nsmiss+
            {  0  (NRCYCL+1)*(nsrjct+nsoutside+ndbsrjct))/float(nshist)*NINCSRC;
            {  0  ]
            {  0  ELSEIF(isource=4)[
            {  0  ainflu=dble(IHSTRY+ncaseold-nsmiss);
            {  0  ]
            {  0  ELSEIF(isource=6)[
            {  0  ainflu=dble(IHSTRY+ncaseold);
            {  0  ]
            {  0  ELSEIF(isource=9|isource=10|isource=21)[
            {  0  ainflu=dble(nhist);
            {  0  ]
            {  0  ELSEIF(isource=20)[
            {  0  ainflu = dble((NRCYCL+1)*(nnread))/dble(nshist)*NINCSRC;
            {  0  ]
            {  0  $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(i_unit_out,ainflu);
            {  0  $IAEA_UPDATE_PHSP_HEADER(i_unit_out);
            {  0
            {  0  };
               0
               0  " The following are null macros that will be overwritten by the library "
               0  " version of BEAM "
               0  REPLACE {$DECLARE-PARTICLE-CONTAINER;} WITH {;};
               0
               0  "End of phsp_macros.mortran"
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc beamdp utility                                                      "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Charlie Ma, 1993                                          "
               0  "                                                                             "
               0  "  Contributors:    Dave Rogers                                               "
               0  "                   Blake Walters                                             "
               0  "                   Joanne Treurniet                                          "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Zdenko Sego                                               "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The beamdp utility is a data processing program to construct an input data "
               0  "  file for Monte Carlo simulation based on the full phase-space data for a   "
               0  "  beam from a radiotherapy machine simulated using BEAMnrc. It can also      "
               0  "  generate planar fluence, mean energy, spectral and angular distributions   "
               0  "  in the format suitable for the Grace plotting program.                     "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Zdenko Sego and Dave Rogers, 2006: add double precision scoring arrays to  "
               0  "  ensure subsource intensities add up to one even when there are large       "
               0  "  differences in weights. Change circular and square ring fluence types.     "
               0  "  Eliminate a big chunk of redundant data in help output.                    "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  !INDENT F 2;
               0  "*******************************************************************************
               0  "
               0  "               BEAM CHARACTERIZATION: BEAM DATA PROCESSOR
               0  "               ******************************************
               0  "
               0  "                           Original programmer:  C-M Ma  (NRC)
               0  "                             June 2, 1993
               0  "
               0  "*******************************************************************************
               0  "
               0  %L                                                                             ;
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  %I4                                                                            ;
1              0  %E
               0  %B132                                                                          ;
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  "*******************************************************************************
               0
               0  "We need the $REAL, $INTEGER and $LOGICAL macros "
               0  REPLACE {$REAL} WITH {real*8}
               0  REPLACE {$INTEGER} WITH {integer*4}
               0  REPLACE {$LOGICAL} WITH {logical}
               0
               0  ;REPLACE {$NS} WITH {22}  "maximum number of sub-sources for the source model
               0  "note: this number should be consistent with
               0  "that used in the simulation code (=$MXSMFS in BEAM)
               0
               0  ;REPLACE {$NB} WITH {200} "maximum number of bins for a distribution
               0  "note: this number should be consistent with
               0  "that used in the simulation code
               0
               0  ;REPLACE {$ND} WITH {2000}  "maximum number of bins for a distribution
               0
               0  REPLACE {$NBINANGLE} WITH {200}; "number of bins for the angular distribution"
               0
               0  REPLACE {$MAXANGLE} WITH {0.1745};
               0  "ANGLE IN RAD, = 10 DEGREES. Very few particles will be scattered at angles"
               0  "greater than 10 degrees after going through 100 cm air"
               0
               0  REPLACE {$LATCH_NUMBER_OF_BITS} WITH {5}
               0  "number of bits used in LATCH to record region # where a particle is created"
               0
               0  REPLACE {$MAX_SC_PLANES} WITH {1};
               0  "a dummy replacement needed for new write macros"
               0
               0  "Macro to set bit {P2} in {P1}  to 1
               0  REPLACE {$IBSET(#,#);} WITH {IBSET({P1},{P2});}
               0
               0  "Macro to set test bit {P2} in {P1}
               0  REPLACE {$BTEST(#,#)} WITH {BTEST({P1}, {P2}) }
               0
               0  "Macro to set bit {P2} in {P1}  to 0   "
               0  REPLACE {$IBCLR(#,#);} WITH {IBCLR({P1},{P2});}
               0
               0  REPLACE {$LONG_INT} WITH {INTEGER*8}
               0  "use INTEGER*4 if your compiler has trouble with this"
               0
               0  REPLACE {COMIN/CHARACTERS;} WITH {
            {  0  COMMON/CHARACTERS/
            {  0  MODE_RW1,MODE_RW2,C1,C2,AC,PSDNAM,
            {  0  SPCNAM,OLDNAM, SSMFPS,
            {  0  DSMFPS,GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE,SCRIPT,
            {  0  LETTER1,LETTER2;
            {  0  CHARACTER*5
            {  0  MODE_RW1,MODE_RW2;"for use to check phase space file mode"
            {  0  CHARACTER*1  C1;  "|temp. variables"
            {  0  CHARACTER*2  C2;  "|temp. variables"
            {  0  CHARACTER*2  AC(3); "for output of 3D points from IAEA phsp data"
            {  0  CHARACTER*100
            {  0  PSDNAM;         "file name of full phase-space data to be processed"
            {  0  CHARACTER*80
            {  0  SPCNAM,         "file name of source data file to be created"
            {  0  OLDNAM,         "old source data file used as a reference"
            {  0  SSMFPS,         "detailed descriptions of the source (machine, energy, "
            {  0  "field size, etc."
            {  0  DSMFPS;         "detailed descriptions of the source (machine, energy, "
            {  0  "field size, etc."
            {  0  CHARACTER*60 GRAPHTITLE;               "|strings for xvgr plotting"
            {  0  CHARACTER*60 XTITLE,YTITLE,SERIESTITLE;
            {  0  CHARACTER*102 SCRIPT(4);
            {  0  CHARACTER*2 LETTER1(5),LETTER2(0:101);
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {COMIN/REALS;} WITH {
            {  0  COMMON/REALS/
            {  0  XMIN2,XMAX2, XPLOT,HXMIN, YPLOT,YPLOTT,
            {  0  ERRYPLOT,X2Y2,ZTOTAL,RSSD02,RSSD12,SSDVPS,
            {  0  SFACTOR,RFACTOR,RFACTOR1,RFACTOR2,
            {  0  X,Y,Z,RRFACTOR,SSFACTOR,RSSD0,RSSD1,
            {  0  WEIGHT,EI,
            {  0  PARAEMAX2,PARAEMAX1,PARAEMAX,
            {  0  PARAEMNE1,PARAEMNE2,PARAEMNE,
            {  0  PARANINC1,PARANINC2,PARANINC,
            {  0  EREAD,ZLAST, MUIDX,XIN,YIN,ZIN,UIN,VIN,WIN, SMFX2,SMFY2,SMFMXR,
            {  0  HFIELD,  RSCATT, DELTAZ,RSSDST,SSSDST,ERADII,E_ph_sp_e,
            {  0  E_ph_sp_g, E_ph_sp_p, E_MIN_ph_sp, E_MAX_ph_sp,
            {  0  RFIELD,RFIELDe,XFLDMN,XFLDMX,
            {  0  YFLDMN, YFLDMX, SMFMNZ, SMFMXZ, SMFMNX,
            {  0  SMFMXX, SMFMNY, SMFMXY, SMFMNR,RTREAT,RTREATe,XTREATMN,XTREATMX,
            {  0  YTREATMN,YTREATMX, SMFMNE,SMFMXE,
            {  0  ABNTOTAL,ABNTOTALH,FLUAREA,NINC,
            {  0  RMIN_MIN,RMIN_MAX,RMAX_MIN,RMAX_MAX,DOMEGA,
            {  0  SUM_TMP,SUM_TMP2,Z_SCORE,mumin,mumax;
            {  0
            {  0  $REAL
            {  0  XMIN2,XMAX2,    "|temp. variables"
            {  0  XPLOT($NB),HXMIN,  "|VARIABLES FOR XVGR PLOTTING"
            {  0  YPLOT($NB),YPLOTT,
            {  0  ERRYPLOT($NB),
            {  0  X2Y2,           "=XIN*XIN+YIN*YIN"
            {  0  ZTOTAL($NS),    "calculated SSD for a particular particle from a point source"
            {  0  RSSD02,RSSD12,  "squares of RSSD0 and RSSD1"
            {  0  SSDVPS($NS+3),  "SSD of a virtual point source for a particular source"
            {  0  SFACTOR,RFACTOR,RFACTOR1,RFACTOR2,X,Y,Z,RRFACTOR,SSFACTOR,"temp. variables"
            {  0  RSSD0,RSSD1,    "radius of a ring used for SSD analysis for a point source"
            {  0  WEIGHT,EI,
            {  0  PARAEMAX2,PARAEMAX1,PARAEMAX,
            {  0  PARAEMNE1,PARAEMNE2,PARAEMNE,
            {  0  PARANINC1,PARANINC2,PARANINC,
            {  0  EREAD,ZLAST,MUIDX,
            {  0  XIN,YIN,ZIN,UIN,
            {  0  VIN,WIN,        "|variables for phase-space data reading"
            {  0  SMFX2($NS),
            {  0  SMFY2($NS),     "|outer dimensions of applicators and collimators"
            {  0  SMFMXR($NS),    "outer radius for rings and cones"
            {  0  HFIELD($NS),    "variable for SSD calculation"
            {  0  RSCATT,         "mean scattering radius"
            {  0  DELTAZ,         "distance from scoring plane to image plane for SSD analysis"
            {  0  RSSDST($NS,$ND),"distribution used to find SSD for a virtual point source"
            {  0  SSSDST($NS,$ND),"distribution used to find SSD for a virtual point source"
            {  0  ERADII($NB),    "energy spectrum radii"
            {  0  E_ph_sp_e,      "energy of e- from phase space file"
            {  0  E_ph_sp_g,      "energy of gamma read from phase space file"
            {  0  E_ph_sp_p,      "energy of e+ read from phase space file"
            {  0  E_MIN_ph_sp,    "min energy of particles read from phase space file"
            {  0  E_MAX_ph_sp,    "max energy of particles read from phase space file"
            {  0  RFIELD,         "radius for field planar fluence distribution"
            {  0  RFIELDe,        "radius for energy distribution"
            {  0  "Note: RFIELDe must be equal to RFIELD"
            {  0  XFLDMN,         "minimum x coordinate for field planar fluence distribution"
            {  0  XFLDMX,         "maximum x coordinate for field planar fluence distribution"
            {  0  YFLDMN,         "minimum y coordinate for field planar fluence distribution"
            {  0  YFLDMX,         "maximum y coordinate for field planar fluence distribution"
            {  0  SMFMNZ($NS),    "distance from the sub-source to the scoring plane"
            {  0  "for a tubular applicator: source bottom to the phantom"
            {  0  SMFMXZ($NS),    "distance from the top of the source to the scoring plane"
            {  0  SMFMNX($NS),    "minimum x coordinate for a sub-source"
            {  0  SMFMXX($NS),    "maximum x coordinate for a sub-source"
            {  0  SMFMNY($NS),    "minimum y coordinate for a sub-source"
            {  0  SMFMXY($NS),    "maximum y coordinate for a sub-source"
            {  0  SMFMNR($NS),    "radius of a sub-source"
            {  0  RTREAT,         "defined field radius for treatment or measurement"
            {  0  RTREATe,        "treatment field radius for energy spectra"
            {  0  "Note: RTREATe could generally be different then RTREAT"
            {  0  XTREATMN,       "min X for treatment or measurement field"
            {  0  XTREATMX,       "max X for treatment or measurement field"
            {  0  YTREATMN,       "min Y for treatment or measurement field"
            {  0  YTREATMX,       "max Y for treatment or measurement field"
            {  0  SMFMNE,SMFMXE,  "minimum and maximum energy of the spectrum for a sub-source"
            {  0  ABNTOTAL,ABNTOTALH, "TMP VARIABLES FOR ANGLE CALCULATION"
            {  0  FLUAREA,        "area of rectangular or annular region in which fluence"
            {  0  "is evaluated"
            {  0  NINC,           "number of incident particles"
            {  0  RMIN_MIN,
            {  0  RMIN_MAX,       "used to index radial bin that user wants to plot"
            {  0  RMAX_MIN,       "in a multiple source model with multiple radial bins"
            {  0  RMAX_MAX,
            {  0  DOMEGA,         "bin width in solid angle"
            {  0  SUM_TMP($NB),   "keeps track of sums in a bin over one primary history"
            {  0  SUM_TMP2($NB),  "keeps track of sums in a bin over one primary history"
            {  0  Z_SCORE,        "Z where phsp file was scored (IAEA only)"
            {  0  mumin,mumax;    "MU range for output of (X,Y,Z) (IAEA only)"
            {  0  }
               0  ;
               0
               0  REPLACE {COMIN/DOUBLES;} WITH {
            {  0  COMMON/DOUBLES/
            {  0  KWEI,SMFRTN,
            {  0  FSMFBN1,FSMABN1,FSMABN2,FSMFXX,FSMFYY,FSMFR1,FSMFR2,FSMFR11,FSMFR12,
            {  0  FSMFRR,FSMFXY,BINSIZE,RBin,RBin_X,RBin_Y;
            {  0
            {  0  REAL*8
            {  0  KWEI,
            {  0  SMFRTN($NS), "relative source intensity for a sub-source"
            {  0  FSMFBN1($NS,$NB,$NB),"No of particles/bin a bin for an energy distribution "
            {  0  FSMABN1($NBINANGLE),"No of particles/bin for an angular distribution "
            {  0  FSMABN2($NBINANGLE),"= FSMABN1 SQUARED  "
            {  0  FSMFXX($NS,$NB),"No of particles/bin for a spatial distribution along x-axis"
            {  0  FSMFYY($NS,$NB),"No of particles/bin for a spatial distribution along y-axis"
            {  0  FSMFR1($NS,$NB),"No of particles/bin for a spatial distribution "
            {  0  FSMFR2($NS,$NB),"No of particles/bin for a spatial distribution "
            {  0  FSMFR11($NS,$NB),"parameters for spatial distribution"
            {  0  FSMFR12($NS,$NB),"parameters for spatial distribution"
            {  0  FSMFRR($NS,$NB),"No of particles/bin for a spatial distribution"
            {  0  FSMFXY($NS,$NB,$NB),"No of particles/bin for a rectangular field"
            {  0  BINSIZE($NB),"We deal with different bin sizes. Keep sizes here"
            {  0  RBin,RBin_X,RBin_Y;
            {  0  }
               0  ;
               0
               0  REPLACE {COMIN/INTEGERS;} WITH {
            {  0  COMMON/INTEGERS/
            {  0  PARANOT,PARANOT1,PARANOT2,PARANOP,PARANOP1,
            {  0  PARANOP2,IPARANOT,IPARANOT1,IPARANOT2,
            {  0  LPARANINC,LPARANINC1,LPARANINC2,NHSTRY,NHSTRY_LAST,
            {  0  I,II,III,IIII,IIIII,ITYPE, J,JJ,NUMBERP,NUMBERST,NBIT1,NBIT2,
            {  0  NFIELDi,NFIELDo,NFIELDe,
            {  0  NWRONG,LATCHJ,CHOICE,CHOICE1, K1,K2,K3,K4,IA,
            {  0  IX,IY,IR,K,IQ,LATCHI,IE,
            {  0  NPASSI,LATCH,SMFPXY,NFIELD,NSMFPS,I_IN_EX,
            {  0  ISMFPS,IQSMFP,MSTART,MSMFXY,NSMFEE,NPASS_ph_sp,
            {  0  N_ph_sp_e, N_ph_sp_g, N_ph_sp_p, FLUTYPE,ANGTYPE,IZLAST1,
            {  0  IZLAST2,IMUIDX1,IMUIDX2,IZSCORE1,IZSCORE2,JUSTONE,
            {  0  MAXSCATTER,NUMSCATTER,ESTYPE,i_iaea_in,i_iaea_out,i_log,
            {  0  i_unit_in,i_unit_out;
            {  0
            {  0  $LONG_INT PARANOT,PARANOT1,PARANOT2,
            {  0  PARANOP,PARANOP1, "these need to be made long because IAEA format handles"
            {  0  PARANOP2,IPARANOT,IPARANOT1,IPARANOT2, "> 2^31-1 particles"
            {  0  LPARANINC,LPARANINC1,LPARANINC2, "long int storage for no. of original "
            {  0  "histories for use in IAEA headers, where"
            {  0  "this is an integer*8 variable"
            {  0  NHSTRY,NHSTRY_LAST($NB);
            {  0
            {  0  INTEGER
            {  0  I,II,III,IIII,IIIII,ITYPE,
            {  0  J,JJ,NUMBERP,NUMBERST,NBIT1,NBIT2,  "temp. constants"
            {  0  NWRONG,LATCHJ(29),"flag for wrong field size, tmp for latch"
            {  0  CHOICE,CHOICE1,   "choice of operations"
            {  0  K1,K2,K3,K4,IA,
            {  0  IX,IY,IR,K($NS),
            {  0  IQ,LATCHI,IE,
            {  0  NPASSI,         "|integers for phase-space data reading"
            {  0  LATCH($NS),     "LATCH number for each sub-source when the beam is "
            {  0  "simulated using BEAM"
            {  0  SMFPXY($NS),    "orientation of the collimator: 0-along x-axis,"
            {  0  "1-along y-axis"
            {  0  NFIELD,         "total number of bins for field planar fluence distribution"
            {  0  "NFIELD=NFIELDi+NFIELDo for circular and square field types"
            {  0  NFIELDi,        "number of bins for field planar fluence distribution"
            {  0  "inside the treatment field"
            {  0  NFIELDo,        "number of bins for field planar fluence distribution"
            {  0  "outside the treatment field"
            {  0  NFIELDe,        "number of energy spectra bins"
            {  0  NSMFPS,         "number of sub-sources for the source model (Max.= $MXNSMF)"
            {  0  I_IN_EX,        "flag for inclusive or exclusive LATCH check"
            {  0  ISMFPS($NS),    "source type: 1-applicator, 2-collimator, 3-ring,"
            {  0  "cone and point source"
            {  0  IQSMFP($NS),    "charge of particles from a subsource"
            {  0  "-1 for electrons, 0 for photons and 1 for positrons"
            {  0  MSTART,         "=0 fresh start"
            {  0  "=1 re-start within an option"
            {  0  MSMFXY,         "field type: 0-circular, 1-square, 2-rectangular"
            {  0  NSMFEE,         "number of bins for energy distribution for a sub-source"
            {  0  NPASS_ph_sp,    "number of particles rejected read from ph-sp for NPAS1"
            {  0  N_ph_sp_e,      "No of e- read from phase space file"
            {  0  N_ph_sp_g,      "No of gamma read from phase space file"
            {  0  N_ph_sp_p,      "No of e+ read from phase space file"
            {  0  FLUTYPE,        "choice of estimate of real fluence or planar fluence"
            {  0  ANGTYPE,   "choice to plot particles/unit solid angle or part./angular bin"
            {  0  IZLAST1,        "=0 for no ZLAST, 1 with ZLAST, added for new phsp macros"
            {  0  IZLAST2,        "same but for 2nd file when adding files"
            {  0  IMUIDX1,        "=0 if fractional MU index not stored in IAEA phsp, 1"
            {  0  " otherwise.  For file no. 1"
            {  0  IMUIDX2,        "same as above for file no. 2"
            {  0  IZSCORE1,       "=1 if particle Z scored, 0 otherwise"
            {  0  IZSCORE2,       "same as above for file no. 2"
            {  0  JUSTONE($NB),   "keeps track of actual number of particles in bin"
            {  0  MAXSCATTER,     "max. number of particles to output to scatter plot"
            {  0  NUMSCATTER,     "keeps track of number of particles written to scatter plot"
            {  0  ESTYPE          , "energy spectrum type"
            {  0  i_iaea_in,      "set to 1 to analyze IAEA-format phase space file"
            {  0  i_iaea_out,     "set to 1 if file 2, the file being appended to when two"
            {  0  " phsp files are added, is IAEA-format"
            {  0  i_log,          "standard output, need to declare it because we are using"
            {  0  "phase space macros"
            {  0  i_unit_in,i_unit_out; "input and output units; must use variables for"
            {  0  "IAEA routines rather than just specifying the unit no."
            {  0  "directly"
            {  0  }
               0  ;
               0  REPLACE {COMIN/LOGICALS;} WITH {
            {  0  COMMON/LOGICALS/OLDFILE,EGSPERT;
            {  0
            {  0  LOGICAL OLDFILE,  "flag for reading parameters from an old source data file"
            {  0  " T => read an old file"
            {  0  " F => user type in all the parameters himself  "
            {  0  EGSPERT;        "flag for EGS_PERT prompts"
            {  0  " T => user is an EGS_PERT"
            {  0  " F => user is not an EGS_PERT"
            {  0
            {  0  }
               0
               0  REPLACE {ASSIGN-LETTERS;} WITH {
            {  0  LETTER1(1)='-1';LETTER1(2)=' 0';LETTER1(3)=' 1';
            {  0  LETTER1(4)='2';LETTER1(5)=' 3';
            {  0  LETTER2(0)=' 0';
            {  0  LETTER2(1)=' 1';LETTER2(2)=' 2';LETTER2(3)=' 3';LETTER2(4)=' 4';
            {  0  LETTER2(5)=' 5';LETTER2(6)=' 6';LETTER2(7)=' 7';LETTER2(8)=' 8';
            {  0  LETTER2(9)=' 9';LETTER2(10)='10';
            {  0  LETTER2(11)='11';LETTER2(12)='12';LETTER2(13)='13';LETTER2(14)='14';
            {  0  LETTER2(15)='15';LETTER2(16)='16';LETTER2(17)='17';LETTER2(18)='18';
            {  0  LETTER2(19)='19';LETTER2(20)='20';
            {  0  LETTER2(21)='21';LETTER2(22)='22';LETTER2(23)='23';LETTER2(24)='24';
            {  0  LETTER2(25)='25';LETTER2(26)='26';LETTER2(27)='27';LETTER2(28)='28';
            {  0  LETTER2(29)='29';LETTER2(30)='30';
            {  0  LETTER2(31)='31';LETTER2(32)='32';LETTER2(33)='33';LETTER2(34)='34';
            {  0  LETTER2(35)='35';LETTER2(36)='36';LETTER2(37)='37';LETTER2(38)='38';
            {  0  LETTER2(39)='39';LETTER2(40)='40';
            {  0  LETTER2(41)='41';LETTER2(42)='42';LETTER2(43)='43';LETTER2(44)='44';
            {  0  LETTER2(45)='45';LETTER2(46)='46';LETTER2(47)='47';LETTER2(48)='48';
            {  0  LETTER2(49)='49';LETTER2(50)='50';
            {  0  LETTER2(51)='51';LETTER2(52)='52';LETTER2(53)='53';LETTER2(54)='54';
            {  0  LETTER2(55)='55';LETTER2(56)='56';LETTER2(57)='57';LETTER2(58)='58';
            {  0  LETTER2(59)='59';LETTER2(60)='60';
            {  0  LETTER2(61)='61';LETTER2(62)='62';LETTER2(63)='63';LETTER2(64)='64';
            {  0  LETTER2(65)='65';LETTER2(66)='66';LETTER2(67)='67';LETTER2(68)='68';
            {  0  LETTER2(69)='69';LETTER2(70)='70';
            {  0  LETTER2(71)='71';LETTER2(72)='72';LETTER2(73)='73';LETTER2(74)='74';
            {  0  LETTER2(75)='75';LETTER2(76)='76';LETTER2(77)='77';LETTER2(78)='78';
            {  0  LETTER2(79)='79';LETTER2(80)='80';
            {  0  LETTER2(81)='81';LETTER2(82)='82';LETTER2(83)='83';LETTER2(84)='84';
            {  0  LETTER2(85)='85';LETTER2(86)='86';LETTER2(87)='87';LETTER2(88)='88';
            {  0  LETTER2(89)='89';LETTER2(90)='90';
            {  0  LETTER2(91)='91';LETTER2(92)='92';LETTER2(93)='93';LETTER2(94)='94';
            {  0  LETTER2(95)='95';LETTER2(96)='96';LETTER2(97)='97';LETTER2(98)='98';
            {  0  LETTER2(99)='99';LETTER2(100)=' 0';LETTER2(101)='  ';}
               0
               0  ;
               0
               0  REPLACE {$SCORE(#:#:#:#)} WITH {;
            {  0
            {  0  "Scoring macro:"
            {  0  "{P1}=bin index"
            {  0  "{P2}=scoring array storing quantity summed over primary histories"
            {  0  "{P3}=scoring array storing quantity**2 summed over primary histories"
            {  0  "{P4}=quantity to be scored (eg WEIGHT)"
            {  0
            {  0  "If the primary history number, NHSTRY, is the same as the history"
            {  0  "that last scored in this array, NHSTRY_LAST{P1}, then {P4} is added"
            {  0  "to a temporary array, SUM_TMP{P1}.  Otherwise, we add"
            {  0  "SUM_TMP{P1} to {P2}, SUM_TMP{P1}*SUM_TMP{P1} to {P3},"
            {  0  "set SUM_TMP{P1}={P4}, and set NHSTRY_LAST{P1}=NHSTRY."
            {  0  "This scoring method allows us to calculate uncorrelated value"
            {  0  "of {P3} which is then used to calculate the uncertainty"
            {  0  "in {P2}."
            {  0
            {  0  IF(NHSTRY_LAST({P1})=NHSTRY)["same primary history"
            {  0  SUM_TMP({P1})=SUM_TMP({P1})+{P4};
            {  0  ]
            {  0  ELSE[
            {  0  {P2}={P2}+SUM_TMP({P1});
            {  0  {P3}={P3}+SUM_TMP({P1})*SUM_TMP({P1});
            {  0  SUM_TMP({P1})={P4};
            {  0  NHSTRY_LAST({P1})=NHSTRY;
            {  0  ]
            {  0  }
               0
               0  REPLACE {$SCORE_COV(#:#:#:#:#:#:#:#)} WITH {;
            {  0
            {  0  "Scoring macro for ratio of 2 correlated quantities ({P7}/{P8}):"
            {  0  "{P1}=bin index"
            {  0  "{P2}=scoring array storing quantity1 summed over primary histories"
            {  0  "{P3}=scoring array storing quantity1**2 summed over primary histories"
            {  0  "{P4}=scoring array storing quantity2 summed over primary histories"
            {  0  "{P5}=scoring array storing quantity2**2 summed over primary histories"
            {  0  "{P6}=scoring array storing quantity1*quantity2 summed over prim. histories"
            {  0  "{P7}=quantity1 (eg WEIGHT*EI)"
            {  0  "{P8}=quantity2 (eg WEIGHT)"
            {  0
            {  0  "If the primary history number, NHSTRY, is the same as the history"
            {  0  "that last scored in this bin, NHSTRY_LAST{P1}, then"
            {  0  "SUM_TMP{P1}=SUM_TMP{P1}+{P7} and SUM_TMP2{P1}+{P8}."
            {  0  "Otherwise, we add SUM_TMP{P1} to {P2} and SUM_TMP{P1}*SUM_TMP{P1} to {P3};"
            {  0  "add SUM_TMP2{P1} to {P4} and SUM_TMP2{P1}*SUM_TMP2{P1} to {P5};"
            {  0  "add SUM_TMP{P1}*SUM_TMP2{P1} to {P6};"
            {  0  "set SUM_TMP{P1}={P7}; set SUM_TMP2{P1}={P8}; and set NHSTRY_LAST{P1}=NHSTRY."
            {  0
            {  0  IF(NHSTRY_LAST({P1})=NHSTRY)["same primary history"
            {  0  SUM_TMP({P1})=SUM_TMP({P1})+{P7};
            {  0  SUM_TMP2({P1})=SUM_TMP2({P1})+{P8};
            {  0  ]
            {  0  ELSE[
            {  0  {P2}={P2}+SUM_TMP({P1});
            {  0  {P3}={P3}+SUM_TMP({P1})*SUM_TMP({P1});
            {  0  {P4}={P4}+SUM_TMP2({P1});
            {  0  {P5}={P5}+SUM_TMP2({P1})*SUM_TMP2({P1});
            {  0  {P6}={P6}+SUM_TMP({P1})*SUM_TMP2({P1});
            {  0  SUM_TMP({P1})={P7};
            {  0  SUM_TMP2({P1})={P8};
            {  0  NHSTRY_LAST({P1})=NHSTRY;
            {  0  ]
            {  0  }
               0
               0  REPLACE {$ANALYZE(#:#:#)} WITH {;
            {  0
            {  0  "uncertainty analysis macro:"
            {  0  "{P1}=bin index"
            {  0  "{P2}=scoring array storing quantity summed over primary histories"
            {  0  "{P3}=scoring array storing quantity**2 summed over primary histories"
            {  0
            {  0  "Adds the remaining quantity in SUM_TMP({P1}) to {P2} and"
            {  0  "SUM_TMP({P1})*SUM_TMP({P1}) to {P3} and then performs"
            {  0  "statistical analysis for uncertainty.  Absolute uncertainty ends up in"
            {  0  "{P3} and may still have to be normalized in main program.  Note"
            {  0  "that the quantity {P2} is normalized by NINC in this macro."
            {  0
            {  0  {P2}={P2}+SUM_TMP({P1});
            {  0  {P3}={P3}+SUM_TMP({P1})*SUM_TMP({P1});
            {  0
            {  0  {P2}={P2}/NINC;
            {  0  {P3}={P3}/NINC;
            {  0  {P3}=({P3}-{P2}*{P2})/(NINC-1);
            {  0  IF({P3}>0.){P3}=SQRT({P3});
            {  0  {P3}=MIN({P3},0.9999D00*{P2});
            {  0
            {  0  }
               0
               0  REPLACE {$ANALYZE_COV(#:#:#:#:#:#)} WITH {;
            {  0
            {  0  "uncertainty analysis macro for ratio of correlated quantities"
            {  0  "(quantity1/quantity2):"
            {  0  "{P1}=bin index"
            {  0  "{P2}=scoring array storing quantity1 summed over primary histories"
            {  0  "{P3}=scoring array storing quantity1**2 summed over primary histories"
            {  0  "{P4}=scoring array storing quantity2 summed over primary histories"
            {  0  "{P5}=scoring array storing quantity2**2 summed over primary histories"
            {  0  "{P6}=scoring array storing quantity1*quantity2 summed over prim. histories"
            {  0
            {  0  "Adds the remaining quantity in SUM_TMP({P1}) to {P2} and"
            {  0  "SUM_TMP({P1})*SUM_TMP({P1}) to {P3}.  Adds remaining quantity in"
            {  0  "SUM_TMP2({P1}) to {P4} and SUM_TMP2({P1})*SUM_TMP2({P1}) to {P5}.  And"
            {  0  "adds remaining SUM_TMP({P1})*SUM_TMP2({P1}) to {P6}.  The macro then performs"
            {  0  "statistical analysis for uncertainty.  Fractional uncertainty ends up in"
            {  0  "{P3}.  Note that the"
            {  0  "quantities {P2} and {P4} are normalized by NINC in this macro."
            {  0  "Also note that the covariance term is not used for bins that"
            {  0  "have fewer than 10 particles in them (this is consistent with BEAM)."
            {  0
            {  0  {P2}={P2}+SUM_TMP({P1});
            {  0  {P3}={P3}+SUM_TMP({P1})*SUM_TMP({P1});
            {  0  {P4}={P4}+SUM_TMP2({P1});
            {  0  {P5}={P5}+SUM_TMP2({P1})*SUM_TMP2({P1});
            {  0  {P6}={P6}+SUM_TMP({P1})*SUM_TMP2({P1});
            {  0
            {  0  "get relative uncertainty on {P2}"
            {  0  {P2}={P2}/NINC;
            {  0  {P3}={P3}/NINC;
            {  0  {P3}=({P3}-{P2}*{P2})/(NINC-1);
            {  0  IF({P3}>0.){P3}=SQRT({P3});
            {  0  {P3}=MIN(0.9999D00,{P3}/{P2});
            {  0
            {  0  "get relative uncertainty on {P4}"
            {  0  {P4}={P4}/NINC;
            {  0  {P5}={P5}/NINC;
            {  0  {P5}=({P5}-{P4}*{P4})/(NINC-1);
            {  0  IF({P5}>0.){P5}=SQRT({P5});
            {  0  {P5}=MIN(0.9999D00,{P5}/{P4});
            {  0
            {  0  IF(JUSTONE({P1})<10)["fewer than 10 particles in bin"
            {  0  {P6}=0.;
            {  0  ]
            {  0  ELSE[
            {  0  {P6}={P6}/NINC-{P2}*{P4};
            {  0  {P6}={P6}/({P2}*{P4}*(NINC-1));
            {  0  ]
            {  0
            {  0  {P3}={P3}**2+{P5}**2-2*{P6};
            {  0  IF({P3}>0.){P3}=SQRT({P3});
            {  0  {P3}=MIN(0.9999D00,{P3});
            {  0
            {  0  }
               0
               0
               0
               0  "**VARIABLES**"
               0  "---Force declarations of all variables---"
               0  IMPLICIT NONE;
               0
               0  COMIN/CHARACTERS;
               0  COMIN/DOUBLES;
               0  COMIN/REALS;
               0  COMIN/INTEGERS;
               0  COMIN/LOGICALS;
               0  COMIN/RWPHSP/;
               0
               0  INTEGER lnblnk1;
               0
               0  ASSIGN-LETTERS;
               0
               0  $INIT_PHSP_COUNTERS;
               0
               0  "-----------------------------------------------------------------------------
               0
               0  "**Checks to see if user is EGS_PERT, and sets logical variable to choose
               0  "**appropriate prompts.
               0
               0  EGSPERT = .false.; "Turn on wordy prompts for first-time users"
               0  "EGSPERT=system('exit $?EGS_PERT'); "
               0
               0  "-------------------------------------------------------------------------------
               0
               0  "**Print out a header page for non-experts
               0
               0  OUTPUT;(
               0  //
               0  ' Running BEAMDP, Version v 1.9'/
               0  ' -----------------------------------------------------------'/
               0  ' Type ? at any prompt for help                              ');
               0
               0  IF ~EGSPERT[
               1      CALL HELP_MESSAGE(0);
               1      OUTPUT ;(
               1      ' Do you wish more detailed information about the file created '/
               1      ' by the program?   (y/n[Default])=> ',$);
               1      INPUT C1; (A1);
               1      ]
               0
               0  IF (~EGSPERT)[
               1      IF ((C1='y')|(C1='Y')|( C1='?'))[
               2          CALL HELP_MESSAGE(1); ]
               1      ELSE[
               2          EGSPERT = .true.; "Turn off wordy prompts for first-time users"
               2          ]
               1      ]
               0
               0  :CHOICE1:  ;
               0  OUTPUT;(/' Input a number for the operation required: ');
               0  OUTPUT;(' ********************************************'/);
               0  OUTPUT;(' (0) - Process data for beam characterization models');
               0  OUTPUT;(' (1) - Derive fluence vs position from ph-sp data');
               0  OUTPUT;(' (2) - Derive energy fluence vs position from ph-sp data');
               0  OUTPUT;(' (3) - Derive spectral distribution from ph-sp data');
               0  OUTPUT;(' (4) - Derive energy fluence distribution from ph-sp data');
               0  OUTPUT;(' (5) - Derive mean energy distribution from ph-sp data');
               0  OUTPUT;(' (6) - Derive angular distribution from ph-sp data');
               0  OUTPUT;(' (7) - Derive ZLAST distribution from ph-sp data');
               0  OUTPUT;(' (8) - Derive distribution of particle weights from ph-sp data');
               0  OUTPUT;(' (9) - Derive X-Y scatter plot of particles from ph-sp data');
               0  OUTPUT;(' (10) - Combine two ph-sp files into one');
               0  OUTPUT;(' (11) - List parameters for a number of ph-sp particles ');
               0  OUTPUT;(' (12) - Output (x,y,z) coordinates to file (IAEA only)');
               0  OUTPUT;(' (13) - Quit');
               0  OUTPUT;(' ',$);
               0
               0  INPUT C2,ITYPE;(A2,I8);IF(ITYPE=0)[ITYPE=1;]ELSE[ITYPE=0;]
               0  IF (C2='? ') [ C1='?'; CALL HELP_MESSAGE(1); GOTO :CHOICE1:;]
               0  READ(C2,'(I8)')CHOICE1 ;
               0  OUTPUT CHOICE1;('Selected option', I4);
               0
               0  IF(CHOICE1 = 13) GOTO :STOP-FOR-GOOD1:;
               0  IF(CHOICE1>13)|(CHOICE1<0)[
               1      OUTPUT;(//' SORRY, NO SUCH OPTIONS!'/);
               1      CALL HELP_MESSAGE(1);
               1      GOTO :CHOICE1:;
               1      ]
               0  IF(CHOICE1 = 0) [
               1      CALL BEAMDP1;
               1      GOTO :STOP-FOR-GOOD1:;
               1      ]
               0
               0  MSTART=0;"mark a fresh start"
               0  :START-INPUTS-FOR-AN-OPTION:;
               0
               0  " Derive fluence vs position from ph-sp data "
               0  " Derive energy fluence vs position from ph-sp data "
               0  " Derive mean energy distribution from ph-sp data "
               0  " ----------------------------------------------- "
               0  IF(CHOICE1=1)|(CHOICE1=2)|(CHOICE1=5)[
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(2); ]
               1      :IA12:
               1      OUTPUT;(/' FIELD TYPE (0-circular ring, 1-square ring, 2-rectangular): '
               1      /' ',$);
               1      READ(5,'(I15)',ERR=:IA11:) MSMFXY ;
               1      GOTO :IA13:;
               1      :IA11:
               1      CALL HELP_MESSAGE(2);
               1      GOTO :IA12:;
               1      :IA13:;
               1      IF ((MSMFXY<0)|(MSMFXY>2)) [
               2          OUTPUT;(/' SORRY, NO SUCH FIELD TYPE!!!'//);
               2          GO TO :IA11:;
               2          ]
               1
               1      IF (MSMFXY = 0)[" circular field"
               2          IF ~EGSPERT[ CALL HELP_MESSAGE(3); ]
               2          :MA2:  ;
               2          ;OUTPUT;
               2          (/' Nbin,IQ(-1,0,1,2,3),RFIELD'/' ',$);
               2
               2          READ(5,'(2I12,F15.0)',ERR=:MA1:)
               2          NFIELD,IQSMFP(1),RFIELD;
               2          GOTO :MA3:;
               2          :MA1:
               2          CALL HELP_MESSAGE(3);
               2          GOTO :MA2:;
               2          :MA3:
               2          IF (IQSMFP(1)< -1)|(IQSMFP(1)>3)|(NFIELD<0)|(NFIELD > $NB)|(RFIELD<0.)[
               3              OUTPUT;(//' SORRY, RFIELD SHOULD BE > 0.0'/
               3              '        NFIELD SHOULD BE BETWEEN 1 AND $NB');
               3              OUTPUT; ( ' AND    IQ SHOULD BE -1, 0, 1, 2 OR 3!'//);
               3              GO TO :MA1:;
               3              ]
               2          IF (NFIELD=0)[ NFIELD=40; OUTPUT;(//' Nbin DEFAULTS TO 40'/); ]
               2          IF (RFIELD=0.)[ RFIELD=15.; OUTPUT;(//' RFIELD DEFAULTS TO 15.0'/); ]
               2          IF (IQSMFP(1)=0)[ OUTPUT;(/' IQ = 0 (ONLY SCORE FOR PHOTONS)'); ]
               2          ]
               1
               1      ELSEIF (MSMFXY = 1)[" square field"
               2          IF ~EGSPERT[ CALL HELP_MESSAGE(4); ]
               2          :MA13:
               2          ;OUTPUT;
               2          (/' Nbin,IQ(-1,0,1,2,3),HALF-WIDTH'/' ',$);
               2
               2          READ(5,'(2I12,F15.0)',ERR=:MA12:) NFIELD,IQSMFP(1),RFIELD;
               2          GOTO :MA14:;
               2          :MA12:
               2          CALL HELP_MESSAGE(4);
               2          GOTO :MA13:;
               2          :MA14:
               2          IF (IQSMFP(1)<-1)|(IQSMFP(1)>3)|(NFIELD<0)|(NFIELD>$NB)|(RFIELD<0.)[
               3              OUTPUT;(//' SORRY, RFIELD SHOULD BE > 0.0'/
               3              '        NFIELD SHOULD BE BETWEEN 1 AND $NB');
               3              OUTPUT;
               3              (         ' AND    IQ SHOULD BE -1, 0, 1, 2 OR 3!'//);
               3              GO TO :MA12:;
               3              ]
               2          IF (NFIELD=0.)[NFIELD=40;OUTPUT;(/' Nbin defaults to 40'/);]
               2          IF (RFIELD=0.)[
               3              RFIELD=15.;
               3              OUTPUT;(/' HALF-WIDTH DEFAULTS TO 15.0'/);
               3              ]
               2          IF (IQSMFP(1)=0)[
               3              OUTPUT;(/' IQ = 0 (ONLY SCORE FOR PHOTONS)');
               3              ]
               2          ]
               1
               1      ELSEIF (MSMFXY = 2)[" rectangular field"
               2          IF ~EGSPERT[ CALL HELP_MESSAGE(5); ]
               2          :MA124:
               2          ;OUTPUT;
               2          (/' Nbin,Orient(0:along x,1: y),IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax'/
               2          ' ',$);
               2          READ(5,:FORMAT-CHOICE1:,ERR=:MA123:)
               2          NFIELD,ISMFPS(1),IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               2          :FORMAT-CHOICE1: FORMAT(3I12,4F15.0);
               2          OUTPUT NFIELD,ISMFPS(1),IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               2          (I5, I3,I4,4F10.4);
               2          GOTO :MA125:;
               2          :MA123:
               2          CALL HELP_MESSAGE(5);
               2          GOTO :MA124:;
               2          :MA125:
               2          IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&
               2          (SMFMXY(1)=0.)[
               3              OUTPUT;(/' Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
               3              SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
               3              ]
               2          IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
               2          (IQSMFP(1)>3)|(NFIELD<1)|(NFIELD>$NB)|(ISMFPS(1)<0)|(ISMFPS(1)>1)[
               3              OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,'/
               3              '        NFIELD SHOULD BE BETWEEN 1 AND $NB'/
               3              '                         Ymin < Ymax,'/
               3              '        Orientation    = 0  or   1');
               3              OUTPUT;
               3              (         ' AND    IQ SHOULD BE -1, 0, 1, 2 OR 3!'//);
               3              GO TO :MA123:;
               3              ]
               2          ]"end of field type inputs"
               1      ]
               0
               0  " Derive spectral distribution from ph-sp data "
               0  " Derive energy fluence distribution from ph-sp data "
               0  " -------------------------------------------------- "
               0  ELSEIF(CHOICE1 = 3 | CHOICE1 = 4)[
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(6); ]
               1      :JA124:
               1      ;OUTPUT;(/' IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax(or Rmin,Rmax)'/' ',$);
               1      READ(5,'(I12,4F15.0)',ERR=:JA123:)
               1      IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               1      OUTPUT IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1); (I4,4F10.4);
               1      GOTO :JA125:;
               1      :JA123:
               1      CALL HELP_MESSAGE(6);
               1      GOTO :JA124:;
               1      :JA125:
               1      IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
               1      (IQSMFP(1)>3)[
               2          OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,' /
               2          '                         Ymin < Ymax,');
               2          OUTPUT;
               2          (         ' AND    IQ SHOULD BE -1, 0, 1, OR 2!'//);
               2          GO TO :JA123:;
               2          ]
               1      IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&(SMFMXY(1)=0.)[
               2          OUTPUT;
               2          (/' Rectangular region: Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
               2          SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
               2          FLUAREA=(SMFMXX(1)-SMFMNX(1))*(SMFMXY(1)-SMFMNY(1));
               2          MSMFXY=1;
               2          ]
               1      ELSEIF (SMFMNY(1)=0.)&(SMFMXY(1)=0.)["suppose for an annular"
               2          IF(SMFMNX(1)<0.)[SMFMNX(1)=0.;OUTPUT;(/' Rmin defaults to 0.');]
               2          IF(SMFMXX(1)<=0.)[SMFMXX(1)=15.;OUTPUT;(/' Rmax defaults to 15.');]
               2          OUTPUT SMFMNX(1),SMFMXX(1);
               2          (/' Annular region: Rmin,Rmax=',2F10.3);
               2          FLUAREA=3.1415927*(SMFMXX(1)**2-SMFMNX(1)**2);
               2          MSMFXY=0;
               2          ]
               1      ELSE[
               2          OUTPUT SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               2          (/' Rectangular region: Xmin,Xmax,Ymin,Ymax =',4F10.3);
               2          FLUAREA=(SMFMXX(1)-SMFMNX(1))*(SMFMXY(1)-SMFMNY(1));
               2          MSMFXY=1;
               2          ]
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(7); ]
               1      :H2:
               1      OUTPUT;
               1      (/' Nbin, Emin, Emax (in MeV, kinetic only) for the distribution ='/' ',$);
               1      READ(5,'(I15,2F15.0)',ERR=:H1:) NSMFEE,SMFMNE,SMFMXE;
               1      OUTPUT NSMFEE,SMFMNE,SMFMXE; (I6,2F12.4);
               1      GOTO :H3:;
               1      :H1:
               1      CALL HELP_MESSAGE(7);
               1      GOTO :H2:;
               1      :H3:
               1      IF ((SMFMNE<0.0)|(SMFMNE>SMFMXE)|(SMFMXE<0.0)|(NSMFEE>$NB)|(NSMFEE<1))[
               2          OUTPUT $NB;(/' SORRY, ENERGIES SHOULD BE Emax > Emin > 0.0 '/
               2          '    AND BIN NUMBER MUST BE BETWEEN 1 AND ',I4,'!!!'//);
               2          GO TO :H1:;
               2          ]
               1      ]
               0
               0  " Derive angular distribution from ph-sp data "
               0  " ------------------------------------------- "
               0  ELSEIF(CHOICE1 = 6)[
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(8); ]
               1      :JA13:
               1      ;OUTPUT;(/' IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax(or Rmin,Rmax)'/' ',$);
               1      READ(5,'(I12,4F15.0)',ERR=:JA12:)
               1      IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               1      OUTPUT IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);(I4,4F10.4);
               1      GOTO :JA14:;
               1      :JA12:
               1      CALL HELP_MESSAGE(8);
               1      GOTO :JA13:;
               1      :JA14:
               1      IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
               1      (IQSMFP(1)>3)[
               2          OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,' /
               2          '                         Ymin < Ymax,');
               2          OUTPUT;
               2          (         ' AND    IQ SHOULD BE -1, 0, 1, OR 2!'//);
               2          GO TO :JA12:;
               2          ]
               1      IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&(SMFMXY(1)=0.)[
               2          OUTPUT;
               2          (/' Rectangular region: Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
               2          SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
               2          MSMFXY=1;
               2          ]
               1      IF (SMFMNY(1)=0.)&(SMFMXY(1)=0.)["suppose for an annular"
               2          IF(SMFMNX(1)<0.)[SMFMNX(1)=0.;OUTPUT;(/' Rmin defaultS to 0.');]
               2          IF(SMFMXX(1)<=0.)[SMFMXX(1)=15.;OUTPUT;(/' RmAX defaultS to 15.');]
               2          OUTPUT SMFMNX(1),SMFMXX(1);
               2          (/' Annular region: Rmin,Rmax=',2F8.3);
               2          MSMFXY=0;
               2          ]
               1      ELSE[
               2          OUTPUT SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               2          (/' Rectangular region: Xmin,Xmax,Ymin,Ymax =',4F8.3);
               2          MSMFXY=1;
               2          ]
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(9); ]
               1      :H13:
               1      OUTPUT;
               1      (/' Nbin, Amin, Amax (in degree) for the distribution ='/' ',$);
               1      READ(5,'(I15,2F15.0)',ERR=:H12:)
               1      NSMFEE,SMFMNE,SMFMXE;
               1      GOTO :H14:;
               1      :H12:
               1      CALL HELP_MESSAGE(9);
               1      GOTO :H13:;
               1      :H14:
               1      IF ((SMFMNE<0.0)|(SMFMNE>SMFMXE)|(SMFMXE>180.)|(NSMFEE>$NBINANGLE)|
               1      (NSMFEE<0))[
               2          OUTPUT;(/' SORRY, ANGLE SHOULD BE 180 > Amax > Amin > 0.0 '/
               2          '    AND BIN NUMBER MUST BE BETWEEN 1 AND ',I4,'!!!'//);
               2          GO TO :H12:;
               2          ]
               1      IF ((SMFMNE=0.0)&(SMFMXE=0.))|(NSMFEE=0)[
               2          NSMFEE=$NBINANGLE;SMFMNE=0.;SMFMXE=90.;
               2          OUTPUT$NBINANGLE;(/' Nbin, Amin, Amax default to ',I2,', 0., 90. ');
               2          ]
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(52); ]
               1      :H16:
               1      OUTPUT;
               1      (/' Emin, Emax (in MeV, kinetic only) FOR THE ANGULAR DISTRIBUTION ='/' ',$);
               1      READ(5,'(2F15.0)',ERR=:H15:)
               1      SMFMNZ(1),SMFMXZ(1);
               1      GOTO :H17:;
               1      :H15:
               1      CALL HELP_MESSAGE(52);
               1      GOTO :H16:;
               1      :H17:
               1      IF ((SMFMNZ(1)<0.0)|(SMFMNZ(1)>SMFMXZ(1))|(SMFMXZ(1)<0.0))[
               2          OUTPUT ;(/' SORRY, ENERGIES SHOULD BE Emax > Emin > 0.0 '//);
               2          GO TO :H15:;
               2          ]
               1      IF(SMFMNZ(1)=0.0 & SMFMXZ(1)=0.0)[
               2          SMFMNZ(1)=0.0;SMFMXZ(1)=999.0;
               2          OUTPUT;(/' Emin, Emax default to 0 MeV, 999 MeV. ');
               2          ]
               1      ]
               0
               0  " Derive ZLAST distribution from ph-sp data "
               0  " ----------------------------------------- "
               0  ELSEIF(CHOICE1 = 7)[
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(10); ]
               1      :JB13:
               1      ;OUTPUT;(/' IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax(or Rmin,Rmax)'/' ',$);
               1      READ(5,'(I12,4F15.0)',ERR=:JB12:)
               1      IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               1      GOTO :JB14:;
               1      :JB12:
               1      CALL HELP_MESSAGE(10);
               1      GOTO :JB13:;
               1      :JB14:
               1      IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
               1      (IQSMFP(1)>3)[
               2          OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,' /
               2          '                         Ymin < Ymax,');
               2          OUTPUT;
               2          (         ' AND    IQ SHOULD BE -1, 0, 1, OR 2!'//);
               2          GO TO :JB12:;
               2          ]
               1      IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&(SMFMXY(1)=0.)[
               2          OUTPUT;
               2          (/' Rectangular region: Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
               2          SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
               2          MSMFXY=1;
               2          ]
               1      IF (SMFMNY(1)=0.)&(SMFMXY(1)=0.)["suppose for an annular"
               2          IF(SMFMNX(1)<0.)[SMFMNX(1)=0.;OUTPUT;(/' Rmin defaultS to 0.');]
               2          IF(SMFMXX(1)<=0.)[SMFMXX(1)=15.;OUTPUT;(/' RmAX defaultS to 15.');]
               2          OUTPUT SMFMNX(1),SMFMXX(1);
               2          (/' Annular region: Rmin,Rmax=',2F8.3);
               2          MSMFXY=0;
               2          ]
               1      ELSE[
               2          OUTPUT SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               2          (/' Rectangular region: Xmin,Xmax,Ymin,Ymax =',4F8.3);
               2          MSMFXY=1;
               2          ]
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(11); ]
               1      :HB13:
               1      OUTPUT;
               1      (/' Nbin, Zmin, Zmax (in cm) for the distribution ='/' ',$);
               1      READ(5,'(I15,2F15.0)',ERR=:HB12:)
               1      NSMFEE,SMFMNE,SMFMXE;
               1      GOTO :HB14:;
               1      :HB12:
               1      CALL HELP_MESSAGE(11);
               1      GOTO :HB13:;
               1      :HB14:
               1      IF ((SMFMNE>SMFMXE)|(NSMFEE>$NBINANGLE)|
               1      (NSMFEE<0))[
               2          OUTPUT;(/' SORRY, ZLAST SHOULD BE BETWEEN Zmin AND Zmax '/
               2          '    AND BIN NUMBER MUST BE BETWEEN 1 AND ',I4,'!!!'//);
               2          GO TO :HB12:;
               2          ]
               1      IF ((SMFMNE=0.0)&(SMFMXE=0.))|(NSMFEE=0)[
               2          NSMFEE=$NBINANGLE;SMFMNE=0.;SMFMXE=100.;
               2          OUTPUT$NBINANGLE;(/' Nbin, Zmin, Zmax default to ',I2,', 0., 100. ');
               2          ]
               1      ]
               0
               0  " Derive distribution of particle weights from ph-sp data "
               0  " ------------------------------------------------------- "
               0  ELSEIF(CHOICE1 = 8)[
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(12); ]
               1      :JA127:
               1      ;OUTPUT;(/' IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax(or Rmin,Rmax)'/' ',$);
               1      READ(5,'(I12,4F15.0)',ERR=:JA126:)
               1      IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               1      GOTO :JA128:;
               1      :JA126:
               1      CALL HELP_MESSAGE(12);
               1      GOTO :JA127:;
               1      :JA128:
               1      IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
               1      (IQSMFP(1)>3)[
               2          OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,'/
               2          '                         Ymin < Ymax,');
               2          OUTPUT;
               2          (         ' AND    IQ SHOULD BE -1, 0, 1, OR 2!'//);
               2          GO TO :JA126:;
               2          ]
               1      IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&(SMFMXY(1)=0.)[
               2          OUTPUT;
               2          (/' Rectangular region: Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
               2          SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
               2          MSMFXY=1;
               2          ]
               1      ELSEIF (SMFMNY(1)=0.)&(SMFMXY(1)=0.)["suppose for an annular"
               2          IF(SMFMNX(1)<0.)[SMFMNX(1)=0.;OUTPUT;(/' Rmin defaults to 0.');]
               2          IF(SMFMXX(1)<=0.)[SMFMXX(1)=15.;OUTPUT;(/' Rmax defaults to 15.');]
               2          OUTPUT SMFMNX(1),SMFMXX(1);
               2          (/' Annular region: Rmin,Rmax=',2F10.3);
               2          MSMFXY=0;
               2          ]
               1      ELSE[
               2          OUTPUT SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               2          (/' Rectangular region: Xmin,Xmax,Ymin,Ymax =',4F10.3);
               2          MSMFXY=1;
               2          ]
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(13); ]
               1      :H5:
               1      OUTPUT;
               1      (/' Nbin, MIN WEIGHT, MAX WEIGHT FOR THE DISTRIBUTION ='/' ',$);
               1      READ(5,'(I15,2F15.0)',ERR=:H4:)
               1      NSMFEE,SMFMNE,SMFMXE;
               1      GOTO :H6:;
               1      :H4:
               1      CALL HELP_MESSAGE(13);
               1      GOTO :H5:;
               1      :H6:
               1      IF ((SMFMNE<=0)|(SMFMNE>SMFMXE)|(NSMFEE>$NB)|(NSMFEE<1))[
               2          OUTPUT $NB;(/' SORRY, MIN WEIGHT MUST BE > 0 '/
               2          ' WITH MAX WEIGHT > MIN WEIGHT '/
               2          ' AND BIN NUMBER MUST BE BETWEEN 1 AND ',I4,'!!!'//);
               2          GO TO :H4:;
               2          ]
               1      ]
               0
               0  " Derive X-Y scatter plot of particles from ph-sp data "
               0  " ---------------------------------------------------- "
               0  ELSEIF(CHOICE1 = 9)[
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(14); ]
               1      :JA130:
               1      ;OUTPUT;(/' IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax(or Rmin,Rmax)'/' ',$);
               1      READ(5,'(I12,4F15.0)',ERR=:JA129:)
               1      IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               1      GOTO :JA131:;
               1      :JA129:
               1      CALL HELP_MESSAGE(14);
               1      GOTO :JA130:;
               1      :JA131:
               1      IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
               1      (IQSMFP(1)>3)[
               2          OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,' /
               2          '                         Ymin < Ymax,');
               2          OUTPUT;
               2          (         ' AND    IQ SHOULD BE -1, 0, 1, OR 2!'//);
               2          GO TO :JA129:;
               2          ]
               1      IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&(SMFMXY(1)=0.)[
               2          OUTPUT;
               2          (/' Rectangular region: Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
               2          SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
               2          MSMFXY=1;
               2          ]
               1      ELSEIF (SMFMNY(1)=0.)&(SMFMXY(1)=0.)["suppose for an annular"
               2          IF(SMFMNX(1)<0.)[SMFMNX(1)=0.;OUTPUT;(/' Rmin defaults to 0.');]
               2          IF(SMFMXX(1)<=0.)[SMFMXX(1)=15.;OUTPUT;(/' Rmax defaults to 15.');]
               2          OUTPUT SMFMNX(1),SMFMXX(1);
               2          (/' Annular region: Rmin,Rmax=',2F10.3);
               2          MSMFXY=0;
               2          ]
               1      ELSE[
               2          OUTPUT SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
               2          (/' Rectangular region: Xmin,Xmax,Ymin,Ymax =',4F10.3);
               2          MSMFXY=1;
               2          ]
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(15); ]
               1      :H21:
               1      OUTPUT;
               1      (/' Emin, Emax (in MeV, kinetic only) FOR THE SCATTER PLOT ='/' ',$);
               1      READ(5,'(2F15.0)',ERR=:H20:)
               1      SMFMNE,SMFMXE;
               1      GOTO :H22:;
               1      :H20:
               1      CALL HELP_MESSAGE(15);
               1      GOTO :H21:;
               1      :H22:
               1      IF ((SMFMNE<0.0)|(SMFMNE>SMFMXE)|(SMFMXE<0.0))[
               2          OUTPUT $NB;(/' SORRY, ENERGIES SHOULD BE Emax > Emin > 0.0 '//);
               2          GO TO :H20:;
               2          ]
               1      ]
               0
               0  " CHOICE1 = 1-8 case "
               0  " ------------------ "
               0  IF(CHOICE1>0)&(CHOICE1<10)[
               1
               1      IF ~EGSPERT[ "inputs for LATCH"
               2          CALL HELP_MESSAGE(16);
               2          CALL HELP_MESSAGE(17);
               2          CALL HELP_MESSAGE(18); ]
               1      :LA21:;
               1      OUTPUT;
               1      (/' Input three integer variables on one line: I_IN_EX, Nbit1,Nbit2'/
               1      ' I_IN_EX (0-incl/excl bits, 1-excl bits, 2-incl regions, 3-excl regions),'/
               1      ' Nbit1   (# bits or regions to incl (if I_IN_EX=0 or 2) or excl ',
               1      '(I_IN_EX=1 or 3),'/
               1      ' Nbit2   (# bits to excl (I_IN_EX=0 only)--all on one line :'/
               1      ' ',$);
               1      READ(5,'(3I8)',ERR=:LA20:)I_IN_EX,NBIT1,NBIT2;
               1      OUTPUT I_IN_EX,NBIT1,NBIT2; (3I6);
               1      GOTO :LA22:;
               1      :LA20:
               1      CALL HELP_MESSAGE(16);
               1      CALL HELP_MESSAGE(17);
               1      GOTO :LA21:;
               1      :LA22:
               1      IF(I_IN_EX < 0 | I_IN_EX > 3)[
               2          OUTPUT;(//' I_IN_EX OUT OF RANGE.  TRY AGAIN.');
               2          CALL HELP_MESSAGE(16);
               2          GO TO :LA21:;
               2          ]
               1
               1      IF(I_IN_EX~=0 & NBIT2 ~= 0)[
               2          OUTPUT;(//' ***WARNING: Nbit2 is not 0 and you are using'/
               2          ' I_IN_EX=1, 2 or 3.  Nbit2 set to 0 here.'//);
               2          NBIT2=0;
               2          ]
               1
               1      IF (NBIT1<0)[
               2          OUTPUT;(//' SORRY, YOU SHOULD INPUT Nbit1 >= 0');
               2          CALL HELP_MESSAGE(17);
               2          GO TO :LA21:;
               2          ]
               1      IF(NBIT2<0)[
               2          OUTPUT;(//' SORRY, YOU SHOULD INPUT Nbit2 >= 0');
               2          CALL HELP_MESSAGE(17);
               2          GO TO :LA21:;
               2          ]
               1
               1      IF (I_IN_EX < 2 & (NBIT1+NBIT2<0|NBIT1+NBIT2>29))[
               2          OUTPUT;(//' SORRY, YOU SHOULD INPUT 0 <= total # of bits <= 29');
               2          CALL HELP_MESSAGE(16);
               2          CALL HELP_MESSAGE(17);
               2          GO TO :LA21:;
               2          ]
               1      ELSEIF(NBIT1<0|NBIT1>24)[
               2          OUTPUT;(//' SORRY, YOU SHOULD INPUT 0 <= total # of regions <= 24');
               2          CALL HELP_MESSAGE(16);
               2          CALL HELP_MESSAGE(17);
               2          GO TO :LA21:;
               2          ]
               1
               1      IF(NBIT1 ~= 0)[
               2          :LA23:;
               2          IF(I_IN_EX=0|I_IN_EX=2)[
               3              OUTPUT; (/' BIT(I)/IREGION_TO_BIT(I) (I=1,Nbit1) to include:'/' ',$);
               3              ]
               2          IF(I_IN_EX=1|I_IN_EX=3)[
               3              OUTPUT; (/' BIT(I)/IREGION_TO_BIT(I) (I=1,Nbit1) to exclude:'/' ',$);
               3              ]
               2          READ(5,'(29I8)',ERR=:LA24:)(LATCH(I),I=1,NBIT1);
               2          GOTO :LA25:;
               2          :LA24:
               2          CALL HELP_MESSAGE(18);
               2          GOTO :LA23:;
               2          :LA25:
               2          DO I=1,NBIT1[
               3              IF (I_IN_EX < 2 & (LATCH(I)<0|LATCH(I)>28))[
               4                  OUTPUT;(//' SORRY, YOU SHOULD INPUT 0 <= BIT(I) <= 28');
               4                  CALL HELP_MESSAGE(18);GOTO :LA23:;
               4                  ]
               3              ELSEIF(I_IN_EX >= 2 & (LATCH(I)<0|LATCH(I)>23))[
               4                  OUTPUT;(//' SORRY, YOU SHOULD INPUT 0 <= IREGION_TO_BIT(I) <= 23');
               4                  CALL HELP_MESSAGE(18);GOTO :LA23:;
               4                  ]
               3              ]
               2          ]
               1      IF(NBIT2 ~= 0)[
               2          :LA26:
               2          OUTPUT;
               2          (/' BIT(I)/IREGION_TO_BIT(I) (I=Nbit1+1,Nbit1+Nbit2) to exclude:'/' ',$);
               2          READ(5,'(29I8)',ERR=:LA27:)(LATCH(NBIT1+I),I=1,NBIT2);
               2          GOTO :LA28:;
               2          :LA27:
               2          CALL HELP_MESSAGE(18);
               2          GOTO :LA26:;
               2          :LA28:
               2          DO I=1,NBIT2[
               3              IF (LATCH(NBIT1+I)<0 | LATCH(NBIT1+I)>28)[
               4                  OUTPUT;(//' SORRY, YOU SHOULD INPUT 0 <= BIT(I) <= 28');
               4                  CALL HELP_MESSAGE(18);GOTO :LA26:;
               4                  ]
               3              ]
               2          ]
               1      ]
               0
               0  " List parameters for a number of ph-sp particles "
               0  " ----------------------------------------------- "
               0  IF(CHOICE1=11)[
               1
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(19); ]
               1      :LB2:
               1      OUTPUT;
               1      (/' From particle no. (default=1), to particle no. (default=100),'
               1      ' IQ(-1,0,1,2,3) =?'/' ',$);
               1      READ(5,'(3I12)',ERR=:LB1:)NUMBERST,NUMBERP,IQSMFP(1);
               1      GOTO :LB3:;
               1      :LB1:
               1      CALL HELP_MESSAGE(19);
               1      GOTO :LB2:;
               1      :LB3:
               1      IF (NUMBERST<1)[
               2          NUMBERST=1;
               2          OUTPUT;(/' First particle no. defaults to 1!');
               2          ]
               1      IF (NUMBERP<1)[
               2          NUMBERP=100;
               2          OUTPUT;(/' Last particle no. defaults to 100!');
               2          ]
               1      IF(IQSMFP(1)<-1)|(IQSMFP(1)>3)[
               2          IQSMFP(1)=2;"defaults to all the particles"
               2          OUTPUT;(/' IQ defaults to 2 (all the particles)!');
               2          ]
               1      ELSEIF(IQSMFP(1)=0)[ OUTPUT;(/' IQ = 0 (only for photons)'); ]
               1      ]
               0
               0  " Output 3D points to a file for plotting"
               0  IF(CHOICE1=12)[
               1
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(84); ]
               1      :LB4:
               1      OUTPUT;(/' min. MU, max. MU, no. of particles to plot '/
               1      ' (defaults are 0, 1, and all particles in the range): ',$);
               1      READ(5,*) mumin,mumax,NUMBERP;
               1      IF(mumin<0)mumin=0.0;
               1      IF(mumax<mumin|mumax=0)mumax=1.0;
               1      OUTPUT mumin,mumax;
               1      (/' Will output (X,Y,Z) over MU range ',F8.3,' to ',F8.3);
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1      IF(NUMBERP<=0)[
               2          OUTPUT;(' Will output all particles in the range.'/);
               2          ]
               1      ELSE[
               2          OUTPUT NUMBERP; (' Will output ',I5,' particles. '/);
               2          ]
               1      ]
               0
               0  " Open phase space file and read it "
               0  " --------------------------------- "
               0  IF(MSTART=0 & ((CHOICE1>0 & CHOICE1<10)|CHOICE1=11|CHOICE1=12))[
               1      CALL READNAME;
               1      CALL OPENFILE;
               1      ]
               0
               0  " List parameters for a number of ph-sp particles "
               0  " ----------------------------------------------- "
               0  IF(MSTART=0 & CHOICE1=11)[
               1      IF(MODE_RW='MODE0')[
               2          WRITE(6,:LIST-FORMAT0:);
               2          :LIST-FORMAT0: FORMAT(/' ENERGY  IQ     X',
               2          5X, '  Y',4X,'  U',4X,'  V',4X,'  W',4X,'WEIGHT',6X,
               2          ' LATCH (set=1, not set=0)'/);
               2          ]
               1      ELSEIF(MODE_RW='MODE2')[
               2          WRITE(6,:LIST-FORMAT01:);
               2          :LIST-FORMAT01: FORMAT(/' ENERGY  IQ     X',
               2          5X, '  Y',4X,'  U',4X,'  V',4X,'  W',4X,' ZLAST   WEIGHT',6X,
               2          ' LATCH (set=1, not set=0)'/);
               2          ]
               1      CALL READ_DATA;"to read the ph-sp file"
               1      ]
               0
               0  IF(MSTART=0 & CHOICE1=12)[
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1      IF(IMUIDX1=0)[
               2          OUTPUT;(' This file does not include MU for each particle.'/
               2          ' Will not filter based on MU range.'/);
               2          ]
               1      OUTPUT;(/' Name of file to save data for graph plotting:'/' ',$);
               1      INPUT SPCNAM;(A80);
               1      OPEN(UNIT=3,STATUS='UNKNOWN',FILE=SPCNAM);
               1      CALL READ_DATA;"to read the ph-sp file"
               1      CLOSE(3);
               1      ]
               0
               0  " CHOICE1 = 1-8 case "
               0  " ------------------ "
               0  IF(CHOICE1>0 & CHOICE1<10)[
               1      IF(MSTART=0)[
               2          OUTPUT;(/' Name of file to save data for graph plotting:'/' ',$);
               2          INPUT SPCNAM;(A80);
               2          OUTPUT SPCNAM;(' File name input is:', A80);
               2
               2          OPEN(UNIT=3,STATUS='UNKNOWN',FILE=SPCNAM);
               2          IF(CHOICE1<9)[
               3              IF ~EGSPERT[ CALL HELP_MESSAGE(20); ]
               3
               3              :ITYPE:
               3
               3              OUTPUT;(/' INPUT GRAPH TYPE (0: normal, 1: histogram) ');
               3              OUTPUT;(/' ',$);
               3
               3              INPUT C1;(A1);
               3              IF (C1='?') [   CALL HELP_MESSAGE(20); GOTO :ITYPE:; ]
               3              READ(C1,'(I8)')ITYPE ;
               3              IF(ITYPE~=1)[ITYPE=0;]
               3
               3              IF(CHOICE1>=1 & CHOICE1<=4)[
               4                  IF ~EGSPERT[
               5                      CALL HELP_MESSAGE(21);
               5                      IF(CHOICE1 = 2 | CHOICE1 = 4)[
               6                          OUTPUT;(/' The fluence being estimated is the energy fluence'/);
               6                          ]
               5                      ]
               4                  :FLUTYPE:
               4                  OUTPUT;
               4                  (/' Plot planar fluence (1) or estimate of real fluence (0--default)');
               4                  OUTPUT;(/' ',$);
               4                  INPUT C1;(A1);
               4                  IF (C1='?') [ CALL HELP_MESSAGE(21); GOTO :FLUTYPE:; ]
               4                  READ(C1,'(I8)')FLUTYPE;
               4                  IF(FLUTYPE~=1)[FLUTYPE=0;]
               4                  ]
               3              ELSEIF(CHOICE1=6)["give user choice to plot particles/unit solid angle"
               4                  IF ~EGSPERT[ CALL HELP_MESSAGE(53); ]
               4                  :ANGTYPE:
               4                  OUTPUT;
               4                  (/' Plot particles/solid angle (1) or particles/angular bin (0--default)');
               4                  OUTPUT;(/' ',$);
               4                  INPUT C1;(A1);
               4                  IF (C1='?')[ CALL HELP_MESSAGE(53); GOTO :ANGTYPE:; ]
               4                  READ(C1,'(I8)')ANGTYPE;
               4                  IF(ANGTYPE~=1)[ANGTYPE=0;]
               4                  ]
               3              ]
               2          ]"end of if MSTART=0"
               1
               1      " Ask the user how many particles they want to plot "
               1      IF(CHOICE1=9)[
               2          IF ~EGSPERT[ CALL HELP_MESSAGE(51); ]
               2          :SCATTINPUT:
               2          OUTPUT;
               2          (/' Input the maximum number of particles to include in scatter plot'/
               2          ' (default=total number of particles in phase space file).');
               2          OUTPUT;(/' ',$);
               2          READ(5,'(I12)',ERR=:SCATTERR:)MAXSCATTER;
               2          GOTO :SCATTOK:;
               2          :SCATTERR:
               2          CALL HELP_MESSAGE(51);
               2          GOTO :SCATTINPUT:;
               2          :SCATTOK:
               2          IF (MAXSCATTER<=0 | MAXSCATTER>PARANOT)[
               3              MAXSCATTER=PARANOT;
               3              OUTPUT MAXSCATTER;(/' Number defaults to',I12/);
               3              ]
               2          ]
               1
               1      :BEGIN-READING-PH-SP-DATA:;
               1
               1      SERIESTITLE(1:4)='IQ =';
               1      SERIESTITLE(5:6)=LETTER1(IQSMFP(1)+2);
               1      IF(NBIT1=0 & NBIT2 = 0)[ SERIESTITLE(7:60)=' NO LATCH CHECK'; ]
               1      ELSE[
               2          IF(I_IN_EX=0)["inclusive and exclusive bits"
               3              IF(NBIT1 > 0)[
               4                  SERIESTITLE(7:19)=' INCL BIT #: ';
               4                  DO I=1,NBIT1[
               5                      SERIESTITLE(17+3*I:60)=LETTER2(LATCH(I));
               5                      ]
               4                  ]
               3              ELSE [SERIESTITLE(7:19)='             ';]
               3              "we should really fix this to not leave the space but I am lazy"
               3              IF(NBIT2>0)[
               4                  SERIESTITLE(17+3*NBIT1+2:17+3*NBIT1+14)=' EXCL BIT #: ';
               4                  DO I=1,NBIT2[
               5                      SERIESTITLE(17+3*(NBIT1+I-1)+15:60)=
               5                      LETTER2(LATCH(NBIT1+I));
               5                      ]
               4                  ]
               3              ]
               2          ELSEIF(I_IN_EX=1)[
               3              SERIESTITLE(7:19)=' EXCL BIT #: ';
               3              DO I=1,NBIT1[
               4                  SERIESTITLE(17+3*I:60)=LETTER2(LATCH(I));
               4                  ]
               3              ]
               2          IF(I_IN_EX=2)[
               3              SERIESTITLE(7:26)=' INCL REGION BIT #: ';
               3              DO I=1,NBIT1[
               4                  SERIESTITLE(24+3*I:60)=LETTER2(LATCH(I));
               4                  ]
               3              ]
               2          ELSEIF(I_IN_EX=3)[
               3              SERIESTITLE(7:26)=' EXCL REGION BIT #: ';
               3              DO I=1,NBIT1[
               4                  SERIESTITLE(24+3*I:60)=LETTER2(LATCH(I));
               4                  ]
               3              ]
               2          ]
               1
               1      " Special case here because this option does not use xvgrplot"
               1      IF(CHOICE1 = 9)[
               2          WRITE(6,*)'Begin writing graph data into file...';
               2          IF(MSTART=0)[
               3              WRITE(3,:101:)PSDNAM(1:lnblnk1(PSDNAM));
               3              :101: FORMAT('@g0 type xy '/
               3              ,'@    title "X-Y scatter plot"'/
               3              ,'@    subtitle "',A,'"'/
               3              ,'@    legend on'/
               3              ,'@    legend x1 0.6'/
               3              ,'@    legend y1 0.75'/
               3              ,'@    view xmin 0.250000'/
               3              ,'@    xaxis  label "X (cm)"'/
               3              ,'@    yaxis  label "Y (cm)"');
               3              ]
               2          "find exact length of series title"
               2          IIII=61;
               2          LOOP [
               3              IIII = IIII - 1;
               3              ] UNTIL (SERIESTITLE(IIII:IIII) ~= ' ');
               2          WRITE(3,:102:)MSTART,MSTART,MSTART,MSTART+1,
               2          MSTART,SERIESTITLE(1:IIII);
               2          :102: FORMAT('@    s',I1,' symbol 1'/
               2          ,'@    s',I1,' linestyle 0'/
               2          ,'@    s',I1,' symbol color ',I2/
               2          ,'@    legend string ',I2,' "',A,'"');
               2          ]
               1
               1      CALL READ_DATA;"moved so that seriestitle defined first"
               1
               1      IF(CHOICE1<9)[WRITE(6,*)'Begin writing graph data into file...';]
               1
               1      YPLOTT=FLOAT(IPARANOT-1);"this is the total number of particles read"
               1      IF(CHOICE1=1)[
               2          GRAPHTITLE='fluence vs position';
               2          IF(FLUTYPE=1)[ YTITLE='planar fluence/incident particle /cm\\S-2\\N'; ]
               2          ELSE[ YTITLE='fluence/incident particle /cm\\S-2\\N'; ]
               2          IF(MSMFXY=0)["circular field"
               3              XTITLE='R /cm ';
               3              DO II=1,NFIELD[
               4
               4                  $ANALYZE(II:FSMFRR(1,II):FSMFRR(2,II));
               4
               4                  XPLOT(II)=SQRT(FLOAT(II)/FLOAT(NFIELD))*RFIELD;
               4                  YPLOT(II)=FSMFRR(1,II)/(3.1415927*RFIELD**2/NFIELD);
               4                  ERRYPLOT(II)=FSMFRR(2,II)/(3.1415927*RFIELD**2/NFIELD);
               4                  ]
               3              HXMIN=0.;
               3              IF(ITYPE=0)["make sure we plot center points"
               4                  DO II=NFIELD,1,-1[
               5                      IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               5                      ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               5                      ]
               4                  ]
               3              CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               3              SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               3              ]
               2          ELSEIF(MSMFXY=1)["a square field with equal area square rings"
               3              XTITLE='X /cm ';
               3              DO II=1,NFIELD[
               4
               4                  $ANALYZE(II:FSMFRR(1,II):FSMFRR(2,II));
               4
               4                  XPLOT(II)=RFIELD*SQRT(FLOAT(II)/FLOAT(NFIELD));
               4                  YPLOT(II)=FSMFRR(1,II)/(4*RFIELD**2/NFIELD);
               4                  ERRYPLOT(II)=FSMFRR(2,II)/(4*RFIELD**2/NFIELD);
               4                  ]
               3              HXMIN=0.;
               3              IF(ITYPE=0)["make sure we plot center points"
               4                  DO II=NFIELD,1,-1[
               5                      IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               5                      ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               5                      ]
               4                  ]
               3              CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               3              SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               3              ]
               2          ELSEIF(MSMFXY=2)["rectangular field"
               3              IF(ISMFPS(1)=0)["planar fluence along x-axis"
               4                  XTITLE='X /cm';
               4                  DO II=1,NFIELD[
               5
               5                      $ANALYZE(II:FSMFXX(1,II):FSMFXX(2,II));
               5
               5                      XPLOT(II)=((SMFMXX(1)-SMFMNX(1))*FLOAT(II)/FLOAT(NFIELD))
               5                      +SMFMNX(1);
               5
               5                      YPLOT(II)=FSMFXX(1,II)/((SMFMXX(1)-SMFMNX(1))*
               5                      (SMFMXY(1)-SMFMNY(1))/NFIELD);
               5
               5                      ERRYPLOT(II)=FSMFXX(2,II)/((SMFMXX(1)-SMFMNX(1))*
               5                      (SMFMXY(1)-SMFMNY(1))/NFIELD);
               5                      ]
               4                  HXMIN=SMFMNX(1);
               4                  IF(ITYPE=0)["make sure we plot center points"
               5                      DO II=NFIELD,1,-1[
               6                          IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               6                          ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               6                          ]
               5                      ]
               4                  CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               4                  SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               4                  ]
               3              ELSE["along y-axis"
               4                  XTITLE='Y /cm';
               4                  DO II=1,NFIELD[
               5
               5                      $ANALYZE(II:FSMFYY(1,II):FSMFYY(2,II));
               5
               5                      XPLOT(II)=((SMFMXY(1)-SMFMNY(1))*FLOAT(II)/FLOAT(NFIELD))
               5                      +SMFMNY(1);
               5
               5                      YPLOT(II)=FSMFYY(1,II)/((SMFMXX(1)-SMFMNX(1))*
               5                      (SMFMXY(1)-SMFMNY(1))/NFIELD);
               5
               5                      ERRYPLOT(II)=FSMFYY(2,II)/((SMFMXX(1)-SMFMNX(1))*
               5                      (SMFMXY(1)-SMFMNY(1))/NFIELD);
               5                      ]
               4                  HXMIN=SMFMNY(1);
               4                  IF(ITYPE=0)["make sure we plot center points"
               5                      DO II=NFIELD,1,-1[
               6                          IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               6                          ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               6                          ]
               5                      ]
               4                  CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               4                  SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               4                  ]
               3              ]
               2          ]
               1
               1      IF(CHOICE1=2)[
               2          GRAPHTITLE='energy fluence vs position';
               2          IF(FLUTYPE=1)[
               3              YTITLE='planar energy fluence/incident particle /MeV cm\\S-2\\N)';
               3              ]
               2          ELSE[
               3              YTITLE='energy fluence/incident particle /MeV cm\\S-2\\N)';
               3              ]
               2          IF(MSMFXY=0)["circular field"
               3              XTITLE='R /cm';
               3              DO II=1,NFIELD[
               4                  $ANALYZE(II:FSMFRR(1,II):FSMFRR(2,II));
               4                  XPLOT(II)=SQRT(FLOAT(II)/FLOAT(NFIELD))*RFIELD;
               4                  YPLOT(II)=FSMFRR(1,II)/(3.1415927*RFIELD**2/NFIELD);
               4                  ERRYPLOT(II)=FSMFRR(2,II)/(3.1415927*RFIELD**2/NFIELD);
               4                  ]
               3              HXMIN=0.;
               3              IF(ITYPE=0)["make sure we plot center points"
               4                  DO II=NFIELD,1,-1[
               5                      IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               5                      ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               5                      ]
               4                  ]
               3              CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               3              SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               3              ]
               2          ELSEIF(MSMFXY=1)["a square field with square rings, equal area"
               3              XTITLE='X /cm';
               3              DO II=1,NFIELD[
               4                  $ANALYZE(II:FSMFRR(1,II):FSMFRR(2,II));
               4                  XPLOT(II)=RFIELD*SQRT(FLOAT(II)/FLOAT(NFIELD));
               4                  YPLOT(II)=FSMFRR(1,II)/(4*RFIELD**2/NFIELD);
               4                  ERRYPLOT(II)=FSMFRR(2,II)/(4*RFIELD**2/NFIELD);
               4                  ]
               3              HXMIN=0.;
               3              IF(ITYPE=0)["make sure we plot center points"
               4                  DO II=NFIELD,1,-1[
               5                      IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               5                      ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               5                      ]
               4                  ]
               3              CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               3              SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               3              ]
               2          ELSEIF(MSMFXY=2)["rectangular field"
               3              IF(ISMFPS(1)=0)["planar fluence along x-axis"
               4                  XTITLE='X /cm';
               4                  DO II=1,NFIELD[
               5                      $ANALYZE(II:FSMFXX(1,II):FSMFXX(2,II));
               5                      XPLOT(II)=((SMFMXX(1)-SMFMNX(1))*FLOAT(II)/FLOAT(NFIELD))
               5                      +SMFMNX(1);
               5                      YPLOT(II)=FSMFXX(1,II)/((SMFMXX(1)-SMFMNX(1))*
               5                      (SMFMXY(1)-SMFMNY(1))/NFIELD);
               5                      ERRYPLOT(II)=FSMFXX(2,II)/((SMFMXX(1)-SMFMNX(1))*
               5                      (SMFMXY(1)-SMFMNY(1))/NFIELD);
               5                      ]
               4                  HXMIN=SMFMNX(1);
               4                  IF(ITYPE=0)["make sure we plot center points"
               5                      DO II=NFIELD,1,-1[
               6                          IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               6                          ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               6                          ]
               5                      ]
               4                  CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               4                  SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               4                  ]
               3              ELSE["along y-axis"
               4                  XTITLE='Y /cm';
               4                  DO II=1,NFIELD[
               5                      $ANALYZE(II:FSMFYY(1,II):FSMFYY(2,II));
               5                      XPLOT(II)=((SMFMXY(1)-SMFMNY(1))*FLOAT(II)/FLOAT(NFIELD))
               5                      +SMFMNY(1);
               5                      YPLOT(II)=FSMFYY(1,II)/((SMFMXX(1)-SMFMNX(1))*
               5                      (SMFMXY(1)-SMFMNY(1))/NFIELD);
               5                      ERRYPLOT(II)=FSMFYY(2,II)/((SMFMXX(1)-SMFMNX(1))*
               5                      (SMFMXY(1)-SMFMNY(1))/NFIELD);
               5                      ]
               4                  HXMIN=SMFMNY(1);
               4                  IF(ITYPE=0)["make sure we plot center points"
               5                      DO II=NFIELD,1,-1[
               6                          IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               6                          ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               6                          ]
               5                      ]
               4                  CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               4                  SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               4                  ]
               3              ]
               2          ]
               1
               1      ELSEIF(CHOICE1=3)[
               2          GRAPHTITLE='spectral distribution';
               2          IF(FLUTYPE=1)[
               3              YTITLE='planar fluence/MeV/incident particle /cm\\S-2\\N MeV\\S-1\\N';
               3              ]
               2          ELSE[
               3              YTITLE='fluence/MeV/incident particle /cm\\S-2\\N MeV\\S-1\\N';
               3              ]
               2          XTITLE='energy /MeV';
               2          DO II=1,NSMFEE[
               3              $ANALYZE(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II));
               3              XPLOT(II)=(SMFMXE-SMFMNE)*FLOAT(II)/FLOAT(NSMFEE)+SMFMNE;
               3              YPLOT(II)=FSMFBN1(1,1,II)/(FLUAREA*
               3              (SMFMXE-SMFMNE)/FLOAT(NSMFEE));
               3              ERRYPLOT(II)=FSMFBN1(2,1,II)/(FLUAREA*
               3              (SMFMXE-SMFMNE)/FLOAT(NSMFEE));
               3              ]
               2          HXMIN=SMFMNE;
               2          IF(ITYPE=0)["make sure we plot center points"
               3              DO II=NSMFEE,1,-1[
               4                  IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               4                  ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               4                  ]
               3              ]
               2          CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
               2          SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               2          ]
               1
               1      ELSEIF(CHOICE1=4)[
               2          GRAPHTITLE='energy fluence distribution';
               2          IF(FLUTYPE=1)[
               3              YTITLE='planar energy fluence/MeV/incident particle  /cm\\S-2\\N';
               3              ]
               2          ELSE[
               3              YTITLE='energy fluence/MeV/incident particle  /cm\\S-2\\N';
               3              ]
               2          XTITLE='energy /MeV';
               2          DO II=1,NSMFEE[
               3              $ANALYZE(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II));
               3              XPLOT(II)=(SMFMXE-SMFMNE)*FLOAT(II)/FLOAT(NSMFEE)+SMFMNE;
               3              YPLOT(II)=FSMFBN1(1,1,II)/(FLUAREA*
               3              (SMFMXE-SMFMNE)/FLOAT(NSMFEE));
               3              ERRYPLOT(II)=FSMFBN1(2,1,II)/(FLUAREA*
               3              (SMFMXE-SMFMNE)/FLOAT(NSMFEE));
               3              ]
               2          HXMIN=SMFMNE;
               2          IF(ITYPE=0)["make sure we plot center points"
               3              DO II=NSMFEE,1,-1[
               4                  IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               4                  ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               4                  ]
               3              ]
               2          CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
               2          SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               2          ]
               1
               1      ELSEIF(CHOICE1=5)[
               2          GRAPHTITLE='mean energy distribution';
               2          YTITLE='mean energy /MeV';
               2          IF(MSMFXY=0)["circular field"
               3              XTITLE='R /cm';
               3              DO II=1,NFIELD[
               4                  $ANALYZE_COV(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II):FSMFBN1(1,2,II):
               4                  FSMFBN1(2,2,II):FSMFBN1(3,1,II));
               4                  XPLOT(II)=SQRT(FLOAT(II)/FLOAT(NFIELD))*RFIELD;
               4                  IF(FSMFBN1(1,1,II)=0.)[YPLOT(II)=0;]
               4                  ELSE[YPLOT(II)=FSMFBN1(1,1,II)/FSMFBN1(1,2,II);]
               4                  IF(FSMFBN1(1,1,II)=0.)|(FSMFBN1(1,2,II)=0.)[ERRYPLOT(II)=0;]
               4                  ELSE[ERRYPLOT(II)=FSMFBN1(2,1,II)*YPLOT(II);]
               4                  ]
               3              HXMIN=0.;
               3              IF(ITYPE=0)["make sure we plot center points"
               4                  DO II=NFIELD,1,-1[
               5                      IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               5                      ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               5                      ]
               4                  ]
               3              CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               3              SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               3              ]
               2          ELSEIF(MSMFXY=1)["a square field with square rings, equal area"
               3              XTITLE='X /cm';
               3              DO II=1,NFIELD[
               4                  $ANALYZE_COV(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II):FSMFBN1(1,2,II):
               4                  FSMFBN1(2,2,II):FSMFBN1(3,1,II));
               4                  XPLOT(II)=RFIELD*SQRT(FLOAT(II)/FLOAT(NFIELD));
               4                  IF(FSMFBN1(1,1,II)=0.)[YPLOT(II)=0;]
               4                  ELSE[YPLOT(II)=FSMFBN1(1,1,II)/FSMFBN1(1,2,II);]
               4                  IF(FSMFBN1(1,1,II)=0.)|(FSMFBN1(1,2,II)=0.)[ERRYPLOT(II)=0;]
               4                  ELSE[ERRYPLOT(II)=FSMFBN1(2,1,II)*YPLOT(II);]
               4                  ]
               3              HXMIN=0.;
               3              IF(ITYPE=0)["make sure we plot center points"
               4                  DO II=NFIELD,1,-1[
               5                      IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               5                      ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               5                      ]
               4                  ]
               3              CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               3              SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               3              ]
               2          ELSEIF(MSMFXY=2)["rectangular field"
               3              IF(ISMFPS(1)=0)["planar fluence along x-axis"
               4                  XTITLE='X /cm';
               4                  DO II=1,NFIELD[
               5                      $ANALYZE_COV(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II):FSMFBN1(1,2,II):
               5                      FSMFBN1(2,2,II):FSMFBN1(3,1,II));
               5                      XPLOT(II)=((SMFMXX(1)-SMFMNX(1))*FLOAT(II)/FLOAT(NFIELD))
               5                      +SMFMNX(1);
               5                      IF(FSMFBN1(1,1,II)=0.)[YPLOT(II)=0.;]
               5                      ELSE[YPLOT(II)=FSMFBN1(1,1,II)/FSMFBN1(1,2,II);]
               5                      IF(FSMFBN1(1,1,II)=0.)|(FSMFBN1(1,2,II)=0.)[ERRYPLOT(II)=0;]
               5                      ELSE[ERRYPLOT(II)=FSMFBN1(2,1,II)*YPLOT(II);]
               5                      ]
               4                  HXMIN=SMFMNX(1);
               4                  IF(ITYPE=0)["make sure we plot center points"
               5                      DO II=NFIELD,1,-1[
               6                          IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               6                          ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               6                          ]
               5                      ]
               4                  CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               4                  SERIESTITLE,XTITLE,
               4                  YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               4                  ]
               3              ELSE["along y-axis"
               4                  XTITLE='Y /cm';
               4                  DO II=1,NFIELD[
               5                      $ANALYZE_COV(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II):FSMFBN1(1,2,II):
               5                      FSMFBN1(2,2,II):FSMFBN1(3,1,II));
               5                      XPLOT(II)=((SMFMXY(1)-SMFMNY(1))*FLOAT(II)/FLOAT(NFIELD))
               5                      +SMFMNY(1);
               5                      IF(FSMFBN1(1,1,II)=0.)[YPLOT(II)=0.;]
               5                      ELSE[YPLOT(II)=FSMFBN1(1,1,II)/FSMFBN1(1,2,II);]
               5                      IF(FSMFBN1(1,1,II)=0.)|(FSMFBN1(1,2,II)=0.)[ERRYPLOT(II)=0;]
               5                      ELSE[ERRYPLOT(II)=FSMFBN1(2,1,II)*YPLOT(II);]
               5                      ]
               4                  HXMIN=SMFMNY(1);
               4                  IF(ITYPE=0)["make sure we plot center points"
               5                      DO II=NFIELD,1,-1[
               6                          IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               6                          ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               6                          ]
               5                      ]
               4                  CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               4                  SERIESTITLE,XTITLE,
               4                  YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               4                  ]
               3              ]
               2          ]
               1      " Angular distribution "
               1      " -------------------- "
               1      ELSEIF(CHOICE1=6)[
               2          GRAPHTITLE='angular distribution';
               2          IF(ANGTYPE=1)[
               3              YTITLE='particles/unit solid angle/incident particle';
               3              ]
               2          ELSE[
               3              YTITLE='particles/angular bin/incident particle';
               3              ]
               2          XTITLE='angle /degree';
               2          DO II=1,NSMFEE[
               3              $ANALYZE(II:FSMABN1(II):FSMABN2(II));
               3              XPLOT(II)=(SMFMXE-SMFMNE)*FLOAT(II)/FLOAT(NSMFEE)+SMFMNE;
               3              IF(ANGTYPE=1)["get particles/unit solid angle"
               4                  "below is 2*pi*sin(theta)*dtheta, where theta is the"
               4                  "angle in the middle of the bin (radians) and dtheta is"
               4                  "the bin width (radians)"
               4                  IF(II=1)[
               5                      DOMEGA=2*3.1415927*SIN((XPLOT(II)+SMFMNE)/2/57.29578)*
               5                      (XPLOT(II)-SMFMNE)/57.29578;
               5                      ]
               4                  ELSE[
               5                      DOMEGA=2*3.1415927*SIN((XPLOT(II)+XPLOT(II-1))/2/57.29578)*
               5                      (XPLOT(II)-XPLOT(II-1))/57.29578;
               5                      ]
               4                  ]
               3              ELSE[DOMEGA=1.;]
               3              YPLOT(II)=FSMABN1(II)/DOMEGA;
               3              ERRYPLOT(II)=FSMABN2(II)/DOMEGA;
               3              ]
               2          HXMIN=SMFMNE;
               2          IF(ITYPE=0)["make sure we plot center points"
               3              DO II=NSMFEE,1,-1[
               4                  IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               4                  ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               4                  ]
               3              ]
               2          CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
               2          SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               2
               2          ]
               1      ELSEIF(CHOICE1=7)[
               2          GRAPHTITLE='distribution of ZLAST';
               2          YTITLE='particles/bin(equal)/incident particle';
               2          XTITLE='Z /cm ';
               2          DO II=1,NSMFEE[
               3              $ANALYZE(II:FSMABN1(II):FSMABN2(II));
               3              XPLOT(II)=(SMFMXE-SMFMNE)*FLOAT(II)/FLOAT(NSMFEE)+SMFMNE;
               3              YPLOT(II)=FSMABN1(II);
               3              ERRYPLOT(II)=FSMABN2(II);
               3              ]
               2          HXMIN=SMFMNE;
               2          IF(ITYPE=0)["make sure we plot center points"
               3              DO II=NSMFEE,1,-1[
               4                  IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               4                  ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               4                  ]
               3              ]
               2          CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
               2          SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               2
               2          ]
               1      ELSEIF(CHOICE1=8)[
               2          GRAPHTITLE='weight distribution';
               2          YTITLE='particles/bin(equal width)/incident particle';
               2          XTITLE='weight';
               2          DO II=1,NSMFEE[
               3              $ANALYZE(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II));
               3              XPLOT(II)=EXP((LOG(SMFMXE)-LOG(SMFMNE))*FLOAT(II)/FLOAT(NSMFEE)+
               3              LOG(SMFMNE));
               3              YPLOT(II)=FSMFBN1(1,1,II);
               3              ERRYPLOT(II)=FSMFBN1(2,1,II);
               3              ]
               2          HXMIN=SMFMNE;
               2          IF(ITYPE=0)["make sure we plot center points"
               3              DO II=NSMFEE,1,-1[
               4                  IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
               4                  ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               4                  ]
               3              ]
               2          CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
               2          SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,2);
               2          ]
               1      ELSEIF(CHOICE1=9)[WRITE(3,'(''&'')');]
               1      "just write the ampersand at the end of the data"
               1
               1      "FINISHED OPTIONS 1 - 9"
               1      IF(CHOICE1=1)[
               2          OUTPUT ;
               2          (/' Create another set of fluence vs position data using the same'/
               2          ' ph-sp file?');
               2          ]
               1      IF(CHOICE1=2)[
               2          OUTPUT ;
               2          (/' Create another set of energy fluence vs position data using the'/
               2          ' same ph-sp file?');
               2          ]
               1      ELSEIF(CHOICE1=3)[
               2          OUTPUT ;
               2          (/' Create another set of spectral data using the same ph-sp file?');
               2          ]
               1      IF(CHOICE1=4)[
               2          OUTPUT ;
               2          (/' Create another set of energy fluence data using the same ph-sp file?');
               2          ]
               1      ELSEIF(CHOICE1=5)[
               2          OUTPUT ;
               2          (/' Create another set of mean energy data using the same ph-sp file?');
               2          ]
               1      ELSEIF(CHOICE1=6)[
               2          OUTPUT ;
               2          (/' Create another set of angular data using the same ph-sp file?');
               2          ]
               1      ELSEIF(CHOICE1=7)[
               2          OUTPUT ;
               2          (/' Create another set of zlast data using the same ph-sp file?');
               2          ]
               1      ELSEIF(CHOICE1=8)[
               2          OUTPUT ;
               2          (/' Create another set of weight data using the same ph-sp file?');
               2          ]
               1      ELSEIF(CHOICE1=9)[
               2          OUTPUT ;
               2          (/' Create another set of x-y scatter data using the same ph-sp file?');
               2          ]
               1      OUTPUT ;
               1      (' (1: yes, 0: no - quit)'/' ',$);
               1      INPUT II; (I8);
               1      OUTPUT II; (I8);
               1      IF(II = 1)[
               2          MSTART=MSTART+1;
               2          OUTPUT;(' Using same ph-sp file');
               2          GOTO :START-INPUTS-FOR-AN-OPTION:;
               2          ]
               1      ELSE[
               2          OUTPUT ;
               2          (/' Plot the data just created using xmgrace before quiting?');
               2          OUTPUT ;
               2          (' (1: yes, 0: no - quit)'/' ',$);
               2          INPUT II; (I8);
               2          IF(II = 1)[
               3              OUTPUT;('Plot the data');
               3              CALL XVGR_SCRIPT;
               3              ]
               2          GOTO :STOP-FOR-GOOD1:;
               2          ]
               1      ] " end of choice1=1-8 case "
               0
               0  " Combine two ph-sp files into one "
               0  " -------------------------------- "
               0  IF(CHOICE1 = 10)
               0  CALL ADD_FILES;
               0
               0  :STOP-FOR-GOOD1:;
               0
               0  OUTPUT;(/' BYE!'///
               0  ' If running gui, this window will close before next run!'/);
               0
               0  STOP;
               0  END;
               0
               0  %L                                                                             ;
               0  !LABELS 5000;
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  %I4                                                                            ;
1              0  %E
               0  %B132                                                                          ;
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  "*******************************************************************************
               0  SUBROUTINE XVGR_SCRIPT;
               0  "
               0  " THIS IS A SUBROUTINE USED BY BEAMDP TO GENERATE A SCRIPT AND RUN xmgrace.
               0  "
               0  " PROGRAMMER C-M MA
               0  "
               0  "*******************************************************************************
               0
               0  "**VARIABLES**"
               0
               0  "---Force declarations of all variables---"
               0  IMPLICIT NONE;
               0
               0  COMIN/CHARACTERS;
               0
               0  "CREATING A SCRIPT FILE FOR xmgrace"
               0  OPEN(4,FILE='xmgrace_script',FORM='FORMATTED',STATUS='UNKNOWN');
               0  SCRIPT(3)(1:22)='xmgrace -autoscale xy ';
               0  SCRIPT(3)(23:100)= SPCNAM;
               0  SCRIPT(1)='#!/bin/sh';
               0  SCRIPT(2)='#xmgrace_script';
               0  SCRIPT(4)='exit';
               0  WRITE (4,*)SCRIPT(1)(1:60);
               0  WRITE (4,*)SCRIPT(2)(1:60);
               0  WRITE (4,*)SCRIPT(3)(1:);
               0  WRITE (4,*)SCRIPT(4)(1:60);
               0  CLOSE(4);
               0  CALL SYSTEM('chmod +x xmgrace_script');
               0  "converts script file to executable mode"
               0  CALL SYSTEM('xmgrace_script &')
               0  ;
               0  "CALL SYSTEM('xmgr_script > /dev/null &');
               0  "executes xmgr_script file"
               0  "redirected output to null device, and runs xvgr in background"
               0  RETURN;
               0  END;
               0
               0  %L                                                                             ;
               0  !LABELS 5000;
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  %I4                                                                            ;
1              0  %E
               0  %B132                                                                          ;
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  "*******************************************************************************
               0  SUBROUTINE READ_DATA;
               0  "
               0  " THIS IS A SUBROUTINE USED BY BEAMDP TO READ DATA FROM PHASE-SPACE FILES.
               0  "
               0  " PROGRAMMER C-M MA
               0  "
               0  "*******************************************************************************
               0
               0  "**VARIABLES**"
               0
               0  "---Force declarations of all variables---"
               0  IMPLICIT NONE;
               0
               0
               0  COMIN/CHARACTERS;
               0  COMIN/DOUBLES;
               0  COMIN/REALS;
               0  COMIN/INTEGERS;
               0  COMIN/LOGICALS;
               0  COMIN/RWPHSP/;
               0
               0  integer lnblnk1;
               0
               0  i_log=6;
               0
               0  "initialize counters"
               0  DO III=1,$NB[
               1      XPLOT(III)=0.0;
               1      YPLOT(III)=0.0;
               1      ERRYPLOT(III)=0.0;
               1      JUSTONE(III)=0;
               1      NHSTRY_LAST(III)=0.;
               1      SUM_TMP(III)=0.;
               1      SUM_TMP2(III)=0.;
               1      ]
               0  DO III=1,$NBINANGLE[
               1      FSMABN1(III)=0.0;"ANGULAR DISTRIBUTION"
               1      FSMABN2(III)=0.0;"FSMABN1 SQUARED"
               1      ]
               0  DO III=1,$NS[
               1      DO IIII=1,$NB[
               2          FSMFRR(III,IIII)=0.0;
               2          FSMFXX(III,IIII)=0.0;
               2          FSMFYY(III,IIII)=0.0;
               2          DO IIIII=1,$NB[FSMFXY(III,IIII,IIIII)=0.0;]
               2          ]
               1      DO IIII=1,$NB[
               2          DO IIIII=1,$NB[
               3              FSMFBN1(III,IIIII,IIII)=0.0;
               3              ]
               2          ]
               1      ]
               0
               0  "calculate constants for later use"
               0  IF((SMFMXE-SMFMNE) ~= 0.)[
               1      SFACTOR=FLOAT(NSMFEE)/(SMFMXE-SMFMNE);"energy"
               1      SSFACTOR=FLOAT(NSMFEE)/(SMFMXE-SMFMNE);
               1      "angle, ZLAST, note we use the same variables here for convenience"
               1      ]
               0  ELSE[SFACTOR=FLOAT(NSMFEE);SSFACTOR=FLOAT(NSMFEE);]
               0  IF(RFIELD ~= 0.)[RFACTOR=FLOAT(NFIELD)/(RFIELD**2);"ring field"]
               0  ELSE[RFACTOR=FLOAT(NFIELD);]
               0  IF((SMFMXY(1)-SMFMNY(1)) ~= 0.)[
               1      Y=FLOAT(NFIELD)/(SMFMXY(1)-SMFMNY(1));"rectangular field"
               1      ]
               0  IF((SMFMXX(1)-SMFMNX(1)) ~= 0.)[
               1      X=FLOAT(NFIELD)/(SMFMXX(1)-SMFMNX(1));
               1      ]
               0  ELSE[X=FLOAT(NFIELD);]
               0  XMIN2=SMFMNX(1)*SMFMNX(1);
               0  XMAX2=SMFMXX(1)*SMFMXX(1);
               0
               0  "Read ph-sp particles"
               0  :LOOP-THROUGH-PH-SP-FILE:;
               0  IPARANOT=1; "START WITH THE FIRST PARTICLE IN FILE"
               0  NUMSCATTER=0;
               0  IIII=0;
               0  NHSTRY=0;"no. of primary histories"
               0  LOOP["read phase-space data from the data file"
               1
               1      ;:start-of-file-read0:;
               1
               1      IPARANOT=IPARANOT+1;"NOTE THE SECOND RECORD STORES THE FIRST PARTICLE"
               1      IF(IPARANOT = PARANOT+2)["end of file encountered"
               2          GOTO :end-of-file-read0:;
               2          ]
               1
               1      IF(i_iaea_in=1)[
               2          $IAEA_READ_PHSP_RECORD(i_unit_in,NPASSI,NHSTRY,LATCHI,IQ,EI,
               2          WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MUIDX);
               2          ]
               1      ELSE[
               2
               2          IZLAST1=0;
               2          IF(MODE_RW='MODE2')IZLAST1=1;
               2
               2          $READ_PHSP(IZLAST1,2,IPARANOT:NHSTRY,NPASSI,IQ,WIN,ZLAST,LATCHI,
               2          EI,WEIGHT,XIN,YIN,UIN,VIN);
               2          ]
               1
               1      IF (NPASSI ~= 0) [
               2          NPASS_ph_sp = NPASS_ph_sp + 1;
               2          "  GOTO :start-of-file-read0:;  changed by cma"
               2          "Discard particles if they or their ancestors have crossed"
               2          "scoring plane"
               2          ]
               1
               1      IF(IQ ~= 0)[ "We need kinetic energy only"
               2          EI=EI-0.5109989461;
               2          ]
               1
               1      "processing the ph-sp data"
               1      "*************************"
               1
               1      IF(IQSMFP(1) ~= 2)["check charge first"
               2          IF(IQSMFP(1) =3)[IF(IQ =0)[GOTO :start-of-file-read0:;]]
               2          ELSEIF(IQSMFP(1) ~= IQ)[GOTO :start-of-file-read0:;]
               2          ]"discard the particle if the charge is not right"
               1      IF(CHOICE1=11)[
               2          DO I=1,29[
               3              IF($BTEST(LATCHI,I-1))[LATCHJ(30-I)=1;"Bit I is set"]
               3              ELSE[LATCHJ(30-I)=0;"bit I is not set"]
               3              ]
               2          IIII=IIII+1;
               2          IF(IIII>=NUMBERST)[
               3              IF(MODE_RW='MODE0')[
               4                  WRITE(6,:LIST-FORMAT1:)
               4                  EI,IQ,XIN,YIN,UIN,VIN,WIN,WEIGHT,(LATCHJ(I),I=1,29);
               4                  :LIST-FORMAT1:FORMAT(F7.3,I4,2F8.3,3F7.3,1PE10.3,
               4                  2X,$LATCH_NUMBER_OF_BITSI1,1X,24I1);
               4                  ]
               3              ELSEIF(MODE_RW='MODE2')[
               4                  WRITE(6,:LIST-FORMAT11:)
               4                  EI,IQ,XIN,YIN,UIN,VIN,WIN,ZLAST,WEIGHT,(LATCHJ(I),I=1,29);
               4                  :LIST-FORMAT11:FORMAT(F7.3,I4,2F8.3,3F7.3,F8.3,1PE10.3,
               4                  2X,$LATCH_NUMBER_OF_BITSI1,1X,24I1);
               4                  ]
               3              ]
               2          IF(NUMBERP = IIII)RETURN;
               2          IF(IIII=1)[
               3              IF(MODE_RW='MODE0')[
               4                  WRITE(6,:LIST-FORMAT02:);
               4                  ]
               3              ELSEIF(MODE_RW='MODE2')[
               4                  WRITE(6,:LIST-FORMAT03:);
               4                  ]
               3              ]
               2          ]
               1      ELSEIF(CHOICE1=12)[
               2
               2
               2
               2
               2
               2
               2
               2
               2
               2
               2          IF(IMUIDX1=0 | (MUIDX>=mumin & MUIDX<=mumax))[
               3              IIII=IIII+1;
               3              WRITE(3,'(F8.3,'','',F8.3,'','',F8.3)')XIN,YIN,ZIN;
               3              ]
               2          IF(NUMBERP = IIII)RETURN;
               2          ]
               1
               1      :LIST-FORMAT02: FORMAT(/' ENERGY  IQ     X',
               1      5X, '  Y',4X,'  U',4X,'  V',4X,'  W',4X,'WEIGHT',6X,
               1      ' LATCH (set=1, not set=0)'/);
               1      :LIST-FORMAT03: FORMAT(/' ENERGY  IQ     X',
               1      5X, '  Y',4X,'  U',4X,'  V',4X,'  W',4X,' ZLAST   WEIGHT',6X,
               1      ' LATCH (set=1, not set=0)'/);
               1
               1      "below is the bit filtering"
               1      IF(I_IN_EX = 0)[
               2          DO I=1,NBIT1[
               3              III=LATCH(I);"check whether bit I has been set"
               3              IF($BTEST(LATCHI,III))EXIT;
               3              "now check the bits to be excluded"
               3              IF(I=NBIT1)GOTO :start-of-file-read0:;
               3              "discard the particle"
               3              ]
               2          DO I=1,NBIT2[
               3              III=LATCH(I+NBIT1);"check whether bit I has been set"
               3              IF($BTEST(LATCHI,III))GOTO :start-of-file-read0:;
               3              "discard the particle"
               3              ]
               2          GOTO :PARTICLE-WITH-CORRECT_LATCH:;
               2          ]
               1      ELSEIF(I_IN_EX = 1)[
               2          DO I=1,NBIT1[
               3              III=LATCH(I);"check whether bit I has been set"
               3              IF($BTEST(LATCHI,III))GOTO :start-of-file-read0:;
               3              "as long as a specified bit is set we discard the particle"
               3              ]
               2          ]
               1      ELSEIF(I_IN_EX = 2)[
               2          DO I=1,NBIT1[
               3              III=LATCH(I);"check whether bit I has been set"
               3              IF(IBITS(LATCHI,24,5)=III)GOTO :PARTICLE-WITH-CORRECT_LATCH:;
               3              "now check the bits to be excluded"
               3              ]
               2          GOTO :start-of-file-read0:;
               2          ]
               1      ELSEIF(I_IN_EX = 3)[
               2          DO I=1,NBIT1[
               3              III=LATCH(I);"check whether particle originated in region I"
               3              IF(IBITS(LATCHI,24,5)=III)GOTO :start-of-file-read0:;
               3              "as long as particle originated in specified region, chuck it"
               3              ]
               2          ]
               1
               1      :PARTICLE-WITH-CORRECT_LATCH:;
               1
               1      X2Y2=XIN*XIN+YIN*YIN;
               1
               1      " Fluence "
               1      IF(CHOICE1 = 1)[
               2          IF(FLUTYPE~=1)["use estimate of real fluence"
               3              WEIGHT=WEIGHT/MAX(0.08716,ABS(WIN));
               3              ]
               2          IF(MSMFXY=0)["circular field"
               3              IR=INT(X2Y2*RFACTOR)+1;
               3              IF(IR > NFIELD)[
               4                  "discard this particle, outside the given field"
               4                  GOTO :start-of-file-read0:;
               4                  ]
               3              $SCORE(IR:FSMFRR(1,IR):FSMFRR(2,IR):WEIGHT);
               3              ]
               2          ELSEIF(MSMFXY=1)["a square field with square rings"
               3              IX=INT(XIN*XIN*RFACTOR)+1;
               3              IY=INT(YIN*YIN*RFACTOR)+1;
               3              IF((IX > NFIELD) |  (IY > NFIELD))[
               4                  "discard this particle, outside the given field"
               4                  GOTO :start-of-file-read0:;
               4                  ]
               3              IF(IX <= IY)["find index"
               4                  $SCORE(IY:FSMFRR(1,IY):FSMFRR(2,IY):WEIGHT);
               4                  ]
               3              ELSE[
               4                  $SCORE(IX:FSMFRR(1,IX):FSMFRR(2,IX):WEIGHT);
               4                  ]
               3              ]
               2          ELSEIF(MSMFXY=2)["rectangular field"
               3              IF(ISMFPS(1)=0)["score planar fluence along x-axis"
               4                  IX=INT((XIN-SMFMNX(1))*X)+1;
               4                  IF(IX>NFIELD)|(IX<1)|((XIN-SMFMNX(1))<0. |
               4                  YIN>=SMFMXY(1) | YIN<=SMFMNY(1))[
               5                      "discard this particle"
               5                      GOTO :start-of-file-read0:;
               5                      ]
               4                  $SCORE(IX:FSMFXX(1,IX):FSMFXX(2,IX):WEIGHT);
               4                  ]
               3              ELSE["along y-axis"
               4                  IY=INT((YIN-SMFMNY(1))*Y)+1;
               4                  IF(IY>NFIELD)|(IY<1)|((YIN-SMFMNY(1))<0. |
               4                  XIN>=SMFMXX(1) | XIN<=SMFMNX(1))[
               5                      "discard this particle"
               5                      GOTO :start-of-file-read0:;
               5                      ]
               4                  $SCORE(IY:FSMFYY(1,IY):FSMFYY(2,IY):WEIGHT);
               4                  ]
               3              ]
               2          ]
               1
               1      " Energy fluence vs position "
               1      IF(CHOICE1 = 2)[
               2          IF(FLUTYPE~=1)["use estimate of real fluence"
               3              WEIGHT=WEIGHT/MAX(0.08716,ABS(WIN));
               3              ]
               2          IF(MSMFXY=0)["circular field"
               3              IR=INT(X2Y2*RFACTOR)+1;
               3              IF(IR > NFIELD)[
               4                  "discard this particle, outside the given field"
               4                  GOTO :start-of-file-read0:;
               4                  ]
               3              $SCORE(IR:FSMFRR(1,IR):FSMFRR(2,IR):WEIGHT*EI);
               3              ]
               2          ELSEIF(MSMFXY=1)["a square field with square rings"
               3              IX=INT(XIN*XIN*RFACTOR)+1;
               3              IY=INT(YIN*YIN*RFACTOR)+1;
               3              IF((IX > NFIELD) |  (IY > NFIELD))[
               4                  "discard this particle, outside the given field"
               4                  GOTO :start-of-file-read0:;
               4                  ]
               3              IF(IX <= IY)["find index"
               4                  $SCORE(IY:FSMFRR(1,IY):FSMFRR(2,IY):WEIGHT*EI);
               4                  ]
               3              ELSE[
               4                  $SCORE(IX:FSMFRR(1,IX):FSMFRR(2,IX):WEIGHT*EI);
               4                  ]
               3              ]
               2          ELSEIF(MSMFXY=2)["rectangular field"
               3              IF(ISMFPS(1)=0)["score planar fluence along x-axis"
               4                  IX=INT((XIN-SMFMNX(1))*X)+1;
               4                  IF(IX>NFIELD)|(IX<1)|((XIN-SMFMNX(1))<0. |
               4                  YIN>=SMFMXY(1) | YIN<=SMFMNY(1))[
               5                      "discard this particle"
               5                      GOTO :start-of-file-read0:;
               5                      ]
               4                  $SCORE(IX:FSMFXX(1,IX):FSMFXX(2,IX):WEIGHT*EI);
               4                  ]
               3              ELSE["along y-axis"
               4                  IY=INT((YIN-SMFMNY(1))*Y)+1;
               4                  IF(IY>NFIELD)|(IY<1)|((YIN-SMFMNY(1))<0. |
               4                  XIN>=SMFMXX(1) | XIN<=SMFMNX(1))[
               5                      "discard this particle"
               5                      GOTO :start-of-file-read0:;
               5                      ]
               4                  $SCORE(IY:FSMFYY(1,IY):FSMFYY(2,IY):WEIGHT*EI);
               4                  ]
               3              ]
               2          ]
               1
               1      " Spectrum "
               1      ELSEIF(CHOICE1 = 3)[
               2          IF(FLUTYPE~=1)["use estimate of real fluence"
               3              WEIGHT=WEIGHT/MAX(0.08716,ABS(WIN));
               3              ]
               2          IF(MSMFXY=0)["ANNULAR"
               3              IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
               4                  IF(EI<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IE=INT((EI-SMFMNE)*SFACTOR)+1;
               4                  IF(IE > NSMFEE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):WEIGHT);
               4                  ]
               3              ]
               2          ELSEIF(MSMFXY=1)["RECTANGULAR"
               3              IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
               3              &(XIN<SMFMXX(1))["inside the given field"
               4                  IF(EI<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IE=INT((EI-SMFMNE)*SFACTOR)+1;
               4                  IF(IE > NSMFEE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):WEIGHT);
               4                  ]
               3              ]
               2          ]
               1
               1      " Energy fluence distribution "
               1      ELSEIF(CHOICE1 = 4)[
               2          IF(FLUTYPE~=1)["use estimate of real fluence"
               3              WEIGHT=WEIGHT/MAX(0.08716,ABS(WIN));
               3              ]
               2          IF(MSMFXY=0)["ANNULAR"
               3              IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
               4                  IF(EI<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IE=INT((EI-SMFMNE)*SFACTOR)+1;
               4                  IF(IE > NSMFEE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):WEIGHT*EI);
               4                  ]
               3              ]
               2          ELSEIF(MSMFXY=1)["RECTANGULAR"
               3              IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
               3              &(XIN<SMFMXX(1))["inside the given field"
               4                  IF(EI<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IE=INT((EI-SMFMNE)*SFACTOR)+1;
               4                  IF(IE > NSMFEE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):WEIGHT*EI);
               4                  ]
               3              ]
               2          ]
               1
               1      " Mean energy "
               1      ELSEIF(CHOICE1 = 5)[
               2          WEIGHT=WEIGHT/MAX(0.08716,ABS(WIN));
               2          IF(MSMFXY=0)["circular field"
               3              IR=INT(X2Y2*RFACTOR)+1;
               3              IF(IR > NFIELD)[
               4                  "discard this particle, outside the given field"
               4                  GOTO :start-of-file-read0:;
               4                  ]
               3              JUSTONE(IR)=JUSTONE(IR)+1;
               3              $SCORE_COV(IR:FSMFBN1(1,1,IR):FSMFBN1(2,1,IR):FSMFBN1(1,2,IR):
               3              FSMFBN1(2,2,IR):FSMFBN1(3,1,IR):WEIGHT*EI:WEIGHT);
               3              ]
               2          ELSEIF(MSMFXY=1)["a square field with square rings"
               3              IX=INT(XIN*XIN*RFACTOR)+1;
               3              IY=INT(YIN*YIN*RFACTOR)+1;
               3              IF((IX > NFIELD) |  (IY > NFIELD))[
               4                  "discard this particle, outside the given field"
               4                  GOTO :start-of-file-read0:;
               4                  ]
               3              IF(IX <= IY)["find index"
               4                  JUSTONE(IY)=JUSTONE(IY)+1;
               4                  $SCORE_COV(IY:FSMFBN1(1,1,IY):FSMFBN1(2,1,IY):FSMFBN1(1,2,IY):
               4                  FSMFBN1(2,2,IY):FSMFBN1(3,1,IY):WEIGHT*EI:WEIGHT);
               4                  ]
               3              ELSE[
               4                  JUSTONE(IX)=JUSTONE(IX)+1;
               4                  $SCORE_COV(IX:FSMFBN1(1,1,IX):FSMFBN1(2,1,IX):FSMFBN1(1,2,IX):
               4                  FSMFBN1(2,2,IX):FSMFBN1(3,1,IX):WEIGHT*EI:WEIGHT);
               4                  ]
               3              ]
               2          ELSEIF(MSMFXY=2)["rectangular field"
               3              IF(ISMFPS(1)=0)["score planar fluence along x-axis"
               4                  IX=INT((XIN-SMFMNX(1))*X)+1;
               4                  IF(IX>NFIELD)|(IX<1)|((XIN-SMFMNX(1))<0. |
               4                  YIN>=SMFMXY(1) | YIN<=SMFMNY(1))[
               5                      "discard this particle"
               5                      GOTO :start-of-file-read0:;
               5                      ]
               4                  JUSTONE(IX)=JUSTONE(IX)+1;
               4                  $SCORE_COV(IX:FSMFBN1(1,1,IX):FSMFBN1(2,1,IX):FSMFBN1(1,2,IX):
               4                  FSMFBN1(2,2,IX):FSMFBN1(3,1,IX):WEIGHT*EI:WEIGHT);
               4                  ]
               3              ELSE["along y-axis"
               4                  IY=INT((YIN-SMFMNY(1))*Y)+1;
               4                  IF(IY>NFIELD)|(IY<1)|((YIN-SMFMNY(1))<0. |
               4                  XIN>=SMFMXX(1) | XIN<=SMFMNX(1))[
               5                      "discard this particle"
               5                      GOTO :start-of-file-read0:;
               5                      ]
               4                  JUSTONE(IY)=JUSTONE(IY)+1;
               4                  $SCORE_COV(IY:FSMFBN1(1,1,IY):FSMFBN1(2,1,IY):FSMFBN1(1,2,IY):
               4                  FSMFBN1(2,2,IY):FSMFBN1(3,1,IY):WEIGHT*EI:WEIGHT);
               4                  ]
               3              ]
               2          ]
               1
               1      " Angular distribution "
               1      ELSEIF(CHOICE1 = 6)[
               2          "reject the particle based on energy here, because EI stands"
               2          "in for angle later"
               2          IF(EI<SMFMNZ(1))[
               3              GOTO :start-of-file-read0:;"discard the particle"
               3              ]
               2          IF(EI>SMFMXZ(1))[
               3              GOTO :start-of-file-read0:;"discard the particle"
               3              ]
               2          IF(MSMFXY=0)["ANNULAR"
               3              IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
               4                  EI=ACOS(WIN)*57.29578; "=180./3.14159"
               4                  IF(EI<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IA=INT((EI-SMFMNE)*SSFACTOR)+1;
               4                  IF(IA>NSMFEE)|(IA<1)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  $SCORE(IA:FSMABN1(IA):FSMABN2(IA):WEIGHT);
               4                  ]
               3              ]
               2          ELSEIF(MSMFXY=1)["RECTANGULAR"
               3              IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
               3              &(XIN<SMFMXX(1))["inside the given field"
               4                  EI=ACOS(WIN)*57.29578; "=180./3.14159"
               4                  IF(EI<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IA=INT((EI-SMFMNE)*SSFACTOR)+1;
               4                  IF(IA > NSMFEE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  $SCORE(IA:FSMABN1(IA):FSMABN2(IA):WEIGHT);
               4                  ]
               3              ]
               2          ]
               1
               1      " ZLAST distribution "
               1      ELSEIF(CHOICE1 = 7)[
               2          IF(MSMFXY=0)["ANNULAR"
               3              IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
               4                  IF(ZLAST<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IA=INT((ZLAST-SMFMNE)*SSFACTOR)+1;
               4                  IF(IA > NSMFEE)|(IA < 1)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  $SCORE(IA:FSMABN1(IA):FSMABN2(IA):WEIGHT);
               4                  ]
               3              ]
               2          ELSEIF(MSMFXY=1)["RECTANGULAR"
               3              IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
               3              &(XIN<SMFMXX(1))["inside the given field"
               4                  IF(ZLAST<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IA=INT((ZLAST-SMFMNE)*SSFACTOR)+1;
               4                  IF(IA > NSMFEE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  $SCORE(IA:FSMABN1(IA):FSMABN2(IA):WEIGHT);
               4                  ]
               3              ]
               2          ]
               1
               1      " Weight distribution "
               1      ELSEIF(CHOICE1 = 8)[
               2          IF(SMFMXE~=SMFMNE)[
               3              SFACTOR=FLOAT(NSMFEE)/(LOG(SMFMXE)-LOG(SMFMNE));
               3              ]
               2          IF(MSMFXY=0)["ANNULAR"
               3              IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
               4                  IF(WEIGHT<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IE=INT((LOG(WEIGHT)-LOG(SMFMNE))*SFACTOR)+1;
               4                  IF(IE > NSMFEE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):1);
               4                  ]
               3              ]
               2          ELSEIF(MSMFXY=1)["RECTANGULAR"
               3              IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
               3              &(XIN<SMFMXX(1))["inside the given field"
               4                  IF(WEIGHT<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IE=INT((LOG(WEIGHT)-LOG(SMFMNE))*SFACTOR)+1;
               4                  IF(IE > NSMFEE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):1);
               4                  ]
               3              ]
               2          ]
               1
               1      " X-Y scatter plot "
               1      ELSEIF(CHOICE1 = 9)[
               2          IF(MSMFXY=0)["ANNULAR"
               3              IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
               4                  IF(EI<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IF(EI > SMFMXE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  WRITE(3,'(1PE15.4,1PE15.4)')XIN,YIN;
               4                  NUMSCATTER=NUMSCATTER+1;
               4                  ]
               3              ]
               2          ELSEIF(MSMFXY=1)["RECTANGULAR"
               3              IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
               3              &(XIN<SMFMXX(1))["inside the given field"
               4                  IF(EI<SMFMNE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  IF(EI > SMFMXE)[
               5                      GOTO :start-of-file-read0:;"discard the particle"
               5                      ]
               4                  WRITE(3,'(1PE15.4,1PE15.4)')XIN,YIN;
               4                  NUMSCATTER=NUMSCATTER+1;
               4                  ]
               3              ]
               2          IF(NUMSCATTER=MAXSCATTER) GOTO :end-of-file-read0:;
               2          ]
               1      ]"end of reading ph-sp data loop"
               0
               0  :end-of-file-read0:;
               0  RETURN;
               0  END;
               0
               0  %L                                                                             ;
               0  !LABELS 3000;
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  %I4                                                                            ;
1              0  %E
               0  %B132                                                                          ;
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  "*******************************************************************************
               0  SUBROUTINE ADD_FILES;
               0  "
               0  " THIS IS A SUBROUTINE USED BY BEAMDP TO COMBINE TWO PHASE-SPACE FILES
               0  " INTO ONE.
               0  "
               0  " PROGRAMMER C-M MA
               0  "
               0  "*******************************************************************************
               0
               0  "**VARIABLES**"
               0
               0  "---Force declarations of all variables---"
               0  IMPLICIT NONE;
               0
               0  COMIN/CHARACTERS;
               0  COMIN/DOUBLES;
               0  COMIN/REALS;
               0  COMIN/INTEGERS;
               0  COMIN/LOGICALS;
               0  COMIN/RWPHSP/;
               0
               0  $INTEGER len, lnblnk1, itmp;
               0
               0  $INITIALIZE_PHSP_VARIABLES;
               0
               0  i_log=6;
               0
               0  :TRY-AGAIN-1:;
               0  IF ~EGSPERT[ CALL HELP_MESSAGE(22); ]
               0  :RR2:
               0  OUTPUT ; (/' Name of the old ph-sp file 1: '/);
               0  INPUT OLDNAM ; (A80);
               0  IF(OLDNAM=' ')|(OLDNAM='?')[GOTO :RR1:;]
               0  GOTO :RR3:;
               0  :RR1:
               0  CALL HELP_MESSAGE(22);
               0  GOTO :RR2:;
               0  :RR3:
               0  i_iaea_in=0; "assume not in IAEA format"
               0  len=lnblnk1(OLDNAM);
               0  IF(OLDNAM(len-8:len)='.IAEAphsp')[
               1      i_iaea_in=1;
               1      OLDNAM=OLDNAM(:len-9);
               1      OUTPUT;(/' Data is in IAEA format.'/);
               1      ]
               0
               0  ;/PARANOT1,PARANOP1/=0;/PARAEMAX1,PARAEMNE1,PARANINC1/=0.;
               0  MODE_RW1=' ';IZLAST1=0; IMUIDX1=0; IZSCORE1=0;
               0
               0  IF(i_iaea_in=1)[
               1      i_unit_in=2;
               1      $IAEA_OPEN_PHSP_FOR_READ(i_unit_in,OLDNAM);
               1      $IAEA_READ_PHSP_HEADER(i_unit_in,PARANOT1,PARANOP1,PARAEMAX1,LPARANINC1,
               1      Z_SCORE,IZLAST1,IMUIDX1,IZSCORE1);
               1      OUTPUT PARANOT1,PARANOP1,PARAEMAX1,LPARANINC1;
               1      (/'            Total number of particles in file:',I13/
               1      '                      Total number of photons:',I13/
               1      '             The rest are electrons/positrons.'/
               1      ' '/
               1      '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
               1      ' # of incident particles from original source:',I13);
               1      IF(IZSCORE1=0)[
               2          OUTPUT Z_SCORE;
               2          ('                     Z where phsp file scored:',F13.3,' cm');
               2          ]
               1      IF(IZLAST1~=0)[
               2          OUTPUT;
               2          ( ' ZLAST scored in this file.');
               2          ]
               1      IF(IMUIDX1~=0)[
               2          OUTPUT;
               2          ( ' Fractional MU index scored in this file.');
               2          ]
               1      ]
               0
               0  ELSE[
               1
               1
               1      itmp=-1;
               1      $OPEN_PHSP_FOR_READ(itmp,2,OLDNAM,MODE_RW1,PARANOT1,
               1      PARANOP1,PARAEMAX1,PARAEMNE1,PARANINC1);
               1      IF(IERR_PHSP~=0) GOTO :RRR1:;
               1
               1      OUTPUT PARANOT1,PARANOP1,PARAEMAX1,PARAEMNE1;
               1      (/'            Total number of particles in file:',I13/
               1      '                      Total number of photons:',I13/
               1      '             The rest are electrons/positrons.'/
               1      ' '/
               1      '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
               1      '      Minimum kinetic energy of the electrons:',F13.3,' MeV');
               1      PARANOT=PARANOT1; "store total for later"
               1      IF(PARANINC1 < 2.)["an old file which stored min. phot. energy"
               2          OUTPUT PARANINC1;
               2          ('        Minimum kinetic energy of the photons:',F13.3,' MeV');
               2          ]
               1      ELSE[
               2          OUTPUT PARANINC1;
               2          (' # of incident particles from original source:',F13.1);
               2          ]
               1      ]
               0
               0  :TRY-AGAIN-2:;
               0
               0  OUTPUT ; (/' Name of the old ph-sp file 2: '/' ',$);
               0  INPUT SPCNAM ; (A80);
               0
               0  IF(SPCNAM = ' ')[GOTO :TRY-AGAIN-2:;]
               0
               0  i_iaea_out=0; "assume not in IAEA format"
               0  len=lnblnk1(SPCNAM);
               0  IF(SPCNAM(len-8:len)='.IAEAphsp')[
               1      i_iaea_out=1;
               1      SPCNAM=SPCNAM(:len-9);
               1      OUTPUT;(/' Data is in IAEA format.'/);
               1      ]
               0
               0  IF(i_iaea_in~=i_iaea_out)[
               1      OUTPUT;(//' *****ERROR*****'/
               1      ' Both phase space files must have the same format'/
               1      ' (IAEA or standard BEAMnrc).  Try again.'//);
               1      STOP;
               1      ]
               0
               0
               0  /PARANOT2,PARANOP2,LPARANINC2/=0;/PARAEMAX2,PARAEMNE2,PARANINC2/=0.;
               0  MODE_RW2=' ';IZLAST2=0;IMUIDX2=0; IZSCORE2=0;
               0
               0  IF(i_iaea_out=1)[
               1      i_unit_out=3;
               1      $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,SPCNAM,IZLAST2,1,Z_SCORE,IMUIDX2,
               1      IZSCORE2);
               1      $IAEA_READ_PHSP_HEADER(i_unit_out,PARANOT2,PARANOP2,PARAEMAX2,LPARANINC2,
               1      Z_SCORE,IZLAST2,IMUIDX2,IZSCORE2);
               1      OUTPUT PARANOT2,PARANOP2,PARAEMAX2,LPARANINC2;
               1      (/'            Total number of particles in file:',I13/
               1      '                      Total number of photons:',I13/
               1      '             The rest are electrons/positrons.'/
               1      ' '/
               1      '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
               1      ' # of incident particles from original source:',I13);
               1      IF(IZSCORE2=1)[
               2          OUTPUT Z_SCORE;
               2          ('                     Z where phsp file scored:',F13.3,' cm');
               2          ]
               1      IF(IZLAST2~=0)[
               2          OUTPUT;(' ZLAST scored in phase space data.');
               2          ]
               1      IF(IMUIDX2~=0)[
               2          OUTPUT;(' Fractional MU index scored in phase space data.');
               2          ]
               1      ]
               0
               0  ELSE[
               1
               1      itmp=-1;
               1      $OPEN_PHSP_FOR_READ(itmp,3,SPCNAM,MODE_RW2,
               1      PARANOT2,PARANOP2,PARAEMAX2,PARAEMNE2,PARANINC2);
               1      IF(IERR_PHSP~=0) GOTO :RRR2:;
               1
               1      OUTPUT PARANOT2,PARANOP2,PARAEMAX2,PARAEMNE2;
               1      (/'            Total number of particles in file:',I13/
               1      '                       Total number of photons:',I13/
               1      '             The rest are electrons/positrons.'/
               1      ' '/
               1      '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
               1      '      Minimum kinetic energy of the electrons:',F13.3,' MeV');
               1
               1      IF(PARANINC2 < 2.)["an old file which stored min. phot. energy"
               2          OUTPUT PARANINC2;
               2          ('        Minimum kinetic energy of the photons:',F13.3,' MeV');
               2          ]
               1      ELSE[
               2          OUTPUT PARANINC2;
               2          (' # of incident particles from original source:',F13.1);
               2          ]
               1      ]
               0  IF(i_iaea_in~=i_iaea_out)[
               1      OUTPUT;(//' *****ERROR*****'/
               1      ' Both phase space files must have the same format'/
               1      ' (IAEA or standard BEAMnrc).  Try again.'//);
               1      IF(i_iaea_in=1)[
               2          $IAEA_DESTROY_PHSP_FILE(i_unit_in);
               2          ]
               1      ELSE[ CLOSE(2);]
               1      IF(i_iaea_out=1)[
               2          $IAEA_DESTROY_PHSP_FILE(i_unit_out);
               2          ]
               1      ELSE[ CLOSE(3);]
               1      RETURN;
               1      ]
               0  ELSEIF((i_iaea_in=0 & MODE_RW2 ~= MODE_RW1) |
               0  (i_iaea_in=1 & IZLAST1 ~= IZLAST2))["FILES OF DIFFERENT MODES"
               1      OUTPUT;
               1      (/' SORRY, CANNOT COMBINE FILES OF DIFFERENT MODES!!! '/);
               1      OUTPUT;
               1      (/' PLEASE CONVERT FILES INTO EITHER MODE0 OR 2, THEN TRY AGAIN.'/);
               1      IF(i_iaea_in=1)[
               2          $IAEA_DESTROY_PHSP_FILE(i_unit_in);
               2          $IAEA_DESTROY_PHSP_FILE(i_unit_out);
               2          ]
               1      ELSE[
               2          CLOSE(2);
               2          CLOSE(3);
               2          ]
               1      RETURN;
               1      ]
               0  ELSEIF(i_iaea_in=1 & IZSCORE1 ~= IZSCORE2)[
               1      OUTPUT;
               1      (/' Error: One IAEA phase space file scores particle Z, while the'/
               1      ' other does not.  Cannot combine.'/);
               1      $IAEA_DESTROY_PHSP_FILE(i_unit_in);
               1      $IAEA_DESTROY_PHSP_FILE(i_unit_out);
               1      RETURN;
               1      ]
               0  ELSEIF(i_iaea_in=1 & IMUIDX1 ~= IMUIDX2)[
               1      OUTPUT;
               1      (/' Warning: One IAEA phase space file scores fractional MU index,'/
               1      ' while the other does not.  Combined file will lose this '/
               1      ' information.'/);
               1      ]
               0
               0  OUTPUT;(/' The contents of file 1 will be appended to file 2.'/);
               0
               0  OUTPUT;(/' BEGIN READING/WRITING PH-SP DATA .....'/);
               0
               0  IPARANOT2=PARANOT2+1;
               0
               0  IF(i_iaea_in=0 & MODE_RW1='MODE2') IZLAST1=1;
               0
               0  "check that summed files will not go over 2.147483648 GByte limit"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  NHSTRY=0;"no. of primary histories--ensures -E markers are preserved"
               0
               0  IF(i_iaea_in=1)[
               1      DO IPARANOT1=1,PARANOT1["read phase-space data from the data file 1"
               2          $IAEA_READ_PHSP_RECORD(i_unit_in,NPASSI,NHSTRY,LATCHI,IQ,EREAD,
               2          WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MUIDX);
               2          $IAEA_WRITE_PHSP_RECORD(i_unit_out,NPASSI,1,NHSTRY,LATCHI,IQ,EREAD,
               2          WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MUIDX);
               2          ]
               1      $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(i_unit_out,LPARANINC1+LPARANINC2);
               1      $IAEA_DESTROY_PHSP_FILE(i_unit_in);
               1      $IAEA_DESTROY_PHSP_FILE(i_unit_out);
               1      ]
               0  ELSE["standard BEAMnrc format"
               1
               1      PARANOP1=0; "only count photons as read in case we are not adding a full"
               1      "file"
               1      DO IPARANOT1=2,PARANOT1+1["read phase-space data from the data file 1"
               2          "NOTE THE SECOND RECORD STORES THE FIRST PARTICLE"
               2          $READ_PHSP_RECORD(IZLAST1,2,IPARANOT1:NHSTRY,ZLAST,LATCHI,EREAD,
               2          WEIGHT,XIN,YIN,UIN,VIN);
               2          IPARANOT2=IPARANOT2+1;
               2          PARANOP1=PARANOP1+1-IBITS(LATCHI,29,1)-IBITS(LATCHI,30,1);
               2          "bit 29 is set if electron, bit 30 if positron"
               2          $WRITE_PHSP_RECORD(IZLAST1,3,SPCNAM,IPARANOT2,1:NHSTRY,ZLAST,LATCHI,EREAD,
               2          WEIGHT,XIN,YIN,UIN,VIN);
               2          "write to file2"
               2          ]
               1      :end-of-file1-read:;
               1      $PHSP_BUFFER_FLUSH(IZLAST1,3,SPCNAM,IPARANOT2,1);
               1      "Re-write the first line of file 2"
               1      PARANOT2 = PARANOT2 + PARANOT1;
               1      PARANOP2 = PARANOP2 + PARANOP1;
               1      IF(PARANOT1>0 & PARAEMAX2 < PARAEMAX1)[PARAEMAX2=PARAEMAX1;]
               1      IF(PARANOT1>0 & PARAEMNE2 > PARAEMNE1)[PARAEMNE2=PARAEMNE1;]
               1      "COMPUTE NINC"
               1      NINC = (PARANOT1/PARANOT)*PARANINC1 + PARANINC2;
               1      IF((PARANINC1 < 2.)|(PARANINC2 < 2.))[
               2          OUTPUT;(/' FILE 1 AND/OR 2 IS AN OLDER FILE WHICH STORED',/
               2          ' MIN. PHOTON ENERGY INSTEAD OF # OF INCIDENT PARTICLES',/
               2          ' NUMBER OF INCIDENT PARTICLES SET TO 1 IN COMBINED FILE');
               2          NINC = 1;
               2          ]
               1      $WRITE_PHSP_HEADER(IZLAST1,3,SPCNAM,MODE_RW2,PARANOT2,PARANOP2,
               1      PARAEMAX2,PARAEMNE2,NINC);
 Unclosed quote?
               1      CLOSE(UNIT=2);
 Unclosed quote?
               1      CLOSE(UNIT=3);
               1      ]"end of standard BEAMnrc format"
               0  OUTPUT;(/' Finished reading/writing ph-sp data .....'/);
               0
               0  RETURN;
               0  :RRR2:;
               0  OUTPUT;(//' CANNOT FIND/OPEN THE PH-SP FILE!!!'///);
               0  "ask the user whether a different ph-sp file to be used"
               0  CALL HELP_MESSAGE(22);
               0  GOTO :TRY-AGAIN-2:;
               0  :RRR1: OUTPUT;(//' CANNOT FIND/OPEN THE PH-SP FILE!!!'///);
               0  "ask the user whether a different ph-sp file to be used"
               0  GOTO :RR1:;"OPEN FILE AGAIN"
               0
               0  END;
               0
               0  %L                                                                             ;
               0  !LABELS 20000;
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  %I4                                                                            ;
1              0  %E
               0  %B132                                                                          ;
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  "*******************************************************************************
               0  SUBROUTINE BEAMDP1;
               0  "
               0  " THIS IS A SUBROUTINE USED BY BEAMDP TO PROCESS BEAM DATA AND TO GENERATE
               0  " AN INPUT FILE FOR MULTIPLE SOURCE MODEL BEAM RE-CONSTRUCTION.
               0  "
               0  " PROGRAMMER C-M MA
               0  "
               0  "*******************************************************************************
               0
               0  "**VARIABLES**"
               0
               0  "---Force declarations of all variables---"
               0  IMPLICIT NONE;
               0
               0  REAL TENERGY,TPARTICLE,TEEE;
               0  REAL*8 TPPP;
               0
               0  LOGICAL RMINUNDEFINED;
               0
               0  COMIN/CHARACTERS;
               0  COMIN/DOUBLES;
               0  COMIN/REALS;
               0  COMIN/INTEGERS;
               0  COMIN/LOGICALS;
               0  ASSIGN-LETTERS;
               0
               0  :START-CHOICE1-0:;
               0
               0  IF(CHOICE1 = 0)[
               1
               1      OUTPUT;(/' INPUT A NUMBER TO CHOOSE AN OPTION: '/);
               1      OUTPUT;(' (0) - Input new sub-source specifiers & analyze ph-sp data');
               1      OUTPUT;(' (1) - Change sub-source specifiers in an existing source model');
               1      OUTPUT;(' (2) - Analyze ph-sp data using sub-source specifiers from an'/
               1      '       existing source model');
               1      OUTPUT;(' (3) - Plot characteristics of source model');
               1      OUTPUT;(' (4) - QUIT');
               1      OUTPUT;(' ',$);
               1      INPUT CHOICE;(I8);
               1
               1      IF(CHOICE = 4)RETURN;
               1      IF(CHOICE>4)|(CHOICE<0)[
               2          OUTPUT;(//' SORRY, NO SUCH OPTIONS!'/);
               2          RETURN;
               2          ]
               1      ]
               0
               0  IF ~EGSPERT[ CALL HELP_MESSAGE(59); ]
               0
               0  " ---------------------------------------------------------------------------- "
               0
               0  " Initialise variables for later use "
               0  RSSD1=0.0;
               0  K1=0;
               0  K2=0;
               0  K3=0;
               0  K4=0;
               0  KWEI=0.;
               0  DELTAZ=25.;
               0  SSMFPS=' ';
               0
               0  OLDFILE= .true.; "all options except 0 use an existing source parameter file"
               0
               0  " Input new sub-source specifiers & analyze ph-sp data "
               0  " ---------------------------------------------------- "
               0  IF(CHOICE=0)[
               1      OLDFILE=.false.; "default to entering sub-source specifiers from scratch"
               1      IF (~EGSPERT)[ CALL HELP_MESSAGE(60); ]
               1      :USE_REF_FILE:;
               1      OUTPUT ;
               1      (/
               1      ' Would you like to use sub-source specifiers from an existing source model'/
               1      ' as a reference? (y/n[Default])=> ',$);
               1      INPUT C1; (a1);
               1      IF (C1='?') [CALL HELP_MESSAGE(30); GOTO :USE_REF_FILE:;]
               1      IF (C1='y' | C1='Y') OLDFILE=.true.;
               1      ]
               0
               0  " Read existing sub-source specifiers "
               0  " ----------------------------------- "
               0  IF(OLDFILE)[
               1      IF ~EGSPERT[
               2          IF(CHOICE=0)[ CALL HELP_MESSAGE(55); ]
               2          ELSEIF(CHOICE=1)[ CALL HELP_MESSAGE(56); ]
               2          ELSEIF(CHOICE=2)[ CALL HELP_MESSAGE(57); ]
               2          ELSEIF(CHOICE=3)[ CALL HELP_MESSAGE(58); ]
               2          ]
               1      :READ_FILE_NAME:
               1      IF(CHOICE=0)[
               2          OUTPUT;
               2          (/' Source model containing sub-source specifiers to use as reference=> '/
               2          ' ',$);
               2          ]
               1      ELSEIF(CHOICE=1)[
               2          OUTPUT;
               2          (/' Source model containing sub-source specifiers to be modified=> '/
               2          ' ',$);
               2          ]
               1      ELSEIF(CHOICE=2)[
               2          OUTPUT;
               2          (/' Source model containing sub-source specifiers for analyzing phsp data=>'/
               2          ' ',$);
               2          ]
               1      ELSEIF(CHOICE=3)[
               2          OUTPUT;(/' Source model to plot=>'/' ',$);
               2          ]
               1
               1      " Input multiple-source file name "
               1      INPUT OLDNAM ; (A80);
               1      IF (OLDNAM='?') [
               2          CALL HELP_MESSAGE(49);
               2          GOTO :READ_FILE_NAME:;
               2          ]
               1      CLOSE(UNIT=3,STATUS='KEEP');
               1
               1      OPEN(UNIT=3,STATUS='OLD',FILE=OLDNAM,ERR=:AAA01:);
               1
               1      " Read existing multiple-source data "
               1      " ---------------------------------- "
               1      READ(3,'(A80)',ERR=:AAA01:)SSMFPS; "detailed descriptions of the source"
               1      READ(3,*,ERR=:AAA01:)NSMFPS; "number of sub-sources for the source model"
               1      DO I=1,NSMFPS["output from each sub-sources"
               2          READ(3,*,ERR=:AAA01:)ISMFPS(I),IQSMFP(I),LATCH(I);
               2          IF(CHOICE=2 & LATCH(I)>$NS)["print a warning of LATCH out of range"
               3              OUTPUT I,ISMFPS(I),IQSMFP(I),LATCH(I),$NS;
               3              (//' ***WARNING IN SUB-SOURCE ',I3,' (type=',I3,',charge=',I3,'):'/
               3              ' LATCH bit associated with source = ',I3/
               3              ' LATCH bit should be <=',I3/
               3              ' Bit will be selected anyway.'//);
               3              ]
               2          IF (ISMFPS(I) = 1) ["model for aperture applicators"
               3              READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),
               3              SMFMNY(I),SMFMXY(I),SMFX2(I),SMFY2(I);
               3              ]
               2          ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
               3              READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),
               3              SMFMNY(I),SMFMXY(I),SMFX2(I),SMFY2(I);
               3              ]
               2          ELSEIF (ISMFPS(I) = 2) ["model for collimators"
               3              READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),
               3              SMFMXY(I),SMFX2(I),SMFY2(I),SMFPXY(I);
               3              ]
               2          ELSEIF(ISMFPS(I) = 3)["model for ring, cone, and point source"
               3              READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD0;
               3              ]
               2          ELSEIF(ISMFPS(I) = 4) ["model for rectangular plane source"
               3              READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),
               3              SMFMNY(I),SMFMXY(I);
               3              ]
               2          ELSE["model for circular plane source"
               3              READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMNR(I);
               3              ]
               2          ]"end of read for each sub-source"
               1
               1      " In case user writes his own input data, try 1 source first "
               1      DO I=1,1[
               2          " Energy spectrum "
               2          READ(3,*,ERR=:AAA01:)NSMFEE,SMFMNE,SMFMXE;
               2          " Energy spectrum type "
               2          READ(3,*,ERR=:AAA01:)ESTYPE;
               2          IF(ESTYPE = 0) [
               3              " energy spectrum type for Inside/outside the treatment field"
               3              READ(3,*,ERR=:AAA01:)RTREATe,RFIELDe;
               3              NFIELDe=2;
               3              ERADII(1) = RTREATe;
               3              ERADII(2) = RFIELDe;
               3              ]
               2          ELSE [
               3              " energy spectrum with different radii "
               3              READ(3,*,ERR=:AAA01:)NFIELDe,RFIELDe;
               3              READ(3,*,ERR=:AAA01:)(ERADII(II),II=1,NFIELDe);
               3              ]
               2
               2          " Field type "
               2          READ(3,*,ERR=:AAA01:)MSMFXY;
               2          IF(MSMFXY = 0)["circular field distribution"
               3              READ(3,*,ERR=:AAA01:)NFIELDi,RTREAT,NFIELDo,RFIELD;
               3              ]
               2          ELSEIF(MSMFXY = 1)["square field with symmetrical rings"
               3              READ(3,*,ERR=:AAA01:)NFIELDi,RTREAT,NFIELDo,RFIELD;
               3              ]
               2          ELSEIF(MSMFXY = 2)["rectangular field"
               3              READ(3,*,ERR=:AAA01:)NFIELD,XFLDMN,XFLDMX,YFLDMN,YFLDMX;
               3              READ(3,*,ERR=:AAA01:)XTREATMN,XTREATMX,YTREATMN,YTREATMX;
               3              ]
               2          READ(3,'(A100)',ERR=:AAA01:)PSDNAM;
               2          ]
               1
               1      GOTO :AA01:;
               1      :AAA01:
               1      CALL HELP_MESSAGE(49);
               1      GOTO :READ_FILE_NAME:;
               1      :AA01:
               1      ] " end of reading existing sub-source specifiers "
               0
               0
               0  " Change sub-source specifiers in an existing source model "
               0  " Plot characteristics of source model "
               0  " ------------------------------------ "
               0  IF(CHOICE=1)|(CHOICE=3)[
               1      " Read parameters from the input file for each sub-source "
               1      DO I=1,NSMFPS[
               2          READ(3,*,ERR=:A001:)II;
               2          IF(I ~= II)[GOTO :A000001:;"data not right"]
               2          READ(3,*,ERR=:A001:)ISMFPS(I),IQSMFP(I),LATCH(I);
               2          IF (ISMFPS(I) = 1) ["model for aperture applicators"
               3              READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),
               3              SMFMNY(I),SMFMXY(I),SMFX2(I),SMFY2(I);
               3              ]
               2          ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
               3              READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),
               3              SMFMNY(I),SMFMXY(I),SMFX2(I),SMFY2(I);
               3              ]
               2          ELSEIF (ISMFPS(I) = 2) ["model for collimators"
               3              READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),
               3              SMFMXY(I),SMFX2(I),SMFY2(I),SMFPXY(I);
               3              ]
               2          ELSEIF(ISMFPS(I) = 3)["model for ring, cone, and point source"
               3              READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD0;
               3              ]
               2          ELSEIF(ISMFPS(I) = 4) ["model for rectangular plane source"
               3              READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),
               3              SMFMNY(I),SMFMXY(I);
               3              ]
               2          ELSE["model for circular plane source"
               3              READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMNR(I);
               3              ]
               2
               2          " Relative source intensity "
               2          READ(3,*,ERR=:A001:)SMFRTN(I);
               2          " Number of bins, maximum and minimum energy "
               2          READ(3,*,ERR=:A001:)NSMFEE,SMFMNE,SMFMXE;
               2
               2          DO III=1,NFIELDe[
               3              READ(3,*,ERR=:A001:) (FSMFBN1(I,III,II),II=1,NSMFEE);
               3              ]
               2
               2          " Fielf type"
               2          READ(3,*,ERR=:A001:)MSMFXY;
               2
               2          IF(MSMFXY = 0)["circular field distribution"
               3              READ(3,*,ERR=:A001:)NFIELDi,RTREAT,NFIELDo,RFIELD;
               3              NFIELD = NFIELDi + NFIELDo;
               3              "probability for each bin"
               3              READ(3,*,ERR=:A001:)(FSMFRR(I,II),II=1,NFIELD);
               3              ]
               2          ELSEIF(MSMFXY = 1)["square field with symmetrical square rings"
               3              READ(3,*,ERR=:A001:)NFIELDi,RTREAT,NFIELDo,RFIELD;
               3              NFIELD = NFIELDi + NFIELDo;
               3              READ(3,*,ERR=:A001:)(FSMFRR(I,II),II=1,NFIELD);
               3              READ(3,*)(FSMFR11(I,II),II=1,NFIELD);"parameters used in sampling"
               3              READ(3,*)(FSMFR12(I,II),II=1,NFIELD);"parameters used in sampling"
               3              "probability for each bin"
               3              ]
               2          ELSEIF(MSMFXY = 2)["rectangular field"
               3              READ(3,*,ERR=:A001:)NFIELD,XFLDMN,XFLDMX;
               3              READ(3,*,ERR=:A001:)NFIELD,YFLDMN,YFLDMX;
               3              READ(3,*,ERR=:A001:)((FSMFXY(I,II,III),II=1,NFIELD),
               3              III=1,NFIELD);
               3              "probability for each bin"
               3              ]
               2          ]"end of read for each sub-source"
               1
               1      READ(3,*,ERR=:A001:) (FSMABN1(II),II=1,$NBINANGLE);
               1      ABNTOTAL=0.;
               1      DO II=1,$NBINANGLE[ABNTOTAL=ABNTOTAL+FSMABN1(II);]
               1      ABNTOTALH=0.;
               1      DO II=1,$NBINANGLE[
               2          ABNTOTALH=ABNTOTALH+FSMABN1(II);
               2          IF((ABNTOTAL ~= 0.) & (ABNTOTALH/ABNTOTAL >= 0.5))[
               3              RSCATT=100.*TAN(FLOAT(II)*0.1745/FLOAT($NBINANGLE));
               3              "calculating mean scattering radius"
               3              IF((RSCATT <= 0.) & (RSCATT > 50.))[RSCATT=5.;]
               3              GOTO :FOUND-RSCATT:;
               3              ]
               2          ]
               1      :FOUND-RSCATT:;
               1
               1      GOTO :A0001:;
               1      :A000001:OUTPUT;
               1      (//' SUB-SOURCES ARE NOT IN THE RIGHT ORDER, WHY?'//);GOTO :A0001:;
               1      :A001: OUTPUT;
               1      (//' ENERGY OR PLANAR FLUENCE MAY NOT BE CORRECT!'//);
               1      :A0001:
               1      CLOSE(UNIT=3,STATUS='KEEP');
               1      OUTPUT;
               1      (//' WARNING: data contained in the file may not be right if it was'/
               1      '          created before the execution of the programme BEAMDP'/
               1      '          was completed!!!'/);
               1      IF(CHOICE=3)GOTO :DATA-FOR-GRAPH-PLOTTING:;
               1      ] " END OF CHOICE=1 OR 3 "
               0
               0  IF ~EGSPERT[ CALL HELP_MESSAGE(54); ]
               0  :A:
               0  OUTPUT;(/' File name for the new/modified source model:'/' ',$);
               0  INPUT SPCNAM ; (A80);
               0  IF (SPCNAM='?') [
               1      CALL HELP_MESSAGE(31);
               1      GO TO :A:;
               1      ]
               0
               0  IF (SPCNAM=' ') [
               1      IF (OLDNAM=' ') [
               2          OLDNAM='beamdp.tmp';
               2          OUTPUT;(/' FILE NAME DEFAULT TO [beamdp.tmp]'/);
               2          ]
               1      SPCNAM=OLDNAM;
               1      ]
               0
               0  IF ~EGSPERT[ CALL HELP_MESSAGE(32); ]
               0  :B:
               0  OUTPUT ; (/' Detailed information about the source: ');
               0  IF(SSMFPS ~= ' ')[
               1      OUTPUT SSMFPS;(/' THE OLD INFORMATION WAS:'/' ', A80/
               1      ' (Return to keep the information, otherwise type in the new one):'/);
               1      ]
               0  INPUT DSMFPS ; (A80);
               0  IF(DSMFPS='?') [CALL HELP_MESSAGE(32); GO TO :B:;]
               0  IF(DSMFPS ~= ' ')[SSMFPS=DSMFPS;]
               0  ELSEIF(SSMFPS = ' ')[
               1      OUTPUT;(/' INFORMATION ABOUT THE SIMULATED BEAM (to be filled later)'/);
               1      SSMFPS='to-be-filled-later';
               1      ]
               0
               0  IF(CHOICE = 2)[
               1      RSSD1=RSSD0;"radius of a ring for SSD analysis"
               1      GOTO :OPEN-PHSP-FILE:;
               1      ]
               0
               0  IF ~EGSPERT[ CALL HELP_MESSAGE(33); ]
               0  :C:
               0  OUTPUT ; (/' Number of sub-sources=> ',$);
               0  IF OLDFILE[
               1      OUTPUT NSMFPS; "number of sub-sources for the source model"
               1      (/' The old value was',I4,'. You cannot change this value.'/);
               1      ]
               0  ELSE[
               1      INPUT C2;(A2);
               1      IF (C2='? ') [ CALL HELP_MESSAGE(33);   GO TO :C:; ]
               1      READ(C2,'(I8)')NSMFPS ; "number of sub-sources for the source model"
               1      IF (NSMFPS < 1)|(NSMFPS > $NS) [CALL HELP_MESSAGE(33);   GO TO :C:; ]
               1      ]
               0
               0  DO I=1,NSMFPS["input parameters for each sub-source"
               1
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(34); ]
               1      :D1:
               1      OUTPUT I;
               1      (/' INPUT PARAMETERS FOR SUB-SOURCE',I4,':'//
               1      ' SOURCE TYPE(1&11-appl,2-coll,3-ring,4-rect.plane,5-circ.plane),'/
               1      ' CHARGE OF PARTICLES (0-photons,-1-electrons,1-positrons),'/
               1      ' LATCH NUMBER FOR THE SUB-SOURCE DURING BEAM SIMULATION'/' ',$);
               1      IF OLDFILE[
               2          OUTPUT ISMFPS(I),IQSMFP(I),LATCH(I);
               2          (/' The old values were',3I4,'.'/' Do you want to change them?'/' ',$);
               2          INPUT C1;(A1);
               2          IF (C1='?') [   GO TO :D:; ]
               2          IF (C1='y')|(C1='Y') [
               3              OUTPUT I;
               3              (//' INPUT PARAMETERS FOR SUB-SOURCE:',I4///
               3              ' SOURCE TYPE (1&11-appl,2-coll,3-ring,4-rect.plane,5-circ.plane),'/
               3              ' CHARGE OF PARTICLES (0-photons,-1-electrons,1-positrons), AND'/
               3              ' LATCH NUMBER FOR THE SUB-SOURCE DURING BEAM SIMULATION'/);
               3              ]
               2          ELSE[GOTO :DD:;]
               2          ]
               1      READ(5,'(3I15)',ERR=:D:) ISMFPS(I),IQSMFP(I),LATCH(I);
               1      GOTO :DD:;
               1      :D:
               1      CALL HELP_MESSAGE(34);
               1      GOTO :D1:;
               1      :DD:;
               1      IF ((ISMFPS(I)<1)|(ISMFPS(I)>11)|(IQSMFP(I)<-1)
               1      |(IQSMFP(I)>1)) [
               2          OUTPUT;(/' SORRY, OUT OF RANGE!!!'//);
               2          GO TO :D:;
               2          ]
               1      IF(LATCH(I) > $NS)[
               2          OUTPUT $NS;
               2          (///' SORRY, LATCH BIT MUST BE <=',I3,'!!!'//)
               2          GOTO :D:;
               2          ]
               1
               1      IF(ISMFPS(I)=1)["sub-source is applicator"
               2          IF ~EGSPERT[ CALL HELP_MESSAGE(35); ]
               2          :E:
               2          OUTPUT;
               2          (/' Zmin, X-, X+, Y-, Y+, |x|max, |y|max (in cm) OF THE SOURCE:'/
               2          ' ',$);
               2          IF OLDFILE[
               3              OUTPUT SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               3              SMFX2(I),SMFY2(I);
               3              (/' The old values were',7F10.3,'.'/
               3              ' Do you want to change them?'/' ',$);
               3              INPUT C1;(A1);
               3              IF (C1='?') [GO TO :EEE:; ]
               3              IF (C1='y')|(C1='Y') [
               4                  OUTPUT;
               4                  (/' Zmin, X-, X+, Y-, Y+, |x|max, |y|max (in cm) OF THE SOURCE:'
               4                  /' ',$);
               4                  ]
               3              ELSE[GOTO :EE:;]
               3              ]
               2          READ(5,'(7F15.0)',ERR=:EEE:)
               2          SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),SMFX2(I),SMFY2(I);
               2          GOTO :EE:;
               2          :EEE:
               2          CALL HELP_MESSAGE(35);
               2          GO TO :E:;
               2          :EE:;
               2          IF (SMFMNZ(I)<0.)|(SMFMNX(I)>= SMFMXX(I))|
               2          (SMFMNY(I)>= SMFMXY(I))[
               3              OUTPUT;(//' SORRY, Zmin MUST BE >= 0.0 cm');
               3              OUTPUT;(  '        X+ MUST BE > X-');
               3              OUTPUT;(  '        Y+ MUST BE > Y-'//);
               3              GO TO :E:;
               3              ]
               2          HFIELD(I)=(SMFMXX(I)-SMFMNX(I)+SMFMXY(I)-SMFMNY(I))*1.1/4.;
               2          "a factor of 1.1 is used here to account for the variation of"
               2          "distance and weighting from different part of the source"
               2
               2          ]"end of sub-source = 1"
               1
               1      ELSEIF(ISMFPS(I)=11)["sub-source is tubular applicator"
               2          IF ~EGSPERT[ CALL HELP_MESSAGE(36); ]
               2          :E11:
               2          OUTPUT;(/' Zmin,Zmax,X-,X+,Y-,Y+,|x|max,|y|max (in cm) OF THE SOURCE:'/);
               2          IF OLDFILE[
               3              OUTPUT SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               3              SMFX2(I),SMFY2(I);
               3              (/' The old values were',8F10.3,'.'/
               3              ' Do you want to change them?'/' ',$);
               3              INPUT C1;(A1);
               3              IF (C1='?') [   GO TO :EEE11:; ]
               3              IF (C1='y')|(C1='Y') [
               4                  OUTPUT;(/' Zmin,Zmax,X-,X+,Y-,Y+,|x|max,|y|max (in cm) OF THE SOURCE:'/);
               4                  ]
               3              ELSE[GOTO :EE11:;]
               3              ]
               2          READ(5,'(7F15.0)',ERR=:EEE11:)
               2          SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I);
               2          GOTO :EE11:;
               2          :EEE11:
               2          CALL HELP_MESSAGE(36);
               2          GOTO :E11:;
               2          :EE11:;
               2          IF (SMFMNZ(I)<0.)|(SMFMNZ(I)>SMFMXZ(I))|(SMFMNX(I)>= SMFMXX(I))|
               2          (SMFMNY(I)>= SMFMXY(I))[
               3              OUTPUT;(//' SORRY, Zmax MUST BE >= Zmin >=0.0 cm');
               3              OUTPUT;(  '        X+ MUST BE > X-');
               3              OUTPUT;(  '        Y+ MUST BE > Y-'//);
               3              GO TO :E11:;
               3              ]
               2          HFIELD(I)=(SMFMXX(I)-SMFMNX(I)+SMFMXY(I)-SMFMNY(I))*1.1/4.;
               2          "a factor of 1.1 is used here to account for the variation of"
               2          "distance and weighting from different part of the source"
               2
               2          ]"end of sub-source = 11"
               1
               1      ELSEIF(ISMFPS(I)=2)["sub-source is collimator"
               2          IF ~EGSPERT[ CALL HELP_MESSAGE(37); ]
               2          :F:
               2          OUTPUT;
               2          (/' Zmin,X-,X+,Y-,Y+,|x|max,|y|max(in cm),Orientation OF THE SOURCE'/
               2          ' (0-collimator bars along x-axis,1-along y-axis):'/' ',$);
               2          IF OLDFILE[
               3              OUTPUT SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               3              SMFX2(I),SMFY2(I),SMFPXY(I);
               3              (/' The old values were',7F10.3,I4,'.'/
               3              ' Do you want to change them?'/' ',$);
               3              INPUT C1;(A1);
               3              IF (C1='?') [   GO TO :FFF:; ]
               3              IF (C1='y')|(C1='Y') [
               4                  OUTPUT;
               4                  (/' Zmin,X-,X+,Y-,Y+,|x|max,|y|max(in cm),Orientation OF THE SOURCE'/
               4                  '  (0-collimator bars along x-axis,1-along y-axis):'/' ',$);
               4                  ]
               3              ELSE[GOTO :FF:;]
               3              ]
               2          READ(5,'(7F15.0,I4)',ERR=:FFF:)
               2          SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I),SMFPXY(I);
               2          GOTO :FF:;
               2          :FFF:
               2          CALL HELP_MESSAGE(37);
               2          GOTO :F:;
               2          :FF:;
               2          IF ((SMFMNZ(I)<0.)|(SMFMNX(I)>= SMFMXX(I))|
               2          (SMFMNY(I)>= SMFMXY(I))|(SMFPXY(I)<0.0)|(SMFPXY(I)>1.))[
               3              OUTPUT;(//' SORRY, SSD  MUST BE >= 0.0');
               3              OUTPUT;(  '        X+ MUST BE > X-');
               3              OUTPUT;(  '        Y+ MUST BE > Y-');
               3              OUTPUT;(  '        Orientation must be = 0 or 1'//);
               3              GO TO :F:;
               3              ]
               2          HFIELD(I)=(SMFMXX(I)-SMFMNX(I)+SMFMXY(I)-SMFMNY(I))/4.;
               2          ]"end of sub-source = 2"
               1
               1
               1      ELSEIF(ISMFPS(I) = 3)["sub-source is ring, cone or point source"
               2          IF ~EGSPERT[ CALL HELP_MESSAGE(38); ]
               2          :G:
               2          OUTPUT;
               2          (/' SSD, Rmin and Rmax OF THE SOURCE(=0 for point source):'
               2          /' ',$);
               2          IF OLDFILE[
               3              OUTPUT SMFMNZ(I),SMFMNR(I),SMFMXR(I);
               3              (/' The old values were',3F10.3,'.'/
               3              ' Do you want to change them?'/' ',$);
               3              INPUT C1;(A1);
               3              IF (C1='?') [   GO TO :GGG:; ]
               3              IF (C1='y')|(C1='Y') [
               4                  OUTPUT;
               4                  (/' SSD, Rmin and Rmax OF THE SOURCE(=0 for point source):'
               4                  /' ',$);
               4                  ]
               3              ELSE[GOTO :GG:;]
               3              ]
               2          READ(5,'(3F15.0)',ERR=:GGG:)SMFMNZ(I),SMFMNR(I),SMFMXR(I);
               2          GOTO :GG:;
               2          :GGG:
               2          CALL HELP_MESSAGE(38);
               2          GOTO :G:;
               2          :GG:;
               2          IF (SMFMNZ(I)<0.)|(SMFMNR(I)<0.0)|(SMFMNR(I) > SMFMXR(I))[
               3              OUTPUT;(//' SORRY, SSD  MUST BE >= 0.0');
               3              OUTPUT;(  '        Radius MUST BE >= 0.0'//);
               3              OUTPUT;(  '        Rmax MUST BE >= Rmin'//);
               3              GO TO :G:;
               3              ]
               2          IF(SMFMNR(I) < 1.0)&(SMFMNZ(I) > 50.)&(RSSD0 ~= 1000.)[
               3              "a point source or a ring with a small radius but large SSD"
               3              "RSSD0 = 1000.0 means that ring radius has not been set"
               3              IF ~EGSPERT[ CALL HELP_MESSAGE(39); ]
               3              :G1:
               3              OUTPUT;
               3              (/' Radius(cm) of a ring region on the surface for SSD analysis:'/
               3              ' ',$);
               3              IF OLDFILE[
               4                  OUTPUT RSSD0;
               4                  (/' The old value was',F10.3,'.'/
               4                  ' Do you want to change it?'/' ',$);
               4                  INPUT C1;(A1);
               4                  IF (C1='?') [   GO TO :GGG1:; ]
               4                  IF (C1='y')|(C1='Y') [
               5                      OUTPUT;
               5                      (/' Radius(cm) of a ring region on the surface for SSD analysis:'
               5                      /' ',$);
               5                      ]
               4                  ELSE[GOTO :GG1:;]
               4                  ]
               3              READ(5,'(F15.0)',ERR=:GGG1:)RSSD0;
               3              GOTO :GG1:;
               3              :GGG1:
               3              CALL HELP_MESSAGE(39);
               3              GOTO :G1:;
               3              :GG1:
               3              IF (RSSD0<0.)[
               4                  OUTPUT;(//' SORRY, Radius  MUST BE >= 0.0'/);
               4                  GO TO :GGG1:;
               4                  ]
               3              IF(RSSD0 = RSSD1)[
               4                  OUTPUT;(///' SORRY, YOU CAN ONLY HAVE ONE POINT SOURCE!!!'//
               4                  ' THINK ABOUT IT AND TRY AGAIN.'//);
               4                  STOP;
               4                  ]
               3              RSSD1=RSSD0;"first time using point source, we take this value"
               3              RSSD0=1000.;"flag: ring radius has been set"
               3              ]"end of point-source case"
               2          HFIELD(I)=SMFMNR(I);
               2          ]"end of sub-source = 3"
               1
               1      ELSEIF(ISMFPS(I) = 4)["sub-source is a rectangular plane source"
               2          IF ~EGSPERT[ CALL HELP_MESSAGE(40); ]
               2          :G4:
               2          OUTPUT;
               2          (/' SSD, X-, X+, Y- and Y+ (in cm) OF THE SOURCE:',$);
               2          IF OLDFILE[
               3              OUTPUT SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I);
               3              (/' The old values were',5F10.3,'.'/
               3              ' Do you want to change them?'/' ',$);
               3              INPUT C1;(A1);
               3              IF (C1='?') [   GO TO :GGG4:; ]
               3              IF (C1='y')|(C1='Y') [
               4                  OUTPUT;
               4                  (/' SSD, X-, X+, Y- and Y+ (in cm) OF THE SOURCE:',$);
               4                  ]
               3              ELSE[GOTO :GG4:;]
               3              ]
               2          READ(5,'(5F15.0)',ERR=:GGG4:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),
               2          SMFMNY(I),SMFMXY(I);
               2          GOTO :GG4:;
               2          :GGG4:
               2          CALL HELP_MESSAGE(40);
               2          GOTO :G4:;
               2          :GG4:;
               2          IF (SMFMNZ(I)<0.)|(SMFMXX(I)<SMFMNX(I))|(SMFMNY(I) > SMFMXY(I))[
               3              OUTPUT;(//' SORRY, SSD  MUST BE >= 0.0');
               3              OUTPUT;(  '        X+ MUST BE > X-'//);
               3              OUTPUT;(  '        Y+ MUST BE > Y-'//);
               3              GO TO :GGG4:;
               3              ]
               2          ]
               1
               1      ELSEIF(ISMFPS(I) = 5)["sub-source is a plane source"
               2          IF ~EGSPERT[ CALL HELP_MESSAGE(41); ]
               2          :G5:
               2          OUTPUT;
               2          (/' SSD and Radius (in cm) OF THE SOURCE:'/ ' ',$);
               2          IF OLDFILE[
               3              OUTPUT SMFMNZ(I),SMFMNR(I);
               3              (/' The old values were',2F10.3,'.'/
               3              ' Do you want to change them?'/' ',$);
               3              INPUT C1;(A1);
               3              IF (C1='?') [   GO TO :GGG5:; ]
               3              IF (C1='y')|(C1='Y') [
               4                  OUTPUT;
               4                  (/' SSD and Radius (in cm) OF THE SOURCE:'/ ' ',$);
               4                  ]
               3              ELSE[GOTO :GG5:;]
               3              ]
               2          READ(5,'(2F15.0)',ERR=:GGG5:)SMFMNZ(I),SMFMNR(I);
               2          GOTO :GG5:;
               2          :GGG5:
               2          CALL HELP_MESSAGE(41);
               2          GOTO :G5:;
               2          :GG5:;
               2          IF (SMFMNZ(I)<0.)|(SMFMNR(I)<0.0)[
               3              OUTPUT;(//' SORRY, SSD  MUST BE >= 0.0');
               3              OUTPUT;(  '        Radius MUST BE >= 0.0'//);
               3              GO TO :GGG5:;
               3              ]
               2          ]
               1
               1      ]"end of I loop"
               0
               0
               0  " Energy spectrum "
               0  " --------------- "
               0  IF ~EGSPERT[ CALL HELP_MESSAGE(42); ]
               0  :H:
               0  OUTPUT; (/' Nbin, Emin, Emax (in MeV, kinetic only) for the spectrum:'/
               0  ' ',$);
               0  IF OLDFILE[
               1      OUTPUT NSMFEE,SMFMNE,SMFMXE;
               1      (/' The old values were',I4,2F10.3,'.'/
               1      ' Do you want to change them?'/' ',$);
               1      INPUT C1;(A1);
               1      IF (C1='?') [   GO TO :HHH:; ]
               1      IF (C1='y')|(C1='Y') [
               2          OUTPUT;
               2          (/' Nbin, Emin, Emax (in MeV, kinetic only) for the spectrum:'/' ',$);
               2          ]
               1      ELSE[GOTO :HH:;]
               1      ]
               0  READ(5,'(I15,2F15.0)',ERR=:HHH:) NSMFEE,SMFMNE,SMFMXE;
               0  OUTPUT NSMFEE,SMFMNE,SMFMXE; (I6,2F12.4);
               0  GOTO :HH:;
               0  :HHH:
               0  CALL HELP_MESSAGE(42);
               0  GOTO :H:;
               0  :HH:;
               0  IF ((SMFMNE<0.0)|(SMFMNE>SMFMXE)|(SMFMXE<0.0)|(NSMFEE>$NB)|(NSMFEE<1)) [
               1      OUTPUT $NB;(/' Sorry, energies should be Emax > Emin > 0.0 '/
               1      '    and bin number must be between 1 and ',I4,'!!!'/);
               1      GO TO :HHH:;
               1      ]
               0
               0  " Energy spectrum type "
               0  " -------------------- "
               0  IF ~EGSPERT[ CALL HELP_MESSAGE(80); ]
               0  :EST1:
               0  OUTPUT; (/' ENERGY SPECTRUM TYPE ',
               0  '(0-inside/outside treatment field, 1-different radii):'/' ',$);
               0  IF OLDFILE[
               1      OUTPUT ESTYPE;
               1      (/' The old value was',I4,'.'/' Do you want to change it?'/' ',$);
               1      INPUT C1;(A1);
               1      IF (C1='?') [   GO TO :EST3:; ]
               1      IF (C1='y')|(C1='Y') [
               2          OUTPUT;
               2          (/' ENERGY SPECTRUM TYPE (0-inside/outside, 1-different radii):'/' ',$);
               2          ]
               1      ELSE[GOTO :EST2:;]
               1      ]
               0  READ(5,'(I15)',ERR=:EST3:) ESTYPE;
               0  GOTO :EST2:;
               0  :EST3:
               0  CALL HELP_MESSAGE(80);
               0  GOTO :EST1:;
               0  :EST2:;
               0  IF ((ESTYPE<0)|(ESTYPE>1)) [
               1      OUTPUT;(/' SORRY, NO SUCH ENERGY SPECTRUM TYPE!!!'//);
               1      GO TO :EST3:;
               1      ]
               0
               0  " energy spectrum type for Inside/outside the treatment field"
               0  " ----------------------------------------------------------- "
               0  IF (ESTYPE = 0)[
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(81);]
               1      :ES01:
               1      OUTPUT;(/' R_treatment,R_scoring:'/' ',$);
               1      IF OLDFILE[
               2          OUTPUT RTREATe,RFIELDe;
               2          (/' The old values were',F10.3,F10.3,'.'/
               2          'Do you want to change them?'/' ',$);
               2          INPUT C1;(A1);
               2          IF (C1='?') [ GO TO :ES03:; ]
               2          IF (C1='y')|(C1='Y') [
               3              OUTPUT;(/' R_treatment,R_scoring:'/' ',$);
               3              ]
               2          ELSE[GOTO :ES02:;]
               2          ]
               1      READ(5,'(F15.0,F15.0)',ERR=:ES03:) RTREATe,RFIELDe;
               1      GOTO :ES02:;
               1      :ES03:
               1      CALL HELP_MESSAGE(81);
               1      GOTO :ES01:;
               1      :ES02:;
               1      IF (RTREATe<0.0001)|(RFIELDe<RTREATe)[
               2          OUTPUT;(//' SORRY, RADIUS  MUST BE >= 0.0001' /
               2          ' AND DEFINED FIELD MUST BE INSIDE SCORING FIELD');
               2          GO TO :ES03:;
               2          ]
               1      " Success, set NFIELDe = 2 for this energy type "
               1      NFIELDe = 2;
               1      ERADII(1) = RTREATe;
               1      ERADII(2) = RFIELDe;
               1      ]
               0  " energy spectrum with different radii "
               0  " ------------------------------------ "
               0  ELSEIF(ESTYPE = 1)[
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(82); ]
               1      :ES11:
               1      OUTPUT;(/' NbinEn,R_scoring:'/' ',$);
               1      IF OLDFILE[
               2          OUTPUT NFIELDe,RFIELDe;
               2          (/' The old values were',I4,F10.3,'.'/
               2          'Do you want to change them?'/' ',$);
               2          INPUT C1;(A1);
               2          IF (C1='?') [   GO TO :ES13:; ]
               2          IF (C1='y')|(C1='Y') [
               3              OUTPUT;(/' NbinEn,R_scoring:'/' ',$);
               3              ]
               2          ELSE[GOTO :ES12:;]
               2          ]
               1      READ(5,'(I12,F15.0)',ERR=:ES13:) NFIELDe,RFIELDe;
               1      GOTO :ES12:;
               1      :ES13:
               1      CALL HELP_MESSAGE(82);
               1      GOTO :ES11:;
               1      :ES12:;
               1      IF (RFIELDe<0.0001)|(NFIELDe<1)|(NFIELDe>$NB)[
               2          OUTPUT;(//' SORRY, SCORING FIELD RADIUS MUST BE >= 0.0001,');
               2          OUTPUT $NB;
               2          (         ' AND NUMBER OF BINS MUST BE BETWEEN 1 AND ',I5,'!'//);
               2          GO TO :ES13:;
               2          ]
               1      " Success, NFIELDe is the number of different radii "
               1      " Now, read different radii "
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(83); ]
               1      :ESR1:
               1      WRITE(6,*) ('R[',I,'],',I=1,NFIELDe);
               1      IF OLDFILE[
               2          WRITE(6,*)(ERADII(I),I=1,NFIELDe); "different radii for energy spectra"
               2
               2          OUTPUT (ERADII(I),I=1,NFIELDe);
               2          (/' The old values were',A,'.'/'Do you want to change it?'/' ',$);
               2          INPUT C1;(A1);
               2          IF (C1='?') [   GO TO :ESR3:; ]
               2          IF (C1='y')|(C1='Y') [
               3              WRITE(6,*) ('R[',I,'],',I=1,NFIELDe);
               3              ]
               2          ELSE[GOTO :ESR2:;]
               2          ]
               1      READ(5,*,ERR=:ESR3:)(ERADII(I),I=1,NFIELDe);
               1      GOTO :ESR2:;
               1      :ESR3:
               1      CALL HELP_MESSAGE(83);
               1      GOTO :ESR1:;
               1      :ESR2:;
               1      DO I=1,NFIELDe[
               2          IF (ERADII(I)<0.0001)|(ERADII(I)>RFIELDe)[
               3              OUTPUT;(//' SORRY, RADIUS  MUST BE >= 0.0001' /
               3              ' AND MUST BE INSIDE SCORING FIELD');
               3              GO TO :ESR3:;
               3              ]
               2          ]
               1      IF (ERADII(NFIELDe) ~= RFIELDe)[
               2          OUTPUT;(//' SORRY, LAST RADIUS MUST BE EQUAL TO R_scoring,');
               2          GO TO :ESR3:;
               2          ]
               1      ]"end of energy spectrum with different radii"
               0
               0  " Field type "
               0  " ---------- "
               0  IF ~EGSPERT[ CALL HELP_MESSAGE(43); ]
               0  :I:
               0  OUTPUT; (/' FIELD TYPE (0-circular ring,1-square ring,2-rectangular):'/' ',$);
               0  IF OLDFILE[
               1      OUTPUT MSMFXY ;
               1      (/' The old value was',I4,'.'/' Do you want to change it?'/' ',$)
               1      INPUT C1;(A1);
               1      IF (C1='?') [   GO TO :III:; ]
               1      IF (C1='y')|(C1='Y') [
               2          OUTPUT;
               2          (/' INPUT FIELD TYPE (0-circular, 1-square, 2-rectangular):'/' ',$);
               2          ]
               1      ELSE[GOTO :II:;]
               1      ]
               0  READ(5,'(I15)',ERR=:III:) MSMFXY ;
               0  GOTO :II:;
               0  :III:
               0  CALL HELP_MESSAGE(43);
               0  GOTO :I:;
               0  :II:;
               0  IF ((MSMFXY<0)|(MSMFXY>2)) [
               1      OUTPUT;(/' SORRY, NO SUCH FIELD TYPE!!!'//);
               1      GO TO :III:;
               1      ]
               0
               0  IF (MSMFXY = 0)["circular field with symmetrical rings"
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(44);]
               1      :J:
               1      OUTPUT;
               1      (/' NbinFlIn, R_treatment, NbinFlOut, R_scoring:'/' ',$);
               1      IF OLDFILE[
               2          OUTPUT NFIELDi,RTREAT,NFIELDo,RFIELD;
               2          (/' The old values were',I4,F10.3,I4,F10.3,'.'/
               2          'Do you want to change them?'/' ',$);
               2          INPUT C1;(A1);
               2          IF (C1='?') [ GO TO :JJJ:; ]
               2          IF (C1='y')|(C1='Y') [
               3              OUTPUT;
               3              (/' NbinFlIn, R_treatment, NbinFlOut, R_scoring:'/' ',$);
               3              ]
               2          ELSE[GOTO :JJ:;]
               2          ]
               1      READ(5,'(I12,F15.0,I12,F15.0)',ERR=:JJJ:) NFIELDi,RTREAT,NFIELDo,RFIELD;
               1      GOTO :JJ:;
               1      :JJJ:
               1      CALL HELP_MESSAGE(44);
               1      GOTO :J:;
               1      :JJ:;
               1
               1      " Successful input - calculate NFIELD "
               1      NFIELD = NFIELDi + NFIELDo;
               1
               1      IF (RTREAT<0.0001)|(RFIELD<RTREAT)[
               2          OUTPUT;(//' SORRY, RADIUS  MUST BE >= 0.0001' /
               2          ' AND DEFINED FIELD MUST BE INSIDE SCORING FIELD');
               2          GO TO :JJJ:;
               2          ]
               1      IF (NFIELDi<1)|(NFIELDi>$NB)|(NFIELDo<1)|(NFIELDo>$NB)[
               2          OUTPUT $NB;
               2          (//' SORRY, NUMBER OF BINS MUST BE BETWEEN 0 AND ',I5,'!'//);
               2          GO TO :JJJ:;
               2          ]
               1      IF ((NFIELD<1)|(NFIELD)>$NB)[
               2          OUTPUT $NB;
               2          (//' SORRY, TOTAL NUMBER OF BINS MUST BE BETWEEN 1 AND ',I5,'!'//);
               2          GO TO :JJJ:;
               2          ]
               1      ]"end of circular field with symmetrical rings"
               0
               0  ELSEIF(MSMFXY = 1)["square field with symmetrical square rings"
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(47); ]
               1      :J123:
               1      OUTPUT;
               1      (/' NbinFlIn,1/2 TREAT FIELD WIDTH,NbinFlOut,1/2 SCORING FIELD WIDTH:'/
               1      ' ',$);
               1      IF OLDFILE[
               2          OUTPUT NFIELDi,RTREAT,NFIELDo,RFIELD;
               2          (/' The old values were',I4,F10.3,I4,F10.3,'.'/
               2          'Do you want to change them?'/' ',$);
               2          INPUT C1;(A1);
               2          IF (C1='?') [   GO TO :JJJ123:; ]
               2          IF (C1='y')|(C1='Y') [
               3              OUTPUT;
               3              (/' NbinFlIn,1/2 TREAT FIELD WIDTH,NbinFlOut,1/2 SCORING FIELD WIDTH:'/
               3              ' ',$);
               3              ]
               2          ELSE[GOTO :JJ123:;]
               2          ]
               1      READ(5,'(I12,F15.0,I12,F15.0)',ERR=:JJJ123:) NFIELDi,RTREAT,NFIELDo,RFIELD;
               1      GOTO :JJ123:;
               1      :JJJ123:
               1      CALL HELP_MESSAGE(47);
               1      GOTO :J123:;
               1      :JJ123:;
               1
               1      " Successful input - calculate NFIELD "
               1      NFIELD = NFIELDi + NFIELDo;
               1
               1      IF (RTREAT<0.0001)|(RFIELD<RTREAT)[
               2          OUTPUT;(//' SORRY, 1/2 WIDTH  MUST BE >= 0.0001,' /
               2          ' AND DEFINED FIELD MUST BE INSIDE SCORING FIELD,');
               2          GO TO :JJJ123:;
               2          ]
               1      IF (NFIELDi<1)|(NFIELDi>$NB)|(NFIELDo<1)|(NFIELDo>$NB)[
               2          OUTPUT $NB;(//' SORRY, NUMBER OF BINS MUST BE BETWEEN 0 AND ',I5,'!'//);
               2          GO TO :JJJ123:;
               2          ]
               1      IF (NFIELD<1)|(NFIELD>$NB)[
               2          OUTPUT;
               2          (//' SORRY, TOTAL NUMBER OF BINS MUST BE BETWEEN 1 AND ',I5,'!'//);
               2          GO TO :JJJ123:;
               2          ]
               1      ]"end of square field with symmetrical square rings"
               0
               0  ELSEIF(MSMFXY = 2)["rectangular field"
               1
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(45); ]
               1      :K:
               1      OUTPUT;
               1      (/' INPUT NFbin,XFmin,XFmax,YFmin,YFmax FOR THE SCORING FIELD:'/' ',$);
               1      IF OLDFILE[
               2          OUTPUT NFIELD,XFLDMN,XFLDMX,YFLDMN,YFLDMX;
               2          (/' The old values were',I4,4F10.3,'.'/
               2          ' Do you want to change them? '/' ',$);
               2          INPUT C1;(A1);
               2          IF (C1='?') [   GO TO :KKKK:; ]
               2          IF (C1='y')|(C1='Y') [
               3              OUTPUT;
               3              (/' INPUT NFbin, XFmin, XFmax, YFmin, YFmax:'/' ',$);
               3              ]
               2          ELSE[GOTO :KK:;]
               2          ]
               1      READ(5,'(I12,4F15.0)',ERR=:KKKK:)NFIELD,XFLDMN,XFLDMX,YFLDMN,YFLDMX;
               1      GOTO :KK:;
               1      :KKKK:
               1      CALL HELP_MESSAGE(45);
               1      GOTO :K:;
               1      :KK:;
               1      IF (XFLDMN>=XFLDMX)|(YFLDMN>=YFLDMX)|
               1      (NFIELD<1)|(NFIELD>$NB)[
               2          OUTPUT;(//' SORRY, XFmax MUST BE > XFmin');
               2          OUTPUT;(  '        YFmax MUST BE > YFmin'//);
               2          OUTPUT $NB;(  '        NFbin MUST BE BETWEEN 1 AND ',I5,'!!'//);
               2          GO TO :KKKK:;
               2          ]
               1
               1      IF ~EGSPERT[ CALL HELP_MESSAGE(46); ]
               1      :KD:
               1      OUTPUT;
               1      (/' INPUT Xmin,Xmax,Ymin,Ymax FOR TREATMENT FIELD: ',$);
               1      IF OLDFILE[
               2          OUTPUT XTREATMN,XTREATMX,YTREATMN,YTREATMX;
               2          (/' The old values were',4F10.3,'.'/
               2          ' Do you want to change them?'/' ',$);
               2          INPUT C1;(A1);
               2          IF (C1='?') [   GO TO :KKKD:; ]
               2          IF (C1='y')|(C1='Y') [
               3              OUTPUT;
               3              (/' INPUT Xmin,Xmax,Ymin,Ymax FOR TREATMENT FIELD: ',$);
               3              ]
               2          ELSE[GOTO :KKD:;]
               2          ]
               1      READ(5,'(4F15.0)',ERR=:KKKD:)XTREATMN,XTREATMX,YTREATMN,YTREATMX;
               1      GOTO :KKD:;
               1      :KKKD:
               1      CALL HELP_MESSAGE(46);
               1      GOTO :KD:;
               1      :KKD:;
               1      IF (XTREATMX<XTREATMN)|(YTREATMX<YTREATMN)[
               2          OUTPUT;(//' SORRY, XTFmin > XTFmax OR YTFmin > YTFmax NOT ALLOWED!');
               2          GO TO :KKKD:;
               2          ]
               1      ]"end of rectangular field"
               0
               0  :OPEN-PHSP-FILE:;
               0
               0  "first do some preparation work"
               0
               0  "PUT LATCH NUMBERS IN ORDER FOR LATER USE"
               0  "*******************************************"
               0  "we relate LATCH numbers to the SSD for each sub-source so that"
               0  "K(1) corresponds to the smallest SSD, and then K(2), then K(3),..."
               0
               0  OUTPUT;
               0  (/' The order of the sub-sources in terms of their distances to the'/
               0  ' scoring plane and their LATCH numbers:                       '//
               0  '   order     sub-source #       SSD           LATCH #       CHARGE'/);
               0  DO I=1,NSMFPS[
               1      K(I)=1;Z=SMFMNZ(1);"always start from K(I) = 1"
               1      IF(I > 1)[
               2          "check whether K(I) has been put into right order."
               2          :CHECK:;
               2          DO II=1,I-1[
               3              IF(K(I) = K(II))[
               4                  K(I)=K(I)+1;Z=SMFMNZ(K(I));
               4                  GOTO :CHECK:;
               4                  ]
               3              ]
               2          ]
               1      :CHECK-IS-OVER:;
               1      "we now have the next Z that should be checked against the rest"
               1      IF(I ~= NSMFPS)[
               2          DO III=1,NSMFPS[
               3              IF(SMFMNZ(III) < Z)[
               4                  "Z is probably NOT the next nearest"
               4                  DO II=1,I["check whether SMFMNZ(III) is one of the values"
               5                      "that are already in the right order.          "
               5                      IF(III = K(II))[GOTO :ALREADY-USED:;]
               5                      ]
               4                  "yes, this is the next nearest Z to be put in order"
               4                  K(I)=III;Z=SMFMNZ(III);
               4                  :ALREADY-USED:;
               4                  ]
               3              ]
               2          ]
               1      OUTPUT I,K(I),SMFMNZ(K(I)),LATCH(K(I)),IQSMFP(K(I));
               1      (I6, I14, F16.3,2I14);
               1      "go back to put the next Z in the right order"
               1      ]
               0
               0  :RR2:;
               0
               0  CALL READNAME;
               0
               0  "in case we cannot go any further and be stopped here we output the "
               0  "parameters already typed in by the user. We may have many 0 in the file"
               0  "but it does not matter"
               0  "OUTPUT PARAMETERS ALREADY TYPED IN BY THE USER
               0  "**********************************************
               0  OPEN(UNIT=1,STATUS='UNKNOWN',FILE=SPCNAM);
               0  "OPEN(UNIT=1,STATUS='UNKNOWN',FILE=SPCNAM,FORM='UNFORMATTED');"
               0
               0  WRITE(1,'(A80)')SSMFPS; "detailed descriptions of the source"
               0  WRITE(1,*)NSMFPS; "number of sub-sources for the source model"
               0
               0  " Write output for each sub-source "
               0  DO I=1,NSMFPS[
               1      WRITE(1,*)ISMFPS(I),IQSMFP(I),LATCH(I);
               1      IF (ISMFPS(I) = 1) ["model for aperture applicators"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I);
               2          ]
               1      ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
               2          WRITE(1,*)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I);
               2          ]
               1      ELSEIF (ISMFPS(I) = 2) ["model for collimators"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I),SMFPXY(I);
               2          ]
               1      ELSEIF(ISMFPS(I) = 3) ["model for ring, cone, and point source"
               2          WRITE(1,*)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD1;
               2          ]
               1      ELSEIF(ISMFPS(I) = 4) ["model for rectangular plane source"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I);
               2          ]
               1      ELSEIF(ISMFPS(I) = 5) ["model for circular plane source"
               2          WRITE(1,*)SMFMNZ(I),SMFMNR(I);
               2          ]
               1      ]"end of output for each sub-source"
               0
               0  " Write the number of energy distributio bins, minimum and maximum energy "
               0  WRITE(1,*)NSMFEE,SMFMNE,SMFMXE;
               0  " Write the energy spectrum type "
               0  WRITE(1,*)ESTYPE;
               0  IF(ESTYPE = 0)["Energy spectrum inside/outside the treatment field"
               1      WRITE(1,*)RTREATe,RFIELDe;
               1      ]
               0  ELSEIF(ESTYPE = 1)["Energy spectrum with different radii"
               1      WRITE(1,*)NFIELDe,RFIELDe;
               1      WRITE(1,*)(ERADII(I),I=1,NFIELDe);
               1      ]
               0
               0  " Write the field type number "
               0  WRITE(1,*)MSMFXY;
               0  I=1;"we use the same field for all the sub-sources"
               0  IF(MSMFXY = 0)["circular field distribution"
               1      WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
               1      ]
               0  ELSEIF(MSMFXY = 1)["square field distribution with symmetrical rings"
               1      WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
               1      ]
               0  ELSEIF(MSMFXY = 2)["rectangular field"
               1      WRITE(1,*)NFIELD,XFLDMN,XFLDMX,YFLDMN,YFLDMX;
               1      WRITE(1,*)XTREATMN,XTREATMX,YTREATMN,YTREATMX;
               1      ]
               0
               0  " Write the phase-space file name "
               0  WRITE(1,'(A100)')PSDNAM;
               0
               0  " Write output for each sub-source "
               0  DO I=1,NSMFPS[
               1      WRITE(1,*)I;
               1      WRITE(1,*)ISMFPS(I),IQSMFP(I),LATCH(I);
               1      IF (ISMFPS(I) = 1) ["model for aperture applicators"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I);
               2          ]
               1      ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
               2          WRITE(1,*)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I);
               2          ]
               1      ELSEIF (ISMFPS(I) = 2) ["model for collimators"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I),SMFPXY(I);
               2          ]
               1      ELSEIF(ISMFPS(I) = 3) ["model for ring, cone, and point source"
               2          WRITE(1,*)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD1;
               2          ]
               1      ELSEIF(ISMFPS(I) = 4) ["model for rectangular plane source"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I);
               2          ]
               1      ELSEIF(ISMFPS(I) = 5) ["model for circular plane source"
               2          WRITE(1,*)SMFMNZ(I),SMFMNR(I);
               2          ]
               1
               1      " Write relative sub-source intensity and virtual SSD "
               1      WRITE(1,*)SMFRTN(I),SSDVPS(I);
               1
               1      " Write the number of energy distributio bins, minimum and maximum energy "
               1      WRITE(1,*)NSMFEE,SMFMNE,SMFMXE;
               1      " Energy spectra within field "
               1      " for inside/outside the treatment field there are NFIELDe=2 spectra "
               1      " for different radii there are NFIELDe spectra "
               1      DO III=1,NFIELDe["
               2          WRITE(1,*) (FSMFBN1(I,III,II),II=1,NSMFEE);
               2          ]
               1
               1      " Write the field fluence type "
               1      WRITE(1,*)MSMFXY;
               1
               1      IF(MSMFXY = 0)["circular field distribution"
               2          WRITE(1,*) NFIELDi,RTREAT,NFIELDo,RFIELD;
               2          " Write probability for each bin "
               2          WRITE(1,*)(FSMFRR(I,II),II=1,NFIELD);
               2          ]
               1      IF(MSMFXY = 1)["square field distribution with symmetrical rings"
               2          WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
               2          " Write probability for each bin "
               2          WRITE(1,*)(FSMFRR(I,II),II=1,NFIELD);
               2          " Write parameters used in sampling "
               2          WRITE(1,*)(FSMFR11(I,II),II=1,NFIELD);
               2          WRITE(1,*)(FSMFR12(I,II),II=1,NFIELD);
               2          ]
               1      ELSEIF(MSMFXY = 2)["rectangular field"
               2          WRITE(1,*)NFIELD,XFLDMN,XFLDMX;
               2          WRITE(1,*)NFIELD,YFLDMN,YFLDMX;
               2          WRITE(1,*)((FSMFXY(I,II,III),II=1,NFIELD),III=1,NFIELD);
               2          "probability for each bin"
               2          ]
               1      ]"end of output for each sub-source"
               0
               0  " Write angular distribution "
               0  WRITE(1,*) (FSMABN1(II),II=1,$NBINANGLE);
               0  CLOSE(UNIT=1,STATUS='KEEP');
               0
               0  IF(CHOICE = 1)[GOTO :STOP-FOR-GOOD:;]
               0
               0  :OPEN-PH-SP-FILE:;
               0  CALL OPENFILE;
               0
               0  CALL READ_PHSP;
               0
               0  CLOSE (2); "Close the ph-sp file"
               0
               0  OUTPUT;(/' BEGIN SUMMARISING THE PH-SP DATA.....');
               0
               0  " Summarize phase space data just read"
               0  " ************************************"
               0
               0  IF(N_ph_sp_e ~= 0)[E_ph_sp_e = E_ph_sp_e/N_ph_sp_e; "average"]
               0  IF(N_ph_sp_g ~= 0)[E_ph_sp_g = E_ph_sp_g/N_ph_sp_g; "average"]
               0  IF(N_ph_sp_p ~= 0)[E_ph_sp_p = E_ph_sp_p/N_ph_sp_p; "average"]
               0  WRITE(6,'(/T10,''INFORMATION ABOUT THE FULL PHASE SPACE DATA ''//
            '  0  '' Read total''
            '  0  ,I10,'' particles and ignored'',I6,'' multiple passers'')')
               0  N_ph_sp_e+N_ph_sp_g+N_ph_sp_p,NPASS_ph_sp;
               0  WRITE(6,'(/'' There were'',I10,'' electrons with average energy'',
            '  0  T55, F9.4,'' MeV'')') N_ph_sp_e,E_ph_sp_e;
               0  WRITE(6,'(/'' There were'',I10,'' photons with average energy'',
            '  0  T55, F9.4,'' MeV'')') N_ph_sp_g,E_ph_sp_g;
               0  WRITE(6,'(/'' There were'',I10,'' positrons with average energy'',
            '  0  T55, F9.4,'' MeV'')') N_ph_sp_p,E_ph_sp_p;
               0  WRITE(6,'(/'' Minimum / maximum particle energies were'',
            '  0  F9.3,'' /'',F9.3,'' MeV'')') E_MIN_ph_sp,E_MAX_ph_sp;
               0
               0  OUTPUT K4,(K1+K2+K3),K1,K2,K3,NWRONG;
               0  (/'           ',I10,' PARTICLES SCORED FOR ENERGY/FLUENCE DISTRIBUTIONS'
               0  /'           ',I10,' PARTICLES IGNORED BECAUSE LATCH # ARE NOT SET'
               0  /'           ',I10,' OF THEM ARE ELECTRONS'
               0  /'           ',I10,' OF THEM ARE PHOTONS, AND'
               0  /'           ',I10,' OF THEM ARE POSITRONS'
               0  /'  ALSO     ',I10,' PARTICLES NOT SCORED DUE TO OUT OF THE FIELD');
               0
               0  DO I=1,NSMFPS[
               1
               1      IF(ISMFPS(I) = 3)&(SMFMNR(I) = 0.0)["check for point source only"
               2          III=0;
               2          DO IIII=1,$ND[
               3              IF(RSSDST(I,IIII) ~= 0.0)&(III = 0)[III=1;]
               3              ]
               2          IF(III = 0)[
               3              OUTPUT I;
               3              (/' No particles from source ',I4,' falling into the ring.'/
               3              ' Was the radius of the ring outside of the field?'/
               3              '   '/
               3              ' The SSD for the point source has been taken to be 100 cm.'/
               3              ' However, you can try again with a different ring radius.');
               3              IF(IQSMFP(I) = -1)[SSDVPS($NS+1)=100.;]
               3              ELSEIF(IQSMFP(I) = 0)[SSDVPS($NS+2)=100.;]
               3              ELSEIF(IQSMFP(I) = 1)[SSDVPS($NS+3)=100.;]
               3              GOTO :NO-PARTICLES-DETECTED:;
               3              ]
               2          DO II=1,3["smooth the distribution 4 times"
               3              DO IIII=3,1998["using weighted smoothing"
               4                  SSSDST(I,IIII)=RSSDST(I,IIII)*0.3+
               4                  RSSDST(I,IIII-1)*0.25+RSSDST(I,IIII+1)*0.25+
               4                  RSSDST(I,IIII-2)*0.1+RSSDST(I,IIII+2)*0.1;
               4                  ]
               3              DO IIII=3,1998[
               4                  RSSDST(I,IIII)=SSSDST(I,IIII);
               4                  ]
               3              J=1;
               3              DO IIII=2,2000[
               4                  IF(II = 1)[
               5                      "weight the distribution by the radius (=IIII/10)"
               5                      RSSDST(I,IIII)=10.*RSSDST(I,IIII)/FLOAT(IIII);
               5                      ]
               4                  IF(RSSDST(I,IIII) >= RSSDST(I,J))[
               5                      J=IIII;"find the maximum of the image radius (times 10)"
               5                      ]
               4                  ]
               3              ]
               2          DO IIII=J-10,J+10["further smooth the distribution around the maximum"
               3              DO III=1,10["subdivide each region into 10 regions"
               4                  RSSDST(I,IIII*10+III)=RSSDST(I,IIII+1);
               4                  ]
               3              ]
               2          J=(J-8)*10;
               2          DO JJ=1,3["further smooth 4 times"
               3              IF(JJ ~= 1) J=J-80;
               3              DO IIII=J,J+160[
               4                  SSSDST(I,IIII)=RSSDST(I,IIII)*0.05+
               4                  RSSDST(I,IIII-1)*0.04+RSSDST(I,IIII+1)*0.04+
               4                  RSSDST(I,IIII-2)*0.035+RSSDST(I,IIII+2)*0.035+
               4                  RSSDST(I,IIII-3)*0.03+RSSDST(I,IIII+3)*0.03+
               4                  RSSDST(I,IIII-4)*0.025+RSSDST(I,IIII+4)*0.025+
               4                  RSSDST(I,IIII-5)*0.025+RSSDST(I,IIII+5)*0.025+
               4                  RSSDST(I,IIII-6)*0.025+RSSDST(I,IIII+6)*0.025+
               4                  RSSDST(I,IIII-7)*0.025+RSSDST(I,IIII+7)*0.025+
               4                  RSSDST(I,IIII-8)*0.025+RSSDST(I,IIII+8)*0.025+
               4                  RSSDST(I,IIII-9)*0.025+RSSDST(I,IIII+9)*0.025+
               4                  RSSDST(I,IIII-10)*0.02+RSSDST(I,IIII+10)*0.02+
               4                  RSSDST(I,IIII-11)*0.02+RSSDST(I,IIII+11)*0.02+
               4                  RSSDST(I,IIII-12)*0.02+RSSDST(I,IIII+12)*0.02+
               4                  RSSDST(I,IIII-13)*0.02+RSSDST(I,IIII+13)*0.02+
               4                  RSSDST(I,IIII-14)*0.02+RSSDST(I,IIII+14)*0.02+
               4                  RSSDST(I,IIII-15)*0.02+RSSDST(I,IIII+15)*0.02+
               4                  RSSDST(I,IIII-16)*0.02+RSSDST(I,IIII+16)*0.02+
               4                  RSSDST(I,IIII-17)*0.02+RSSDST(I,IIII+17)*0.02+
               4                  RSSDST(I,IIII-18)*0.02+RSSDST(I,IIII+18)*0.02+
               4                  RSSDST(I,IIII-19)*0.02+RSSDST(I,IIII+19)*0.02+
               4                  RSSDST(I,IIII-20)*0.02+RSSDST(I,IIII+20)*0.02;
               4                  ]
               3              DO IIII=J,J+160[
               4                  RSSDST(I,IIII)=SSSDST(I,IIII);
               4                  IF(RSSDST(I,IIII) >= RSSDST(I,J))J=IIII;
               4                  ]
               3              ]
               2
               2          ZTOTAL(I)=DELTAZ*(RSSD1+RSSD0)/2./(FLOAT(J)/100.-(RSSD1+RSSD0)/2.);
               2
               2          IF(ZTOTAL(I) > 1.0E+30)[
               3              OUTPUT;
               3              (///' The particles are incident along Z-axis. Is it a parallel'/
               3              ' beam or the radius of the ring close to zero?'/
               3              '   '/
               3              ' The SSD for the point source has been taken to be 1.0E+30 cm.'/
               3              ' However, you can try again with a different ring radius.'//);
               3              IF(IQSMFP(I) = -1)[SSDVPS($NS+1)=1.0E+30;]
               3              ELSEIF(IQSMFP(I) = 0)[SSDVPS($NS+2)=1.0E+30;]
               3              ELSEIF(IQSMFP(I) = 1)[SSDVPS($NS+3)=1.0E+30;]
               3              ]
               2          ELSE[
               3              OUTPUT I,ZTOTAL(I);
               3              (/' The virtual SSD for source',I4,' is',F7.1,' cm '/
               3              ' according to the full ph-sp data.'/);
               3              IF(IQSMFP(I) = -1)[SSDVPS($NS+1)=ZTOTAL(I);]
               3              ELSEIF(IQSMFP(I) = 0)[SSDVPS($NS+2)=ZTOTAL(I);]
               3              ELSEIF(IQSMFP(I) = 1)[SSDVPS($NS+3)=ZTOTAL(I);]
               3              ]
               2          ;:NO-PARTICLES-DETECTED:;
               2          ]
               1      ]"end of calculating SSD for each of the point sources"
               0
               0  IF(MSMFXY = 1)[   "square field distribution with symmetrical rings"
               1      DO I=1,NSMFPS[ "ESTIMATE INVERSE-SQUARE RATIO FOR THE PARTICLES IN A BIN"
               2          FSMFR11(I,1)=1.;FSMFR12(I,1)=0.;
               2
               2          DO II=2,NFIELD[
               3              " We have different bin sizes, RBin depends on it "
               3              IF(II<=NFIELDi) [
               4                  RBin=RTREAT**2*(FLOAT(II)/FLOAT(NFIELDi));
               4                  ]
               3              ELSE [
               4                  RBin=(RFIELD**2-RTREAT**2)*(FLOAT(II-NFIELDi)/FLOAT(NFIELDo))+
               4                  RTREAT**2;
               4                  ]
               3
               3              IF(FSMFR1(I,II)<FSMFR2(I,II))&(FSMFR2(I,II)>0.)[
               4                  IF(FSMFR1(I,II)+FSMFR2(I,II) <= 10.)[
               5                      FSMFR11(I,II)=1.;FSMFR12(I,II)=0.;
               5                      ]
               4                  ELSE[
               5                      FSMFR11(I,II)=(7.*FSMFR1(I,II)-FSMFR2(I,II))/
               5                      (11.*FSMFR2(I,II)-5.*FSMFR1(I,II));
               5                      FSMFR12(I,II)=12.*(FSMFR1(I,II)-FSMFR2(I,II))/
               5                      (11.*FSMFR2(I,II)-5.*FSMFR1(I,II))/RBin;
               5                      ]
               4                  ]
               3              ELSEIF(FSMFR2(I,II)<=FSMFR1(I,II))&(FSMFR1(I,II)>0.)[
               4                  IF(FSMFR1(I,II)+FSMFR2(I,II) <= 10.)[
               5                      FSMFR11(I,II)=1.;FSMFR12(I,II)=0.;
               5                      ]
               4                  ELSE[
               5                      FSMFR11(I,II)=1.;
               5                      FSMFR12(I,II)=12.*(FSMFR1(I,II)-FSMFR2(I,II))/
               5                      (7.*FSMFR1(I,II)-FSMFR2(I,II))/RBin
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      ]
               0
               0
               0  "Throw in some defaults in case the user does not have point sources"
               0
               0  IF(SSDVPS($NS+1)=0.)[
               1      OUTPUT;(//' ***WARNING:'/
               1      ' You have not defined a virtual point source for e-'/
               1      ' However, the SSD of this source may be used in some calculations.'/
               1      ' A value of 100cm will be assumed.'//);
               1      SSDVPS($NS+1)=100.
               1      ]
               0  IF(SSDVPS($NS+2)=0.)[
               1      OUTPUT;(//' ***WARNING:'/
               1      ' You have not defined a virtual point source for photons'/
               1      ' However, the SSD of this source may be used in some calculations.'/
               1      ' A value of 100cm will be assumed.'//);
               1      SSDVPS($NS+2)=100.
               1      ]
               0
               0  DO I=1,NSMFPS[
               1      IF(IQSMFP(I) =  -1)[SSDVPS(I)=SSDVPS($NS+1);]
               1      ELSEIF(IQSMFP(I) =  0)[SSDVPS(I)=SSDVPS($NS+2);]
               1      ELSEIF(IQSMFP(I) =  1)[
               2          IF(SSDVPS($NS+3) =  0.)[SSDVPS(I)=SSDVPS($NS+1);]
               2          ELSE[SSDVPS(I)=SSDVPS($NS+3);]
               2          ]
               1      ]
               0
               0  OUTPUT;(/' BEGIN OUTPUTING DATA.....');
               0
               0  "OUTPUT ANALYSED DATA"
               0  "********************"
               0
               0  "Open source parameter output file"
               0  OPEN(UNIT=1,STATUS='UNKNOWN',FILE=SPCNAM);
               0
               0  WRITE(1,'(A80)')SSMFPS; "detailed descriptions of the source"
               0  WRITE(1,*)NSMFPS; "number of sub-sources for the source model"
               0
               0  " Write output for each sub-source "
               0  DO I=1,NSMFPS[
               1      WRITE(1,*)ISMFPS(I),IQSMFP(I),LATCH(I);
               1      IF (ISMFPS(I) = 1) ["model for aperture applicators"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I);
               2          ]
               1      ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
               2          WRITE(1,*)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I);
               2          ]
               1      ELSEIF (ISMFPS(I) = 2) ["model for collimators"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I),SMFPXY(I);
               2          ]
               1      ELSEIF (ISMFPS(I) = 3) ["model for ring, cone, and point source"
               2          IF(SMFMNZ(I) ~= SSDVPS(I))&(SMFMNR(I) = 0.0)[
               3              "re-set SSD for the source"
               3              OUTPUT I,SMFMNZ(I),SSDVPS(I);
               3              (/' SSD FOR SUB-SOURCE',I4,' HAS BEEN RE-SET FROM',F7.1,
               3              ' cm TO',F7.1,' cm'/' ACCORDING TO THE PHASE-SPACE DATA.');
               3              SMFMNZ(I)=SSDVPS(I);
               3              ]
               2          WRITE(1,*)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD1;
               2          ]
               1      ELSEIF (ISMFPS(I) = 4) ["model for rectangular plane source"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I);
               2          ]
               1      ELSE ["model for circular plane source"
               2          WRITE(1,*)SMFMNZ(I),SMFMNR(I);
               2          ]
               1      ]"end of output for each sub-source"
               0
               0  " Write the number of energy distributio bins, minimum and maximum energy "
               0  WRITE(1,*)NSMFEE,SMFMNE,SMFMXE;
               0
               0  " Write the energy spectrum type "
               0  WRITE(1,*)ESTYPE;
               0  IF(ESTYPE = 0)["Energy spectrum inside/outside the treatment field"
               1      WRITE(1,*)RTREATe,RFIELDe;
               1      ]
               0  ELSEIF(ESTYPE = 1)["Energy spectrum with different radii"
               1      WRITE(1,*)NFIELDe,RFIELDe;
               1      WRITE(1,*)(ERADII(I),I=1,NFIELDe);
               1      ]
               0
               0  " Write the field type number "
               0  WRITE(1,*)MSMFXY;
               0  I=1;"we use the same field for all the sub-sources"
               0  IF(MSMFXY = 0)["circular field distribution with symmetrical rings"
               1      WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
               1      ]
               0  ELSEIF(MSMFXY = 1)["square field distribution with symmetrical square rings"
               1      WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
               1      ]
               0  ELSEIF(MSMFXY = 2)["rectangular field"
               1      WRITE(1,*)NFIELD,XFLDMN,XFLDMX,YFLDMN,YFLDMX;
               1      WRITE(1,*)XTREATMN,XTREATMX,YTREATMN,YTREATMX;
               1      ]
               0
               0  " Write the phase-space file name "
               0  WRITE(1,'(A100)')PSDNAM;
               0
               0  " Write output for each sub-source "
               0  DO I=1,NSMFPS[
               1      WRITE(1,*)I;
               1      WRITE(1,*)ISMFPS(I),IQSMFP(I),LATCH(I);
               1      IF (ISMFPS(I) = 1) ["model for aperture applicators"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I);
               2          ]
               1      ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
               2          WRITE(1,*)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I);
               2          ]
               1      ELSEIF (ISMFPS(I) = 2) ["model for collimators"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
               2          SMFX2(I),SMFY2(I),SMFPXY(I);
               2          ]
               1      ELSEIF (ISMFPS(I) = 3) ["model for ring, cone, and point source"
               2          IF(SMFMNZ(I) ~= SSDVPS(I))&(SMFMNR(I) = 0.0)[
               3              "re-set SSD for the source"
               3              OUTPUT I,SMFMNZ(I),SSDVPS(I);
               3              (//' SSD FOR SUB-SOURCE',I4,' HAS BEEN RE-SET FROM',F7.1,
               3              ' cm TO',F7.1,' cm ACCORDING TO THE PH-SP DATA.'//);
               3              SMFMNZ(I)=SSDVPS(I);
               3              ]
               2          WRITE(1,*)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD1;
               2          ]
               1      ELSEIF (ISMFPS(I) = 4) ["model for rectangular plane source"
               2          WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I);
               2          ]
               1      ELSE ["model for circular plane source"
               2          WRITE(1,*)SMFMNZ(I),SMFMNR(I);
               2          ]
               1
               1      " Calculate relative sub-source intensity "
               1      SMFRTN(I)=SMFRTN(I)/KWEI;"this is the relative source intensity"
               1
               1      " Write relative sub-source intensity and virtual SSD "
               1      WRITE(1,*)SMFRTN(I),SSDVPS(I);
               1
               1      " Write the number of energy distributio bins, minimum and maximum energy "
               1      WRITE(1,*)NSMFEE,SMFMNE,SMFMXE;
               1      " Energy spectra within field "
               1      " for inside/outside the treatment field there are NFIELDe=2 spectra "
               1      " for different radii there are NFIELDe spectra "
               1      DO III=1,NFIELDe["
               2          WRITE(1,*) (FSMFBN1(I,III,II),II=1,NSMFEE);
               2          ]
               1
               1      " Write the field fluence type "
               1      WRITE(1,*)MSMFXY;
               1
               1      IF(MSMFXY = 0)["circular field distribution"
               2          WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
               2          " Write probability for each bin "
               2          WRITE(1,*)(FSMFRR(I,II),II=1,NFIELD);
               2          ]
               1      ELSEIF(MSMFXY = 1)["square field distribution with symmetrical rings"
               2          WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
               2          " Write probability for each bin "
               2          WRITE(1,*)(FSMFRR(I,II),II=1,NFIELD);
               2          " Write parameters used in sampling "
               2          WRITE(1,*)(FSMFR11(I,II),II=1,NFIELD);
               2          WRITE(1,*)(FSMFR12(I,II),II=1,NFIELD);
               2          ]
               1      ELSEIF(MSMFXY = 2)["rectangular field"
               2          WRITE(1,*)NFIELD,XFLDMN,XFLDMX;
               2          WRITE(1,*)NFIELD,YFLDMN,YFLDMX;
               2          WRITE(1,*)((FSMFXY(I,II,III),II=1,NFIELD),III=1,NFIELD);
               2          "probability for each bin"
               2          ]
               1      ]"end of output for each sub-source"
               0  III=1;
               0  DO II=2,$NBINANGLE["find maximum value FOR ANGULAR DISTRIBUTION"
               1      IF(FSMABN1(II) > FSMABN1(III))[III=II;]
               1      ]
               0  DO II=1,$NBINANGLE["now, normalize it"
               1      IF(FSMABN1(III)>0)["prevents NaN for photon only beams"
               2          IF(II ~= III)FSMABN1(II)=FSMABN1(II)/FSMABN1(III);
               2          ]
               1      IF(II = $NBINANGLE)FSMABN1(III)=1.;
               1      ]
               0  WRITE(1,*)(FSMABN1(II),II=1,$NBINANGLE);
               0  CLOSE(UNIT=1,STATUS='KEEP');
               0
               0  :DATA-FOR-GRAPH-PLOTTING:;
               0
               0  " Plot characteristics of source model "
               0  " ------------------------------------ "
               0  IF(CHOICE > 2)[
               1
               1      DO I=1,NFIELD[
               2          IF (I <= NFIELDi)[
               3              BINSIZE(I)=RTREAT**2/(FLOAT(NFIELDi));
               3              ]
               2          ELSE[
               3              BINSIZE(I)=(RFIELD**2-RTREAT**2)/(FLOAT(NFIELDo));
               3              ]
               2          ]
               1
               1      DO I=1,NSMFPS[
               2          III=1;IIIII=1;
               2          DO II=1,NFIELD["find maximum planar fluence value"
               3
               3              IF(MSMFXY = 0)|(MSMFXY = 1)[
               4                  " Bins are not of the equal areas "
               4                  " so, find # of particles/unit area "
               4                  IF(FSMFRR(I,II)/BINSIZE(II) > FSMFRR(I,III)/BINSIZE(III))[
               5                      III=II;
               5                      ]
               4                  ]
               3              ELSEIF(MSMFXY = 2)[
               4                  DO IIII=1,NFIELD[
               5                      IF(FSMFXY(I,II,IIII) > FSMFXY(I,III,IIIII))[
               6                          III=II;IIIII=IIII;
               6                          ]
               5                      ]
               4                  ]
               3              ]
               2
               2          " Normalize to the maximum value "
               2          DO II=1,NFIELD[
               3              IF(MSMFXY = 0)|(MSMFXY = 1)[
               4                  IF(FSMFRR(I,III) ~= 0.)[
               5                      IF(II ~= III)FSMFRR(I,II)=FSMFRR(I,II)/FSMFRR(I,III);
               5                      IF(II = NFIELD)FSMFRR(I,III)=1.;
               5                      ]
               4                  ]
               3              ELSEIF(MSMFXY = 2)[
               4                  DO IIII=1,NFIELD[
               5                      IF(FSMFXY(I,III,IIIII) ~= 0.)[
               6                          IF((II ~= III) | (IIII ~= IIIII))[
               7                              FSMFXY(I,II,IIII)=FSMFXY(I,II,IIII)/
               7                              FSMFXY(I,III,IIIII);
               7                              IF((II = NFIELD) & (IIII = NFIELD))
               7                              FSMFXY(I,III,IIIII)=1.;
               7                              "   WRITE(6,*)III,IIIII,FSMFXY(I,II,IIII);"
               7                              ]
               6                          ]
               5                      ]
               4                  ]
               3              ]
               2
               2          " Loop over bins and find maximum energy value "
               2          DO IIII=1,NFIELDe[
               3              III=1; " At the beginning set this one as the highest "
               3              DO II=2,NSMFEE[ " start from the second one "
               4                  IF(FSMFBN1(I,IIII,II) > FSMFBN1(I,IIII,III))[
               5                      III=II; " new highest value "
               5                      ]
               4                  ]
               3              DO II=1,NSMFEE[
               4                  IF(II ~= III)
               4                  FSMFBN1(I,IIII,II)=FSMFBN1(I,IIII,II)/FSMFBN1(I,IIII,III);
               4                  IF(II = NSMFEE)
               4                  FSMFBN1(I,IIII,III)=1.;
               4                  ]
               3              ]
               2          ] " end of loop "
               1
               1      OUTPUT;(//'Name of file to save data for graph plotting:'/' ',$);
               1      INPUT SPCNAM;(A80);
               1      OUTPUT SPCNAM;(' File name input is:', A80);
               1      OPEN(UNIT=3,STATUS='UNKNOWN',FILE=SPCNAM);
               1
               1      MSTART=-1;
               1      :PLOTTING-DATA:;
               1
               1      TEEE=0.;TPPP=0.;
               1
               1      " For each sub-source "
               1      DO I=1,NSMFPS[
               2          TENERGY=0.0;
               2          TPARTICLE=0;
               2          :MODEL_GRAPH_TYPE:
               2
               2          OUTPUT I,IQSMFP(I);
               2          (/' PLOT ENERGY/PLANAR FLUENCE FOR SOURCE',I3,' (CHARGE=',I3,')?'/);
               2          OUTPUT;(' (0) - No');
               2          IF(ESTYPE = 0) [
               3              OUTPUT;(' (1) - E inside treatment field');
               3              OUTPUT;(' (2) - E outside treatment field');
               3              ]
               2          ELSE [
               3              OUTPUT;(' (3) - E annulus');
               3              ]
               2          OUTPUT;(' (4) - Fluence');
               2
               2          INPUT CHOICE;(I8);
               2
               2          IF((CHOICE=1 & ESTYPE=1) | (CHOICE=2 & ESTYPE=1))[
               3              OUTPUT;(//' Not a valid energy option with this field type.'/
               3              ' Try again.'//);
               3              GOTO :MODEL_GRAPH_TYPE:;
               3              ]
               2          ELSEIF(CHOICE=3 & ESTYPE=0)[
               3              OUTPUT;(//' You must have different energy spectra to'/
               3              ' plot energy in an arbitrary radial bin.'/
               3              ' Try again.'//);
               3              GOTO :MODEL_GRAPH_TYPE:;
               3              ]
               2          ELSEIF(CHOICE ~= 0)[
               3              MSTART=MSTART+1;"graph number + 1"
               3              ]
               2
               2          IF(CHOICE = 1)|(CHOICE = 2)|(CHOICE = 3)[
               3              IF(CHOICE = 1)[
               4                  II=1;
               4                  ]
               3              ELSEIF(CHOICE = 2)[
               4                  II=2;
               4                  ]
               3              ELSEIF(CHOICE = 3)[
               4                  LOOP[
               5                      OUTPUT NFIELDe;(' There are ',I3,' different annuluses');
               5                      OUTPUT;(' Input the number of the annulus: ',$);
               5                      INPUT II; (I3);
               5                      ] UNTIL (II>0)&(II<=NFIELDe);
               4                  ]
               3
               3              GRAPHTITLE='spectral distribution';
               3              YTITLE='relative particles/bin';
               3              XTITLE='energy /MeV';
               3              DO III=1,NSMFEE[
               4                  XPLOT(III)=SMFMXE*FLOAT(III)/FLOAT(NSMFEE);
               4                  YPLOT(III)=0;
               4                  IF(FSMFBN1(I,II,III)>0) YPLOT(III)=FSMFBN1(I,II,III);
               4                  ERRYPLOT(III)=0.;
               4                  TENERGY=TENERGY+YPLOT(III)*XPLOT(III);
               4                  TPARTICLE=TPARTICLE+YPLOT(III);
               4                  ]
               3              IF(TPARTICLE>0)[
               4                  OUTPUT TENERGY/TPARTICLE;
               4                  (/' MEAN E FOR THIS SOURCE INSIDE TREATMENT FIELD=',F10.3,'MeV');
               4                  TEEE=TEEE+TENERGY/TPARTICLE*SMFRTN(I);
               4                  TPPP=TPPP+SMFRTN(I);
               4                  ]
               3              ELSE[
               4                  OUTPUT;(/' NO PARTICLES FROM THIS SOURCE INSIDE TREATMENT FIELD');
               4                  ]
               3              IF(TPPP>0)[
               4                  OUTPUT TEEE/TPPP;
               4                  (/' MEAN E FOR ALL THE PARTICLES (SO FAR)=',F10.3,'MeV');
               4                  ]
               3              HXMIN=SMFMNE;ITYPE=1;
               3              SERIESTITLE(1:7)='SOURCE';
               3              SERIESTITLE(8:9)=LETTER2(I);
               3              SERIESTITLE(10:15)=' IQ =';
               3              SERIESTITLE(16:17)=LETTER1(IQSMFP(I)+2);
               3              " Diffrenet aoutput for this three cases "
               3              IF(CHOICE = 1)[
               4                  SERIESTITLE(18:60)=' IN TREATMENT FIELD';
               4                  ]
               3              ELSEIF(CHOICE = 2)[
               4                  SERIESTITLE(18:60)=' OUTSIDE TREATMENT FIELD';
               4                  ]
               3              ELSEIF(CHOICE = 3)[
               4                  IF(II=1)[
               5                      SERIESTITLE(18:60)=' IN R = 0.00 - '
               5                      //LETTER2(INT(ERADII(II)))//'.'
               5                      //LETTER2(INT(100*(ERADII(II)-INT(ERADII(II)))));
               5                      ]
               4                  ELSE [
               5                      SERIESTITLE(18:60)=' IN R = '
               5                      //LETTER2(INT(ERADII(II-1)))//'.'
               5                      //LETTER2(INT(100*(ERADII(II-1)-INT(ERADII(II-1)))))//' - '
               5                      //LETTER2(INT(ERADII(II)))//'.'
               5                      //LETTER2(INT(100*(ERADII(II)-INT(ERADII(II)))));
               5                      ]
               4                  ]
               3              CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
               3              SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               3              ]
               2
               2          ELSEIF(CHOICE = 4)[
               3              GRAPHTITLE='planar fluence distribution';
               3              YTITLE='relative particles/bin';
               3              ITYPE=1;
               3              SERIESTITLE(1:20)='PLANAR-F FOR SOURCE';
               3              SERIESTITLE(21:23)=LETTER2(I);
               3              SERIESTITLE(24:28)=' IQ =';
               3              SERIESTITLE(29:60)=LETTER1(IQSMFP(I)+2);
               3              IF(MSMFXY = 0)[
               4                  XTITLE='radius /cm';
               4                  ]
               3              ELSEIF(MSMFXY = 1)[
               4                  XTITLE='half-side /cm';
               4                  ]
               3              ELSEIF(MSMFXY = 2)[
               4                  OUTPUT NFIELD;
               4                  (' ORIENTATION (0: ALONG X, 1: Y), BIN NUMBER (1 - ',I3,'):'
               4                  /' ',$);
               4                  INPUT II,III;(2I8);
               4                  IF(II = 0)[
               5                      XTITLE='X /cm ';HXMIN=XFLDMN;
               5                      SERIESTITLE(32:40)=' Y-BIN #:';
               5                      SERIESTITLE(41:60)=LETTER2(III);
               5                      ]
               4                  ELSEIF(II = 1)[
               5                      XTITLE='Y /cm ';HXMIN=YFLDMN;
               5                      SERIESTITLE(32:40)=' X-BIN #:';
               5                      SERIESTITLE(41:60)=LETTER2(III);
               5                      ]
               4                  ]
               3              IF(MSMFXY = 0)|(MSMFXY = 1)[
               4                  DO II=1,NFIELDi[
               5                      XPLOT(II)=RTREAT*SQRT((FLOAT(II))/(FLOAT(NFIELDi)));
               5                      YPLOT(II)=FSMFRR(I,II);
               5                      ERRYPLOT(II)=0.;HXMIN=0;"minimum R/half-side = 0"
               5                      ]
               4                  DO II=NFIELDi+1,NFIELD[
               5                      XPLOT(II)=SQRT(((RFIELD**2-RTREAT**2)*
               5                      ((FLOAT(II-NFIELDi))/(FLOAT(NFIELDo))))+RTREAT**2);
               5                      " Not equal areas, divide the area of RTREAT region "
               5                      " with the area of RFIELD region "
               5                      YPLOT(II)=FSMFRR(I,II)*(((RTREAT**2/FLOAT(nFIELDi)))/
               5                      ((RFIELD**2-RTREAT**2)/FLOAT(NFIELDo)));
               5                      ERRYPLOT(II)=0.;HXMIN=0;"minimum R/half-side = 0"
               5                      ]
               4                  ]
               3              ELSEIF(MSMFXY = 2)["rectangular field"
               4                  IF(II = 0)["along x"
               5                      DO II=1,NFIELD[
               6                          XPLOT(II)=(XFLDMN+(XFLDMX-XFLDMN)*FLOAT(II)/
               6                          FLOAT(NFIELD));
               6                          YPLOT(II)=FSMFXY(I,II,III);
               6                          ERRYPLOT(II)=0.;
               6                          WRITE(6,*)XFLDMN,XFLDMX,XPLOT(II),YPLOT(II);
               6                          ]
               5                      ]
               4                  ELSEIF(II = 1)["along y"
               5                      DO II=1,NFIELD[
               6                          XPLOT(II)=(YFLDMN+(YFLDMX-YFLDMN)*FLOAT(II)/
               6                          FLOAT(NFIELD));
               6                          YPLOT(II)=FSMFXY(I,III,II);
               6                          ERRYPLOT(II)=0.;
               6                          WRITE(6,*)YFLDMN,YFLDMX,XPLOT(II),YPLOT(II);
               6                          ]
               5                      ]
               4                  ]
               3              CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
               3              SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
               3              ]"end of choice=3"
               2          ]"END OF LOOP FOR EACH SOURCE"
               1
               1      OUTPUT;(/' PLOT ANOTHER ENERGY/PLANAR FLUENCE INTO THE SAME FILE?'/
               1      ' (Note: energy and fluence should be in separate file!)'/);
               1      OUTPUT;( ' INPUT (1) TO CONTINUE OR (0) TO QUIT:'/' ',$);
               1      INPUT CHOICE;(I8);
               1      IF(CHOICE = 1) [
               2          GOTO :PLOTTING-DATA:;
               2          ]
               1      CLOSE(UNIT=3,STATUS='KEEP');
               1      CALL XVGR_SCRIPT;
               1      ]
               0  :STOP-FOR-GOOD:;
               0
               0  OUTPUT;(/' WOULD YOU LIKE TO RUN THIS PROGRAMME AGAIN?');
               0  OUTPUT;(/' INPUT (1) TO CONTINUE OR (0) TO QUIT:'/' ',$);
               0  INPUT CHOICE;(I8);
               0  IF(CHOICE = 1) [
               1      EGSPERT = .true.; "Turn off wordy prompts for first-time users"
               1      GOTO :START-CHOICE1-0:;
               1      ]
               0
               0  RETURN;
               0  END; "End of SUBROUTINE BEAMDP1"
               0
               0  %L                                                                             ;
               0  !LABELS 7000;
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  %I4                                                                            ;
1              0  %E
               0  %B132                                                                          ;
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  "*******************************************************************************
               0  SUBROUTINE READ_PHSP;
               0  "
               0  " THIS IS A SUBROUTINE USED BY BEAMDP TO READ DATA FROM A PHASE-SPACE FILE.
               0  "
               0  " PROGRAMMER C-M MA
               0  "
               0  "*******************************************************************************
               0
               0  "**VARIABLES**"
               0
               0  "---Force declarations of all variables---"
               0  IMPLICIT NONE;
               0
               0  COMIN/CHARACTERS;
               0  COMIN/DOUBLES;
               0  COMIN/REALS;
               0  COMIN/INTEGERS;
               0  COMIN/LOGICALS;
               0  COMIN/RWPHSP/;
               0
               0  i_log=6;
               0
               0  "initialize counters"
               0  E_MIN_ph_sp = 1000.0;
               0  E_MAX_ph_sp = 0.0;
               0  RSSD0=RSSD1-RSSD1/40.;"the inner radius of the ring for SSD analysis"
               0  RSSD02=RSSD0*RSSD0;RSSD12=RSSD1*RSSD1;"we need the squares for later use"
               0  DO III=1,$ND[
               1      DO IIII=1,$NS[
               2          RSSDST(IIII,III)=0.0;
               2          ]
               1      ]
               0  DO III=1,$NBINANGLE[
               1      FSMABN1(III)=0.0;"ANGULAR DISTRIBUTION:
               1      ]
               0  DO III=1,NSMFPS[
               1      SMFRTN(III)=0.0;
               1      DO IIII=1,NFIELD[
               2          FSMFRR(III,IIII)=0.0;
               2          FSMFXX(III,IIII)=0.0;
               2          FSMFYY(III,IIII)=0.0;
               2          DO IIIII=1,NFIELD[FSMFXY(III,IIII,IIIII)=0.0;]
               2          ]
               1      DO IIII=1,NSMFEE[
               2          DO IIIII=1,NFIELD[
               3              FSMFBN1(III,IIIII,IIII)=0.0;
               3              ]
               2          ]
               1      ]
               0  /N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,NPASS_ph_sp/=0;
               0  /E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp/=0.0;
               0  E_MIN_ph_sp = 1000.0;
               0
               0  "calculate constants for later use"
               0  SFACTOR=FLOAT(NSMFEE)/SMFMXE;
               0  SSFACTOR=FLOAT($NBINANGLE)/$MAXANGLE;
               0  IF(RFIELD = 0.0)&(MSMFXY ~= 2)
               0  [RFIELD=0.0001;OUTPUT;(/' RADIUS RE-SET TO 0.0001 CM');]
               0
               0  IF(RFIELD = 0.)[RFACTOR=FLOAT(NFIELD);]
               0  ELSE[RFACTOR=FLOAT(NFIELD)/(RFIELD**2);]
               0
               0  RFACTOR1 = FLOAT(NFIELDi)/(RTREAT**2);
               0  RFACTOR2 = FLOAT(NFIELDo)/(RFIELD**2-RTREAT**2);
               0
               0  IF((YFLDMX-YFLDMN) = 0.)[Y=FLOAT(NFIELD);]
               0  ELSE[Y=FLOAT(NFIELD)/(YFLDMX-YFLDMN);]
               0  IF((XFLDMX-XFLDMN) = 0.)[X=FLOAT(NFIELD);]
               0  ELSE[X=FLOAT(NFIELD)/(XFLDMX-XFLDMN);]
               0
               0  :READING-PH-SP-FILE:;
               0
               0  OUTPUT;(/' BEGIN READING PH-SP DATA .....');
               0
               0  IPARANOT=1; "START WITH THE FIRST PARTICLE IN FILE"
               0  NHSTRY=0;"no. of primary histories"
               0
               0  LOOP["read phase-space data from the data file"
               1
               1      ;:start-of-file-read:;
               1
               1      IPARANOT=IPARANOT+1;"NOTE THE SECOND RECORD STORES THE FIRST PARTICLE"
               1      IF(IPARANOT = PARANOT+2)["end of file encountered"
               2          GOTO :end-of-file-read:;
               2          ]
               1
               1      IF(i_iaea_in=1)[
               2          $IAEA_READ_PHSP_RECORD(i_unit_in,NPASSI,NHSTRY,LATCHI,IQ,EI,
               2          WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MUIDX);
               2          ]
               1      ELSE[
               2
               2          IZLAST1=0;
               2          IF(MODE_RW='MODE2') IZLAST1=1;
               2          $READ_PHSP(IZLAST1,2,IPARANOT:NHSTRY,NPASSI,IQ,WIN,ZLAST,LATCHI,
               2          EI,WEIGHT,XIN,YIN,UIN,VIN);
               2          ]
               1
               1      IF (NPASSI ~= 0) [
               2          NPASS_ph_sp = NPASS_ph_sp + 1;
               2          GOTO :start-of-file-read:;
               2          "Discard particles if they or their ancestors have crossed"
               2          "scoring plane"
               2          ]
               1
               1      IF(IQ = -1)[ "We need kinetic energy only"
               2          EI=EI-0.5109989461;
               2          N_ph_sp_e = N_ph_sp_e + 1; E_ph_sp_e = E_ph_sp_e+EI;
               2          ]
               1      ELSEIF(IQ = 0)[
               2          N_ph_sp_g = N_ph_sp_g + 1; E_ph_sp_g = E_ph_sp_g+EI;
               2          ]
               1      ELSEIF(IQ = +1)[
               2          EI=EI-0.5109989461;
               2          N_ph_sp_p = N_ph_sp_p + 1; E_ph_sp_p = E_ph_sp_p+EI;
               2          ]
               1      ELSE[
               2          OUTPUT IQ;(/' Charge of the particle = ',I4,' ???'//
               2          ' Never seen this kind of particle!!!'//
               2          ' Something must have gone WRONG!!!'/);
               2          STOP;
               2          ]
               1      E_MIN_ph_sp = MIN(E_MIN_ph_sp,EI);
               1      E_MAX_ph_sp = MAX(E_MAX_ph_sp,EI);
               1
               1      IF (SMFMNE > E_MIN_ph_sp)[
               2          OUTPUT IPARANOT-1,IQ,EI,SMFMNE;
               2          (/' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'/
               2          ' '/
               2          '     For particle number', I13, '  of charge',I3/
               2          '     The (min.) energy read from the PH-SP file= ',F12.5//
               2          '     is smaller than your input lower limit of', F10.3 /
               2          '              stopping now                    '/
               2          ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'/);
               2          STOP;
               2          ]
               1      IF (SMFMXE < E_MAX_ph_sp)[
               2          OUTPUT IPARANOT-1,IQ,EI,SMFMXE;
               2          (/' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'/
               2          ' '/
               2          '     For particle number', I13, '  of charge',I3/
               2          '     The (max.) energy read from the PH-SP file= ',F12.5//
               2          '     is larger than your input upper limit of', F10.3 /
               2          '              stopping now                    '/
               2          ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'/);
               2          STOP;
               2          ]
               1      ELSEIF(EI < 0.0)[
               2          OUTPUT;(/' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'///
               2          ' '/
               2          '     THE ENERGY READ FROM THE PH-SP DATA FILE '//
               2          '       IS SMALLER THAN ZERO, ANYTHING WRONG?  '///
               2          '              stopping now                    '/
               2          ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'/);
               2          STOP;
               2          ]
               1
               1      " Processing the ph-sp data "
               1      " ************************* "
               1
               1      I=0;II=0;
               1      LOOP[
               2          " find out the sub-source where  the particle came from this method is "
               2          " approximate but good enough for the simplified model.We suppose that "
               2          " the particle is from the  sub-source ( i.e. a component module, CM), "
               2          " which is the  nearest to the  scoring plane compared with other CMs, "
               2          " and  where  the  particle has  been to. We  therefore  ignore  those "
               2          " particles which have been to a nearer  CM but scattered back to a CM "
               2          " further away from the  scoring plane and then  scattered back to the "
               2          " scoring  plane. Their  effects are  supposed  to  be  negligible for "
               2          " high-energy electron beams.       "
               2
               2          I=I+1;
               2          IF(I > NSMFPS)
               2          GOTO :no-source-found:;
               2          III=LATCH(K(I));
               2
               2          IF(III<=0 & IBITS(LATCHI,1,$NS)=0 & IQSMFP(K(I)) = IQ)[
               3              "this is for photons that do not interact anywhere"
               3              II=K(I);
               3              GOTO :found-sub-source:;
               3              ]
               2          ELSEIF($BTEST(LATCHI,III))&(IQSMFP(K(I)) = IQ)[
               3              II=K(I); "the particle is from sub-source II"
               3              GOTO :found-sub-source:;
               3              ]
               2          "Otherwise, go back to check whether the particle is from the next "
               2          "nearest source."
               2          ]
               1
               1      ;:no-source-found:;
               1
               1      IF(II = 0)[
               2          "no sub-source has been found"
               2          IF(IQ = -1)[K1=K1+1;]
               2          ELSEIF(IQ = 0)[K2=K2+1;]
               2          ELSE[K3=K3+1;]
               2          ]
               1      GOTO :start-of-file-read:;
               1
               1      ;:found-sub-source:;
               1
               1      X2Y2=XIN*XIN+YIN*YIN;
               1      IF(ISMFPS(II) = 3)&(SMFMNR(II) = 0.0)[
               2          IF(X2Y2<RSSD12)&(X2Y2>RSSD02)&(WIN ~= 0.0)[
               3              "fill in array for the image distribution"
               3              IF(WIN ~= 0.)[RRFACTOR=DELTAZ/WIN;]ELSE[RRFACTOR=DELTAZ;]
               3              IIII=INT(10.*SQRT((XIN+RRFACTOR*UIN)*(XIN+RRFACTOR*UIN)+
               3              (YIN+RRFACTOR*VIN)*(YIN+RRFACTOR*VIN)))+1;
               3              IF(IIII < 2000)[
               4                  RSSDST(II,IIII)=RSSDST(II,IIII)+WEIGHT;
               4                  ]
               3              ]
               2          "fill in array for angular distribution"
               2          IF(IQ ~= 0)["ONLY FOR CHARGED PARTICLES"
               3              IF(X2Y2 <= 0.25)["within r = 0.5 cm"
               4                  IA=INT(ACOS(WIN)*SSFACTOR)+1;
               4                  IF((IA <= $NBINANGLE) & (EI >= SMFMXE/2.))[
               5                      FSMABN1(IA)=FSMABN1(IA)+WEIGHT;
               5                      ]
               4                  ]
               3              ]
               2          ]
               1
               1      " Circular field "
               1      " -------------- "
               1      IF(MSMFXY = 0)[
               2          " Is particle in the treatment field? "
               2          IF(X2Y2<=(RTREAT*RTREAT))[
               3              " Inside the treatment field (RTREAT) we "
               3              " can have NFIELDi equal area size bins "
               3              IR=INT(X2Y2*RFACTOR1)+1;
               3              ]
               2          " Is particle in the scoring field? "
               2          ELSEIF(X2Y2<=(RFIELD*RFIELD))[
               3              " Inside the scoring field (RFIELD) we "
               3              " can have NFIELDo equal area size bins "
               3              " This index goes on top of NFILEDi "
               3              IR=INT((X2Y2-RTREAT**2)*RFACTOR2)+NFIELDi+1;
               3              ]
               2          ELSE [
               3              " This can happen if scoring field in this program "
               3              " is smaller than scoring field in the phase-space "
               3              IR = NFIELD + 1;
               3              ]
               2
               2          " Check indexes "
               2          IF(IR > NFIELD) [
               3              NWRONG=NWRONG+1;
               3              GOTO :start-of-file-read:;
               3              ]
               2          " Fill in field distribution "
               2          FSMFRR(II,IR)=FSMFRR(II,IR)+WEIGHT;
               2          ]
               1
               1      " Square field with square rings "
               1      " ------------------------------ "
               1      ELSEIF(MSMFXY = 1)[
               2          " Is X coordinate inside the treatment field? "
               2          IF(ABS(XIN) <= RTREAT) [
               3              " Inside the treatment field (RTREAT) we "
               3              " can have NFIELDi equal area size bins "
               3              IX=INT(XIN*XIN*RFACTOR1)+1;
               3              RBin_X=0.5*SQRT(RTREAT**2*(FLOAT(IX)/FLOAT(NFIELDi)));
               3              ]
               2          " Is X coordinate inside the scoring field? "
               2          ELSEIF(ABS(XIN) <= RFIELD) [
               3              " Inside the scoring field (RFIELD) we "
               3              " can have NFIELDo equal area size bins "
               3              IX=INT((XIN*XIN-RTREAT**2)*RFACTOR2)+NFIELDi+1;
               3              RBin_X=0.5*SQRT((RFIELD**2-RTREAT**2)*(FLOAT(IX-NFIELDi)/
               3              FLOAT(NFIELDo))+RTREAT**2);
               3              ]
               2          ELSE [
               3              " This can happen if scoring field in this program "
               3              " is smaller than scoring field in the phase-space "
               3              IX = NFIELD + 1;
               3              ]
               2
               2          " Is Y coordinate inside the treatment field? "
               2          IF(ABS(YIN) <= RTREAT) [
               3              " Inside the treatment field (RTREAT) we "
               3              " can have NFIELDi equal area size bins "
               3              IY=INT(YIN*YIN*RFACTOR1)+1;
               3              RBin_Y=0.5*RTREAT*SQRT(FLOAT(IY)/FLOAT(NFIELDi))
               3              ]
               2          " Is Y coordinate inside the scoring field? "
               2          ELSEIF(ABS(YIN) <= RFIELD) [
               3              " Inside the scoring field (RFIELD) we "
               3              " can have NFIELDo equal area size bins "
               3              IY=INT((YIN*YIN-RTREAT**2)*RFACTOR2)+NFIELDi+1;
               3              RBin_Y=0.5*SQRT((RFIELD**2-RTREAT**2)*(FLOAT(IY-NFIELDi)/
               3              FLOAT(NFIELDo))+RTREAT**2);
               3              ]
               2          ELSE [
               3              " This can happen if scoring field in this program "
               3              " is smaller than scoring field in the phase-space "
               3              IY = NFIELD + 1;
               3              ]
               2
               2          " Check indexes "
               2          IF((IX > NFIELD) | (IY > NFIELD))[
               3              NWRONG=NWRONG+1;
               3              GOTO :start-of-file-read:;
               3              ]
               2
               2          IF(IX <= IY)[ "find index"
               3              FSMFRR(II,IY)=FSMFRR(II,IY)+WEIGHT;
               3              IF(ABS(XIN) <= RBin_Y)[
               4                  FSMFR1(II,IY)=FSMFR1(II,IY)+WEIGHT;
               4                  "this array will be used to fit a function later"
               4                  "to simulate the variation of planar fluence in a bin"
               4                  ]
               3              ELSE[
               4                  FSMFR2(II,IY)=FSMFR2(II,IY)+WEIGHT;
               4                  ]
               3              IF(IX = IY)
               3              FSMFR2(II,IY)=FSMFR2(II,IY)+WEIGHT;
               3              "The particles in the corners should be counted twice"
               3              ]
               2          ELSE[
               3              FSMFRR(II,IX)=FSMFRR(II,IX)+WEIGHT;
               3              IF(ABS(YIN) <= RBin_X)[
               4                  FSMFR1(II,IX)=FSMFR1(II,IX)+WEIGHT;
               4                  ]
               3              ELSE[
               4                  FSMFR2(II,IX)=FSMFR2(II,IX)+WEIGHT;
               4                  ]
               3              ]
               2          ]
               1      " Rectangular field "
               1      " ----------------- "
               1      ELSEIF(MSMFXY = 2)[
               2          IF((XIN-XFLDMN) >= 0.0)[IX=INT((XIN-XFLDMN)*X)+1;]
               2          ELSE[IX=0;"to avoid round-off error for minus values close to 0"]
               2          IF((YIN-YFLDMN) >= 0.0)[IY=INT((YIN-YFLDMN)*Y)+1;]
               2          ELSE[IY=0;]
               2          IF((IX > NFIELD) |  (IY > NFIELD))[
               3              NWRONG=NWRONG+1;
               3              GOTO :start-of-file-read:;
               3              ]
               2          ELSEIF((IX < 1) |  (IY < 1))[
               3              NWRONG=NWRONG+1;
               3              GOTO :start-of-file-read:;
               3              ]
               2          FSMFXY(II,IX,IY)=FSMFXY(II,IX,IY)+WEIGHT;
               2          ]
               1
               1      " Weighted number of particles for this source "
               1      SMFRTN(II)=SMFRTN(II)+WEIGHT;
               1
               1      " Fill in each bin of the energy and field planar fluence distribution "
               1      " -------------------------------------------------------------------- "
               1      IE=INT(EI*SFACTOR)+1;
               1
               1      " If the index is bigger than the number of bins ... "
               1      IF(IE > NSMFEE)
               1      IE=NSMFEE;
               1
               1      " Circular field distribution "
               1      IF(MSMFXY = 0)[
               2          " In the following loop both type of energy spectrums were covered "
               2          " Inside/outside because NFIELDe=2 "
               2          " but also energy spectrum type with different radii "
               2          DO III=1,NFIELDe [
               3              IF( SQRT(XIN*XIN+YIN*YIN) <= ERADII(III) ) [
               4                  FSMFBN1(II,III,IE) = FSMFBN1(II,III,IE)+WEIGHT;
               4                  " Done, exit the loop "
               4                  EXIT;
               4                  ]
               3              ]
               2          ]
               1      " Square field distribution with symmetrical rings "
               1      ELSEIF(MSMFXY = 1)[
               2          " In the following loop both type of energy spectrums were covered "
               2          " Inside/outside because NFIELDe=2 "
               2          " but also energy spectrum type with different radii "
               2          DO III=1,NFIELDe [
               3              IF((ABS(XIN) <= ERADII(III)) & (ABS(YIN) <= ERADII(III))) [
               4                  FSMFBN1(II,III,IE) = FSMFBN1(II,III,IE)+WEIGHT;
               4                  " Done, exit the loop "
               4                  EXIT;
               4                  ]
               3              ]
               2          ]
               1      " Rectangular field "
               1      ELSEIF(MSMFXY = 2)[
               2          IF((XIN <= XTREATMX) & (YIN <= YTREATMX) &
               2          (XIN > XTREATMN) & (YIN > YTREATMN))[
               3              FSMFBN1(II,1,IE)=FSMFBN1(II,1,IE)+WEIGHT;
               3              "energy distribution, within treatment field"
               3              ]
               2          ELSE[
               3              FSMFBN1(II,2,IE)=FSMFBN1(II,2,IE)+WEIGHT;
               3              "energy distribution, outside treatment field"
               3              ]
               2          ]
               1
               1      K4=K4+1;"total number of particles analyzed for e/f distributions"
               1      KWEI=KWEI+WEIGHT;"weighted total number of particles analyzed"
               1
               1      ]"end of read phase-space data loop"
               0
               0  ;:end-of-file-read:;
               0
               0  RETURN;
               0  END;
               0
               0  %L                                                                             ;
               0  !LABELS 10000;
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  %I4                                                                            ;
1              0  %E
               0  %B132                                                                          ;
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  "*******************************************************************************
               0  SUBROUTINE READNAME;
               0  "
               0  " THIS IS A SUBROUTINE USED BY BEAMDP TO READ A PHASE-SPACE FILE NAME.
               0  "
               0  " PROGRAMMER C-M MA
               0  "
               0  "*******************************************************************************
               0
               0  "**VARIABLES**"
               0
               0  "---Force declarations of all variables---"
               0  IMPLICIT NONE;
               0
               0  COMIN/CHARACTERS;
               0  COMIN/DOUBLES;
               0  COMIN/REALS;
               0  COMIN/INTEGERS;
               0  COMIN/LOGICALS;
               0
               0  INTEGER lnblnk1,len;
               0
               0  IF ~EGSPERT[ CALL HELP_MESSAGE(61); ]
               0  :R:
               0  OUTPUT;
               0  (/' Name of file containing phase space data (with ext., < A100):'/' ',$);
               0  IF OLDFILE[
               1      OUTPUT PSDNAM;
               1      (/' The old file was      ',A100/
               1      ' Do you want to change it? ',$);
               1      INPUT C1;(A1);
               1      IF (C1='?')GO TO :RRR:;
               1      IF (C1='y')|(C1='Y')[ OUTPUT;
               2          (/' Name of file containing phase space data (with ext., < A100):'
               2          /' ',$);
               2          ]
               1      ELSE[GOTO :RR:;]
               1      ]
               0  READ(5,'(A100)',ERR=:RRR:)PSDNAM;
               0  OUTPUT PSDNAM;(' File name input is:', A100);
               0  i_iaea_in=0; "assume not in IAEA format"
               0  len=lnblnk1(PSDNAM);
               0  IF(PSDNAM(len-8:len)='.IAEAphsp')[
               1      i_iaea_in=1;
               1      PSDNAM=PSDNAM(:len-9)//char(0);
               1      OUTPUT;(/' Data is in IAEA format.'/);
               1      ]
               0  GOTO :RR:;
               0  :RRR:
               0  CALL HELP_MESSAGE(50);
               0  GOTO :R:;
               0  :RR:;
               0
               0  RETURN;
               0  END;
               0
               0  %L                                                                             ;
               0  !LABELS 1000;
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  %I4                                                                            ;
1              0  %E
               0  %B132                                                                          ;
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  "*******************************************************************************
               0  SUBROUTINE OPENFILE;
               0  "
               0  " THIS IS A SUBROUTINE USED BY BEAMDP TO OPEN A PHASE-SPACE FILE.
               0  "
               0  " PROGRAMMER C-M MA
               0  "
               0  "*******************************************************************************
               0
               0  "**VARIABLES**"
               0
               0  "---Force declarations of all variables---"
               0  IMPLICIT NONE;
               0  COMIN/CHARACTERS;
               0  COMIN/DOUBLES;
               0  COMIN/REALS;
               0  COMIN/INTEGERS;
               0  COMIN/LOGICALS;
               0  COMIN/RWPHSP/;
               0  integer itmp;
               0
               0  i_log=6;
               0
               0  :OPEN-FILE:;
               0
               0  IF(i_iaea_in=1)[
               1      i_unit_in=2;
               1      $IAEA_OPEN_PHSP_FOR_READ(i_unit_in,PSDNAM);
               1      $IAEA_READ_PHSP_HEADER(i_unit_in,PARANOT,PARANOP,PARAEMAX,LPARANINC,
               1      Z_SCORE,IZLAST1,IMUIDX1,IZSCORE1);
               1      OUTPUT PARANOT,PARANOP,PARAEMAX,LPARANINC;
               1      (/'            Total number of particles in file:',I13/
               1      '                      Total number of photons:',I13/
               1      '             The rest are electrons/positrons.'/
               1      ' '/
               1      '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
               1      ' # of incident particles from original source:',I13);
               1      IF(IZLAST1=1)[MODE_RW='MODE2';]
               1      ELSE[MODE_RW='MODE0';]
               1      IF(IZSCORE1=0)[
               2          OUTPUT Z_SCORE;
               2          ('                       Z at which phsp scored:',F13.3,' cm');
               2          ]
               1      IF(IMUIDX1~=0)[
               2          OUTPUT;(' Fractional MU index also scored in phase space data. '/);
               2          ]
               1      NINC=LPARANINC;
               1      ]
               0  ELSE[
               1
               1      itmp=-1;
               1      $OPEN_PHSP_FOR_READ(itmp,2,PSDNAM,MODE_RW,PARANOT,
               1      PARANOP,PARAEMAX,PARAEMNE,PARANINC);
               1      IF(IERR_PHSP~=0) GOTO :RRRR1:;
               1
               1      OUTPUT PARANOT,PARANOP,PARAEMAX,PARAEMNE;
               1      (/'            Total number of particles in file:',I13/
               1      '                       Total number of photons:',I13/
               1      '             The rest are electrons/positrons.'/
               1      ' '/
               1      '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
               1      '      Minimum kinetic energy of the electrons:',F13.3,' MeV');
               1      IF(PARANINC < 2.)["an old file which stored min. phot. energy"
               2          OUTPUT PARANINC;
               2          ('        Minimum kinetic energy of the photons:',F13.3,' MeV');
               2          NINC=1;
               2          ]
               1      ELSE[
               2          OUTPUT PARANINC;
               2          (' # of incident particles from original source:',F13.1);
               2          NINC=PARANINC;
               2          ]
               1      ]
               0  RETURN;
               0  :RRRR1: OUTPUT;(//' CANNOT FIND/OPEN THE PH-SP FILE!!!'///);
               0  "ask the user whether a different ph-sp file to be used"
               0  IF EGSPERT[ CALL HELP_MESSAGE(61); ]
               0  CALL READNAME;
               0  GOTO :OPEN-FILE:;"OPEN FILE AGAIN"
               0
               0  END;
               0
               0  %L                                                                             ;
               0  !LABELS 7000;
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  %I4                                                                            ;
1              0  %E
               0  %B132                                                                          ;
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  "*******************************************************************************
               0  SUBROUTINE HELP_MESSAGE(NMESSAGE);
               0  "
               0  " THIS IS A SUBROUTINE USED BY BEAMDP TO PRINT OUT HELP MESSAGES
               0  "
               0  " PROGRAMMER B. Walters
               0  "
               0  "*******************************************************************************
               0
               0  "**VARIABLES**"
               0  INTEGER NMESSAGE; "determines the message to be printed"
               0
               0  IF(NMESSAGE=0)[
               1      OUTPUT;(/
               1      ' BEAMDP (BEAM Data Processor) creates a source parameter file'/
               1      ' for beam characterization models with information obtained'/
               1      ' from the user and derived from a full phase-space data file'/
               1      ' created by BEAM'/
               1      ' '/
               1      ' This programme can be used to derive planar fluence, spectrum,'/
               1      ' mean energy and angle distribution, etc., from a phase-space'/
               1      ' file created by BEAM.'/
               1      ' '/
               1      ' If you are not familiar with this programme, you can get an'/
               1      ' explanation before any input request. Otherwise, the prompts'/
               1      ' will be terse.'//
               1      ' However, you can get help by typing a ? to any prompt.'/);
               1      ]
               0  ELSEIF(NMESSAGE=1)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' You have the following operation options:'/
               1      ' -------------------------------------------------------------'/
               1      '                                                              '/
               1      ' (0) - data processing for beam characterization models'/
               1      '       (input 0 for more detailed information)'/
               1      ' (1) - deriving fluence vs position from ph_sp data'/
               1      '       (number of particles vs position for required charge, region'/
               1      '        and LATCH)'/
               1      ' (2) - deriving energy fluence vs position from ph_sp data'/
               1      '       (kinetic energy vs position for required charge, region and'/
               1      '        LATCH)'/
               1      ' (3) - deriving energy spectrum from ph_sp data'/
               1      '       (particle spectrum for required charge, region and LATCH)'/
               1      ' (4) - deriving energy fluence distribution from ph_sp data '/
               1      '       (energy fluence distribution for required charge, region and'/
               1      '        LATCH)'/
               1      ' (5) - deriving mean energy information from ph_sp data'/
               1      '       (mean energy for required charge, region and LATCH)'/
               1      ' (6) - deriving angular distribution from ph_sp data');
               1      OUTPUT;(
               1      '       (angular distribution for required charge, region and LATCH)'/
               1      ' (7) - deriving zlast distribution from ph_sp data'/
               1      '       (angular distribution for required charge, region and LATCH)'/
               1      ' (8) - deriving information about particle weights from ph_sp data '/
               1      '       (distribution of weights for specified charge,region and LATCH)'/
               1      ' (9) - deriving X-Y positions of particles'/
               1      '       (X-Y scatter plot of particles for specified charge,region and'/
               1      '        LATCH)'/
               1      ' (10) - combining two ph-sp files into one'/
               1      '       (write the contents of file1 into file2)'/
               1      ' (11) - list parameters for a number of ph-sp particles'/
               1      '       (list IQ,X,Y,U,V,W,E,WEIGHT,LATCH on the screen)'/
               1      ' (12) - quit this programme'/
               1      ' -------------------------------------------------------------');
               1      ]
               0  ELSEIF(NMESSAGE=2)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' CHOOSE FROM THE FOLLOWING: '/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      '    0 for a circular field with circular ring bins'/
               1      '    1 for a square field with square ring bins'/
               1      '    2 for a rectangular field with rectangular voxels'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=3)[
               1      OUTPUT $NB;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS REQUIRED FOR FLUENCE/ENERGY FLUENCE VS POSITION:'/
               1      ' ------------------------------------------------------------- '/
               1      ' '/
               1      ' The following parameters are needed for fluence vs position:'/
               1      ' '/
               1      '  1) number of radial bins into which field is divided (<',I4,')'/
               1      '  2) charge of the particles (0:phot,1:posi,-1:elec,2:all,3:e+e-)'/
               1      '  3) outer radius of the circular field'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=4)[
               1      OUTPUT $NB;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS REQUIRED FOR FLUENCE/ENERGY FLUENCE VS POSITION:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are needed for fluence vs position: '/
               1      ' '/
               1      '  1) number of square bins into which field is divided (<',I4,')'/
               1      '  2) charge of the particles (0:photon,1:e+,-1:e-,2:all,3:e+e-)'/
               1      '  3) half-side of the square field'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=5)[
               1      OUTPUT $NB;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS REQUIRED FOR FLUENCE/ENERGY FLUENCE VS POSITION:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' Input the following parameters:'/
               1      ' '/
               1      '  1) number of bins into which field is divided (<',I4,')'/
               1      '  2) orientation (0-along x-axis; 1-along y-axis)'/
               1      '  3) charge (0:photon,1:e+,-1:e-,2:all,3:e+e-)'/
               1      '  4) Xmin for a rectangular field'/
               1      '  5) Xmax for a rectangular field'/
               1      '  6) Ymin for a rectangular field'/
               1      '  7) Ymax for a rectangular field'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=6)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS FOR THE SPECTRAL OR ENERGY FLUENCE DISTRIBUTION:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are needed for the energy spectrum '/
               1      ' or energy fluence distribution: '/
               1      ' '/
               1      '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
               1      '  2) Xmin for a rectangular region anywhere on the scoring plane'/
               1      '  3) Xmax for the rectangular region'/
               1      '  4) Ymin for the rectangular region'/
               1      '  5) Ymax for the rectangular region'/
               1      '     (Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15)'/
               1      ' Or'/
               1      '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
               1      '  2) Rmin for an annular region centred at the z-axis'/
               1      '  3) Rmax for the annular region'/
               1      '     (Rmin,Rmax default to 0,15)'/
               1      ' '/
               1      '     Note: if you hit return here you get a rectangular field'/
               1      '       (i.e.,  Xmin,Xmax,Ymin,Ymax =-15,15,-15,15)'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=7)[
               1      OUTPUT $NB;(/
               1      ' ----------------------------------------------------------------'/
               1      ' NUMBER OF BINS AND MIN. ENERGY, MAX. ENERGY FOR THE DISTRIBUTION:'/
               1      ' ---------------------------------------------------------------- '/
               1      ' '/
               1      ' The maximum number of bins allowed is ',I4/
               1      ' and the energy range given below should be consistent with the'/
               1      ' phase-space data. For example, Emin should be =< (ECUT-0.511)'/
               1      ' used in the simulation with BEAM, and Emax should be greater '/
               1      ' than the maximum kinetic energy of the particles in the ph-sp data.'/
               1      ' '/
               1      ' ----------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=8)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS FOR THE REQUIRED ANGULAR DISTRIBUTION:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are needed:'/
               1      ' '/
               1      '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
               1      '  2) Xmin for a rectangular region anywhere on the scoring plane'/
               1      '  3) Xmax for the rectangular region'/
               1      '  4) Ymin for the rectangular region'/
               1      '  5) Ymax for the rectangular region'/
               1      '     (Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15)'/
               1      ' Or '/
               1      '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
               1      '  2) Rmin for an annular region centred at the z-axis'/
               1      '  3) Rmax for the annular region'/
               1      '     (Rmin,Rmax default to 0,15)'/
               1      ' '/
               1      '     Note: if you hit return here you get a rectangular field'/
               1      '       (i.e.,  Xmin,Xmax,Ymin,Ymax =-15,15,-15,15)'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=9)[
               1      OUTPUT $NBINANGLE;(/
               1      ' -------------------------------------------------------------'/
               1      ' NUMBER OF BINS, MIN. ANGLE, MAX. ANGLE: '/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The maximum number of bins allowed is ',I4/
               1      ' and the angle should be between 0 - 90 degrees'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=10)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS FOR THE REQUIRED ZLAST DISTRIBUTION:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are needed:'/
               1      ' '/
               1      '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
               1      '  2) Xmin for a rectangular region anywhere on the scoring plane'/
               1      '  3) Xmax for the rectangular region'/
               1      '  4) Ymin for the rectangular region'/
               1      '  5) Ymax for the rectangular region'/
               1      '     (Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15)'/
               1      ' Or'/
               1      '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
               1      '  2) Rmin for an annular region centred at the z-axis'/
               1      '  3) Rmax for the annular region'/
               1      '     (Rmin,Rmax default to 0,15)'/
               1      ' '/
               1      '     Note: if you hit return here you get a rectangular field'/
               1      '       (i.e.,  Xmin,Xmax,Ymin,Ymax =-15,15,-15,15)'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=11)[
               1      OUTPUT $NBINANGLE;(/
               1      ' -------------------------------------------------------------'/
               1      ' NUMBER OF BINS, Zmin, Zmax:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The maximum number of bins allowed is ',I4/
               1      ' and the range of ZLAST '/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=12)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS FOR THE REQUIRED WEIGHT DISTRIBUTION:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are needed for the weight distribution:'/
               1      ' '/
               1      '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
               1      '  2) Xmin for a rectangular region anywhere on the scoring plane'/
               1      '  3) Xmax for the rectangular region'/
               1      '  4) Ymin for the rectangular region'/
               1      '  5) Ymax for the rectangular region'/
               1      '     (Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15)'/
               1      ' Or'/
               1      '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
               1      '  2) Rmin for an annular region centred at the z-axis'/
               1      '  3) Rmax for the annular region'/
               1      '     (Rmin,Rmax default to 0,15)'/
               1      ' '/
               1      '     Note: if you hit return here you get a rectangular field'/
               1      '       (i.e.,  Xmin,Xmax,Ymin,Ymax =-15,15,-15,15)'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=13)[
               1      OUTPUT $NB;(/
               1      ' -----------------------------------------------------------------'/
               1      ' NUMBER OF BINS AND MIN. WEIGHT, MAX. WEIGHT FOR THE DISTRIBUTION:'/
               1      ' -----------------------------------------------------------------'/
               1      ' '/
               1      ' The maximum number of bins allowed is ',I4/
               1      ' and the weight range given below should be consistent with the'/
               1      ' phase-space data and also consistent with fact that the weights'/
               1      ' are plotted on a logarithmic scale. For example, the min. weight'/
               1      ' should be slightly greater than 0 and the max. weight should be'/
               1      ' slightly greater than 1.'/
               1      ' '/
               1      ' -----------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=14)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS FOR THE X-Y SCATTER PLOT:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are needed for the X-Y scatter plot'/
               1      ' '/
               1      '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
               1      '  2) Xmin for a rectangular region anywhere on the scoring plane'/
               1      '  3) Xmax for the rectangular region'/
               1      '  4) Ymin for the rectangular region'/
               1      '  5) Ymax for the rectangular region'/
               1      '     (Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15)'/
               1      ' Or'/
               1      '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
               1      '  2) Rmin for an annular region centred at the z-axis'/
               1      '  3) Rmax for the annular region'/
               1      '     (Rmin,Rmax default to 0,15)'/
               1      ' '/
               1      '     Note: if you hit return here you get a rectangular field'/
               1      '       (i.e.,  Xmin,Xmax,Ymin,Ymax =-15,15,-15,15)'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=15)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' MIN. ENERGY, MAX. ENERGY FOR THE PARTICLES IN THE SCATTER PLOT:'/
               1      ' ------------------------------------------------     '/
               1      '                                                             '/
               1      ' The energy range given below should be consistent with the'/
               1      ' phase-space data. For example, Emin should be =< (ECUT-0.511)'/
               1      ' used in the simulation with BEAM, and Emax should be greater '/
               1      ' than the maximum kinetic energy of the particles in the ph-sp data.'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=16)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' LATCH bit filters:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' Input the following 3 varibles in the same line:'/
               1      ' '/
               1      '  1) I_IN_EX: flag for LATCH checking'/
               1      '    = 0 INclusive/EXclusive for bits: if any of the 1st set of'/
               1      '        Nbit1 bits are set and none of the 2nd set of Nbit2 bits'/
               1      '        are set, the particle is scored'/
               1      '    = 1 EXclusive for bits: if any of the set of Nbit1 bits'/
               1      '        are set, the particle is not scored'/
               1      '    = 2 INclusive for regions: score secondary particles that'/
               1      '        originated in the regions with IREGION_TO_BIT'/
               1      '        equal to any of the set of Nbit1 bits'/
               1      '    = 3 EXclusive for regions: do not score secondary particles'/
               1      '        that originated in regions with IREGION_TO_BIT equal'/
               1      '        to any of the set of Nbit1 bits'/);
               1      ]
               0  ELSEIF(NMESSAGE=17)[
               1      OUTPUT;(
               1      '  2) Nbit1: the number of bits or regions of origin to'/
               1      '            include (I_IN_EX=0,2) or exclude (I_IN_EX=1,3)'/
               1      '  3) Nbit2: the number of bits to exclude.  Only has meaning'/
               1      '            for I_IN_EX=0, otherwise, it is automatically'/
               1      '            set to 0.'/
               1      ' '/
               1      '    Restrictions: for I_IN_EX=0:    0<=Nbit1+Nbit2<=29'/
               1      '                  for I_IN_EX=1:    0<=Nbit1<=29'/
               1      '                  for I_IN_EX=2,3:  0<=Nbit1<=24'//);
               1      ]
               0  ELSEIF(NMESSAGE=18)[
               1      OUTPUT;(
               1      ' Input the following in the next line:'/
               1      '  BIT(I) or IREGION_TO_BIT(I) (I = 1, Nbit1):'/
               1      '                                         bits/IREGION_TO_BITs to'/
               1      '                                         include (I_IN_EX=0,2) or'/
               1      '                                         exclude (I_IN_EX=1,3)'/
               1      ' '/
               1      ' Input the next line only if I_IN_EX=0 and Nbit2>0:'/
               1      '  BIT(I) or IREGION_TO_BIT(I) (I = Nbit1+1, Nbit1+Nbit2):'/
               1      '                                         bits to exclude when'/
               1      '                                         I_IN_EX=0'/
               1      ' '/
               1      '     (BIT(I) should be between 0 and 28 and IREGION_TO_BIT(I)'/
               1      '      should) be between 0 and 23)'/
               1      ' '/
               1      '  (Note: if no LATCH checking is required input 0,0,0 below)'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=19)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' LIST PARAMETERS FOR A NUMBER OF PARTICLES:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' Input the following:'/
               1      ' '/
               1      '  1) Number: number of particles to be listed (default to 100)'/
               1      ' '/
               1      '  2) IQ    : charge (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=20)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' YOU CAN CHOOSE THE FOLLOWING GRAPH TYPES:                    '/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' (0) - NORMAL POINT GRAPH'/
               1      ' (1) - HISTOGRAM'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=21)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' Plot of  real fluence or planar fluence:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' (0) - estimated real fluence: E(particle weight/cos(Z-angle))'/
               1      '                               ------------------------------- '/
               1      '                                         total area'/
               1      '  '/
               1      ' (1) - planar fluence: E(particle weight)'/
               1      '                       -------------------'/
               1      '                           total area'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=22)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' FILE CONTAINING FULL PHASE-SPACE DATA:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The full phase-space data created by the NRCC EGSnrc usercode'/
               1      ' BEAMnrc is stored in a compressed form. This programme uncompresses'/
               1      ' the data first and then analyses the data.'/
               1      ' '/
               1      ' The name of the file containing full phase-space data should be'/
               1      ' supplied here (with extension). '/
               1      ' '/
               1      ' A reminder - default BEAM ph-sp file name: [filename].egsphsp1'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=30)[
               1      OUTPUT;(/
               1      ' ------------------------------------------------------------------------'/
               1      ' USING SUB-SOURCE SPECIFIERS FROM AN EXISTING SOURCE MODEL FOR REFERENCE:'/
               1      ' ------------------------------------------------------------------------'/
               1      ' '/
               1      ' In order to help input the sub-source specifiers required to create a'/
               1      ' new source model, the sub-source specifiers from an existing source'/
               1      ' model can be used as a reference. However, if you do this, then the'/
               1      ' old and new source models will consist of the same number of sub-sources.'/
               1      '   '/
               1      ' In fact, it is sometimes easier to modify the sub-source specifiers'/
               1      ' directly by editing the source model than doing it interactively'/
               1      ' by running this program, and you are not confined by the'/
               1      ' condition mentioned above.'/
               1      ' -----------------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=31)[
               1      OUTPUT;(/
               1      ' ---------------------------------------------------------------'/
               1      ' FILE NAME INPUT:'/
               1      ' ---------------------------------------------------------------'/
               1      ' '/
               1      ' The name of the file containing the new source model.'/
               1      ' This could have been created by inputting sub-source specifiers'/
               1      ' from scratch and analyzing phase space data, modifying the'/
               1      ' sub-source specifiers of an existing source model, or analyzing'/
               1      ' phase space data using sub-source specifiers from an existing'/
               1      ' source model.'/
               1      ' ---------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=32)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' DETAILED INFORMATION ABOUT THE BEAM:'/
               1      ' -------------------------------------------------------------'/
               1      '                                                              '/
               1      ' The information about the machine, beam energy, field size, '/
               1      ' etc. will serve as a reminder for later use.'//
               1      ' Now input this information in one line (< 70 characters).'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=33)[
               1      OUTPUT $NS;(/
               1      ' -------------------------------------------------------------'/
               1      ' NUMBER OF SUB-SOURCES FOR THE SOURCE MODEL:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The maximum number of sub-sources is ',I4,'.'/
               1      ' This number is determined by the bit-setting number in BEAM.'/
               1      ' In general, one type of particles from a CM should be considered'/
               1      ' to be from a sub-source. However, scattering foils, mirror and'/
               1      ' monitoring chamber can be worked out as a virtual point source.'/
               1      ' If the relative source intensity of a sub-source is < 0.1% this'/
               1      ' sub-source will automatically be ignored in later use.'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=34)[
               1      OUTPUT I;(/
               1      ' -------------------------------------------------------------'/
               1      ' SOURCE TYPE FOR SUB-SOURCE',I4,', CHARGE, LATCH #:'/
               1      ' -------------------------------------------------------------'/
               1      '                                                             '/
               1      ' The source model consists of a number of sub-sources; each has'/
               1      ' its own energy spectrum and field distribution at the phantom'/
               1      ' surface. '/
               1      ' '/
               1      ' The component modules in a linear accelerator are classified'/
               1      ' into the following types:'/
               1      ' '/
               1      '       Source type 1  for aperture applicators'/
               1      '                   11 for tubular applicators'/
               1      '                   2  for collimators'/
               1      '                   3  for rings, cones, and point sources'/
               1      '                   4  for rectangular plane sources'/
               1      '                   5  for circular plane sources'/);
               1      OUTPUT $NS,$NS,$NS;(/
               1      ' The charge of the particles from the source:'/
               1      ' '/
               1      '           charge  0  for photons'/
               1      '                  -1  for electrons and'/
               1      '                   1  for positrons.'/
               1      ' '/
               1      ' The LATCH bit number must be <=',I3/
               1      ' If you input a LATCH bit in the range 1 - ',I3,' you are'/
               1      ' selecting particles that have been/interacted in region'/
               1      ' associated with the LATCH bit you have input.  If you input'/
               1      ' LATCH <= 0, then you are selecting particles that have none'/
               1      ' of bits 1 - ',I3,' set.  This latter option is generally only'/
               1      ' meaningful for virtual point sources.'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=35)[
               1      OUTPUT;(/
               1      ' --------------------------------------------------------------'/
               1      ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:'/
               1      ' --------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are required for this sub-source:'//
               1      ' 1) distance (in cm) from the sub-source to the scoring plane'/
               1      ' 2) minimum x coordinate (cm) for the opening of the applicator'/
               1      ' 3) maximum x coordinate (cm) for the opening of the applicator'/
               1      ' 4) minimum y coordinate (cm) for the opening of the applicator'/
               1      ' 5) maximum y coordinate (cm) for the opening of the applicator'/
               1      ' 6) maximum |x| coordinate (cm) for the applicator'/
               1      ' 7) maximum |y| coordinate (cm) for the applicator'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=36)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are required for this sub-source: '//
               1      ' 1) distance (in cm) from source bottom to scoring plane'/
               1      ' 2) distance (in cm) from source top to scoring plane'/
               1      ' 3) minimum x coordinate (cm) for the opening of the applicator'/
               1      ' 4) maximum x coordinate (cm) for the opening of the applicator'/
               1      ' 5) minimum y coordinate (cm) for the opening of the applicator'/
               1      ' 6) maximum y coordinate (cm) for the opening of the applicator'/
               1      ' 7) maximum |x| coordinate (cm) for the applicator'/
               1      ' 8) maximum |y| coordinate (cm) for the applicator'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=37)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are required for this sub-source:'/
               1      ' '/
               1      ' 1. distance (in cm) from the sub-source to the scoring plane'/
               1      ' 2. minimum x coordinate (cm) for the opening of the collimator'/
               1      ' 3. maximum x coordinate (cm) for the opening of the collimator'/
               1      ' 4. minimum y coordinate (cm) for the opening of the collimator'/
               1      ' 5. maximum x coordinate (cm) for the opening of the collimator'/
               1      ' 6. maximum |x| coordinate (cm) for the collimator'/
               1      ' 7. maximum |y| coordinate (cm) for the collimator'/
               1      ' 8. orientation of the collimator:'/
               1      '    (0-collimator bars along x-axis, 1-along y-axis)'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=38)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are required for this sub-source:'/
               1      ' '/
               1      '   1) distance from the sub-source to the scoring plane'/
               1      '   2) Rmin: radius of the opening of the ring or cone'/
               1      '   3) Rmax: outer radius of the ring or cone'/
               1      ' '/
               1      ' Note:'/
               1      ' '/
               1      '   If it is a point source the radius must be 0.0 cm, and'/
               1      '   the SSD will be re-evaluated based on the ph-sp data.'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=39)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' RADIUS OF A RING OPENING TO ANALYSE THE VIRTUAL SSD:'/
               1      ' -------------------------------------------------------------'/
               1      '                                                             '/
               1      ' In order to derive the SSD for a (virtual) point source, the'/
               1      ' particles falling into this ring (R1) will be transported'/
               1      ' in vacuum. The radius of the projected image of this ring (R2)'/
               1      ' at a diatance, d, from the scoring plane will be calculated.'/
               1      ' The virtual SSD is then calculated by'/
               1      ' '/
               1      '                   SSD = d R1/(R2 - R1)'/
               1      ' '/
               1      ' see "Beam Characterization: a multiple-source model"'/
               1      '     by C-M Ma and D.W.O. Rogers, NRC Report PIRS-0509(C)'/
               1      ' '/
               1      ' The radius (in cm) of the ring region on the scoring plane'/
               1      ' should be supplied here (R > 0.0 cm and within the field).'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=40)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are required for this sub-source:'/
               1      ' '/
               1      ' 1) distance from the sub-source to the scoring plane'/
               1      ' 2) minimum x coordinate (cm) for the plane source'/
               1      ' 3) maximum x coordinate (cm) for the plane source'/
               1      ' 4) minimum y coordinate (cm) for the plane source'/
               1      ' 5) maximum y coordinate (cm) for the plane source'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=41)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:                       '/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are required for this sub-source:'/
               1      ' '/
               1      '   1) distance from the sub-source to the scoring plane'/
               1      '   2) radius of the plane source '/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=42)[
               1      OUTPUT $NB;(/
               1      ' -------------------------------------------------------------'/
               1      ' NUMBER OF BINS AND MIN. ENERGY, MAX. ENERGY FOR THE SPECTRUM:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The maximum number of bins allowed is ',I4/
               1      ' and the energy range given below should be consistent with the'/
               1      ' phase-space data. For example, Emin should be =< (ECUT-0.511)'/
               1      ' used in the simulation with BEAM, and Emax should be greater '/
               1      ' than the maximum kinetic energy of the particles in the ph-sp data.'/
               1      ' '/
               1      ' Note: the min., max. energy and bin number will be the same '/
               1      ' for all the sub-sources.'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=43)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' SCORING/TREATMENT FIELD TYPE:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' There are four different field types:'/
               1      ' '/
               1      '    field type = 0 for circular field with circular ring bins'/
               1      '               = 1 for square field with square ring bins'/
               1      '               = 2 for rectangular field with rectangular bins'/
               1      ' '/
               1      ' Note: field type will be the same for all the sub-sources.'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=44)[
               1      OUTPUT $NB,$NB,$NB;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS FOR THE CIRCULAR FIELD PLANAR FLUENCE DISTRIBUTION:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are required for this source to'/
               1      ' describe the circular field planar fluence distribution:'/
               1      ' '/
               1      '  1) number of bins for the planar fluence distribution'/
               1      '     inside the treatment field (<',I4,')'/
               1      '  2) radius of the treatment field'/
               1      '     Note: use slightly bigger value'/
               1      '  3) number of bins for the planar fluence distribution'/
               1      '     outside the treatment field (<',I4,')'/
               1      '  4) radius of the scoring field (=1 + a margin)'/
               1      ' '/
               1      ' Note: These will be the same for all the sub-sources.'/
               1      '       Total number of bins must be smaller than (<',I4,').'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=45)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS FOR A RECTANGULAR SCORING FIELD:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are required for the planar fluence'/
               1      ' distribution in the scoring field (usually > treatment field):'/
               1      ' '/
               1      '  1) number of bins for the planar fluence (same for x & y)'/
               1      '  2) minimum x coordinate for the scoring field'/
               1      '  3) maximum x coordinate for the scoring field'/
               1      '  4) minimum y coordinate for the scoring field'/
               1      '  5) maximum y coordinate for the scoring field'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=46)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS DESCRIBING A RECTANGULAR TREATMENT FIELD:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are required to define the field'/
               1      ' for treatment or measurement. Energy spectrum will be scored'/
               1      ' separately for particles falling inside and outside this '/
               1      ' treatment field:   '/
               1      ' '/
               1      '  1) minimum x coordinate for the scoring field'/
               1      '  2) maximum x coordinate for the scoring field'/
               1      '  3) minimum y coordinate for the scoring field'/
               1      '  4) maximum y coordinate for the scoring field'/
               1      ' '/
               1      ' NOTE: The treatment field should be inside the scoring field.'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=47)[
               1      OUTPUT $NB,$NB,$NB;(/
               1      ' -------------------------------------------------------------'/
               1      ' PARAMETERS FOR THE SQUARE FIELD PLANAR FLUENCE DISTRIBUTION:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are required for this source to'/
               1      ' describe the square field planar fluence distribution:'/
               1      ' '/
               1      '  1) number of bins for the planar fluence distribution'/
               1      '     inside the treatment field (<',I4,')'/
               1      '  2) half-width of the treatment field'/
               1      '     Note: use slightly bigger value'/
               1      '  3) number of bins for the planar fluence distribution'/
               1      '     outside the treatment field (<',I4,')'/
               1      '  4) half-width of the scoring field = treat. field + a margin'/
               1      ' '/
               1      ' Note: These will be the same for all the sub-sources.'/
               1      '       Total number of bins must be smaller than (<',I4,').'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  "ELSEIF(NMESSAGE=48)["
               0  "  OUTPUT $NB;(/"
               0  "  ' -------------------------------------------------------------'/"
               0  "  ' PARAMETERS FOR THE FIELD PLANAR FLUENCE DISTRIBUTION:'/"
               0  "  ' -------------------------------------------------------------'/"
               0  "  ' '/"
               0  "  ' The following parameters are required for this source to'/"
               0  "  ' describe the field planar fluence distribution:'/"
               0  "  ' '/"
               0  "  ' 1) number of radial bins for the planar fluence (<',I4,')'/"
               0  "  ' 2) max. radius of the scoring field '/"
               0  "  ' '/"
               0  "  ' Note: these will be the same for all the sub-sources.'/"
               0  "  ' -------------------------------------------------------------'/);"
               0  "]"
               0  ELSEIF(NMESSAGE=49)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' WARNING ON SOURCE MODEL FILE NAME INPUT:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' Are you sure that there is a file in the specified directory'/
               1      ' or it contains the right data? Check it out and then decide'/
               1      ' whether to try again or switch to another file!!!'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=50)[
               1      OUTPUT;(/
               1      ' ---------------------------------------------------------------'/
               1      ' FILE CONTAINING FULL PHASE-SPACE DATA:'/
               1      ' ---------------------------------------------------------------'/
               1      ' '/
               1      ' The full phase-space data created by the NRCC EGSnrc usercode'/
               1      ' BEAMnrc is stored in a compressed form. This programme uncompresses'/
               1      ' the data first and then analyses the data.'/
               1      ' '/
               1      ' The name of the file containing full phase-space data should be'/
               1      ' supplied here (with extension). '/
               1      ' '/
               1      ' A reminder - default BEAM ph-sp file name: [filename].egsphsp1'/
               1      ' ---------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=51)[
               1      OUTPUT;(/
               1      ' ----------------------------------------------------------------'/
               1      ' Input the maximum number of particles to output to the scatter'/
               1      ' plot.  The number actually output may be less than this because'/
               1      ' it is also limited by the charge and/or LATCH bits selected above.'/
               1      ' If input is <=0 or > no. of particles in phase space file'/
               1      ' then this defaults to the total no. of particles in the file.'/
               1      ' ----------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=52)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------------'/
               1      ' MIN. ENERGY, MAX. ENERGY FOR PARTICLES IN THE ANGULAR DISTRIBUTION:'/
               1      ' -------------------------------------------------------------------'/
               1      ' '/
               1      ' If you are interested in the angular distribution of all    '/
               1      ' particles, then the energy range given below should be consistent'/
               1      ' with the phase-space data. For example, Emin should be =< (ECUT-0.511)'/
               1      ' used in the simulation with BEAM, and Emax should be greater '/
               1      ' than the maximum kinetic energy of the particles in the ph-sp data.'/
               1      ' '/
               1      ' -------------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=53)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' Type of angular distribution:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' (0) - plot particles/angular bin'/
               1      ' '/
               1      ' (1) - plot particles/solid angle'/
               1      ' '/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=54)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' FILE NAME INPUT:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' File name of the new/modified source model.'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=55)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' FILE NAME INPUT:'/
               1      ' -------------------------------------------------------------'/
               1      '                                                              '/
               1      ' The name of the existing source model file to be used as a'/
               1      ' reference for sub-source specifier inputs.'/
               1      ' '/
               1      ' The file name should be supplied here (with extension < A80)'/
               1      ' and make sure that it exists and in the right directory!'/
               1      ' '/
               1      ' The most important thing is to make sure that the file'/
               1      ' contains the right data. Check its contents if you are asked'/
               1      ' to supply with the file name again.'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=56)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' FILE NAME INPUT:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The name of the existing source model containing sub-source  '/
               1      ' specifiers to be modified.'/
               1      ' '/
               1      ' The file name should be supplied here (with extension < A80)'/
               1      ' and make sure that it exists and in the right directory!'/
               1      ' '/
               1      ' The most important thing is to make sure that the file '/
               1      ' contains the right data. Check its contents if you are asked'/
               1      ' to supply with the file name again.'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=57)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' FILE NAME INPUT:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The name of the existing source model file containing'/
               1      ' sub-source specifiers to be used for analyzing the phase space'/
               1      ' data.'/
               1      ' '/
               1      ' The file name should be supplied here (with extension < A80)'/
               1      ' and make sure that it exists and in the right directory!'/
               1      ' '/
               1      ' The most important thing is to make sure that the file'/
               1      ' contains the right data. Check its contents if you are asked'/
               1      ' to supply with the file name again.'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=58)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' FILE NAME INPUT:'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The name of the source model file whose characteristics are '/
               1      ' to be plotted.'/
               1      ' '/
               1      ' The file name should be supplied here (with extension < A80)'/
               1      ' and make sure that it exists and in the right directory!'/
               1      ' '/
               1      ' The most important thing is to make sure that the file '/
               1      ' contains the right data. Check its contents if you are asked'/
               1      ' to supply with the file name again.'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=59)[
               1      OUTPUT;(/
               1      ' ----------------------------------------------------------------'/
               1      ' DATA FILE FOR A SOURCE MODEL BASED ON FULL PHASE_SPACE DATA'/
               1      ' ****************************************************************'/
               1      ' '/
               1      ' The program creates a source model file for a Monte'/
               1      ' Carlo code. The source model is based on the full phase-space'/
               1      ' data created by NRCC EGSnrc usercode BEAMnrc for a particular beam'/
               1      ' from a clinical linear accelerator.');
               1      OUTPUT;(/
               1      ' The source model consists of a number of sub-sources; each has'/
               1      ' its own energy spectrum and field distribution at the phantom'/
               1      ' surface. The component modules in a linear accelerator are'/
               1      ' considered as following types of sub-sources:'//
               1      '            source type 1 & 11 for applicators'/
               1      '                        2 for collimators'/
               1      '                        3 for rings, cones, and point sources'/
               1      '                        4 for rectangular plane sources'/
               1      '                        5 for circular plane sources'/
               1      ' ');
               1      OUTPUT;(
               1      ' For more information about the simplified source models, see'//
               1      ' report "Beam Characterization: A Multiple-Source Model"'/
               1      ' by C-M Ma and D W O Rogers, IRS, NRC, Ottawa, Canada K1A 0R6'/);
               1      ]
               0  ELSEIF(NMESSAGE=60)[
               1      OUTPUT;(/
               1      ' ------------------------------------------------------------------------'/
               1      ' USING SUB-SOURCE SPECIFIERS FROM AN EXISTING SOURCE MODEL FOR REFERENCE:'/
               1      ' ------------------------------------------------------------------------'/
               1      ' '/
               1      ' In order to help input the sub-source specifiers required to create a'/
               1      ' new source model, the sub-source specifiers from an existing source'/
               1      ' model can be used as a reference. However, if you do this, then the'/
               1      ' old and new source models will consist of the same number of sub-sources.'/
               1      ' '/
               1      ' In fact, it is sometimes easier to modify the sub-source specifiers'/
               1      ' directly by editing the source model than doing it interactively'/
               1      ' by running this program, and you are not confined by the'/
               1      ' condition mentioned above.'/
               1      ' ------------------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=61)[
               1      OUTPUT;(/
               1      ' ------------------------------------------------------------------'/
               1      ' FILE CONTAINING FULL PHASE-SPACE DATA:'/
               1      ' ------------------------------------------------------------------'/
               1      ' '/
               1      ' The full phase-space data created by the NRCC EGSnrc usercode'/
               1      ' BEAMnrc is stored in a compressed form. This programme uncompresses'/
               1      ' the data first and then analyses the data.'/
               1      ' '/
               1      ' The name of the file containing full phase-space data should be'/
               1      ' supplied here (with extension).'/
               1      ' '/
               1      ' A reminder - default BEAM ph-sp file name: [filename].egsphsp1'/
               1      ' ------------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=80)[
               1      OUTPUT;(/
               1      ' ----------------------------------------------------------------'/
               1      ' ENERGY SPECTRUM TYPE:'/
               1      ' ----------------------------------------------------------------'/
               1      ' '/
               1      ' There are two different energy spectrum types:'/
               1      ' '/
               1      ' 1) Inside and outside the treatment field'/
               1      ' 2) Different radii (independent of treatment-scoring fields)'/
               1      ' '/
               1      ' ----------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=81)[
               1      OUTPUT;(/
               1      ' ----------------------------------------------------------------'/
               1      ' ENERGY SPECTRUM TYPE FOR INSIDE/OUTSIDE FIELD:'/
               1      ' ----------------------------------------------------------------'/
               1      ' The following parameters are required for this energy spectrum'/
               1      ' type:'/
               1      ' '/
               1      '  1) radius of the treatment field'/
               1      '  2) radius of the scoring field'/
               1      ' '/
               1      ' ----------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=82)[
               1      OUTPUT $NB;(/
               1      ' ----------------------------------------------------------------'/
               1      ' ENERGY SPECTRUM TYPE WITH DIFFERENT RADII:'/
               1      ' ----------------------------------------------------------------'/
               1      ' The following parameters are required for this energy spectrum'/
               1      ' type:'/
               1      ' '/
               1      '  1) number of energy bins with different radii (<',I4,')'/
               1      '  2) radius of the scoring field'/
               1      ' '/
               1      ' ----------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=83)[
               1      OUTPUT;(/
               1      ' ----------------------------------------------------------------'/
               1      ' ENERGY SPECTRUM RADII:'/
               1      ' ----------------------------------------------------------------'/
               1      ' The following parameters are required for this energy spectrum'/
               1      ' radii:'/
               1      ' '/
               1      '  NbinEn number of different radii'/
               1      ' '/
               1      ' Note: the last radius must be equal to radius of the scoring field'/
               1      ' ----------------------------------------------------------------'/);
               1      ]
               0  ELSEIF(NMESSAGE=84)[
               1      OUTPUT;(/
               1      ' -------------------------------------------------------------'/
               1      ' Parameters for writing particle (X,Y,Z) to a file (IAEA phsp only):'/
               1      ' -------------------------------------------------------------'/
               1      ' '/
               1      ' The following parameters are input:'/
               1      ' '/
               1      '  1) Min. fractional MU index (default 0)'/
               1      '  2) Max. fractional MU index (default 1)'/
               1      '  3) No. of particles to plot (default all in range)'/
               1      ' '/
               1      ' If MU index is not scored, then it will not be used as a filter.'/
               1      ' -------------------------------------------------------------'/);
               1      ]
               0  ELSE[
               1      OUTPUT;(/
               1      ' ----------------------------------------------------------------'/
               1      ' ERROR: THIS MESSAGE TYPE DOES NOT EXIST'/
               1      ' ----------------------------------------------------------------'/);
               1      ]
               0
               0
               0  RETURN;
               0  END;
               0
               0  "End of beamdp.mortran"
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc xvgr plotting subroutines                                           "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Andrew Booth, 1995                                        "
               0  "                                                                             "
               0  "  Contributors:    Charlie Ma                                                "
               0  "                   Aaron Merovitz                                            "
               0  "                   Dave Rogers                                               "
               0  "                   Blake Walters                                             "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  !INDENT F2;
               0  %I4                                                                            ;
               0  %Q1                                                                            ;
               0  "************************************************************************"
               0
               0  SUBROUTINE XVGRPLOT (X, Y, ERRY, NPTS, CURVENUM, SERIESTITLE,
               0  XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               0  UNITNUM, TYPE, HISTXMIN, AXISTYPE);
               0
               0  "************************************************************************"
               0  "                                                                        "
               0  "  This subroutine is used to create an xvgr plot file that will plot    "
               0  "  Y as a function of X and include all of the pertinent information for "
               0  "  the graph.  Each time the subroutine is called it writes one series   "
               0  "  worth of data points to the unit specified.  For graphs that use      "
               0  "  several series, multiple subroutine calls are required.               "
               0  "                                                                        "
               0  "  Written  by:  Andrew Booth, August 1995                               "
               0  "  Modified by:  C-M Ma, Sept. 1995                                      "
               0  "  Modified by:  Andrew Booth, July 1996                                 "
               0  "                - introduced AXISTYPE argument to handle lin and log    "
               0  "                  axis combinations.                                    "
               0  "   Jan 98 A Merovitz/DR added xview xmin value so y axis label displayed"
               0  "   Feb 98 A Merovitz/DR if non-negative, makes zeros fudge*smalest      "
               0  "   Jun 99 BW/DWOR in Y>0 and ERRY crosses/touches 0, adjusted>0.0       "
               0  "   Jul 99 DWOR made grace/xmgr compatible and added timestamp           "
               0  "                                                                        "
               0  "  The arguments of the subroutine are described in detail below:        "
               0  "                                                                        "
               0  "     1) X - array of x values to be plotted.  Top of bin if histogram.  "
               0  "     2) Y - corresponding array of y values to be plotted.              "
               0  "     3) ERRY - array containing uncertainties in Y for the plot.        "
               0  "            If the first entry of this array is 0, it is                "
               0  "            assumed that the graph is of type XY.  If it is             "
               0  "            not 0, the graph is of type XY-DY.                          "
               0  "     4) NPTS - the number (integer) of points to be plotted. This       "
               0  "            should be the number of data points that exist in the       "
               0  "            X, Y, and ERRY arrays.                                      "
               0  "     5) CURVENUM - the number (integer) of the curve that is to be      "
               0  "            plotted. The first curve number should be 0.  If this       "
               0  "            number is not 0, then it is assumed that the plot file      "
               0  "            already exists and the subroutine call is to add an         "
               0  "            additional series to the existing graph.                    "
               0  "     6) SERIESTITLE - string (max of 60 characters) giving the          "
               0  "            series title (legend) for the data in the X and Y arrays.   "
               0  "     7) XTITLE - string (max of 60 characters) giving the x axis        "
               0  "            title.                                                      "
               0  "     8) YTITLE - string (max of 60 characters) giving the y axis        "
               0  "            title.                                                      "
               0  "     9) GRAPHTITLE - string (max of 60 characters) giving the           "
               0  "            graph title.                                                "
               0  "    10) SUBTITLE - string (max of 60 characters) giving the subtitle    "
               0  "            for the graph.                                              "
               0  "    11) UNITNUM - number (integer) specifying where the data is to      "
               0  "            be written.                                                 "
               0  "            this unit must be opened by the calling routine             "
               0  "    12) TYPE - 0 if data is to be written as normal point plot.         "
               0  "               1 if data is to be written as a histogram plot.          "
               0  "    13) HISTXMIN - used for histogram plots only.  This is a real       "
               0  "                   number with the value of lower xbin for the plot.    "
               0  "    14) AXISTYPE - 0 if linear-linear plot                              "
               0  "                   1 if log-linear plot (y = log; x = lin)              "
               0  "                   2 if linear-log plot (y = lin; x = log)              "
               0  "                   3 if log-log plot                                    "
               0  "                                                                        "
               0  "                                                                        "
               0  "************************************************************************"
               0  REPLACE{$SMALLFACTOR} WITH {1.E-5}
               0  REPLACE{$LARGEFACTOR} WITH {1.E5}
               0
               0  IMPLICIT NONE;
               0
               0  $INTEGER MAX, IDEBUG;
               0  PARAMETER (MAX = 400);  "---MAX used in defining the maximum number of---"
               0  "---points that can be plotted in one series. ---"
               0  $INTEGER NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE;
               0  $REAL X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,HISTXMIN,ERRYOLD,SMALLESTX,
               0  SMALLESTY,FUDGE;
               0  $INTEGER TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENGTH;
               0  $INTEGER LOGX, LOGY, LOGDY,ZEROYCOUNT;
               0
               0  "CHARACTER*80 SUBTITLE;"
               0  "CHARACTER*60 GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;"
               0  " IK changed the above to avoid complains from the compiler about"
               0  " inconsistent argument lists"
               0  CHARACTER*(*) SUBTITLE;
               0  CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
               0  CHARACTER*10 INDEX;
               0  CHARACTER*3  INDEXNUM;
               0
               0  $LOGICAL TESTFILE, ALLPOS;
               0  $REAL    one;
               0  parameter (one = 1);
               0
               0  FUDGE = 1.e-10;              "If a number in the gaph is zero, it is replaced"
               0  "by the (smallest number in the gaph)*(FUDGE)"
               0  IDEBUG = 0;  "set to 1 to get debug stmts active"
               0  IF (IDEBUG = 1) [
               1      write(6,'(//'' Entering xvgrplot ''/)');
               1      write(6,'('' Curve'',I3,'' to go to unit'',I3)')CURVENUM,UNITNUM;
               1      write(6,'(''SERIESTITLE: '',a60)') SERIESTITLE;
               1      write(6,'(''XTITLE:      '',a60)') XTITLE;
               1      write(6,'(''YTITLE       '',a60)') YTITLE;
               1      write(6,'(''GRAPHTILE:   '',a60)') graphtitle;
               1      write(6,'(''SUBTITLE:    '',a80)') subtitle;
               1      ]
               0  IF ( NPTS .gt. MAX) [ "Asked for too many points"
               1      OUTPUT NPTS, MAX;(//' **************************'/
               1      ' Number of points asked for =', I5,
               1      ' is greater than max allowed of', I4/
               1      ' Setting NPTS to MAX, you could adjust MAX in xvgrplot.mortran'/
               1      ' **************************'//);
               1      NPTS1 = MAX;
               1      ] ELSE [NPTS1 = NPTS;]
               0
               0  "---Check to make sure that speicified unit is open for---"
               0  "---writing to.---"
               0  INQUIRE(UNIT = UNITNUM, OPENED = TESTFILE);
               0
               0  IF (~TESTFILE) [ "---File has not been opened - print message.---"
               1      WRITE(6,:125:) UNITNUM;
               1      :125: FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------'
               1      ,/'   Unit specified (',I2,') is not open.'
               1      ,/'   Unit must be opened before using subroutine.'
               1      ,/'   Data not written to file.'
               1      ,/'  ----------------------------------------------'//);
               1      RETURN;
               1      ] "---End of error message for unopened file---"
               0
               0  "---Set defaults if arguments are left blank.---"
               0  IF (GRAPHTITLE = ' ') [
               1      GRAPHTITLE = 'Untitled Graph - No title specified in subroutine';
               1      ]
               0  IF (XTITLE = ' ') [ XTITLE = 'X-axis not titled in subroutine';  ]
               0
               0  IF (YTITLE = ' ') [ YTITLE = 'Y-axis not titled in subroutine'; ]
               0
               0  IF (SERIESTITLE = ' ') [
               1      SERIESTITLE = 'series # ';
               1      INDEX = '0123456789';
               1      INDEXNUM = INDEX(CURVENUM+1:CURVENUM+1);
               1      SERIESTITLE(9:9) = INDEXNUM;
               1      ]
               0
               0  "---Find lengths of stings for formatting purposes---"
               0  "---Initialize variable lengths---"
               0
               0  TITLELENGTH = 61;    SUBLENGTH = 61;       XAXISLENGTH = 61;
               0  YAXISLENGTH = 61;    SERIESLENGTH = 61;
               0
               0  "---Find title string length---"
               0  LOOP [
               1      TITLELENGTH = TITLELENGTH - 1;
               1      ] UNTIL (GRAPHTITLE(TITLELENGTH:TITLELENGTH) ~= ' ');
               0
               0  "---Find subtitle string length---"
               0  LOOP [
               1      SUBLENGTH = SUBLENGTH - 1;
               1      ] UNTIL (SUBTITLE(SUBLENGTH:SUBLENGTH) ~= ' ');
               0
               0  "---Find x-axis string length---"
               0  LOOP [
               1      XAXISLENGTH = XAXISLENGTH - 1;
               1      ] UNTIL (XTITLE(XAXISLENGTH:XAXISLENGTH) ~= ' ');
               0
               0  "---Find y-axis string length---"
               0  LOOP [
               1      YAXISLENGTH = YAXISLENGTH - 1;
               1      ] UNTIL (YTITLE(YAXISLENGTH:YAXISLENGTH) ~= ' ');
               0
               0  "---Find series title length---"
               0  LOOP [
               1      SERIESLENGTH = SERIESLENGTH - 1;
               1      ] UNTIL (SERIESTITLE(SERIESLENGTH:SERIESLENGTH) ~= ' ');
               0  IF( IDEBUG = 1) [
               1      OUTPUT SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH;
               1      (' SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH'/
               1      5I10)
               1      ]
               0
               0  "---Small bit of error checking here done for the purpose of warning the---"
               0  "---user if there is a problem when using a 'log' type graph.           ---"
               0  "---Possible problems are:                                              ---"
               0  "---    1.)  value on log scale < or = 0.                               ---"
               0  "---    2.)  value of error bar for xydy plot extends into the region   ---"
               0  "---                    where y < or = 0.                               ---"
               0  "---                                                                    ---"
               0  "---To keep track of these problems the flags LOGX, LOGY, and LOGDY will---"
               0  "---be set if there is the respective error.                            ---"
               0  "---(ie.  if LOGX set (=1) then there exist an X value that is <= 0 AND ---"
               0  "--- the xaxis is set to be a log scale.)                               ---"
               0  "--------------------------------------------------------------------------"
               0
               0  "---Initialize LOGX, LOGY, and LOGDY to be not set (0)---"
               0  LOGX = 0;          LOGY = 0;          LOGDY = 0;
               0
               0  "---Initialize ZEROYCOUNT to 0---"
               0  ZEROYCOUNT=0;
               0
               0  "In all cases where no negatives are concerned, fix points that are"
               0  "equal to 0.0"
               0  "Aaron Merovitz, Jan 1998"
               0  ALLPOS=.TRUE.;
               0  IF ( X(1)=0.0 ) [SMALLESTX = 0.1;] ELSE [SMALLESTX=X(1);]
               0  IF ( Y(1)=0.0 ) [SMALLESTY = 0.1;] ELSE [SMALLESTY=Y(1);]
               0  DO COUNT = 1, NPTS1 [
               1      IF ((X(COUNT) < SMALLESTX) & (X(COUNT)~=0.)) [SMALLESTX=X(COUNT);]
               1      IF ((Y(COUNT) < SMALLESTY) & (Y(COUNT)~=0.)) [SMALLESTY=Y(COUNT);]
               1      IF ((X(COUNT) < 0.)|(Y(COUNT) < 0.)) [ALLPOS=.FALSE.;]
               1      ]
               0  IF (ALLPOS) [
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT)=0.) [X(COUNT)=SMALLESTX*FUDGE;]
               2          IF (Y(COUNT)=0.) [Y(COUNT)=SMALLESTY*FUDGE;]
               2          ]
               1      ]
               0  "---Loop through data points (if any log scales set) to see if there are---"
               0  "---any  <= 0 problems that might not have been fixed---"
               0
               0  IF (AXISTYPE > 0) [  "---At least one axis is of log type---"
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT) <= 0.) [ LOGX = 1; ]
               2          IF (Y(COUNT) <= 0.) [ LOGY = 1; ]
               2          IF ((Y(COUNT)-ERRY(COUNT)) <= 0.) [ LOGDY = 1; ]
               2          ]
               1      ]
               0  ELSE[ "--fix error bars that just hit Y axis in case user wants"
               1      "to switch to linlog plot while in xmgr--"
               1      DO COUNT = 1, NPTS1 [
               2          IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT) & Y(COUNT)>0.)[
               3              ZEROYCOUNT=ZEROYCOUNT+1;
               3              IF(ZEROYCOUNT=1)[
               4                  WRITE(6,:105:);
               4                  :105: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
               4                  ,/'  Some errors give 0 value and so are adjusted so       '
               4                  ,/'  that you can switch to a log Y scale while in xmgr.   '
               4                  ,/' -------------------------------------------------------'/);
               4                  ]
               3              ERRYOLD=ERRY(COUNT);
               3              ERRY(COUNT) = 0.9999*Y(COUNT);
               3              "WRITE(6,:106:) COUNT,ERRYOLD,ERRY(COUNT);"
               3              ":106: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'"
               3              "       /'        ',1PE11.4,'.');"
               3              ]
               2          ]
               1      ]
               0
               0  "---Use this info later when writing to file---"
               0
               0  "---Now begin writing information to unit---"
               0  IF (CURVENUM = 0) [ "---Case where plot file must start from scratch---"
               1      "---Insert xvgr graph header in file.---"
               1
               1      "---Start with type of graph.  (lin-lin, log-lin, lin-log, or log-log)---"
               1      IF (AXISTYPE = 0) [ "---Graph is of type lin-lin---"
               2          WRITE(UNITNUM,:90:) 'xy';
               2          ] ELSEIF (AXISTYPE = 1) [ "---Graph is of type log-lin---"
               2          WRITE(UNITNUM,:90:) 'logy';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 2) [ "---Graph is of type lin-log---"
               2          WRITE(UNITNUM,:90:) 'logx';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 3) [ "---Graph is of type log-log---"
               2          WRITE(UNITNUM,:90:) 'logxy';
               2          WRITE(UNITNUM,:1080:);
               2          WRITE(UNITNUM,:1090:);
               2          ] ELSE [ "--anything else specified is in error--"
               2          WRITE(6,:91:) AXISTYPE;
               2          :91: FORMAT (//'  ------------Error in Subroutine XVGRPLOT-----------'
               2          ,/'   AXISTYPE specified (',I2,') is not a valid option.'
               2          ,/'  ----------------------------------------------'//);
               2          RETURN;
               2          ]
               1
               1      :90: FORMAT ('@g0 type ',A,' ');
               1      :1080: FORMAT ('@    xaxis  ticklabel format exponential');
               1      :1090: FORMAT ('@    yaxis  ticklabel format exponential');
               1
               1      "---Titles and things---"
               1      WRITE(UNITNUM,:100:) GRAPHTITLE(1:TITLELENGTH)
               1      ,SUBTITLE(1:SUBLENGTH)
               1      ,XTITLE(1:XAXISLENGTH)
               1      ,YTITLE(1:YAXISLENGTH);
               1      :100: FORMAT ('@    title "',A,'"'/
               1      ,'@    subtitle "',A,'"'/
               1      ,'@    legend on'/
               1      ,'@    legend box linestyle 0'/
               1      ,'@    legend x1 0.6'/
               1      ,'@    legend y1 0.75'/
               1      ,'@    view xmin 0.250000'/
               1      ,'@    xaxis  label "',A,'"'/
               1      ,'@    timestamp on'/
               1      ,'@    yaxis  label "',A,'"');
               1      ]  "---End CURVENUM = 0---"
               0
               0  "--XVGR has the characteristic that if the same input command is issued more---"
               0  "--than once, the last one to be read is the one that is executed.  For this---"
               0  "--situation, this is perfect.  Say the first series written to a file is of---"
               0  "--a log scale, and the second is also of log scale, but has a data point   ---"
               0  "--on the log scale that is < or = 0, then we can write the '@g0 type xy'   ---"
               0  "--to the file AFTER the previous '@g0 type logxy' and the xy type will     ---"
               0  "--prevail.  This will prevent errors when executing XVGR.  Of course the   ---"
               0  "--alteration will also be written to the display.                          ---"
               0
               0
               0  IF (AXISTYPE = 1 & LOGY = 1) [  "--LOGY error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:95:);
               1      :95: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for Y axis when one or more   '
               1      ,/'  Y data points are 0 or negative.                  '
               1      ,//'  Y axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 2 & LOGX = 1) [  "--LOGX error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:96:);
               1      :96: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for X axis when one or more   '
               1      ,/'  X data points are 0 or negative.                  '
               1      ,//'  X axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 3 & (LOGX = 1 | LOGY = 1)) [  "--LOGX or LOGY error--"
               1      IF (LOGX = 1 & LOGY = 1) [
               2          WRITE(UNITNUM,:90:) 'xy';
               2          WRITE(6,:97:);
               2          :97: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               2          ,/'  Log scale requested for X axis and Y axis when    '
               2          ,/'  one or more X and Y data points are 0 or negative.'
               2          ,//'  X and Y axes scales changed to linear.            '
               2          ,/' ---------------------------------------------------'/);
               2          ]
               1      ELSEIF (LOGX = 1) [ WRITE(UNITNUM,:90:) 'logy'; WRITE(6,:96:); ]
               1      ELSE              [ WRITE(UNITNUM,:90:) 'logx'; WRITE(6,:95:); ]
               1      ]
               0
               0  "---now make a fix for those error bars that 'dip' beneath the x-axis on---"
               0  "---log plots.                                                          ---"
               0
               0  IF (LOGDY = 1 & LOGY ~= 1 & (AXISTYPE = 3 | AXISTYPE = 1)) [
               1      "--if LOGDY problem and log scale not been already reset to linear--"
               1      "--do fudge to correct the problem--"
               1
               1      WRITE(6,:101:);
               1      :101: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
               1      ,/'  Log scale requested for Y axis, and Y value less      '
               1      ,/'  error gives 0 or negative value.                      '
               1      ,//'  Error adjusted to aviod negavite values on log scale. '
               1      ,/' -------------------------------------------------------'/);
               1
               1      DO COUNT = 1,NPTS1[
               2          IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT)) [
               3              ERRYOLD = ERRY(COUNT);
               3              ERRY(COUNT) = 0.9999*Y(COUNT);
               3              WRITE(6,:103:) COUNT,ERRYOLD,ERRY(COUNT);
               3              :103: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'
               3              /'        ',1PE11.4,'.');
               3              ]
               2          ]
               1
               1      WRITE(6,:104:);
               1      :104: FORMAT (/' -------------------------------------------------------'/);
               1
               1      ]
               0
               0  "---Include data about series for legend purposes.---"
               0  "first line needed to make it work with grace"
               0  IF (CURVENUM < 10 ) [
               1      WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM;
               1      ]
               0  ELSE [
               1      WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM;
               1      ]
               0  WRITE(UNITNUM,:150:)  CURVENUM,SERIESTITLE(1:SERIESLENGTH);
               0  :150: FORMAT ('@    legend string ',I2,' "',A,'"');
               0
               0
               0  "---Do normal plot.  ie. NOT histogram plot.---"
               0  IF (TYPE = 0) [ "---Normal point plot.---"
               1
               1      "---Check all ERRYs.  If even one is nonzero, then series is type xydy---"
               1      DO COUNT = 1, NPTS1 [
               2          IF (ERRY(COUNT) ~= 0) [ "---Data set is not of type XY---"
               3              GOTO :X-Y-DY1:;
               3              ]
               2          ]
               1
               1      "---Data set is of type XY---"
               1      WRITE(UNITNUM,:200:);
               1      :200: FORMAT ('@TYPE xy');
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1      :151: FORMAT ('@    s',I1,' errorbar length 0.000000');
               1      :152: FORMAT ('@    s',I2,' errorbar length 0.000000');
               1      :197: FORMAT ('@    s',I1,' symbol color ',I2);
               1      :198: FORMAT ('@    s',I1,' symbol color ',I1);
               1      :199: FORMAT ('@    s',I2,' symbol color ',I2);
               1
               1      "---Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [ WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT); ]
               1      :250: FORMAT (1PE15.4,1PE15.4);
               1      GOTO  :END-X-Y-DY1:;
               1
               1      "---Data set is of type XY-DY---"
               1      :X-Y-DY1:;
               1      WRITE(UNITNUM,:300:);
               1      :300: FORMAT ('@TYPE xydy');
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1
               1      "---Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [WRITE(UNITNUM,:350:) X(COUNT),Y(COUNT),ERRY(COUNT);]
               1      :350: FORMAT (1PE15.4,1PE15.4,1PE15.4);
               1      :END-X-Y-DY1:;
               1
               1      ]  "--end of point plot block--"
               0  ELSE [ "---Histogram plot---"
               1
               1      "---Must find minimum y value in the y array to    ---"
               1      "---use as scale factor for establishing y-min on  ---"
               1      "---histogram plot.  We don't use 0 here as with 0 ---"
               1      "---plot can not be made into log plot in xvgr.    ---"
               1
               1      YMIN = ABS($LARGEFACTOR * Y(1));
               1
               1      DO COUNT = 1, NPTS1 [
               2          IF (ABS(Y(COUNT)) < YMIN) [ YMIN = ABS(Y(COUNT)); ]
               2          ]  "---End loop to find smalled Y---"
               1
               1      "---Now smallest value of Y has been found.  Want to make sure that the---"
               1      "---first point used is even smaller than this and that it is of the same---"
               1      "---sign as the first Y data point in the plot.---"
               1
               1      "---Now set YMIN to even smaller value for plot and set sign.---"
               1      YMIN = SIGN(one,Y(1)) * $SMALLFACTOR * YMIN ;
               1
               1      "---Set this value in y-array as element after the---"
               1      "---element in index npts.---"
               1      Y(NPTS1+1) = YMIN;
               1
               1      IF ((AXISTYPE = 2 | AXISTYPE = 3) & HISTXMIN = 0) [
               2          IF (X(1) = (X(2)-X(1))) [ HISTXMIN = X(1)-0.5*(X(2)-X(1)); ]
               2          ELSE                    [ HISTXMIN = X(1)-(X(2)-X(1)); ]
               2
               2          WRITE(6,:306:) HISTXMIN;
               2          :306: FORMAT (/' ---------WARNING from Subroutine XVGRPLOT--------'
               2          ,/'  Minimum bin for X specified as 0 with log scale  '
               2          ,/'  on X axis.  Minimum X bin set to ',1PE10.3,'.'
               2          ,/' -------------------------------------------------'/);
               2          ]
               1
               1      DO COUNT = 1, NPTS1 [
               2          IF (ERRY(COUNT) ~= 0.) [ "---Data set is not of type XY---"
               3              GOTO :X-Y-DY:;
               3              ]
               2          ]
               1
               1      "---Data set is of type XY---"
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1      WRITE(UNITNUM,:200:);
               1
               1      "---Plot the first histogram points.---"
               1      WRITE(UNITNUM,:250:) HISTXMIN,YMIN;
               1      WRITE(UNITNUM,:250:) HISTXMIN,Y(1);
               1
               1      "--Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [
               2          WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT);
               2          WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT+1);
               2          ]
               1      GOTO :END-X-Y-DY:;
               1
               1      "---Data set is of type XY-DY---"
               1      :X-Y-DY:;
               1      "---Put error of 0 on last *made-up* point in error array.---"
               1      ERRY(NPTS1+1) = 0.0;
               1
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1      WRITE(UNITNUM,:300:);
               1
               1      "---Plot the first histogram points.---"
               1      IF (HISTXMIN = 0.0) [ "Aaron Meroivtz, Feb. 1998"
               2          HISTXMIN = SMALLESTX*FUDGE;
               2          ]
               1      WRITE(UNITNUM,:350:) HISTXMIN, YMIN, 0.;
               1      WRITE(UNITNUM,:350:) HISTXMIN, Y(1), 0.;
               1      WRITE(UNITNUM,:350:) (X(1)+HISTXMIN)/2., Y(1), ERRY(1);
               1
               1      "---Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [
               2          WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT),0.;
               2          WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT+1),0.;
               2          IF(COUNT < NPTS1)[
               3              WRITE (UNITNUM,:350:) (X(COUNT)+X(COUNT+1))/2.,Y(COUNT+1),ERRY(COUNT+1);
               3              ]
               2          ]
               1      :END-X-Y-DY:;
               1      ] "---End HIST=0 loop---"
               0
               0  "---Insert end of series indicator to file.---"
               0  WRITE(UNITNUM,'(''&'')');
               0
               0  RETURN;
               0  END; "---End of subroutine.---"
               0  ;
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc function to get index of last non-blank character in a string       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2004                                       "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  $INTEGER function lnblnk1(string);
               0
               0  "Function to return index of last non-blank character in a string"
               0  "We use this instead of lnblnk because there are compilers"
               0  "that do not have lnblnk"
               0
               0  "******************************************************************************
               0  character*(*) string;
               0  DO i=len(string),1,-1 [
               1      j = ichar(string(i:i));
               1      IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
               1      "0-terminated C-strings"
               1      IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
               2          lnblnk1 = i; return;
               2          ]
               1      ]
               0  lnblnk1 = 0; return; end;
               0
          END OF MORTRAN INPUT
  85      PERCENT RULE CAPACITY REMAINING
          NO MORTRAN ERRORS DETECTED
