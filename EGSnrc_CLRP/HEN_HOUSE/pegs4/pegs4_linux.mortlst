Mortran 3.2 Tue Aug 19 15:59:51 2025
               0  %L                                                                     ;
1              0  %E
               0  %I4                                                                    ;
               0  !INDENT F2;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  "#############################################################################"
               0  "                                                                             "
               0  " EGSnrc machine dependent macro file for linux                               "
               0  "                                                                             "
               0  " Created by configure version 2.0 on mar 19 ago 2025 15:59:50 -03            "
               0  "                                                                             "
               0  " You may add your own machine dependent macros to this file,                 "
               0  " but be carefull to not overwrite it if you re-run configure.                "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0  REPLACE {$MACHINE} WITH
               0  {,'linux',};
               0  REPLACE {$HEN_HOUSE} WITH
               0  {'/home/usuario/EGSnrc_CLRP/HEN_HOUSE/'};
               0  REPLACE {$CANONICAL_SYSTEM} WITH
               0  {'x86_64-unknown-linux-gnu'};
               0  REPLACE {$CONFIGURATION_NAME} WITH
               0  {'linux'};
               0  REPLACE {$EGS_CONFIG} WITH
               0  {'/home/usuario/EGSnrc_CLRP/HEN_HOUSE/specs/linux.conf'};
               0
               0  REPLACE {$CONFIG_TIME} WITH
               0  {'2025-08-19 18:59:50 UTC'};
               0
               0  " System dependent stuff "
               0  "========================================"
               0  " Unfortunately, there appears to be no reliable way of copying files "
               0  " under Fortran => we use a system call for this"
               0  REPLACE {$copy_file} WITH {'cp '};
               0
               0  " Although one can move files using Fortran's intrinsic rename, "
               0  " we don't know whether the user has not created additional files in "
               0  " the temporary working directory => it is easiest to use a system call "
               0  " to move all files from the temporary working directory to the user-code "
               0  " directory. "
               0  REPLACE {$move_file} WITH {'mv -f '};
               0
               0  " There appears to be no way of removing a directory from Fortran "
               0  " => we use a system call for this. "
               0  REPLACE {$remove_directory} WITH {'rm -rf '};
               0
               0  " The directory separator "
               0  REPLACE {$file_sep} WITH {'/'};
               0
               0  REPLACE {$LONG_INT} WITH { integer*8 };
               0  REPLACE {$SHORT_INT} WITH { integer*2 };
               0  "$MAX_INT SET TO 2^63-1 in egsnrc.macros"
               0  "The machine byte order"
               0  REPLACE {$BYTE_ORDER} WITH {'1234'};
               0  ;
               0  REPLACE {$RECL-FACTOR} WITH {4};
               0  ;
               0  REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
               0  ;
               0  " If you want your user-code to return an exit status, use the "
               0  " following macro to terminate execution"
               0  REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
               0  ;
               0  " mortran3 gets confused by the # char => we need to pass it as an "
               0  " argument to the macro. "
               0  REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
               0  ;
               0  REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Preprocessor for EGS4 source code                                          "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "  Copyright (C) 1986 Stanford Linear Accelerator Center                      "
               0  "  Copyright (C) 1985 Board of Trustees of the Leland                         "
               0  "                     Stanford Junior University                              "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Walter Nelson, 1986                                       "
               0  "                   Hideo Hirayama, 1986                                      "
               0  "                   Dave Rogers, 1986                                         "
               0  "                                                                             "
               0  "  Contributors:    Alex Bielajew                                             "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  PEGS4 is jointly copyrighted by SLAC and NRC, is distributed by NRC under  "
               0  "  the terms of the AGPL 3.0 licence, in agreement with SLAC.                 "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  The authors acknowledge Dr. Richard L. Ford for his part in developing the "
               0  "  previous version of the EGS Code System (EGS3 and PEGS3) including the     "
               0  "  documentation thereof.                                                     "
               0  "                                                                             "
               0  "                                                                             "
               0  "  Description:                                                               "
               0  "                                                                             "
               0  "  PEGS4 ('Preprocessor for EGS4') is a stand-alone program whose purpose is  "
               0  "  to generate material data for the EGS4 code, and to provide other          "
               0  "  services for the user who is studying the simulation of electromagnetic    "
               0  "  interactions.                                                              "
               0  "                                                                             "
               0  "                                                                             "
               0  "  Input/Output unit assignments:                                             "
               0  "                                                                             "
               0  "  Unit 5    user input file                                                  "
               0  "  Unit 6    output listing file                                              "
               0  "  Unit 7    output data for input to egs4                                    "
               0  "  Unit 8    input photoelec.,coherent and pair cross sections                "
               0  "  Unit 9    input atomic form factors                                        "
               0  "  Unit 20   input for density effect corrections if used                     "
               0  "  Unit 21   output from plot1 routine if used                                "
               0  "  Unit 22   input for aprime data if used                                    "
               0  "                                                                             "
               0  "  Iwan Kawrakow, 2003: Iimplemented command line options to specify input    "
               0  "  file, density correction file, cross section data file, etc. These files   "
               0  "  are now explicitly opened by name, instead of relying on symbolik links.   "
               0  "                                                                             "
               0  "  Davbe Rogers, 1998: Played with at NRC to get density effect and to get    "
               0  "  better radiative stopping powers. An alternative PLOT routine is included  "
               0  "  which plots in MeV/g/cm**2 and sends the radiative stopping power to a     "
               0  "  file. It is called PLOT1, rename to use then set IUNRST=5 and use option   "
               0  "  PLTN.                                                                      "
               0  "                                                                             "
               0  "  Dave Rogers, 1996: Open all units explicitly near top to allow use on      "
               0  "  HP machines. Need change in pegs4_run to assign 5/6.                       "
               0  "                                                                             "
               0  "  Alex Bielajew, 1992: Changed read of data on units 8 and 9 to free format  "
               0  "  reads. The long NAMELIST caused problems with SunFortran 1.3 and later.    "
               0  "                                                                             "
               0  "  Alex Bielajew, 1989: SUN version. Search 'SUN' to see changes, most of     "
               0  "  which had to do with adhering to stricter FORTRAN.                         "
               0  "                                                                             "
               0  "  Dave Rogers, 1989: Patched to follow FORTRAN77 formats. Patched to place   "
               0  "  comma after NALG in definition if INP NAMELIST in main. Patched to correct "
               0  "  how IUNRST=2,3,4 is handled in SPTOTE and SPTOTP. Error would only have    "
               0  "  affected PLTN and CALL options, not DECK!! Patched to reflect error re     "
               0  "  GASP in SPINT correction, as suggested by Prof. Kamae in Tokyo.            "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %L                                                                             ;
               0  %I4      "INDENT MORTRAN"                                                      ;
               0  !INDENT F2;
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  "PEGS4 MACROS                                                      "
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0
               0
               0  "=================================================================="
               0  "SELECT THE FORTRAN STANDARD TO BE USED (1966 OR 1977)             "
               0  REPLACE {$FORTVER} WITH {1977}
               0  "=================================================================="
               0
               0  "******************************************************************"
               0
               0  REPLACE {$TYPE} WITH
               0  {{SETR F=$FORTVER}
            {  0  [IF] {COPY F}=1977 [CHARACTER*4] [ELSE] [INTEGER]
            {  0  }
               0
               0  REPLACE {$EXTERNAL} WITH
               0  {{SETR F=$FORTVER}
            {  0  [IF] {COPY F}=1977 [INTRINSIC] [ELSE] [EXTERNAL]
            {  0  }
               0
               0  "******************************************************************"
               0
               0  "                                                                  "
               0  SPECIFY ALPHA    AS (0...$);
               0  SPECIFY SYMBOL   AS (0...?);
               0  SPECIFY AOPER    AS ['+'|'-'|'*'|'/'];
               0  SPECIFY NAME     AS LETTER(0,5)[ALPHA];
               0  SPECIFY <COMMA>  AS [','|''];
               0  SPECIFY <NAME>   AS [NAME|''];
               0  SPECIFY LABEL    AS ':'NAME':';
               0  SPECIFY <LABEL>  AS [LABEL|''];
               0  SPECIFY <*>      AS ['*'|''];
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {NEWLABEL} WITH {@LG};
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {%'{ARB}'={<*>}'{ARB}'}
               0  WITH {[IF] '{P2}'='*' [APPEND'{P3}'TO'{P1}']
            {  0  [ELSE] [ REPLACE {{P1}}WITH{{P3}}]} ;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "FIRST SOME PARAMETERS"
               0  REPLACE {PARAMETER #=#;} WITH
               0  { REPLACE {{P1}} WITH {{P2}}}
               0
               0  PARAMETER $MXOPT=14; "NUMBER OF OPTIONS"
               0  PARAMETER $MXEL=20;  "MAXIMUM NUMBER OF ELEMENTS IN MATERIAL"
               0  PARAMETER $MXSTC=73; "NUMBER OF MEDIA WITH STERNHEIMER COEFFICIENTS"
               0  PARAMETER $MXVRT1=1000; "NUMBER OF REPRESENTATIVE ANGLES IN VERT1"
               0  PARAMETER $MXJREFF=200; "SIZE OF MULTIPLE SCATTERING JREFF MAP"
               0  PARAMETER $MSSTEPS=16; "NUMBER OF MULTIPLE SCATTERING STEP SIZES."
               0  PARAMETER $MXVRT2=200; "DISTRIBUTIONS OF NONOVERLAPPING PARTS OF VERT"
               0  PARAMETER $MXSGE=400; "GAMMA SMALL ENERGY INTERVALS"
               0  PARAMETER $MXGE=2000; "GAMMA MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXSEKE=300; "ELECTRON SMALL ENERGY INTERVALS"
               0  PARAMETER $MXEKE=150; "ELECTRON MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXLEKE=100; "ELECTRON ENERGY INTERVALS BELOW EKELIM"
               0  PARAMETER $MXCMFP=100; "CUMULATIVE ELECTRON MEAN FREE PATH"
               0  PARAMETER $MXRANGE=100; "ELECTRON RANGE"
               0  PARAMETER $MXRL=100;   "RAYLEIGH SCATTERING SAMPLING INTERVAL"
               0  PARAMETER $MXBLC=20; "MOLIERE'S LOWER CASE B"
               0  PARAMETER $MXRNTH=20; "RANDOM NUMBER FOR SUBMEDIAN ANGLES"
               0  PARAMETER $MXRNTHI=20; "RANDOM NUMBER FOR SUPERMEDIAN ANGLES"
               0  PARAMETER $FUDGEMS=1.0;  "FULL MS OFF ATOMIC ELECTRONS"
               0
               0  "    CHANGED"
               0
               0  "    PARAMETER $F0(29)=1.E-43; LAST F0-VALUE"
               0  "    PARAMETER $RERR=1.D-5;  RERR-VALUE NEEDED BY DCADRE"
               0  "    PARAMETER $AERR=1.D-60; AERR-VALUE NEEDED BY DCADRE"
               0
               0  "    TO"
               0
               0  "    PARAMETER $F0(29)=1.18E-38; LAST F0-VALUE"
               0  "    PARAMETER $RERR=1.E-5;      RERR-VALUE NEEDED BY DCADRE"
               0  "    PARAMETER $AERR=1.E-16;     AERR-VALUE NEEDED BY DCADRE"
               0
               0  "    FOR SUN COMPATRIBILITY AFB 89/12/27"
               0
               0  PARAMETER $F0(29)=1.18E-38; "LAST F0-VALUE"
               0  PARAMETER $RERR=1.E-5;      "RERR-VALUE NEEDED BY DCADRE"
               0  PARAMETER $AERR=1.E-16;     "AERR-VALUE NEEDED BY DCADRE"
               0
               0  "COMMON BLOCK INSERTION MACROS"
               0  REPLACE {;COMIN/#,#/;} WITH {;COMIN/{P1}/;COMIN/{P2}/;};
               0
               0  "MACROS TO GENERALIZE MORTRAN'S INPUT AND OUTPUT"
               0  REPLACE {;$UINPUT(#)#;} WITH
               0  {;{SETR A=NEWLABEL}
            {  0  READ({P1},{COPY A}){P2};{COPY A}FORMAT} ;
               0  REPLACE {;$UOUTPUT(#)#;} WITH
               0  {;{SETR A=NEWLABEL}
            {  0  WRITE({P1},{COPY A}){P2};{COPY A}FORMAT};
               0  REPLACE {;$UINPUT(#,#)#;} WITH
               0  {;{SETR A=NEWLABEL}
            {  0  READ({P1},{COPY A},{P2}){P3};{COPY A}FORMAT};
               0  REPLACE {$ECHO#({NAME}{<COMMA>}#)#;} WITH
               0  {{SETR X=NEWLABEL}
            {  0  WRITE(IUECHO,{COPY X});{COPY X}FORMAT(' $ECHO {P1}:{P5}');
            {  0  [IF] {EXIST 3} [{P1}({P2},{P4}){P5};
            {  0  WRITE(IUECHO,{P4}){P5};]
            {  0  [ELSE] [{SETR Y=NEWLABEL}{P1}({P2},{COPY Y}){P5};
            {  0  WRITE(IUECHO,{COPY Y}){P5};{COPY Y}FORMAT]
            {  0  };
               0
               0  "THE FOLLOWING MACRO REMOVES ALL $ECHOWRITE'S AND SHOULD BE"
               0  "COMMENTED OUT IF YOU WANT OUTPUT ON UNIT 6 AS WELL AS UNIT 7"
               0  REPLACE {$ECHOWRITE} WITH {WRITE}
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "REPLACE {$DUMP#;} WITH"
               0  "    {@LG@LS1V@LC10=#1;OUTPUT V@LC10;(' #1=',1P,G15.7);@LU1};"
               0  "REPLACE {$DUMP#,#;} WITH {$DUMP#1;$DUMP#2;}; "
               0  REPLACE {$DUMP{NAME}{<COMMA>}#;} WITH
               0  {{SETR A=NEWLABEL}
            {  0  V{COPY A}={P1};OUTPUT V{COPY A};(' {P1}=',1P,G15.7);
            {  0  [IF] {EXIST 2} [$DUMP{P3};]
            {  0  ;}
               0
               0  "THE FOLLOWING TWO MACROS ARE USEFUL FOR RUNNING ON CDC-MACHINES."
               0  "FOR IBM-MACHINES, THEY SHOULD BE COMMENTED-OUT."
               0  "REPLACE {READ(#,END=#)#;}"
               0  "    WITH {READ(#1)#3;IF (EOF(#1).NE.0.)GOTO#2;}"
               0  "REPLACE {READ(#,#,END=#)#;}"
               0  "    WITH {D(#1,#2)#4;IF (EOF(#1).NE.0.)GO TO #3;}"
               0
               0  "MACROS TO SPLIT LONG STRING INTO A1 STRINGS"
               0  REPLACE {$S'{SYMBOL}#'} WITH
               0  {'#1'[IF]{EXIST 2}[,$S'{P2}']};
               0
               0  "NOW FOR SOME SPECIFIC COMMON BLOCKS"
               0
               0  REPLACE {$REAL} WITH {real*4}
               0  REPLACE {$INTEGER} WITH {integer*4}
               0  ;
               0  "------------------------------------------------------------------"
               0  "*** BREMPR--BREMS & PAIR DATA                                     "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/BREMPR/;} WITH
               0  {;COMMON/BREMPR/DL1(6),DL2(6),DL3(6),DL4(6),DL5(6),DL6(6),
            {  0  DELCM,ALPHI(2),BPAR(2),DELPOS(2);
            {  0  $REAL dl1,dl2,dl3,dl4,dl5,dl6,delcm,alphi,bpar,delpos;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** DBRPR                                                         "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/DBRPR/;} WITH
               0  {;COMMON/DBRPR/ALFP1(2),ALFP2(2),AL2;
            {  0  $REAL ALFP1,ALFP2,al2;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** DERCON                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/DERCON/;} WITH
               0  {;COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RM,RMT2,RMSQ,A22P9,A6680;
            {  0  $REAL RADDEG,FSC,ERGMEV,R0,RM,RMT2,RMSQ,A22P9,A6680;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** ELEMTB                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/ELEMTB/;} WITH
               0  {;{SETR F=$FORTVER}
            {  0  [IF] {COPY F}=1977 [;COMMON/ELEMTB/NET,WATBL(100),RHOTBL(100),
            {  0  ITBL(100),ISTATB(100); $REAL ITBL;
            {  0  COMMON/ELMTBC/ASYMT(100); $TYPE ASYMT;]
            {  0  [ELSE] [;COMMON/ELEMTB/NET,ASYMT(100),WATBL(100),RHOTBL(100),
            {  0  ITBL(100),ISTATB(100); $TYPE ASYMT; $REAL ITBL;]
            {  0  $INTEGER net,istatb;
            {  0  $REAL    watbl,rhotbl;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "***EPSTAR      NRCC ADDITION, NOV 1988                            "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/EPSTAR/;} WITH
               0  {;
            {  0  COMMON/EPSTAR/EPSTEN(150),EPSTD(150),EPSTFL,EPSTTL,NEPST,IEPST,
            {  0  NELEPS,ZEPST(20),WEPST(20),IAPRIM,IAPRFL;
            {  0  $INTEGER    EPSTFL,ZEPST,NELEPS,IAPRIM,IAPRFL,NEPST,IEPST;
            {  0  CHARACTER   EPSTTL*80;
            {  0  $REAL       EPSTEN,EPSTD,WEPST;
            {  0  };
               0
               0  "THIS COMMON IS USED FOR OPTION WHICH READS IN DENSITY EFFECT "
               0  "CORRECTION IN SPINIT AND CALCULATES USING IT IN SPIONB       "
               0  "THE FLAG EPSTFL IS READ UNDER NAMELIST INPUT, AND DEFAULTS   "
               0  "   TO ZERO IN THE BLOCK DATA. SET TO UNITY TO USE THE OPTION "
               0  "PEGS USES THE I-VALUE IN THE DENSITY INPUT FILE              "
               0  "VARIOUS CHECKS ARE DONE TO ENSURE THE DENSITY CORRECTION     "
               0  "   CORRESPONDS TO THE MATERIAL DEFINITION IN PEGS            "
               0  "THE ENERGY TABLE READ IN IS ASSUMED TO BE KINETIC ENERGY IN  "
               0  "   MEV BUT IS CONVERTED TO TOTAL ENERGY BY THE CODE.         "
               0  "THE ENERGY OPTION MUST BE USED IN PEGS PRIOR TO THE MIXT,COMP"
               0  "   OR ELEM OPTIONS TO ALLOW ALL THE CHECKS TO WORK PROPERLY. "
               0  "NELEPS IS THE NUMBER OF ELEMENTS IN THE MATERIAL             "
               0  "ZEPST(I) (INTEGER), WEPST(I) ARE THE Z VALUE AND FRACTION    "
               0  "   BY WEIGHT OF THE I-TH ELEMENT IN THE DATA FILE.           "
               0  "IAPRIM is a flag to tell which correction to the brem        "
               0  "       cross section to use:      0 =>  old Koch and Motz    "
               0  " =1(defaulat) read in new data file; =2, use no corrections. "
               0  "IAPRFL is a flag to say if APRIM file has been initialized   "
               0
               0  "------------------------------------------------------------------"
               0  "*** FUNCS                                                         "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/FUNCS/;} WITH
               0  {;{SETR F=$FORTVER}
            {  0  [IF] {COPY F}=1977 [
            {  0  ;COMMON/FUNCS/NFARG($NFUNS),NFUNS;
            {  0  $INTEGER NFARG,NFUNS;
            {  0  COMMON/FUNCSC/FNAME(6,$NFUNS);
            {  0  $TYPE FNAME;
            {  0  ]
            {  0  [ELSE] [
            {  0  ;COMMON/FUNCS/FNAME(6,$NFUNS),NFARG($NFUNS),NFUNS;
            {  0  $INTEGER NFARG,NFUNS;
            {  0  $TYPE FNAME;
            {  0  ]
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LAMOLM                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LAMOLM/;} WITH {
            {  0  ;COMMON/LAMOLM/C1,C2,CMOLL,T0;
            {  0  $REAL C1,C2,CMOLL,T0;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LANIHM                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LANIHM/;} WITH {
            {  0  ;COMMON/LANIHM/A,C1,C2;
            {  0  $REAL A,C1,C2;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LBHABM                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LBHABM/;} WITH {
            {  0  ;COMMON/LBHABM/B1,B2,B3,B4,CBHAB,BETASI,T0;
            {  0  $REAL B1,B2,B3,B4,CBHAB,BETASI,T0;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LBREMR                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LBREMR/;} WITH {
            {  0  ;COMMON/LBREMR/E,LA,LB,LD;
            {  0  $REAL E;
            {  0  $INTEGER LA,LB,LD;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LBREMZ                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LBREMZ/;} WITH {
            {  0  ;COMMON/LBREMZ/CONST,DELC,E,DELTAM,XLNZ;
            {  0  $REAL CONST,DELC,E,DELTAM,XLNZ;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LCOMPM                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LCOMPM/;} WITH {
            {  0  ;COMMON/LCOMPM/K0,CCOMP,C1,C2,C3;
            {  0  $REAL K0,CCOMP,C1,C2,C3;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LPAIRR                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LPAIRR/;} WITH {
            {  0  ;COMMON/LPAIRR/K,LA,LC,LE;
            {  0  $REAL    K;
            {  0  $INTEGER LA,LC,LE;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LPAIRZ                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LPAIRZ/;}
               0  WITH {;COMMON/LPAIRZ/K,CONST,DELC,XLNZ,DELTAM;
            {  0  $REAL K,CONST,DELC,XLNZ,DELTAM;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LSPION--COMMON FOR COMMUNICATION BETWEEN SPINIT AND SPIONB    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LSPION/;} WITH
               0  {;COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,ISSB,IEV;
            {  0  $REAL CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,ISSB,IEV;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** MIMSD--MATERIAL INDEPENDENT MULTIPLE SCATTERING DATA          "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MIMSD/;} WITH
               0  {;COMMON/MIMSD/BMIN,MSTEPS,JRMAX,MXV1,MXV2,
            {  0  MSMAP($MXJREFF),FSTEP($MSSTEPS),FSQR($MSSTEPS),
            {  0  VERT1($MXVRT1),VERT2($MXVRT2,$MSSTEPS);
            {  0  $INTEGER MSTEPS,JRMAX,MXV1,MXV2,MSMAP;
            {  0  $REAL    BMIN,FSTEP,FSQR,VERT1,VERT2;
            {  0  }; "TO BE ADDED:"
               0  "NBLC,NRNTH,NRNTHI,BLC0,BLC1,RTHR0,RTHR1,RTHRI0,RTHRI1,"
               0  "THRI0($MXBLC,$MXRNTH),THR, ETC."
               0
               0  "------------------------------------------------------------------"
               0  "*** MIXDAT                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MIXDAT/;} WITH
               0  {;{SETR F=$FORTVER}
            {  0  [IF] {COPY F}=1977 [
            {  0  ;COMMON/MIXDAT/NE,PZ($MXEL),Z($MXEL),WA($MXEL),RHOZ($MXEL),
            {  0  LMED,GASP,TPZ,EZ;
            {  0  $INTEGER NE,LMED;
            {  0  $REAL    PZ,Z,WA,RHOZ,GASP,TPZ,EZ;
            {  0  COMMON/MXDATC/MTYP(4),ASYM($MXEL),MEDIUM(24),IDSTRN(24);
            {  0  $TYPE MTYP,ASYM,MEDIUM,IDSTRN;
            {  0  ]
            {  0  [ELSE] [
            {  0  ;COMMON/MIXDAT/MTYP(4),NE,PZ($MXEL),Z($MXEL),WA($MXEL),
            {  0  ASYM($MXEL),RHOZ($MXEL),MEDIUM(24),LMED,
            {  0  IDSTRN(24),GASP,TPZ,EZ;
            {  0  $INTEGER MTYP,NE,MEDIUM,LMED,IDSTRN;
            {  0  $REAL    PZ,Z,WA,RHOZ,GASP,TPZ,EZ;
            {  0  $TYPE ASYM;
            {  0  ]
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** MOLVAR                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MOLVAR/;} WITH
               0  {;COMMON/MOLVAR/RHO,WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLC,
            {  0  EDEN,BLCC,XCC,TEFF0,XR0;
            {  0  $REAL RHO,WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLC,EDEN,BLCC,
            {  0  XCC,TEFF0,XR0;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** PHPAIR                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {$mxpaire} WITH {17}
               0  REPLACE {$mxphote} WITH {61}
               0  REPLACE {;COMIN/PHPAIR/;} WITH
               0  {;COMMON/PHPAIR/NPHE(100),PHE($mxphote,100),PHD($mxphote,100),
            {  0  EKEDGE(100),PRE($mxpaire),PRD($mxpaire,100);
            {  0  $INTEGER      NPHE;
            {  0  $REAL         PHE,PHD,EKEDGE,PRE,PRD;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** PMCONS                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/PMCONS/;} WITH
               0  {;COMMON/PMCONS/PI,C,RME,HBAR,ECGS,EMKS,AN;
            {  0  $REAL PI,C,RME,HBAR,ECGS,EMKS,AN;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** PWLFIN                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/PWLFIN/;} WITH
               0  {;COMMON/PWLFIN/EPE,ZTHRE(8),ZEPE(8),NIPE,NALE,EPG,ZTHRG(4),
            {  0  ZEPG(4),NIPG,NALG,EPR,ZTHRR(1),ZEPR(1),NIPR,NALR;
            {  0  $REAL EPE,ZTHRE,ZEPE,EPG,ZTHRG,ZEPG,EPR,ZTHRR,ZEPR;
            {  0  $INTEGER NIPE,NALE,NIPG,NALG,NIPR,NALR;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** RADLEN                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/RADLEN/;} WITH
               0  {;COMMON/RADLEN/ALRAD(4),ALRADP(4),A1440,A183;
            {  0  $REAL ALRAD,ALRADP,A1440,A183;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** RAYLEI                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/RAYLEI/;} WITH
               0  {;COMMON/RAYLEI/AFAC(100,100),AFAC2(100),AFFI(100),XVAL(100),
            {  0  COHE($mxphote,100),IRAYL;
            {  0  $REAL AFAC,AFAC2,AFFI,XVAL,COHE;
            {  0  $INTEGER IRAYL;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** RSLTS                                                         "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/RSLTS/;} WITH
               0  {;COMMON/RSLTS/EBINDA,NEL,AXE,BXE,AFE($MXEKE,8),BFE($MXEKE,8),
            {  0  NGL,AXG,BXG,AFG($MXGE,4),BFG($MXGE,4),NGR,AXR,BXR,AFR($MXRL),
            {  0  BFR($MXRL);
            {  0  $REAL EBINDA,AXE,BXE,AFE,BFE,AXG,BXG,AFG,BFG,AXR,BXR,AFR,BFR;
            {  0  $INTEGER NEL,NGL,NGR;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** SPCOMM                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/SPCOMM/;} WITH
               0  {;{SETR F=$FORTVER}
            {  0  [IF] {COPY F}=1977 [
            {  0  ;COMMON/SPCOMM/NMED,STDATA(6,$MXSTC);
            {  0  $INTEGER NMED;
            {  0  $REAL    STDATA;
            {  0  COMMON/SPCOMC/MEDTBL(24,$MXSTC);
            {  0  $TYPE         MEDTBL;
            {  0  ]
            {  0  [ELSE] [
            {  0  ;COMMON/SPCOMM/NMED,MEDTBL(24,$MXSTC),STDATA(6,$MXSTC);
            {  0  $INTEGER NMED,MEDTBL;
            {  0  $REAL    STDATA;
            {  0  ]
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** THRESH                                                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/THRESH/;} WITH
               0  {;COMMON/THRESH/AP,AE,UP,UE,TE,TET2,TEM,THBREM,THMOLL,IUNRST;
            {  0  $REAL AP,AE,UP,UE,TE,TET2,TEM,THBREM,THMOLL;
            {  0  $INTEGER IUNRST;
            {  0  };
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "*** FileNames                                                     "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/FileNames/;} WITH
               0  {;common/file_names/input_file,output_file,density_file,
            {  0  xsection_file,formf_file,egs_home,lenfn,
            {  0  using_sym_links;
            {  0  character*256 input_file,output_file,density_file,egs_home,
            {  0  xsection_file,formf_file;
            {  0  $INTEGER      lenfn;
            {  0  logical       using_sym_links;
            {  0  };
               0
               0  REPLACE {$EGS_HOME} WITH {egs_home(:lnblnk1(egs_home))};
               0  ;
               0
               0
               0  "MACROS TO GENERATE CODE FOR FUNCTIONS IN PEGS"
               0
               0  REPLACE {$RSC(#)} WITH {{P1}};
               0  "IF RESCAN DIDN'T MATCH ANYTHING ELSE,STRIP IT"
               0
               0  "DEFINE PREDECESSORS"
               0  REPLACE {$DEFINEPRED(#,#)} WITH
               0  {REPLACE {$RSC({P2})$PRED} WITH {$RSC({P1})}} ;
               0  REPLACE {$DEFINEPRED(#,#,#)} WITH
               0  {REPLACE {$RSC({P2})$PRED} WITH
            {  0  {$RSC({P1})}$DEFINEPRED({P2},{P3})};
               0  $DEFINEPRED(1,2,3,4,5,6,7,8,9)
               0  REPLACE {$FUNCTIONS #;} WITH
               0  {{SETR I=0}   REPLACE {$FLIST} WITH {$RSC( }
            {  0  $RSC({P1})$FSCAN;};
               0  REPLACE {$RSC({SYMBOL}#)$FSCAN;} WITH
               0  {{INCR I}
            {  0  REPLACE {$FN({P2})} WITH
            {  0  {{COPY I}} APPEND {{P2})} TO {$FLIST}
            {  0  REPLACE {$NA({P2})} WITH {$RSC({P1})}
            {  0  REPLACE {$NFUNS} WITH {{COPY I}}} ;
               0  REPLACE {$RSC({SYMBOL}#,#)$FSCAN;} WITH
               0  {{INCR I}
            {  0  REPLACE {$FN({P2})} WITH {{COPY I}}
            {  0  APPEND {{P2},} TO {$FLIST}
            {  0  REPLACE {$NA({P2})} WITH {$RSC({P1})} $RSC({P3})$FSCAN;};
               0  REPLACE {$RSC(#)$NAME} WITH
               0  {{SETR B={LENGTH 1}}
            {  0  [IF] {LENGTH 1}=6 [$S'{P1}']
            {  0  [ELSE] [[IF] {LENGTH 1}~=0
            {  0  [$S'{P1}',{COMPUTE 6-{COPY B}}*' ']]};
               0  REPLACE {$RSC(#)$DATA(#)} WITH
               0  {DATA {P2}(1,$FN({P1})),{P2}(2,$FN({P1})),
            {  0  {P2}(3,$FN({P1})),
            {  0  {P2}(4,$FN({P1})),{P2}(5,$FN({P1})),{P2}(6,$FN({P1}))
            {  0  /$RSC({P1})$NAME/} ;
               0  REPLACE {$RSC(#,#)$DATA(#)} WITH
               0  {$RSC({P1})$DATA({P3});$RSC({P2})$DATA({P3})};
               0  REPLACE {$RSC(#)$NARGS} WITH {$NA({P1})};
               0  REPLACE {$RSC(#,#)$NARGS} WITH {$NA({P1}),$RSC({P2})$NARGS};
               0  REPLACE {$RSC(#)$FNUMS} WITH {$FN({P1})};
               0  REPLACE {$RSC(#,#)$FNUMS} WITH {$FN({P1}),$RSC({P2})$FNUMS};
               0  REPLACE {$RSC(#)$FCALLS} WITH
               0  {$FN({P1})FI={P1}($NA({P1})$ARGLIST);RETURN;};
               0  REPLACE {$RSC(#,#)$FCALLS}
               0  WITH {$RSC({P1})$FCALLS$RSC({P2})$FCALLS};
               0  REPLACE {$RSC(#)$ARGLIST} WITH {$RSC({P1})$PRED$ARGLIST,X{P1}};
               0  REPLACE {$RSC(1)$ARGLIST} WITH {X1};
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "BECAUSE OF THE PRECEDING MACROS, THE FOLLOWING MACRO CALL"
               0  "GENERATES MACROS SUCH THAT:"
               0  "   $NFUNS  WILL GIVE THE NUMBER OF FUNCTIONS"
               0  "   $FLIST$NAMES  WILL GIVE A LIST OF FUNCTION NAMES"
               0  "   $FLIST$NARGS  WILL GIVE A LIST OF NUMBER OF ARGUMENTS"
               0  "   $FLIST$FNUMS  WILL GIVE A LIST OF THE NUMBERS FROM 1 TO $NARGS"
               0  "   $FLIST$FCALLS  WILL GENERATE FUNCTION CALL FOR FUNCTION 'FI'"
               0  "   $FN(FUNCTION-NAME) WILL GIVE THE INDEX OF THE GIVEN FUNCTION"
               0  "   $NA(FUNCTION-NAME) WILL GIVE THE NUMBER OF ARGUMENTS"
               0  "      FOR THAT FUNCT."
               0  " ATTENTION**********:"
               0  "ATTENTION---THE ORDER OF SOME OF THE FUNCTIONS IN THE FOLLOWING"
               0  "LIST IS IMPORTANT.  THESE ARE THE FUNCTIONS WHICH ARE USED FOR"
               0  "DISTRIBUTION FUNCTIONS.  ANY DISTRIBUTION FUNCTION WHICH IS USED"
               0  "BY THE HPLT OPTION MUST BE FOLLOWED BY ITS INVERSE, WHICH MUST BE"
               0  "FOLLOWED BY ITS DERIVATIVE.  DISTRIBUTION FUNCTIONS USED BY THE"
               0  "PLOT ROUTINE MUST BE FOLLOWED BY THEIR INVERSES."
               0  "HPLT NOW USES: ALIN,ADFMOL,ALOG.   PLOT COULD USE ANY OF"
               0  "THESE AND ALSO ALKE.  ALKE AND ITS INVERSE ARE ALSO"
               0  "USED BY PWLF, BUT ARE PASSED BY FUNCTION RATHER THAN NUMBER."
               0  "THE ADVANTAGE OF PASSING BY NUMBER IS THAT THE FUNCTION NAME AND"
               0  "NUMBER OF ARGUMENTS ARE AVAILABLE."
               0  ;
               0  $FUNCTIONS 1ALIN,1ALINI,1ADFMOL,1ADIMOL,1ADDMOL,
               0  1ALOG,1EXP,1AREC,1ALKE,1ALKEI,
               0  2AMOLDM,1AMOLFM,3AMOLRM,1AMOLTM,2ANIHDM,
               0  1ANIHFM,3ANIHRM,1ANIHTM,2APRIM,2BHABDM,1BHABFM,3BHABRM,1BHABTM,
               0  2BREMDR,1BREMFR,3BREMDZ,3BRMSDZ,1BREMFZ,1BRMSFZ,3BREMRR,3BREMRM,
               0  4BREMRZ,1BREMTM,1BREMTR,3BRMSRM,4BRMSRZ,2BRMSTM,1COHETM,2COHETZ,
               0  2COMPDM,1COMPFM,3COMPRM,1COMPTM,1CRATIO,1EBIND,1EBR1,1EDEDX,1ESIG,
               0  1FCOULC,1GBR1,1GBR2,1GMFP,2PAIRDR,1PAIRFR,3PAIRDZ,1PAIRFZ,
               0  3PAIRRM,3PAIRRR,4PAIRRZ,1PAIRTE,1PAIRTM,1PAIRTR,1PAIRTU,2PAIRTZ,
               0  1PBR1,1PBR2,1PDEDX,2PHOTTZ,1PHOTTE,1PSIG,2SPIONE,
               0  2SPIONP,3SPTOTE,3SPTOTP,1TMXB,1TMXS,1TMXDE2,1XSIF;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS TO CONVERT DOUBLE PRECISION TO REAL"
               0  REPLACE {DOUBLEPRECISION} WITH {REAL};
               0  REPLACE {DABS} WITH {ABS} ;
               0  REPLACE {DMAX1} WITH {AMAX1};
               0  REPLACE {DLOG10} WITH {ALOG10};
               0  REPLACE {;DATA#;} WITH {{EMIT;}DATA $$D({P1});};
               0  REPLACE {$$D(#)} WITH {{P1}} ;
               0  REPLACE {$$D(#/#/#)} WITH {{P1}/$$D2({P2})/$$D({P3})};
               0  REPLACE {$$D2(#)} WITH {{P1}} ;
               0  REPLACE {$$D2(#D#)} WITH {{P1}E$$D2({P2})};
               0
               0  "******************************************************************"
               0  "************************ PEGS4 MACROS END ************************"
               0  "******************************************************************"
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  "MAIN PROGRAM FOR PEGS4                                            "
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "******************************************************************"
               0  "************************ DECLARATIONS ****************************"
               0  "******************************************************************"
               0
               0  program main_pegs4;
               0
               0  implicit none;
               0
               0  ;
               0
               0  ;COMIN/BREMPR,DBRPR,DERCON,ELEMTB,FUNCS,LSPION,MIMSD,MIXDAT,MOLVAR,
               0  PHPAIR,PMCONS,PWLFIN,RAYLEI,RSLTS,THRESH,EPSTAR/;"MOD NOV 23,1988"
               0  $REAL XP(4),WASAV(20);
               0  LOGICAL MEDSET,ENGSET;
               0  $TYPE OPTION(4,$MXOPT),OPT(4),BLKW,NAME(6);
               0  $TYPE NAMESB(12),IDFNAM(6);
               0  $INTEGER NH(200);
               0  "*************************"
               0  "Fix errors for gcc > 10.0"
               0  "*************************"
               0  $REAL ALKE,ALKEI,ALIN,ALINI,AFFACT;
               0  EXTERNAL ALKE,ALKEI,EFUNS,GFUNS,RFUNS,ALIN,ALINI,AFFACT;
               0  "*************************"
               0  $EXTERNAL ALOG,EXP;
               0
               0  $INTEGER NOPT,NPTS,IDF,EPSTFL_old,IUNRST_old,IAPRIM_old;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER IFUN,IV,ISUB,I,in,iz,ICH,IOPT,IMIXT,I01,IZZ,NA,ID,
               0  NTIMES,NBINS,IQI,IRNFLG,IBIN;
               0  $REAL    VLO,VHI,EI,RHOSAV,AX,BX,VALUE,RNLO,RNHI,PINC,AVE;
               0
               0  " IK: Function declarations for implicit none"
               0  $INTEGER IFUNT;
               0  $REAL    ZTBL,EBIND,QD,FI;
               0
               0  "******************************************************************"
               0  "*********************** DATA STATEMENTS **************************"
               0  "******************************************************************"
               0
               0  DATA OPTION/$S'ELEM',$S'MIXT',$S'COMP',$S'ENER',$S'MIMS',$S'PWLF',
               0  $S'DECK',$S'TEST',$S'DBUG',$S'CALL',$S'PLTN',$S'STOP',$S'PLTI',
               0  $S'HPLT'/;
               0  DATA NOPT/$MXOPT/,BLKW/' '/;
               0  DATA MEDSET/.FALSE./,ENGSET/.FALSE./;
               0  DATA NPTS/50/,IDF/$FN(ALOG)/;
               0
               0  "******************************************************************"
               0  "********************* NAMELIST DEFINITIONS ***********************"
               0  "******************************************************************"
               0
               0  NAMELIST/PHPRNM/NPHE,PHE,PHD,EKEDGE,PRE,PRD,COHE;
               0  NAMELIST/AFFDT/XVAL,AFAC;
               0  NAMELIST/INP/NE,PZ,RHO,RHOZ,WA,AE,UE,AP,UP,
               0  IFUN,XP,IV,VLO,VHI,IDF,NPTS,
               0  EPE,ZTHRE,ZEPE,NIPE,NALE,EPG,ZTHRG,ZEPG,NIPG,NALG,
               0  EI,ISUB,GASP,IUNRST,IRAYL,AFACT,SK,X0,X1,IEV,CBAR,ISSB,EPSTFL,
               0  IAPRIM;
               0  "                      MOD NOV 23,1988                    ======"
               0  NAMELIST/PWLFNM/EPE,ZTHRE,ZEPE,NIPE,NALE,EPG,ZTHRG,ZEPG,NIPG,NALG,
               0  EPR,ZTHRR,ZEPR,NIPR,NALR;
               0
               0  save NOPT,NPTS,IDF;
               0
               0  "******************************************************************"
               0  "*************** PERFORM ONCE-ONLY INITIALIZATION *****************"
               0  "******************************************************************"
               0
               0  call open_units;
               0  write(6,*) 'Returned from call open_units';
               0
               0  "Nov 27, 1996  added explicit opens of all units so can use HP"
               0  "              Note corresponding change in pegs4_run      DR"
               0  "OPEN(UNIT=5,file='fort.5',STATUS='UNKNOWN');  " "terminal/input file"
               0  "OPEN(UNIT=6,file='fort.6',STATUS='UNKNOWN');  " "terminal output/promp"
               0  "OPEN(UNIT=7,file='fort.7',STATUS='UNKNOWN');  " "output listing"
               0  "OPEN(UNIT=8,file='fort.8',STATUS='OLD');      " "Cross section data"
               0  "OPEN(UNIT=9,file='fort.9',STATUS='OLD');      " "Rayleigh form factors"
               0  "OPEN(UNIT=10,file='fort.10',STATUS='UNKNOWN');" "Error logging"
               0  "OPEN(UNIT=20,file='fort.20',STATUS='UNKNOWN');" "Density effect data"
               0  "OPEN(UNIT=21,file='fort.21',STATUS='UNKNOWN');" "plotting output"
               0  "OPEN(UNIT=22,file='fort.22',STATUS='UNKNOWN');" "ICRU37 brem corr"
               0
               0
               0  OUTPUT;('1',20X,'PEGS4 LISTING FILE',/
               0  20X,'(WITH NRCC MODIFICATIONS, Jan 13,1988)');
               0  OUTPUT;(/);
               0  CALL PMDCON;   "COMPUTE PHYSICAL AND MATHEMATICAL CONSTANTS"
               0
               0  "**************************************************************"
               0  "BLIF 92/04/03 changed below from NAMELIST to free format reads"
               0  OUTPUT;(/' This version reads units 8 and 9 in free format'/);
               0  "READ(8,PHPRNM);" "READ IN PHOTOELECTRIC AND PAIR DATA FROM FILE"
               0  READ(8,*)
               0  NPHE,
               0  ((PHE(in,iz),in=1,61),iz=1,100),
               0  ((PHD(in,iz),in=1,61),iz=1,100),
               0  EKEDGE,
               0  PRE,
               0  ((PRD(in,iz),in=1,17),iz=1,100),
               0  ((COHE(in,iz),in=1,61),iz=1,100);
               0  "READ(9,AFFDT);" "READ IN ATOMIC FORM FACTOR DATA FROM A FILE"
               0  READ(9,*)
               0  XVAL,
               0  ((AFAC(in,iz),in=1,100),iz=1,100);
               0  "**************************************************************"
               0
               0  "------------------------------------------------------------------"
               0  "---------------------- START OF OPTION LOOP ----------------------"
               0  "------------------------------------------------------------------"
               0
               0
               0  :OPTION: "MAIN OPTION LOOP"
               0
               0  DO I=1,$MXEL [WASAV(I)=WA(I);WA(I)=0.;]
               0  RHOSAV=RHO;
               0  RHO=0.0;
               0
               0  "******************************************************************"
               0  "* OPTIONS AND PARAMETERS WHICH SHOULD BE PUT IN ASSOCIATED INPUT *"
               0  "******************************************************************"
               0  "                                                                  "
               0  "   ELEM  -  ASYM, RHO (IF NOT SUPPLIED, IT WILL BE FROM TABLE)    "
               0  "   MIXT  -  NE, RHO, ASYM, RHOZ                                   "
               0  "   COMP  -  NE, RHO, ASYM, PZ                                     "
               0  "   ENER  -  AE, UE, AP, UP                                        "
               0  "   MIMS  -  FOR PRODUCING MEDIUM INDEPENDENT MULTIPLE             "
               0  "            SCATTERING DATA (OBSOLETE LEFT-OVER FROM EGS2)        "
               0  "   PWLF  -  (OPTIONALLY ANY OF THE PARAMETERS IN PWLFIN)          "
               0  "   DECK  -  (NONE)                                                "
               0  "   TEST  -  (DEPENDS ON TEMPORARY CODE)                           "
               0  "   DBUG  -  (DITTO)                                               "
               0  "   CALL  -  IFUN, XP(1:4)                                         "
               0  "   PLTN  -  FNAME, IDFNAME, XP, IV, VLO, VHI, NPTS                "
               0  "   PLTI  -  IFUN, IDF, XP, IV, VLO, VHI, NPTS                     "
               0  "   HPLT  -  EI, ISUB                                              "
               0  "   STOP  -  (NONE)                                                "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $UINPUT(5,END=:STOP:) OPT;(4A1); "READ IN THE OPTION (1ST CARD)"
               0  OUTPUT OPT;
               0  (//,1X,60('*'),/,' *',T61,'*',/,' *  OPT = ',4A1,T61,'*',/,
               0  ' *',T61,'*',/,1X,60('*'),//);
               0
               0  EPSTFL_old=EPSTFL; IUNRST_old=IUNRST; IAPRIM_old=IAPRIM;
               0  READ(5,INP,END=:NONAMELIST:); "READ IN NAMELIST/INP/ (2ND CARD)"
               0
               0  IF (RHO.EQ.0) [
               1      DO ICH=1,4 [
               2          IF(OPT(ICH).NE.OPTION(ICH,1)) [RHO=RHOSAV; EXIT;]
               2          ]
               1      ]
               0
               0  "   LOOK TO SEE IF IT IS IN THE OPTION TABLE."
               0  :LOOK:
               0  DO IOPT=1,NOPT [
               1      DO ICH=1,4 [ IF (OPT(ICH).NE.OPTION(ICH,IOPT)) NEXT :LOOK:;]
               1      GO TO :FOUND:;]
               0  OUTPUT ; (' OPTION NOT FOUND, JOB ABORTED.');  $CALL_EXIT(16);
               0
               0  :FOUND:  "WE FOUND THE OPTION IN THE LIST"
               0  IF (IOPT.GT.3)[
               1      RHO=RHOSAV;DO I=1,$MXEL [WA(I)=WASAV(I);] "RESTORE"
               1      "*********************************************"
               1      "Check if entries placed in wrong OPTION block"
               1      "*********************************************"
               1      IF ( EPSTFL ~= EPSTFL_old )["Read EPSTFL here?"
               2          write(*,'(2a,i2)') 'EPSTFL in wrong OPTION block!',
               2          ' Resetting to EPSTFL= ',EPSTFL_old;
               2          EPSTFL=EPSTFL_old;
               2          ]
               1      IF ( IUNRST ~= IUNRST_old )["Read IUNRST here?"
               2          write(*,'(2a,i2)') 'IUNRST in wrong OPTION block!',
               2          ' Resetting to IUNRST= ',IUNRST_old;
               2          IUNRST=IUNRST_old;
               2          ]
               1      IF ( IAPRIM ~= IAPRIM_old )["Read IAPRIM here?"
               2          write(*,'(2a,i2)') 'IAPRIM in wrong OPTION block!',
               2          ' Resetting to IAPRIM= ',IAPRIM_old;
               2          IAPRIM=IAPRIM_old;
               2          ]
               1      "*********************************************"
               1      ]
               0  ELSE[ DO I=1,4 [MTYP(I)=OPT(I);] "SAVE MEDIUM TYPE" ]
               0
               0  "------------------------------------------------------------------"
               0  GO TO(:ELEM:,:MIXT:,:COMP:,:ENER:,:MIMS:,:PWLF:,:DECK:,:TEST:,
               0  :DBUG:,:CALL:,:PLTN:,:STOP:,:PLTI:,:HPLT:),IOPT;
               0  "------------------------------------------------------------------"
               0
               0  :ELEM:
               0  "     HERE FOR NEW MEDIUM WHICH IS AN ELEMENT"
               0  NE=1;
               0  PZ(1)=1;
               0  IMIXT=0;
               0  GO TO :ELEM/MIXT/COMP:;
               0
               0  :MIXT:
               0  "     HERE FOR NEW MEDIUM WHICH IS A MIXTURE (I.E., PROPORTIONS"
               0  "     ARE PER CENT BY WEIGHT OR SOMETHING PROPORTIONAL)"
               0  IF(NE.LE.1) ["NE IS NOT PROPERLY DEFINED"
               1      OUTPUT NE; (//,' NE=',I6,' IS IMPROPERLY DEFINED FOR A MIXTURE');
               1      STOP;]
               0
               0  IMIXT=1;
               0  GO TO :ELEM/MIXT/COMP:;
               0
               0  :COMP:
               0  "     HERE FOR NEW MEDIUM WHICH IS A COMPOUND (I.E., PROPORTIONS"
               0  "     ARE BY RELATIVE NUMBER OF ATOMS PER FORMULA"
               0  IF(NE.LE.1) ["NE IS NOT PROPERLY DEFINED"
               1      OUTPUT NE; (//,' NE=',I6,' IS IMPROPERLY DEFINED FOR A COMPOUND');
               1      $CALL_EXIT(17);
               1      ]
               0  IMIXT=0;
               0
               0  :ELEM/MIXT/COMP:
               0  "     HERE IS WHERE OPTIONS ELEM, MIXT, AND COMP MEET"
               0
               0  INPUT MEDIUM,IDSTRN; (24A1,6X,24A1);
               0  INPUT (ASYM(I),I=1,NE); (24(A2,1X));
               0  IF (IDSTRN(1).EQ.BLKW) [DO I=1,LMED [IDSTRN(I)=MEDIUM(I);]  ]
               0  OUTPUT MEDIUM,IDSTRN,(ASYM(I),I=1,NE);
               0  (1X,60('-')/' MEDIUM=',24A1,',STERNHEIMER ID=',24A1,/1X,60('-')//
               0  ,' ATOMIC SYMBOLS ARE: ',(1X,24(A2,1X) ) );
               0  IF(IUNRST.EQ.1)[OUTPUT;(/T10,'***CALCULATES UNRESTRICTED COLLISION',
               1      ' STOPPING POWER***  IUNRST=1'//);]
               0  ELSEIF(IUNRST.EQ.2)[OUTPUT;(/T10,'****DATA SET FOR A CSDA CALCULATION',
               1      '******  IUNRST=2'//);]
               0  ELSEIF(IUNRST.EQ.3)[OUTPUT;(/T10,'****DATA SET FOR A CSDA CALCULATION',
               1      ' BUT WITH BREM EVENTS******  IUNRST = 3'//);]
               0  ELSEIF(IUNRST.EQ.4)[OUTPUT;(/T10,'****DATA SET FOR A CALCULATION',
               1      'WITH DELTAS DISCRETE,BREM CSDA******  IUNRST = 4'//);]
               0  ELSEIF(IUNRST.EQ.5)[OUTPUT;
               1      (/T10,'****CALCULATES UNRESTRICTED RADIATIVE',
               1      ' STOPPING POWER***** IUNRST = 5');]
               0  ELSEIF(IUNRST.EQ.6)[OUTPUT;
               1      (/T10,'****CALCULATES RESTRICTED RADIATIVE',
               1      ' STOPPING POWER***** IUNRST = 6');]
               0  ELSEIF(IUNRST.EQ.7)[OUTPUT;
               1      (/T10,'****CALCULATES RESTRICTED COLLISION',
               1      ' STOPPING POWER***** IUNRST = 7');]
               0  DO I=1,NE [
               1      Z(I)=ZTBL(ASYM(I));
               1      IF (Z(I).EQ.0.0)[OUTPUT;
               2          (' BAD ATOMIC SYMBOL....JOB ABORTED.'); $CALL_EXIT(16); ]
               1      "ALLOW USER TO OVER-RIDE ATOMIC WEIGHTS, IN CASE USING NONSTANDARD"
               1      "  ISOTOPES."
               1      IF WA(I).EQ.0. [I01=Z(I);WA(I)=WATBL(I01);]"USE OUR TABLE (DEFAULT)"
               1      IF (IMIXT.NE.0)[PZ(I)=RHOZ(I)/WA(I);]ELSE[RHOZ(I)=PZ(I)*WA(I);]
               1      ]
               0  "     IF RHO IS NOT GIVEN FOR AN ELEMENT, SUPPLY IT FROM OUR TABLE.    "
               0  IF (NE.EQ.1.AND.RHO.EQ.0.)[I01=Z(1);RHO=RHOTBL(I01);]
               0  "     NOW WE HAVE DEFINED THE MIXTURE, SO COMPUTE Z-DEPENDENT PARAMETER"
               0  CALL MIX;
               0  "     INITIALIZE FOR STOPPING POWER USING STERNHEIMER-SELTZER-"
               0  "     BERGER (SSB) PARAMETER OR STERNHEIMER-PEIERLS GENERAL SCHEME"
               0  "     FOR THE DENSITY EFFECT."
               0
               0  "CHANGED"
               0  "CALL SPINIT(MEDIUM);"
               0  "TO"
               0  "CALL SPINIT;"
               0  "FOR SUN AFB 89/12/27"
               0  CALL SPINIT;
               0
               0  "     COMPUTE DIFFERENTIAL SAMPLING(BREMPR) CONSTANTS.                 "
               0  CALL DIFFER;
               0  "     SET FLAG TO SAY THAT THE MEDIUM HAS BEEN SET.                    "
               0  MEDSET=.TRUE.;
               0  OUTPUT ;  (//,' END OF ELEM, MIXT, OR COMP OPTION',///);
               0  "     RETURN TO OPTION LOOP                                            "
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****HERE FOR OPTION TO SET ENERGY LIMITS FOR ELECTRONS AND PHOTONS"
               0  "*****"
               0  :ENER:IF (AE.LT.0)AE=-AE*RM;
               0  IF (UE.LT.0)UE=-UE*RM;
               0  IF (AP.LT.0)AP=-AP*RM;
               0  IF (UP.LT.0)UP=-UP*RM;
               0  TE=AE-RM;
               0  TET2=TE*2.0;
               0  TEM=TE/RM;
               0  THBREM=RM+AP;"THRESHOLD FOR DISCRETE BREMSSTRAHLUNG"
               0  THMOLL=AE+TE;
               0  OUTPUT AE,UE,AP,UP,TE,TET2,TEM,THBREM,THMOLL;
               0  ('0AE,UE,AP,UP,TE,TET2,TEM,THBREM,THMOLL'/1X,1P,5E15.7/1X,1P,4E15.7);
               0  ENGSET=.TRUE.;
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****MIMS -- COMPUTE MATERIAL INDEPENDENT MULTIPLE SCATTERING DATA."
               0  "*****"
               0  :MIMS: CALL MOLIER;
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****HERE FOR OPTION TO DO PIECEWISE LINEAR FITS AND OTHER CALCULATION"
               0  "*****WHICH DEPEND BOTH ON MATERIAL AND ENERGY LIMITS"
               0  "*****"
               0  :PWLF:IF (MEDSET.AND.ENGSET)GO TO :FITEP:;
               0  OUTPUT MEDSET,ENGSET;
               0  (' MEDSET,ENGSET=',2L2,',PWLF REQ. IGNORED.');
               0  $CALL_EXIT(16);
               0
               0  "*****"
               0  "*****FIRST FIT ELECTRON(AND POSITRON)"
               0  "*****"
               0  :FITEP:   EBINDA=EBIND(AP);
               0  WRITE(6,PWLFNM);
               0  OUTPUT EBINDA;
               0  (' AVERAGE K-IONIZATION ENERGY=',F10.6,'(MEV)');
               0
               0  OUTPUT;('0DO PWLF TO ELECTRON DATA SETS'/);
               0  CALL PWLF1(NEL,NALE,AE,UE,THMOLL,EPE,ZTHRE,ZEPE,NIPE,ALKE,ALKEI,
               0  AXE,BXE,$MXEKE,8,AFE,BFE,EFUNS);
               0  "     NEXT FIT GAMMA                                                   "
               0  OUTPUT;('0DO PWLF TO PHOTON DATA SETS'/);
               0  CALL PWLF1(NGL,NALG,AP,UP,RMT2,EPG,ZTHRG,ZEPG,NIPG,ALOG,EXP,
               0  AXG,BXG,$MXGE,4,AFG,BFG,GFUNS);
               0
               0  IF (IRAYL.EQ.1) [
               1      "PWLF FOR DISTRIBUTION FUNCTION FOR RAYLEIGH"
               1      "NOTE THAT TOTAL X-SECTION IS FIT WITH REST OF PHOTON CROSS SECTIONS"
               1      OUTPUT ; (//,' ***** IRAYL=1: RAYLEIGH DATA INCLUDED *****',//);
               1      OUTPUT;(' DO PWLF TO RAYLEIGH DISTRIBUTION'/);
               1      DO I=1,100 [
               2          AFAC2(I)=0.0; "ZERO FOR SUMMATION"
               2          DO IN=1,NE [
               3              IZZ=Z(IN); "INTEGER Z VALUE"
               3              AFAC2(I)=AFAC2(I)+PZ(IN)*AFAC(I,IZZ)**2;]
               2          ] "END OF LOOP ON I"
               1      "THE ABOVE CALCULATES THE COHERENT SCATTERING FORM FACTOR FOR THE"
               1      "MOLECULE ASSUMING EACH ATOM ACTS INDEPENDENTLY.  THIS ASSUMPTION"
               1      "IS ALSO MADE WHEN CALCULATING THE TOTAL COHERENT CROSS SECTION."
               1      "THE ASSUMPTION IS KNOWN TO BE VERY WRONG IN SOME SITUATIONS - MOST"
               1      "NOTABLY WATER - E.G., SEE L.R. MORIN, J. PHYS. CHEM REF. DATA VOL 11"
               1      "(1982) P1091 AND JOHNS AND YAFFE, MEDICAL PHYSICS, VOL. 10 (1983) P40."
               1      DO I=1,100 [XVAL(I)=XVAL(I)**2.;]
               1      AFFI(1)=0.0;
               1      DO I=2,87 [
               2          AX=XVAL(I-1);
               2          BX=XVAL(I);
               2          AFFI(I)=QD(AFFACT,AX,BX,'AFFACT');"INTEGRATE AFAC2 FROM AX TO BX"
               2          ]
               1      DO I=2,87 [
               2          AFFI(I)=AFFI(I)+AFFI(I-1);]
               1      DO I=1,87 [
               2          AFFI(I)=AFFI(I)/AFFI(87);]
               1      CALL PWLF1(NGR,NALR,0.0,1.0,0.0,EPR,ZTHRR,ZEPR,NIPR,ALIN,ALINI,
               1      AXR,BXR,$MXRL,1,AFR,BFR,RFUNS);
               1      ] "END OF RAYLEIGH SCATTERING PWLF"
               0  "     THAT'S ALL FOLKS---PWLF DOES ALL THE WORK."
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****HERE FOR OPTION TO PRODUCE A DECK---PASS THE BUCK TO A SUBROUTINE"
               0  "*****"
               0  :DECK:CALL LAY;
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****TEST OPTION"
               0  "*****"
               0  :TEST:CONTINUE;
               0  CALL PLOT($FN(ESIG),XP,1,AE,UE,NPTS,$FN(ALKE));
               0  CALL PLOT($FN(PSIG),XP,1,AE,UE,NPTS,$FN(ALKE));
               0  CALL PLOT($FN(EDEDX),XP,1,AE,UE,NPTS,$FN(ALKE));
               0  CALL PLOT($FN(PDEDX),XP,1,AE,UE,NPTS,$FN(ALKE));
               0  CALL PLOT($FN(EBR1),XP,1,AE,UE,NPTS,$FN(ALKE));
               0  CALL PLOT($FN(PBR1),XP,1,AE,UE,NPTS,$FN(ALKE));
               0  CALL PLOT($FN(PBR2),XP,1,AE,UE,NPTS,$FN(ALKE));
               0  CALL PLOT($FN(TMXS),XP,1,AE,UE,NPTS,$FN(ALKE));
               0  CALL PLOT($FN(TMXDE2),XP,1,AE,UE,NPTS,$FN(ALKE));
               0  CALL PLOT($FN(GMFP  ),XP,1,AP,UP,NPTS,$FN(ALOG));
               0  CALL PLOT($FN(GBR1  ),XP,1,AP,UP,NPTS,$FN(ALOG));
               0  CALL PLOT($FN(GBR2  ),XP,1,AP,UP,NPTS,$FN(ALOG));
               0  CALL PLOT($FN(CRATIO),XP,1,AP,UP,NPTS,$FN(ALOG));
               0  OUTPUT;('1'); "NEW PAGE"
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****DBUG OPTION"
               0  "*****"
               0  :DBUG:CONTINUE;
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "***** CALL OPTION"
               0  "*****"
               0  :CALL:
               0  INPUT NAME;(6A1); IFUN=IFUNT(NAME); IF (IFUN.LE.0)GOTO :OPTION:;
               0  VALUE=FI(IFUN,XP(1),XP(2),XP(3),XP(4));  NA=NFARG(IFUN);
               0  OUTPUT  VALUE,(FNAME(I,IFUN),I=1,6),(XP(I),I=1,NA);
               0  ('0FUNCTION CALL: ',1P,G15.6,' = ',6A1,' OF ',4G15.6 );
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****PLTN OPTION"
               0  "*****"
               0  :PLTN:
               0  INPUT NAME,IDFNAM;(12A1); IFUN=IFUNT(NAME); IF (IFUN.LE.0)GOTO :OPTION:;
               0  ID=IFUNT(IDFNAM); IF (ID.LT.0)GOTO :OPTION:; IF (ID.NE.0)IDF=ID;
               0
               0  "*****"
               0  "*****OPTION PLTN RUNS INTO PLTI"
               0  "*****"
               0  :PLTI:
               0  CALL PLOT(IFUN,XP,IV,VLO,VHI,NPTS,IDF);
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****HPLT OPTION *** COMPARE ACTUALLY SAMPLED SPECTRA WITH THEORY"
               0  "*****READ IN SAMPLED DATA"
               0  "*****"
               0  :HPLT:READ(5,:FMT:)NAMESB,NTIMES,NBINS,IQI,RNLO,RNHI,IRNFLG,
               0  (NH(IBIN),IBIN=1,NBINS);
               0  :FMT:FORMAT(' TEST DATA FOR ROUTINE=',12A1,',#SAMPLES=',I10,',NBINS=',I5
               0  /' IQI=',I2,',RNLO,RNHI=',2F12.8,',IRNFLG=',I2/(9I8));
               0  WRITE(6,:FMT:)NAMESB,NTIMES,NBINS,IQI,RNLO,RNHI,IRNFLG,
               0  (NH(IBIN),IBIN=1,NBINS);
               0  OUTPUT EI,ISUB;
               0  (' EI=',F14.3,',ISUB=',I3);
               0
               0  GO TO (:PAIR:,:COMPTON:,:BREMS:,:MOLLER:,:BHABHA:,:ANNIH:),ISUB;
               0
               0  "*****"
               0  "*****PAIR"
               0  "*****"
               0  :PAIR:  CALL HPLT1(EI,RM,EI-RM,NAMESB,NTIMES,NBINS,NH,
               0  $FN(ALIN),$FN(PAIRDR),$FN(PAIRRR),$FN(PAIRTR) );
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****COMPTON"
               0  "*****"
               0  :COMPTON:  CALL HPLT1(EI,EI/(1.0+2.0*EI/RM),EI,NAMESB,NTIMES,NBINS,NH,
               0  $FN(ALOG),$FN(COMPDM),$FN(COMPRM),$FN(COMPTM) );
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****BREMS"
               0  "*****"
               0  :BREMS:  CALL HPLT1(EI,AP,EI-RM,NAMESB,NTIMES,NBINS,NH,
               0  $FN(ALOG),$FN(BREMDR),$FN(BREMRR),$FN(BREMTR) );
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****MOLLER"
               0  "*****"
               0  :MOLLER:  CALL HPLT1(EI,AE,RM+(EI-RM)*0.5,NAMESB,NTIMES,NBINS,NH,
               0  $FN(ADFMOL),$FN(AMOLDM),$FN(AMOLRM),$FN(AMOLTM) );
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****BHABHA"
               0  "*****"
               0  :BHABHA:  CALL HPLT1(EI,AE,EI,NAMESB,NTIMES,NBINS,NH,
               0  $FN(ADFMOL),$FN(BHABDM),$FN(BHABRM),$FN(BHABTM) );
               0  GOTO :OPTION:;
               0
               0  "*****"
               0  "*****ANNIH"
               0  "*****"
               0  :ANNIH:  PINC=SQRT(EI**2-RM**2);
               0  AVE=EI+RM;
               0  CALL HPLT1(EI,AVE*RM/(AVE+PINC),AVE*0.5,NAMESB,NTIMES,NBINS,NH,
               0  $FN(ALOG),$FN(ANIHDM),$FN(ANIHRM),$FN(ANIHTM) );
               0
               0  GOTO :OPTION:;
               0
               0  "------------------------------------------------------------------"
               0  "----------------------- END OF OPTION LOOP -----------------------"
               0  "------------------------------------------------------------------"
               0
               0
               0  :NONAMELIST:  "REACH THIS POINT WHEN NAMELIST DATA MISSING"
               0
               0  OUTPUT; (' STOPPED IN MAIN PROGRAM BECAUSE NAMELIST/INP/',/,
               0  ' DATA CARD(S) WERE MISSING.');
               0  $CALL_EXIT(18);
               0
               0  "*****"
               0  "***** STOP OPTION"
               0  "*****"
               0  :STOP:
               0  OUTPUT;(///' END OF FILE READ - EXIT FROM PEGS4'/'1');
               0  $CALL_EXIT(0);
               0
               0  END;  "END OF MAIN PROGRAM OF PEGS4"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  BLOCK DATA;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0
               0  "THIS ROUTINE CONTAINS PHYSICAL AND CONTROL DATA FOR PEGS          "
               0  ;COMIN/BREMPR,DBRPR,DERCON,ELEMTB,FUNCS,LSPION,MIMSD,MIXDAT,MOLVAR,
               0  PHPAIR,PMCONS,PWLFIN,RADLEN,RAYLEI,SPCOMM,RSLTS,THRESH,EPSTAR/;
               0  "                                  MOD NOV 22 1988            ======"
               0
               0  "****STERNHEIMER-SELTZER-BERGER (SSB) DATA                         "
               0
               0  "   STDATA IS THE ACTUAL STERNHEIMER DATA                 "
               0  "   AFACT,SK,X0,X1,IEV,CBAR                              "
               0  "   THE SEQUENCE FIELD OF EACH CARD TELL WHICH MATERIAL ITS FOR."
               0  DIMENSION STDAT1(6,20),STDAT2(6,20),STDAT3(6,20),STDAT4(6,13);
               0  EQUIVALENCE (STDATA(1,1),STDAT1(1,1));
               0  EQUIVALENCE (STDATA(1,21),STDAT2(1,1));
               0  EQUIVALENCE (STDATA(1,41),STDAT3(1,1));
               0  EQUIVALENCE (STDATA(1,61),STDAT4(1,1));
               0  "above declarations moved from below Aug 4/96 so Linux fort77 "
               0  "compiler handles it (declarations before data stmts)"
               0
               0  "     MEDTLB CONTAIN THE IDENTIFIERS FOR THE MEDIUM"
               0  $TYPE MEDTB1(24,20),MEDTB2(24,20),MEDTB3(24,20),MEDTB4(24,13);
               0  EQUIVALENCE (MEDTBL(1,1),MEDTB1(1,1));
               0  EQUIVALENCE (MEDTBL(1,21),MEDTB2(1,1));
               0  EQUIVALENCE (MEDTBL(1,41),MEDTB3(1,1));
               0  EQUIVALENCE (MEDTBL(1,61),MEDTB4(1,1));
               0
               0  "    TAKEN FROM STERNHEIMER, SELTZER, AND BERGER  BNL 31435        "
               0  "DATA FOR COMMON BLOCK LSPION                                      "
               0  DATA AFACT/0.0/,SK/0.0/,X0/0.0/,X1/0.0/,CBAR/0.0/,IEV/0.0/,ISSB/0/;
               0  "DATA FOR COMMON BLOCK SPCOMM                                      "
               0  DATA LMED/24/,NMED/$MXSTC/;
               0
               0  DATA MEDTB1/
               0  $S'H2-GAS',18*' ',$S'H2-LIQUID',15*' ',$S'HE-GAS',18*' ',$S'LI',22*' ',
               0  $S'BE',22*' ',$S'C-2.265 G/CM**3',9*' ',$S'C-1.70 G/CM**3',10*' ',
               0  $S'N2-GAS',18*' ',$S'O2-GAS',18*' ',$S'NE-GAS',18*' ',$S'NA',22*' ',
               0  $S'MG',22*' ',$S'AL',22*' ',$S'SI',22*' ',$S'AR-GAS',18*' ',
               0  $S'K',23*' ',$S'CA',22*' ',$S'TI',22*' ',$S'V',23*' ',$S'MN',22*' '
               0  /;
               0
               0  DATA MEDTB2/
               0  $S'FE',22*' ',$S'CO',22*' ',$S'NI',22*' ',$S'CU',22*' ',$S'ZN',22*' ',
               0  $S'GE',22*' ',$S'SE',22*' ',$S'KR-GAS',18*' ',$S'RB',22*' ',
               0  $S'MO',22*' ',$S'AG',22*' ',$S'CD',22*' ',$S'IN',22*' ',$S'SN',22*' ',
               0  $S'XE-GAS',18*' ',$S'CS',22*' ',$S'GD',22*' ',$S'TA',22*' ',
               0  $S'W',23*' ',$S'PT',22*' '
               0  /;
               0
               0  DATA MEDTB3/
               0  $S'AU',22*' ',$S'HG',22*' ',$S'PB',22*' ',$S'RN-GAS',18*' ',
               0  $S'U',23*' ',
               0  $S'AIR-GAS',17*' ',$S'CO2-GAS',17*' ',$S'POLYETHYLENE',12*' ',
               0  $S'POLYPROPYLENE',11*' ',$S'XYLENE',18*' ',$S'TOLUENE',17*' ',
               0  $S'NYLON',19*' ',$S'VINYLTOLUENE',12*' ',$S'A150-PLASTIC',12*' ',
               0  $S'STILBENE',16*' ',$S'POLYSTYRENE',13*' ',$S'ANTHRACENE',14*' ',
               0  $S'LEXAN',19*' ',$S'LUCITE',18*' ',$S'H2O',21*' '
               0  /;
               0
               0  DATA MEDTB4/
               0  $S'MYLAR',19*' ',
               0  $S'KAPTON',18*' ',$S'LIF',21*' ',$S'POLYVINYL-CL',12*' ',
               0  $S'PYREX-GLASS',13*' ',$S'SIO2',20*' ',$S'CAF2',20*' ',
               0  $S'PHOTOEMULSION',11*' ',$S'AGCL',20*' ',$S'NAI',21*' ',
               0  $S'LII',21*' ',$S'AGBR',20*' ',$S'CSI',21*' '
               0  /;
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "   STDATA IS THE ACTUAL STERNHEIMER DATA                 "
               0  "   AFACT,SK,X0,X1,IEV,CBAR                              "
               0  "   THE SEQUENCE FIELD OF EACH CARD TELL WHICH MATERIAL ITS FOR."
               0  "DIMENSION STDAT1(6,20),STDAT2(6,20),STDAT3(6,20),STDAT4(6,13);"
               0  "EQUIVALENCE (STDATA(1,1),STDAT1(1,1));"
               0  "EQUIVALENCE (STDATA(1,21),STDAT2(1,1));"
               0  "EQUIVALENCE (STDATA(1,41),STDAT3(1,1));"
               0  "EQUIVALENCE (STDATA(1,61),STDAT4(1,1));"
               0  "moved above so don't mix declaration & data stmts for Linux fort77"
               0
               0  DATA STDAT1/
               0  0.03535,6.790,1.864,3.5,19.2,9.584,
               0  0.09179,5.831,0.476,2.0,21.8,3.263,
               0  0.0114,7.625,2.202,4.0,41.8,11.139,
               0  0.3492,3.233,0.0966,2.0,40.0,3.122,
               0  0.3518,3.034,-0.0089,2.0,63.7,2.785,
               0  0.5848,2.360,-0.0089,2.0,78.0,2.868,
               0  0.7154,2.191,-0.0089,2.0,78.0,3.155,
               0  0.2120,3.041,1.738,4.0,82.0,10.540,
               0  0.2666,2.825,1.754,4.0,95.0,10.700,
               0  0.1202,3.357,2.073,4.5,137.0,11.904,
               0  0.2204,3.103,0.4515,2.8,149.0,5.053,
               0  0.1714,3.223,0.2386,2.8,156.0,4.530,
               0  0.3346,2.795,0.0966,2.5,166.0,4.239,
               0  0.3755,2.720,0.0966,2.5,173.0,4.435,
               0  0.1902,2.982,1.764,4.5,188.0,11.948,
               0  0.3041,2.674,0.2386,3.0,190.0,5.642,
               0  0.2177,2.874,0.1751,3.0,191.0,5.040,
               0  0.1782,2.946,0.0485,3.0,233.0,4.445,
               0  0.1737,2.935,-0.0089,3.0,245.0,4.266,
               0  0.1996,2.812,-0.0089,3.0,272.0,4.270
               0  /;
               0
               0  DATA STDAT2/
               0  0.2101,2.771,-0.0089,3.0,286.0,4.291,
               0  0.2229,2.713,-0.0089,3.0,297.0,4.260,
               0  0.2504,2.619,-0.0089,3.0,311.0,4.312,
               0  0.2557,2.613,-0.0089,3.0,322.0,4.419,
               0  0.3163,2.468,0.0485,3.0,330.0,4.691,
               0  0.2809,2.647,0.2386,3.0,350.0,5.141,
               0  0.2979,2.635,0.2386,3.0,348.0,5.321,
               0  0.1519,3.030,1.716,4.8,352.0,12.512,
               0  0.1450,3.078,0.4515,3.5,363.0,6.478,
               0  0.2228,2.824,0.1751,3.0,424.0,4.879,
               0  0.3091,2.563,-0.0089,3.0,470.0,5.063,
               0  0.1853,2.819,0.0485,3.3,469.0,5.273,
               0  0.2004,2.790,0.1751,3.3,487.0,5.517,
               0  0.1898,2.839,0.2386,3.3,488.0,5.534,
               0  0.1329,3.020,1.563,5.0,482.0,12.728,
               0  0.2214,2.784,0.4515,3.5,488.0,6.914,
               0  0.2068,2.686,0.0485,3.5,591.0,5.874,
               0  0.1663,2.805,0.1751,3.5,718.0,5.526,
               0  0.1499,2.870,0.1751,3.5,727.0,5.406,
               0  0.1465,2.903,0.0966,3.5,790.0,5.473
               0  /;
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  DATA STDAT3/
               0  0.1533,2.881,0.0966,3.5,790.0,5.575,
               0  0.1824,2.798,0.2386,3.5,800.0,5.961,
               0  0.1861,2.814,0.2386,3.5,823.0,6.202,
               0  0.1130,3.023,1.537,5.3,794.0,13.284,
               0  0.1362,3.034,0.2386,3.5,890.0,5.869,
               0  0.2466,2.879,1.742,4.0,85.7,10.595,
               0  0.1999,3.022,1.648,4.0,88.7,10.239,
               0  0.4875,2.544,0.1379,2.0,57.4,3.002,
               0  0.2493,2.975,0.1537,2.3,59.2,3.126,
               0  0.2755,2.911,0.1695,2.3,61.8,3.270,
               0  0.2830,2.890,0.1722,2.3,62.5,3.303,
               0  0.5345,2.439,0.1336,2.0,63.9,3.063,
               0  0.3495,2.749,0.1467,2.2,64.7,3.201,
               0  0.5462,2.435,0.1329,2.0,65.1,3.110,
               0  0.2989,2.851,0.1731,2.3,67.7,3.367,
               0  0.3670,2.724,0.1647,2.2,68.7,3.300,
               0  0.5858,2.364,0.1146,2.0,69.5,3.151,
               0  0.3865,2.664,0.1608,2.2,73.1,3.321,
               0  0.3996,2.606,0.1824,2.2,74.0,3.330,
               0  0.2065,3.007,0.2400,2.5,75.0,3.502
               0  /;
               0
               0  DATA STDAT4/
               0  0.3124,2.782,0.1561,2.3,78.7,3.326,
               0  0.4061,2.614,0.1492,2.2,79.3,3.342,
               0  0.1308,3.476,0.0171,2.5,94.0,3.167,
               0  0.1873,2.962,0.1558,2.8,108.2,4.053,
               0  0.2988,2.805,0.1479,2.5,134.0,3.971,
               0  0.1440,3.220,0.1385,2.8,139.2,4.003,
               0  0.3750,2.592,0.0676,2.5,166.0,4.065,
               0  0.3416,2.496,0.1009,3.0,331.0,5.332,
               0  0.1243,3.002,-0.0138,3.5,398.4,5.344,
               0  0.1560,2.926,0.1203,3.5,452.0,6.057,
               0  0.1785,2.845,0.0892,3.5,485.1,6.267,
               0  0.1351,2.976,0.0358,3.5,487.2,5.616,
               0  0.1796,2.840,0.0395,3.5,553.1,6.281
               0  /;
               0
               0  "*****PHOTO ELECTRIC AND PAIR PRODUCTION EMPIRICAL DATA                "
               0  "     SOURCE OF DATA IS HUBBELL, AND ISRAEL AND STORM.                 "
               0  "DATA FOR COMMON BLOCK PHPAIR"
               0  "     EKEDGE IS THE K IONIZATION ENERGY IN KEV                         "
               0  "     NEPP(Z) IS THE # OF ENERGIES AT WHICH DATA IS GIVEN              "
               0  "     EPP(IE,Z) IS THE IE'TH ENERGY FOR ELEMENT Z                      "
               0  "     PHD(IE,Z) IS THE PHOTO CROSS-SECTION AT K=EPP(IE,Z)              "
               0  "     PRD(IE,Z) IS THE PAIR PROC CROSS-SECTION AT K=EPP(IE,Z)          "
               0  "     THE CROSS-SECTIONS ARE IN UNITS OF BARNS/ATOM.                   "
               0  "     PUT IN DATA STMTS FOR NEPP,EPP,PHD,PRD LATER.                    "
               0  "*****DATA CONTROLLING PIECE-WISE LINEAR FITS                          "
               0  "DATA FOR COMMON BLOCK PWLFIN"
               0  DATA EPE/.01/,ZTHRE,ZEPE/16*0.0/,NIPE/20/,NALE/$MXEKE/,EPG/.01/,
               0  ZTHRG/0.0,.1,0.0,0.0/,ZEPG/0.0,.01,0.0,0.0/,NIPG/20/,NALG/$MXGE/,
               0  EPR/.01/,ZTHRR,ZEPR/2*0.0/,NIPR/20/,NALR/$MXRL/;
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "*****TABLES OF ATOMIC SYMBOLS, WEIGHTS, DENSITIES, AND"
               0  "MEAN EXCITATION ENERGIES FOR Z=1 TO NET(=100)."
               0  "DATA FOR COMMON BLOCK ELEMTB"
               0  DATA NET/100/;
               0  DATA ASYMT/'H','HE','LI','BE','B','C','N','O','F','NE',
               0  'NA','MG','AL','SI','P','S','CL','AR','K','CA','SC','TI',
               0  'V','CR','MN','FE','CO','NI','CU','ZN','GA','GE','AS','SE','BR',
               0  'KR','RB','SR','Y','ZR','NB','MO','TC','RU','RH','PD','AG','CD',
               0  'IN','SN','SB','TE','I','XE','CS','BA','LA','CE','PR','ND',
               0  'PM','SM','EU','GD','TB','DY','HO','ER','TM','YB','LU','HF','TA',
               0  'W','RE','OS','IR','PT','AU','HG','TL','PB','BI','PO','AT','RN',
               0  'FR','RA','AC','TH','PA','U','NP','PU','AM','CM','BK','CF','ES',
               0  'FM'/;
               0
               0  DATA WATBL/1.00797,4.0026,6.939,9.0122,10.811,12.01115,14.0067,
               0  15.9994,18.9984,20.183,22.9898,24.312,26.9815,28.088,30.9738,
               0  32.064,35.453,39.948,39.102,40.08,44.956,47.90,50.942,51.998,
               0  54.9380,55.847,58.9332,58.71,63.54,65.37,69.72,72.59,74.9216,
               0  78.96,79.808,83.80,85.47,87.62,88.905,91.22,92.906,95.94,99.0,
               0  101.07,102.905,106.4,107.87,112.4,114.82,118.69,121.75,127.60,
               0  126.9044,131.30,132.905,137.34,138.91,
               0  140.12,140.907,144.24,147.,150.35,151.98,157.25,158.924,162.50,
               0  164.930,167.26,168.934,173.04,174.97,178.49,180.948,183.85,
               0  186.2,190.2,192.2,195.08,196.987,200.59,204.37,207.19,208.980,
               0  210.,210.,222.,223.,226.,227.,232.036,231.,238.03,237.,242.,
               0  243.,247.,247.,248.,254.,253./;
               0
               0  DATA RHOTBL/0.0808,0.19,0.534,1.85,2.5,2.26,1.14,1.568,1.5,1.0,
               0  0.9712,1.74,2.702,2.4,1.82,2.07,2.2,1.65,0.86,1.55,3.02,4.54,
               0  5.87,7.14,7.3,7.86,8.71,8.90,8.9333,7.140,5.91,5.36,5.73,4.80,
               0  4.2,3.4,1.53,2.6,4.47,6.4,8.57,9.01,11.50,12.20,12.50,12.,10.5,
               0  8.65,7.30,7.31,6.684,6.24,4.93,2.7,1.873,3.5,6.15,6.90,6.769,
               0  7.007, 1.  ,7.54,5.17,7.87,8.25,8.56,8.80,9.06,9.32,6.96,9.85,
               0  11.40,16.60,19.30,20.53,22.48,22.42,21.45,19.30,14.19,11.85,
               0  11.34,9.78,9.30, 1.  ,4., 1.  ,5.,  1. ,11.0,15.37,18.90,
               0  20.5,19.737,11.7,7.,1.   , 1.  , 1.  ,  1. /;
               0
               0  DATA ITBL/19.2,41.8,40.,63.7,76.0,78.0,82.0,95.0,115.,137.,
               0  149.,156.,166.,173.,173.,180.,174.,188.,190.,191.,216.,233.,245.,
               0  257.,272.,286.,297.,311.,322.,330.,334.,350.,347.,348.,357.,352.,
               0  363.,366.,379.,393.,417.,424.,428.,441.,449.,470.,470.,469.,488.,
               0  488.,487.,485.,491.,482.,488.,491.,501.,523.,535.,546.,560.,574.,
               0  580.,591.,614.,628.,650.,658.,674.,684.,694.,705.,718.,727.,736.,
               0  746.,757.,790.,790.,800.,810.,823.,823.,830.,825.,794.,827.,826.,
               0  841.,847.,878.,890.,902.,921.,934.,939.,952.,966.,980.,994./;
               0  DATA ISTATB/1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,
               0  0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
               0  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
               0  0,0,0,0,0,0,0,0,0,0,0,0,0/;
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "**** DATA FOR ALRAD AND ALRADP FOR ELEMENT Z.LE.4       ****"
               0  "     TAKEN FROM TABLE B.2 IN Y.TSAI REV.MOD.PHYS. 46,815(1974)  "
               0
               0  DATA ALRAD/5.31,4.79,4.74,4.71/,ALRADP/6.144,5.621,5.805,5.924/,
               0  A1440/1194.0/,A183/184.15/;
               0
               0  "***** TABLES FOR FUNCTIONS IN PEGS, NAMES AND NUMBER OF ARGUMENTS     "
               0  "DATA FOR COMMON BLOCK FUNCS"
               0  DATA NFUNS/$NFUNS/;
               0  DATA NFARG/$FLIST$NARGS/;
               0  $FLIST$DATA(FNAME);
               0
               0  "DATA FOR COMMON BLOCK MIXDAT"
               0  DATA GASP/0.0/;  "GASP=GAS PRESSURE=0.0 MEANS 'NON-GAS' STATE"
               0
               0  "DATA FOR COMMON BLOCK RAYLEI"
               0  DATA IRAYL/0/; "IRAYL=0 MEANS NOT INCLUDE RAYLEIGH SCATTERING"
               0  "                     1 MEANS INCLUDE RAYLEIGH SCATTERING"
               0
               0  "DATA FOR COMMON BLOCK THRESH"
               0  DATA IUNRST/0/; "IUNRST=0 MEANS RESTRICTED STOPPING POWER"
               0  "         IUNRST=1 MEANS UNRESTRICTED COLLISION STOPPING POWER"
               0  "         IUNRST=2 MEANS CSDA DATA - TOTAL UNRESTRICTED STOPPING POWER"
               0  "                  AND NO DISCRETE INTERACTIONS"
               0  "         IUNRST=3 MEANS ALLOW BREM EVENTS BUT NO MOLLER INTERACTIONS"
               0  "         IUNRST=4 MEANS ALLOW MOLLER EVENTS BUT NO BREM - NOTE THIS"
               0  "                  GIVES COMPLETE GARBAGE IN A RUN SINCE ALL BREM IS "
               0  "                  DUMPED ON SPOT"
               0  "         IUNRST=5 MEANS UNRESTRICTED RADIATIVE STOPPING POWER"
               0
               0  "DATA FOR COMMON BLOCK MIMSD"
               0  DATA BMIN/4.5/,MSTEPS/$MSSTEPS/,JRMAX/$MXJREFF/,
               0  FSTEP/1.,2.,3.,4.,6.,8.,10.,15.,20.,30.,40.,60.,80.,100.,150.,200./;
               0
               0  "DATA FOR EPSTAR"
               0  DATA EPSTFL/0/,IEPST/1/,IAPRIM/1/,IAPRFL/0/;
               0
               0  END; "END OF BLOCK DATA"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE DIFFER;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0  ;
               0
               0  " IK: Variable declarations for implicit none"
               0  $REAL AL183,F10,F20,A1DEN,A2DEN,B1DEN,B2DEN,C1DEN,C2DEN;
               0
               0  COMIN/MOLVAR,BREMPR,DBRPR,DERCON,RADLEN/;
               0  "**********************************************************************"
               0  "***THE DIFFERENTIAL CROSS-SECTIONS OF BREMSSTRAHLUNG AND PAIR       "
               0  "   PRODUCTION ARE Z-DEPENDENT.  BUTCHER AND MESSEL USE A SAMPLING   "
               0  "   TECHNIQUE FOR BREMSSTRAHLUNG WHICH ALSO DEPENDS ON THE LARGEST   "
               0  "   AND SMALLEST ALLOWED ENERGY VALUES.                              "
               0  "   THIS IS NOW TAKEN INTO ACCOUNT BY THE FUNCTION ILOG2(E/AP) WHICH "
               0  "   GIVES THE NUMBER OF SUBDISTRIBUTIONS NEED TO PRODUCE PHOTONS DOWN"
               0  "   TO THE LIMIT AP.                                                 "
               0  "   THE DIFFERENTAL CROSS SECTIONS USED FOR BREMS AND PAIR ARE--     "
               0  "   (THEY ARE CROSS SECTION PER RADIATION LENGTH)                    "
               0
               0  "***BELOW 50MEV (BETHE-HEITLER)--                                      "
               0  "         BREMS--                                                      "
               0  "     PHI1=(LOG(2)*(4/3+1/(9*LOG(A183)*(1+ZP)))* (1/LOG(2)*(1-EPS)/EPS)"
               0  "    1 * A(DELTAPRIME) + (1/2) * (2*EPS) * B(DELTAPRIME)               "
               0  "         PAIR --                                                      "
               0  "     PHI2=(2/3 - 1/(36*LOG(A183)*(1+ZP)))*(1) * C(DELTAPRIME)         "
               0  "    1  + (1/12*(4/3+1/(9*LOG(A183)*(1+ZP))))* (12*(EPS-1/2)**2)       "
               0  "    2 * A(DELTAPRIME)                                                 "
               0  "       WHERE A,B,C ARE SCREENING REJECTION FUNCTIONS GIVEN BY         "
               0  "       A(D)=(3*F1(D)-F2(D)+8*ZG)/(3*F1(0)-F2(0)+8*ZG)                 "
               0  "       B(D)=(F1(D)+4*ZG)/(F1(0)+4*ZG)                                 "
               0  "       C(D)=(3*F1(D)+F2(D)+16*ZG)/(3*F1(0)+F2(0)+16*ZG)               "
               0  "       AND WHERE                                                      "
               0  "       DELTAPRIME= 136.*EXP(ZG)*RM*DEL= DELCM *DEL                    "
               0  "       AND                                                            "
               0  "       DEL =  EPS/(E*(1-EPS))      BREMSSTRAHLUNG                     "
               0  "           =  1/(E*EPS*(1-EPS))    PAIR PRODUCTION                    "
               0  "       F1(D) AND F2(D) ARE SCREENING FUNCTIONS GIVEN APPROXIMATELY BY "
               0  "             IF D.LE.1 ,THEN                                          "
               0  "       F1(D) = 20.867 - 3.242*D + 0.625*D**2                          "
               0  "       F2(D) = 20.209 - 1.930*D - 0.086*D**2                          "
               0  "         BUT IF D.GT.1 ,THEN                                          "
               0  "       F1(D)=F2(D)= 21.12 - 4.184*ALOG(D+0.952)                       "
               0  "         IN ADDITION WE HAVE THAT                                     "
               0  "       F1(0)= 4.*ALOG(A183)                                           "
               0  "       F2(0)= F1(0) - 2./3.                                           "
               0  "***ABOVE 50 MEV (COULOMB CORRECTED BETHE HEITLER)                     "
               0  "         BREMS--                                                      "
               0  "     PHI1=(LOG(2)*(4/3+1/(9*LOG(A183)*(1+ZU)))* (1/LOG(2)*(1-EPS)/EPS)"
               0  "    1 * A(DELTAPRIME) + (1/2) * (2*EPS) * B(DELTAPRIME)               "
               0  "         PAIR --                                                      "
               0  "     PHI2=(2/3-1/(36*LOG(A183)*(1+ZU)))* 1 * C(DELTAPRIME)            "
               0  "    1  + (1/12*(4/3+1/(9*LOG(A183)*(1+ZU))))* (12*(EPS-1/2)**2)       "
               0  "    2  * A(DELTAPRIME)                                                "
               0  "       WHERE A,B,AND C ARE NOW GIVEN BY                               "
               0  "       A(D) = (3*F1(D)-F2(D)+8*ZV)/(3*F1(0)-F2(0)+8*ZV)               "
               0  "       B(D) = (F1(D)+4*ZV)/(F1(0)+4*ZV)                               "
               0  "       C(D) = (3*F1(D)+F2(D)+16*ZV)/(3*F1(0)+F2(0)+16*ZV)             "
               0  "       AND DELTAPRIME,DEL,F1, AND F2 ARE THE SAME AS BELOW 50 MEV.    "
               0  "   BREMSSTRAHLUNG ALPHA(I), I=1,...,N.  ALPHA(N+1)=0.5                "
               0  AL2 = ALOG(2.);
               0  AL183= ALOG(A183);
               0  ALPHI(1)= AL2*(4./3. + 1./(9.*AL183*(1.+ZP)));
               0  ALPHI(2)= AL2*(4./3. + 1./(9.*AL183*(1.+ZU)));
               0  "*****PAIR PRODUCTION DIFFERENTIAL CROSS-SECTION NUMBERS               "
               0  ALFP1(1)= 2./3. - 1./(36.*AL183*(1.+ZP));
               0  ALFP1(2)= 2./3. - 1./(36.*AL183*(1.+ZU));
               0  ALFP2(1)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZP)));
               0  ALFP2(2)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZU)));
               0  "*****BRANCHING RATIO FOR PAIR PRODUCTION SAMPLING                     "
               0  BPAR(1)= ALFP1(1)/(ALFP1(1)+ALFP2(1));
               0  BPAR(2)= ALFP1(2)/(ALFP1(2)+ALFP2(2));
               0
               0  "*****WE MUST ALWAYS HAVE A,B,C(DELTA) POSITIVE. SHOWER ASSURES THIS BY"
               0  "     REQUIRING DEL.LT.DELPOS(),AND HENCE THAT DELTA.LT.DELCM *DELPOS()"
               0  "     THE CROSS-OVER POINT IS IN THE DELTA.GT.1 REGION,AND THE CROSSING"
               0  "     CONDITION REDUCES TO --                                          "
               0  "       F1(D) + 4*ZG = 0     IF  E.LT.50 MEV                           "
               0  "       F1(D) + 4*ZV = 0     IF  E.GT.50 MEV                           "
               0  "     OR --                                                            "
               0  "       21.12 - 4.184*ALOG(DELCM *DELPOS(1)+0.952) +4.*ZG =0     E.LT.5"
               0  "       21.12 - 4.184*ALOG(DELCM *DELPOS(2)+0.952) +4.*ZV =0     E.GT.5"
               0  "       THUS DELPOS IN THE TWO ENERGY REGIONS IS GIVEN BY              "
               0  DELCM= 136.0*EXP(ZG)*RM;
               0  DELPOS(1)= (EXP((21.12+4.*ZG)/4.184)-0.952)/DELCM;
               0  DELPOS(2)= (EXP((21.12+4.*ZV)/4.184)-0.952)/DELCM;
               0  "     CALCULATION OF THE BETHE-HEITLER(B-H) A,B,C(DELTA).AND THE       "
               0  "     COULUMB CORRECTED(CC) A,B,C(DELTA).  THE SHOWER PROGRAM COMPUTES "
               0  "     THESE SIX SCREENING REJECTION FUNCTION WITH THE EXPRESSIONS--    "
               0  "       DL1(LVL)+DELTA*(DL2(LVL)+DELTA*DL3(LVL))   IF DELTA.LT.1 ,AND B"
               0  "       DL4(LVL)+DL5(LV)*ALOG(DELTA+DL6(LVL))      IF DELTA.GE.1       "
               0  "       WHERE LVL IS USED TO SELECT THE FUNCTION--                     "
               0  "       LVL=1   B-H A(DELTA)                                           "
               0  "          =2   B-H B(DELTA)                                           "
               0  "          =3   B-H C(DELTA)                                           "
               0  "          =4   CC  A(DELTA)                                           "
               0  "          =5   CC  B(DELTA)                                           "
               0  "          =6   CC  C(DELTA)                                           "
               0  "     FIRST COMPUTE THE DENOMINATORS                                   "
               0  F10=4.*AL183;
               0  F20=F10 - 2./3.;
               0  A1DEN =3.0*F10- F20 + 8.0*ZG;
               0  A2DEN =3.0*F10- F20 + 8.0*ZV;
               0  B1DEN = F10 + 4.0*ZG;
               0  B2DEN = F10 + 4.0*ZV;
               0  C1DEN = 3.0*F10+ F20 + 16.0*ZG;
               0  C2DEN = 3.0*F10+ F20 + 16.0*ZV;
               0  "     LVL=1, B-H A(DELTA)                                              "
               0  DL1(1)= (3.0*20.867-20.209+8.0*ZG)/A1DEN;
               0  DL2(1)= (3.0*(-3.242)-(-1.930))/A1DEN;
               0  DL3(1)= (3.0*(0.625)-(0.086))/A1DEN;
               0  DL4(1)= (2.0*21.12+8.0*ZG)/A1DEN;
               0  DL5(1)=  2.0*(-4.184)/A1DEN;
               0  DL6(1)=  0.952;
               0  "     LVL=4, CC  A(DELTA)                                              "
               0  DL1(4)= (3.0*20.867-20.209+8.0*ZV)/A2DEN;
               0  DL2(4)= (3.0*(-3.242)-(-1.930))/A2DEN;
               0  DL3(4)= (3.0*(0.625)-(0.086))/A2DEN;
               0  DL4(4)= (2.0*21.12+8.0*ZV)/A2DEN;
               0  DL5(4)=  2.0*(-4.184)/A2DEN;
               0  DL6(4)=  0.952;
               0  "     LVL=2, B-H B(DELTA)                                              "
               0  DL1(2)= (20.867+4.0*ZG)/B1DEN;
               0  DL2(2)= -3.242/B1DEN;
               0  DL3(2)=  0.625/B1DEN;
               0  DL4(2)= (21.12+4.0*ZG)/B1DEN;
               0  DL5(2)= -4.184/B1DEN;
               0  DL6(2)= 0.952;
               0  "     LVL=5, CC B(DELTA)                                               "
               0  DL1(5)= (20.867+4.0*ZV)/B2DEN;
               0  DL2(5)= -3.242/B2DEN;
               0  DL3(5)= 0.625/B2DEN;
               0  DL4(5)= (21.12+4.0*ZV)/B2DEN;
               0  DL5(5)= -4.184/B2DEN;
               0  DL6(5)= 0.952;
               0  "     LVL=3, B-H C(DELTA)                                              "
               0  DL1(3)= (3.0*20.867+20.209+16.0*ZG)/C1DEN;
               0  DL2(3)= (3.0*(-3.242)+(-1.930))/C1DEN;
               0  DL3(3)= (3.0*0.625+(-0.086))/C1DEN;
               0  DL4(3)= (4.0*21.12+16.0*ZG)/C1DEN;
               0  DL5(3)=  4.0*(-4.184)/C1DEN;
               0  DL6(3)=  0.952;
               0  "     LVL=6, CC  C(DELTA)                                              "
               0  DL1(6)= (3.0*20.867+20.209+16.0*ZV)/C2DEN;
               0  DL2(6)= (3.0*(-3.242)+(-1.930))/C2DEN;
               0  DL3(6)= (3.0*0.625+(-0.086))/C2DEN;
               0  DL4(6)= (4.0*21.12+16.0*ZV)/C2DEN;
               0  DL5(6)=  4.0*(-4.184)/C2DEN;
               0  DL6(6)=  0.952;
               0  "*****PUNCHED AND PRINTED OUTPUT                                       "
               0  OUTPUT ; (/,' IN SUBROUTINE DIFFER:'//
               0  ' DIFFERENTIAL CROSS-SECTION DATA,COMMON BREMPR'/
               0  ' DL1(6),DL2(6),DL3(6),DL4(6),DL5(6),DL6(6),ALPHI(2),BPAR(2),',
               0  'DELCM,DELPOS(2)');
               0  OUTPUT DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELCM,DELPOS;
               0  (1X,6E14.5);
               0  RETURN;
               0  END; "END OF SUBROUTINE DIFFER"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE EFUNS(E,V);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0  ;
               0
               0  $REAL E,V(8);
               0
               0  " IK: Variable declarations for implicit none"
               0  $REAL BREM,AMOLL,BHAB,ANNIH,ESIG,PSIG;
               0
               0  " IK: Function declarations for implicit none"
               0  $REAL BREMTM,AMOLTM,BHABTM,ANIHTM,SPTOTE,SPTOTP,TMXS;
               0
               0  "*****SUBROUTINE TO COMPUTE ELECTRON FUNCTIONS TO BE FIT           "
               0  "     IN A WAY THAT AVOIDS REPETITION.                             "
               0  COMIN/THRESH/;
               0  IF(IUNRST.EQ.0 .OR. IUNRST.EQ.1 .OR. IUNRST.EQ.5)[
               1      "  REGULAR DATA SET OR"
               1      "   UNRESTRICTED COLLISIONAL(1) OR RADIATIVE(5) STOPPING POWERS"
               1      BREM=BREMTM(E);
               1      AMOLL=AMOLTM(E);
               1      BHAB=BHABTM(E);
               1      ANNIH=ANIHTM(E);
               1      ESIG=BREM+AMOLL; "TOTAL ELECTRON CROSS-SECTION"
               1      V(1)=ESIG;
               1      PSIG=BREM+BHAB+ANNIH;"TOTAL POSITRON CROSS SECTION"
               1      V(2)=PSIG;
               1      V(3)=SPTOTE(E,AE,AP); "TOTAL ELECTRON STOPPING POWER"
               1      V(4)=SPTOTP(E,AE,AP);"TOTAL POSITRON STOPPING POWER"
               1      "EBR1=BREM/(BREM+AMOLL)"
               1      IF (ESIG.GT.0.0)[V(5)=BREM/ESIG;]
               1      ELSE["BELOW THRESHOLD FOR BOTH BREMS AND MOLLER. USE THE BRANCHING"
               2          "RATIO THAT EXISTED WHEN CROSS SECTION APPROACHED ZERO"
               2          IF (THBREM.LE.THMOLL)[V(5)=1.0;]ELSE[V(5)=0.0;]
               2          ]
               1      V(6)=BREM/PSIG;"PBR1=BREM/(BREM+BHABA+ANNIH)"
               1      V(7)=(BREM+BHAB)/PSIG;"PBR2=(BREM+BHABA)/(PSIG)"
               1      "MAXIMUM ALLOWED TRANSPORT STEP, FROM MULTIPLE SCATTERING"
               1      V(8)=TMXS(E);
               1      ]
               0  "  THE FOLLOWING ARE UNDOCUMENTED ADDITIONS"
               0  ELSEIF(IUNRST.EQ.2)[ "FULL CSDA DATA SET WITH NO DISCRETE INTERACTIONS"
               1      /V(1),V(2),V(5),V(6),V(7)/=0.0;
               1      "ZERO TOTAL CROSS SECTION FOR EL & POS, AND ZERO BRANCHING RATIOS"
               1      V(3) = SPTOTE(E,E,E);"  TOTAL UNRESTRICTED STOPPING POWER"
               1      V(4) = SPTOTP(E,E,E);
               1      V(8) = TMXS(E);]
               0
               0
               0  ELSEIF(IUNRST.EQ.3)["CONSIDER BREM AND ANNIHILATION IN FLIGHT AS"
               1      "     DISCRETE EVENTS BUT TREAT DELTAS IN CSDA"
               1      BREM=BREMTM(E);  ANNIH=ANIHTM(E);
               1      V(1)=BREM; "TOTAL X-SECTION IS JUST BREM"
               1      V(2)=BREM + ANNIH;"POSITRONS ALSO HAVE ANNIHILATION IN FLIGHT"
               1      V(3)=SPTOTE(E,E,AP);"UNRESTRICTED COLLISIONAL+RESTRICTED RADIATIVE"
               1      V(4)=SPTOTP(E,E,AP);"    ''                             ''    "
               1      V(5)=1.0;"ALL ELECTRON EVENTS ARE BREM EVENTS"
               1      V(6)=BREM/V(2);"FRACTION FOR POSITRONS WHICH IS BREM"
               1      V(7)=V(6);"FRACTION WHICH IS BREM + COLLISION(=0)"
               1      V(8)=TMXS(E);]
               0
               0  ELSEIF(IUNRST.EQ.4)["CREATE SECONDARIES BUT HAVE NO DISCRETE BREM OR"
               1      "ANNIHILATION IN FLIGHT"
               1
               1      V(1)=AMOLTM(E);"ONLY MOLLERS FOR ELECTRONS"
               1      V(2)=BHABTM(E);"ONLY BHABHA FOR POSITRONS"
               1      V(3)=SPTOTE(E,AE,E);"RESTRICTED COLLISIONAL + UNRESTRICTED RADIATIVE"
               1      V(4)=SPTOTP(E,AE,E);"         ''                         ''       "
               1      V(5)=0.0;"I.E. NEVER BREMS"
               1      V(6)=0.0;"I.E. NEVER BREMS"
               1      V(7)=1.0;"ALL BHABHA - NO ANNIHILATION"
               1      V(8)=TMXS(E);]
               0
               0  ELSE ["IUNRST=6 OR 7 NOT ALLOWED HERE"
               1      OUTPUT IUNRST; (//'*********IUNRST=',I4,' NOT ALLOWED BY EFUNS*****'/
               1      ' IUNRST=6 OR 7 ONLY ALLOWED WITH CALL OR PLTN OPTIONS'//);
               1      $CALL_EXIT(20);]
               0  RETURN;
               0  END; "END OF SUBROUTINE EFUNS"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE GFUNS(E,V);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  "*****SUBROUTINE TO COMPUTE PHOTON FUNCTIONS TO BE FIT             "
               0  "     IN A WAY THAT AVOIDS REPETITION.                             "
               0  implicit none;
               0  $REAL E,V(4);
               0  " IK: Variable declarations for implicit none"
               0  $REAL PAIR,COMP,PHOT,COHR,TSANSC,GMFP;
               0  " IK: Function declarations for implicit none"
               0  $REAL PAIRTU,COMPTM,PHOTTE,COHETM;
               0  ;
               0  PAIR=PAIRTU(E);
               0  COMP=COMPTM(E);
               0  PHOT=PHOTTE(E);
               0  COHR=COHETM(E);
               0  TSANSC=PAIR+COMP+PHOT;
               0  GMFP=1.0/TSANSC;
               0
               0  "V(1)=GMFP (GAMMA MEAN FREE PATH)                                  "
               0  V(1)=GMFP;
               0  "V(2)=GBR1 (GAMMA BRANCHING RATIO NUMBER 1)                        "
               0  V(2)=PAIR*GMFP;
               0  "V(3)=GBR2 (GAMMA BRANCHING RATIO NUMBER 2)                        "
               0  V(3)=(PAIR+COMP)*GMFP;
               0  "V(4)=CRATIO (COHERENT RATIO)                                      "
               0  V(4)=TSANSC/(TSANSC+COHR);
               0  RETURN;
               0  END; "END OF SUBROUTINE GFUNS"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE HPLT1(EI,EL,EH,ICAP,NTIMES,NBINS,NH,IDF,IDSIG,
               0  IRSIG,ITSIG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  " IDF,IDF+1,IDF+2,IDSIG,IRSIG AND ITSIG ARE FMPX POINTERS TO THE   "
               0  " APPROX CDF,CDF INVERSE, PDF, D(SIGMA)/D(ES), INTEGRAL            "
               0  " D(SIGMA)/D(ES) AND TOTAL SIGMA FOR THE INTERACTION BEING TESTED. "
               0  ;
               0  implicit none;
               0  $REAL EI,EL,EH;
               0  $INTEGER NTIMES,NBINS,NH(200),IDF,IDSIG,IRSIG,ITSIG;
               0  $TYPE ICAP(12);
               0
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER IBIN,I,J,IC;
               0  $REAL    Y,AMAX,RTOT,TTOT,DFH,DELDF,DFL,DNORM,ELI,EHI,EINT,V;
               0
               0  " IK: Function declarations for implicit none"
               0  $REAL FI;
               0
               0  COMIN/FUNCS/;
               0  " ROUTINE TO PRINT PLOT COMPARISONS OF EGS SAMPLING ROUTINE H      "
               0  " HISTOGRAMS WHITH THEORETICAL HISTOGRAMS AND FUNCTION VALUES FROM "
               0  " PEGS.  MAYBE EXTEND TO GRAPHIC DEVICES LATER.                    "
               0  $TYPE L(100),CM,CR,CD,CBL;
               0  $INTEGER IPNTS;
               0  DATA L/100*' '/,CM/'M'/,CR/'R'/,CD/'D'/,CBL/' '/,IPNTS/10/
               0  ;
               0  " CONSTRUCT PROPERLY NORMALIZED DATA VALUES.  NOTE THAT WHAT IS    "
               0  " REALLY BEING PLOTTED IS D(SIGMA)/D(DF(ES)) ,E.G. FOR BREMS IT    "
               0  " WOULD BE K*D(SIGMA)/D(K), WHERE K IS THE PHOTON ENERGY.  FOR THE "
               0  " HISTOGRAMS IT IS AVERAGE(D(SIGMA)/D(DF(E(S)))) THAT IS PLOTTED.  "
               0  " What is IBIN and what is Y ???"
               0  " Where do they come from ??? "
               0  IBIN(Y)=MAX0(1,MIN0(100,IFIX(Y/AMAX*100.)+1));
               0  RTOT=FI(IRSIG,EI,EL,EH,0.);
               0  TTOT=FI(ITSIG,EI,0.,0.,0.);
               0  DFH=FI(IDF,EH,0.,0.,0.);
               0  DFL=FI(IDF,EL,0.,0.,0.);
               0  DELDF=(DFH-DFL)/NBINS;
               0  DNORM=RTOT/(DELDF*NTIMES);
               0  " FIND MAXIMUM                                                     "
               0  AMAX=0.0;
               0  ELI=EL;
               0  DO I=1,NBINS[
               1      EHI=FI(IDF+1,DFL+DELDF*I,0.,0.,0.);
               1      AMAX=AMAX1(AMAX,NH(I)*DNORM,FI(IRSIG,EI,ELI,EHI,0.)/DELDF);
               1      " FIND MAXIMUM OVER INTERNAL POINTS                                "
               1      DO J=1,IPNTS[
               2          EINT=FI(IDF+1,DFL+DELDF*(I-1+FLOAT(J-1)/(IPNTS-1)),0.,0.,0.);
               2          AMAX=AMAX1(AMAX,FI(IDSIG,EI,EINT,0.,0.)/FI(IDF+2,EINT,0.,0.,0.));]
               1      ELI=EHI;]
               0  " WRITE OUT FUNCTIONS USED                                         "
               0  OUTPUT ICAP,(FNAME(I,IDSIG),I=1,6),(FNAME(I,IRSIG),I=1,6),
               0  (FNAME(I,ITSIG),I=1,6),((FNAME(I,IDF+J-1),I=1,6),J=1,3),RTOT,TTOT
               0  ;
               0  ('1HPLT FUNCTIONS:MONTE,DSIG,RSIG,TSIG,CDF,CDFINVERSE,PDF=',
               0  12A1,6(',',6A1)/' RTOT,TTOT=',1P,2E15.5);
               0  " WRITE OUT RAW DATA FOR USER TO SEE STATISTICS                    "
               0  OUTPUT ICAP,EI,EL,EH,NBINS,NTIMES,(NH(I),I=1,NBINS);
               0  (' HPLT:RAW EGS DATA FOR ROUTINE ',12A1,',EI,ELO,EHI=',
               0  3F12.3,',NBINS,NTIMES=',2I10,',DATA='/(1X,10I10));
               0  OUTPUT;(' KEY TO PLOT,M=MONTECARLO DATA,R=THEORETICAL INTEGRALS',
               0  ' OVER BINS,D=DIFFERENTIAL CROSS-SECTION'/
               0  '    ENERGY          VALUE');
               0  " NOW PLOT THEM                                                    "
               0  ELI=EL;
               0  DO I=1,NBINS[
               1      EHI=FI(IDF+1,DFL+DELDF*I,0.,0.,0.);
               1      V=NH(I)*DNORM;
               1      IC=IBIN(V);
               1      L(IC)=CM;
               1      OUTPUT ELI,V,L;
               1      (1X,1P,2E15.5,' I',100A1);
               1      L(IC)=CBL;
               1      V=FI(IRSIG,EI,ELI,EHI,0.)/DELDF;
               1      IC=IBIN(V);
               1      L(IC)=CR;
               1      OUTPUT ELI,V,L;(1X,1P,2E15.5,' I',100A1);
               1      L(IC)=CBL;
               1      DO J=1,IPNTS[
               2          EINT=FI(IDF+1,DFL+DELDF*(I-1+FLOAT(J-1)/(IPNTS-1)),0.,0.,0.);
               2          V=FI(IDSIG,EI,EINT,0.,0.)/FI(IDF+2,EINT,0.,0.,0.);
               2          IC=IBIN(V);
               2          L(IC)=CD;
               2          OUTPUT EINT,V,L;(1X,1P,2E15.5,' I',100A1);
               2          L(IC)=CBL;]
               1      ELI=EHI;]
               0  RETURN;
               0  END; "END OF SUBROUTINE HPLT1"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE LAY;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  "PRODUCES DECK OF MATERIAL DEPENDENT DATA.                         "
               0  implicit none;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER IP,IUECHO,IE,NSGE,NSEKE,NLEKE,NCMFP,NRANGE,NGE,NEKE,I,IFUN;
               0  $INTEGER lnblnk1;
               0
               0  COMIN/BREMPR,MIXDAT,RAYLEI,RSLTS,THRESH,MOLVAR,EPSTAR,FileNames/;
               0  "          NRC MOD DEC 2,1988                  ======"
               0
               0  character fn*512,line*80;
               0  logical   is_there;
               0  ;
               0  :INT:FORMAT(1X,14I5);
               0  :FLT:FORMAT(1X,1P,5E14.5);
               0  IP=7;IUECHO=6;
               0  "   PUT OUT HEADING, AND COMPOSITION CARDS"
               0  $ECHOWRITE(IP,:FMT1:) MEDIUM,IDSTRN;
               0  :FMT1: FORMAT(' MEDIUM=',24A1,',STERNCID=',24A1);
               0  IF(GASP.NE.0.0) [$ECHOWRITE(IP,:FMT2:) MTYP,RHO,NE,GASP,
               1      IUNRST,EPSTFL,IAPRIM; "  NRC MODS DEC 2 1988"
               1      :FMT2: FORMAT(1X,4A1,',RHO=',1P,E11.4,',NE=',I2,',GASP=',
               1      1P,E11.4,', IUNRST=',I1,', EPSTFL=',I1,', IAPRIM=',I1);] "GASES"
               0  "   NRC MOD  ========================================="
               0  ELSE [$ECHOWRITE(IP,:FMT3:) MTYP,RHO,NE,IUNRST,EPSTFL,IAPRIM;
               1      "   NRC MODS                            ===================="
               1      :FMT3: FORMAT(1X,4A1,',RHO=',1P,E11.4,',NE=',I2,', IUNRST=',I1,
               1      ', EPSTFL=',I1,', IAPRIM=',I1);] "NRC MODS DEC 1988"
               0  DO IE=1,NE [
               1      $ECHOWRITE(IP,:FMT5:) ASYM(IE),Z(IE),WA(IE),PZ(IE),RHOZ(IE);
               1      :FMT5: FORMAT(' ASYM=',A2,',Z=',F3.0,',A=',F9.3,
               1      ',PZ=',1P,E12.5,',RHOZ=',E12.5); ]
               0  "NOW COMES THE DATA PROPER"
               0  $ECHOWRITE(IP,:FLT:) RLC,AE,AP,UE,UP;
               0  "FAKE SOME PARAMETERS FOR NOW"
               0  /NSGE,NSEKE,NLEKE,NCMFP,NRANGE/=0;
               0  NGE=NGL; NEKE=NEL; "CHANGE NAMES OF SOME VARIABLES"
               0  $ECHOWRITE(IP,:INT:)NSGE,NGE,NSEKE,NEKE,NLEKE,NCMFP,NRANGE,IRAYL,IUNRST;
               0  $ECHOWRITE(IP,:FLT:)(DL1(I),DL2(I),DL3(I),DL4(I),DL5(I),DL6(I),I=1,6);
               0  $ECHOWRITE(IP,:FLT:) DELCM,(ALPHI(I),BPAR(I),DELPOS(I),I=1,2);
               0  $ECHOWRITE(IP,:FLT:) XR0,TEFF0,BLCC,XCC;
               0  $ECHOWRITE(IP,:FLT:) BXE,AXE;
               0  $ECHOWRITE(IP,:FLT:) ((BFE(I,IFUN),AFE(I,IFUN),IFUN=1,8),I=1,NEKE);
               0  $ECHOWRITE(IP,:FLT:) EBINDA,BXG,AXG;
               0  $ECHOWRITE(IP,:FLT:) ((BFG(I,IFUN),AFG(I,IFUN),IFUN=1,3),I=1,NGE);
               0  IF (IRAYL.NE.0) [
               1      $ECHOWRITE(IP,:INT:) NGR;
               1      $ECHOWRITE(IP,:FLT:) BXR,AXR;
               1      $ECHOWRITE(IP,:FLT:) (BFR(I),AFR(I),I=1,NGR);
               1      $ECHOWRITE(IP,:FLT:) (BFG(I,4),AFG(I,4),I=1,NGE);
               1      ]
               0
               0  "Now record this medium in the pegs4 log file so that later"
               0  "we can check and see how the media data was done."
               0  fn = $EGS_HOME//'pegs4'//$file_sep//'data'//$file_sep//'pegs4.log';
               0  inquire(file=fn,exist=is_there);
               0  IF( is_there ) [ "File present, open and go to end"
               1      open(33,file=fn,status='old',access='append',err=:log_open_error:);
               1      "LOOP [ read(33,*,err=:end-of-data-log:,end=:end-of-data-log:); ]"
               1      ":end-of-data-log:;"
               1      ] ELSE [
               1      open(33,file=fn,status='new',err=:log_open_error:);
               1      ]
               0  DO i=1,len(line) [ line(i:i) = '-'; ]
               0  write(33,'(a)') line;
               0  write(33,'(a,24a1)') 'medium = ',medium;
               0  write(33,'(a,$)') 'data generated on: ';
               0  call egs_fdate(33); write(33,*);
               0  write(33,'(a,4a1,a,1pe11.4,a,i2,a,i1,a,i1,a,i1)') 'type=',mtyp,
               0  ' rho=',rho,' ne=',ne,' iunrst=',iunrst,' epstfl=',
               0  epstfl,' iaprim=',iaprim;
               0  IF( irayl ~= 0 ) [ write(33,'(a)') 'Rayleigh data included'; ]
               0  ELSE [ write(33,'(a)') 'Rayleigh data not included'; ]
               0  IF( using_sym_links ) [
               1      write(33,'(a)')
               1      'pegs4 run using symbolik links => no info about file names available';
               1      return;
               1      ]
               0  IF( epstfl = 1 ) [
               1      write(33,'(a,a)') 'density correction file: ',
               1      density_file(:lnblnk1(density_file));
               1      ]
               0  write(33,'(a,a)') 'cross section data from: ',
               0  xsection_file(:lnblnk1(xsection_file));
               0  write(33,'(a,a)') 'form factor data from: ',
               0  formf_file(:lnblnk1(formf_file));
               0  write(33,'(a,1pe14.5,a,1pe14.5,a,1pe14.5,a,1pe14.5)')
               0  'ae=',ae,' ap=',ap,' ue=',ue,' up=',up;
               0  write(33,'(a,a)') 'data written to: ',
               0  output_file(:lnblnk1(output_file));
               0  close(33);
               0
               0  "THAT'S ALL FOR NOW"
               0  RETURN;
               0
               0  :log_open_error:
               0  write(6,*) 'Failed to open pegs4 material log file';
               0  return;
               0  END; "END OF SUBROUTINE LAY"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE MIX;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0
               0  implicit none;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER I,IZZ;
               0  $REAL    AL183,ZAB,V2000;
               0
               0  " IK: Function declarations for implicit none"
               0  $REAL FCOULC,XSIF;
               0
               0  COMIN/MIMSD,MIXDAT,MOLVAR,PMCONS,DERCON,RADLEN/;
               0  $REAL XSI(20),ZZX(20),FZC(20),FCOUL(20),ZZ(20);
               0  " MOLVAR - - MOLECULAR VARIABLES NEEDED BY DIFFER, AND MOLIER      "
               0
               0  " THE FOLLOWING ASSUMES THAT THE MATERIAL BEING DEALT WITH         "
               0  " IS EITHER A COMPOUND, OR A HOMOGENEOUS MIXTURE.                  "
               0  "          MOLECULAR VARIABLES                                     "
               0  " NE       NUMBER OF DIFFERENT TYPES OF ATOMS IN THE MATERIAL.     "
               0  " PZ(I)    PROPORTION OF ELEMENT OF TYPE I.  IF A COUMPOUND,       "
               0  " THEN PZ(I) WILL BE THE NUMBER OF ATOMS OF TYPE I IN THE MOLECULE."
               0  " IF A MIXTURE,SUCH AS CONCRETE, PZ(I) COULD BE THE PER CENT OF    "
               0  " THE ATOMS WHICH ARE OF TYPE I.                                   "
               0  " Z(I)     PERIODIC NUMBER OF ATOMS OF TYPE I                      "
               0  " WA(I)    ATOMIC WEIGHT FOR ATOMS OF TYPE I.                      "
               0  " WM = SUM(PZ(I)*WA(I)) = MOLECULAR  WEIGHT IF A COUMPOUND         "
               0  " OR A 'MIXTURE WEIGHT' IF A MIXTURE.                              "
               0  " RHO      DENSITY OF THE MATERIAL. (IN GRAMS/CM**3)               "
               0  " RHOZ(I)  PARTIAL DENSITY DUE TO ATOMS OF TYPE I. (GM/CM**3)      "
               0  "          ELECTRON DENSITY VARIABLE                               "
               0  " ZC = SUM(PZ(I)*Z(I)) = NUMBER OF ELECTRONS/MOLECULE              "
               0  "          BREMSSTRAHLUNG AND PAIR PRODUCTION VARIABLES ARE WEIGHTE"
               0  " BY PZ(I)*Z(I)**2 FOR THE NUCLEUS, AND BY PZ(I)*Z(I)*XSI(I) FOR   "
               0  " ATOMIC ELECTRONS.                                                "
               0  " TPZ = SUM(PZ(I))                                                 "
               0  " XSI(I) = LOG(A1440/Z(I)**(2./3.))/(LOG(A183/Z(I)**(1./3.))  -    "
               0  "               FCOUL(Z(I)) )                                      "
               0  " ZZX(I) =  PZ(I)*Z(I)*(Z(I)+XSI(I)) = BREMS AND PAAR WEIGHTS      "
               0  " EZ = ZC/TPZ  EFFECTIVE Z                                         "
               0  " ZT = SUM(ZZX(I))                                                 "
               0  " ZA = LOG(A183)*ZT   BUTCHER AND MESSELS L.C.'A' (1960)P.18       "
               0  " ZB = SUM(ZZX(I)*LOG(Z(I)**(-1./3.)  B&M'S L.C.'B' IBID.          "
               0  " ZF = SUM(ZZX(I)*FCOUL(Z(I))),WHERE FCOUL IS THE COULOMB          "
               0  " CORRECTION FUNCTION.                                             "
               0  " RATIOS--                                                         "
               0  " ZG = ZB/ZT ,EXP(ZG)=WEIGHTED GEOMETRIC MEAN OF Z**(-1/3)         "
               0  " ZP = ZB/ZA , B&M IBID.P18 L.C.'P'                                "
               0  " ZV= (ZB-ZF)/ZT                                                   "
               0  " ZU = (ZB-ZF)/ZA                                                  "
               0  "          MULTIPLE SCATTERING VARIABLES                           "
               0  " ACCORDING TO MESSEL AND CRAWFORD(1970), MOST OF THE MULTIPLE     "
               0  " SCATTERING DUE TO THE FIELD OF THE ATOMIC ELECTRONS IS ALREADY   "
               0  " ACCOUNTED FOR BY THE DISCRETE MOLLER SCATTERING. HENCE,THE       "
               0  " FOLLOWING VARIABLES ARE ONLY WEIGHTED BY PZ(I)*Z(I)**2           "
               0  " HOWEVER I HAVE NOT JUSTIFIED THE ABOVE ASSERTION THEORETICALLY   "
               0  " THEORETICALLY, AND COMPARISON OF EXPERIMENTS WITH EGS HAVE       "
               0  " SHOWN EGS PHOTON SPECTRUM DEFICIENT IN THE BACKWARD DIRECTION.   "
               0  " THEREFORE, I WILL EXPERIMENT WITH RESTORING THE ELECTRON SCATTER-"
               0  " ING TERM.  ITS CONTRIBUTION WILL BE REPRESENTED BY THE MACRO VAR-"
               0  " IABLE, $FUDGEMS, WHICH WILL HAVE THE VALUE 0.0 FOR NO ELECTRON   "
               0  " SCATTERING AND 1.0 FOR FULL ELECTRON SCATTERING.  AND WE NOW HAVE"
               0  " WEIGHTING BY PZ(I)*Z(I)*(Z(I)+$FUDGEMS).                         "
               0  " ZZ(I) = PZ(I)*Z(I)*(Z(I)+$FUDGEMS) "
               0  " ZS = SUM(ZZ(I))                                                  "
               0  " ZE = SUM(ZZ(I)*LOG(Z(I)**(-2./3.)))                              "
               0  " ZX = SUM(ZZ(I)*LOG(1.+3.34*(FSC*Z(I))**2))                       "
               0  "               ELECTON DENSITY(ELECTRONS/CM**3)                   "
               0  " EDEN=AN*RHO/WM*ZC                                                "
               0  "          RADIATION LENGTH                                        "
               0  " USEFUL FOR GAUGING THE STEP SIZE, EVEN IF IT IS NOT USED AS THE  "
               0  " UNIT OF DISTANCE.                                                "
               0  "  1./RLC =(AN*RHO/WM)*4.0*FSC*R0**2*                              "
               0  "    SUM( Z(I)*(Z(I)+XSI(I))*(LOG(A183*Z(I)**(-1./3.)-FCOUL(Z(I))) "
               0  "        =(AN*RHO/WM)*4.*FSC*R0**2*(ZAB-ZF)                        "
               0  " INPUT MOLECULAR VARIABLES AND COMPUTE Z-RELATED PARAMETERS       "
               0
               0  OUTPUT ; (/' IN SUBROUTINE MIX: '/);
               0  IF (GASP.EQ.0.0) [OUTPUT NE,RHO;
               1      (' NUMBER OF ELEMENTS = ',I3,',  DENSITY=',1P,G15.6,' (G/CM**3)');]
               0  ELSE [OUTPUT NE,RHO,GASP;
               1      (' NUMBER OF ELEMENTS = ',I3,',  DENSITY=',1P,G15.6,' (G/CM**3) AT NTP',
               1      '  GAS PRESSURE=',1P,G15.6,' ATM.');]
               0  OUTPUT (I,Z(I),WA(I),PZ(I),RHOZ(I),I=1,NE);
               0  ('0  I       Z(I)           WA(I)          PZ(I)         RHOZ(I) '/
               0  ' INDEX   PERIODIC        ATOMIC       PROPORTION     PROPORTION '/
               0  '          NUMBER         WEIGHT        BY NUMBER      BY WEIGHT '//
               0  (I5,1P,4G15.6));
               0  "SCALE RHO FOR GASES BY THE GAS PRESSURE"
               0  IF (GASP.NE.0.0) [RHO=GASP*RHO;]
               0  "     FIND VARIOUS SUMS AND SET OTHER VARIABLES                        "
               0  AL183 = ALOG(A183);
               0  /TPZ,WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZAB/=0.0;
               0  DO I=1,NE[
               1      TPZ = TPZ + PZ(I);
               1      WM = WM + PZ(I)*WA(I);
               1      ZC = ZC + PZ(I)*Z(I);
               1      FZC(I) =(FSC*Z(I))**2;
               1      FCOUL(I) = FCOULC(Z(I));
               1      XSI(I) = XSIF (Z(I));
               1      ZZX(I) = PZ(I)*Z(I)*(Z(I)+XSI(I));
               1      IF (Z(I).LE.4.0) [IZZ=Z(I);
               2          ZAB=ZAB+ZZX(I)*ALRAD(IZZ);] "IN THE CASE OF Z.LE.4 "
               1      ELSE [ZAB=ZAB+ZZX(I)*(AL183+ALOG(Z(I)**(-1./3.)));] "Z.GT.4"
               1      ZT = ZT + ZZX(I);
               1      ZB = ZB + ZZX(I)*ALOG(Z(I)**(-1./3.));
               1      ZF = ZF + ZZX(I)*FCOUL(I);
               1      ZZ(I) = PZ(I)*Z(I)*(Z(I)+$FUDGEMS);
               1      ZS = ZS + ZZ(I);
               1      ZE = ZE + ZZ(I)*((-2./3.)*ALOG(Z(I)));
               1      ZX = ZX + ZZ(I)*ALOG(1.+3.34*FZC(I));] "END OF I LOOP"
               0  EZ = ZC/TPZ;
               0  ZA = AL183*ZT;
               0  ZG = ZB/ZT;
               0  ZP = ZB/ZA;
               0  ZV = (ZB-ZF)/ZT;
               0  ZU = (ZB-ZF)/ZA;
               0  EDEN=AN*RHO/WM*ZC;
               0  RLC = 1./( (ZAB-ZF)*(AN*RHO/WM)*4.0*FSC*R0**2 );
               0  OUTPUT WM,ZC,ZT,ZA,ZB,ZAB,ZF,ZG,ZP,ZV,ZU,ZS,ZE,ZX,RLC,
               0  (I,XSI(I),ZZX(I),FZC(I),FCOUL(I),ZZ(I),I=1,NE);
               0  ('0Z VARIABLES--WM,ZC,ZT,ZA,ZB,ZAB'/1P,6E14.6/
               0  '0ZF,ZG,ZP,ZV,ZU,ZS'/1P,6E14.6/'0ZE,ZX,RLC'/1P,3E14.6/
               0  '0(I,XSI,ZZX,FZC,FCOUL,ZZ,I=1,NE)'/
               0  (I5,1P,5E14.6));
               0  "$DUMP EDEN;"
               0
               0  "NOW COMPUTE MATERIAL-DEPENDENT CONSTANTS FOR MULTIPLE SCATTERING"
               0  "LET B BE MOLIERE'S UPPER CASE B, AND LET BLC BE MOLIERE'S LOWER CASE B"
               0  "THEN USING SCOTT'S NOTATION, A MEASURE OF THE NUMBER OF SCATTERS IS"
               0  "OMEGA0=EXP(BLC).  NOW B AND BLC ARE RELATED BY"
               0  "BLC=B-ALOG(B);, OR EXP(BLC)=EXP(B)/B; "
               0  "NOW LET T BE THE TRANSPORT DISTANCE IN RL. THEN,"
               0  "OMEGA0=EXP(BLC)"
               0  "      =( A6680*RHO*ZS*EXP(ZE/ZS)*RLC/(WM*EXP(ZX/ZS)) )*T/BETA**2"
               0  "WHERE BETA IS V/C FOR THE PARTICLE"
               0  "NOW SUPPOSE THAT XC IS CHI-SUB-C, THE CHARACTERISTIC ANGLE OF"
               0  "MOLIERE'S THEORY.  THEN IT IS GIVEN BY"
               0  "XC= (A22P9/RADDEG)*SQRT( ZS*RHO*RLC/WM ) * SQRT(T) /(E*BETA**2) "
               0  " WHERE E IS THE ENERGY OF THE PARTICLE IN MEV."
               0  "NOW IN MOLIERE'S THEORY, LET XRM BE XC*SQRT(B).  THEN"
               0  " (MOLIERE'S REDUCE ANGLE)=(REAL ANGLE)/XRM."
               0  "FOR THE VARIABLE SAMPLING DONE IN EGS, A DIFFERENT REDUCED"
               0  "ANGLE IS USED:"
               0  " (REDUCED ANGLE FOR VARIABLE SAMPLING)=(REAL ANGLE)/XRV "
               0  " WHERE NOW XRV=XC*SQRT(BLC)."
               0  "THIS IS DONE BECAUSE BLC IS MORE SIMPLY RELATED TO THE TRANSPORT"
               0  "DISTANCE THAN IS B."
               0
               0  "WITH THIS BACKGROUND WE NOW PROCEED TO COMPUTE"
               0  "XR0, TEFF0, BLCC, AND XCC, WHICH ARE PARAMETERS NEEDED IN EGS"
               0  "THESE PARAMETERS ARE USED AS FOLLOWS:(IN OUR NOTATION)"
               0  "XRM=XR0*SQRT(T*B/(T0*BMIN))/(E*BETA) "
               0  "  WHERE B IS EVALUATED FOR DISTANCE T, AND T0 IS THE"
               0  "  DISTANCE THAT WOULD GIVE B=BMIN. T0 IS A FUNCTION OF BETA, AND"
               0  "  IS GIVEN BY THE EXPRESSION  "
               0  "T0=TEFF0*BETA**2;  THIS IS ALSO THE DEFINING RELATION FOR TEFF0"
               0  "BMIN IS THE MINIMUM VALUE OF B FOR WHICH MOLIERE CONSIDERED HIS THEORY"
               0  "VALID.  WE CURRENTLY GIVE BMIN A VALUE OF 4.5."
               0  "OMEGA0=BLCC*T/BETA**2  IS THE USEAGE OF BLCC"
               0  "XRV= XCC*SQRT( T*BLC )/(E*BETA**2) IS THE USAGE OF XCC"
               0
               0  "WE NOW PROCEED TO SOLVE FOR THE ABOVE QUANTITIES."
               0  "COMPARING THE TWO EXPRESSIONS FOR OMEGA0, WE CONCLUDE THAT:"
               0
               0  BLCC= A6680*RHO*ZS*EXP(ZE/ZS)*RLC / (WM*EXP(ZX/ZS)) ;
               0  "NOW USING THE EXPRESSION FOR OMEGA0 AT B=BMIN,WE HAVE"
               0  " OMEGA0=EXP(BLCMIN)"
               0  "       =EXP(BMIN)/BMIN"
               0  "       =BLCC*T0/BETA**2"
               0  "       =BLCC*TEFF0    ,     THEREFORE"
               0
               0  TEFF0 = ( EXP(BMIN)/BMIN )/BLCC;
               0
               0  "COMPARING THE TWO EXPRESSION FOR XRV WE CONCLUDE THAT"
               0  "XC= XCC * SQRT(T) /(E*BETA**2)"
               0  "COMPARING THIS WITH OUR PREVIOUS EXPRESSION FOR XC, WE OBTAIN"
               0
               0  XCC= (A22P9/RADDEG) * SQRT( ZS*RHO*RLC/WM );
               0
               0  "NOW COMPARING THE TWO EXPRESSIONS FOR XRM WE OBTAIN"
               0  "XRM=XC*SQRT(B)       USING DEFINITION OF XRM"
               0  "   =(XCC*SQRT(T)/(E*BETA**2)) *SQRT(B)  AFTER SUBSTITUTING FOR XC"
               0  "   =XR0*SQRT((T*B)/(T0*BMIN))/(E*BETA)  USING EXPRESSION DEFINING XR0"
               0  "   =XR0*SQRT((T*B)/(TEFF0*BETA**2*BMIN))/(E*BETA)  EXPANDING T0"
               0  " THUS AFTER SOME CANCELLATION AND SOLVING FOR XR0 WE OBTAIN"
               0
               0  XR0 = XCC*SQRT(TEFF0*BMIN);
               0
               0  "THIS COMPLETE THE MS CALCULATIONS"
               0  OUTPUT BLCC,XCC,TEFF0,XR0;('0BLCC,XCC,TEFF0,XR0=',1P,4E14.5);
               0
               0  RETURN;
               0  END; "END OF SUBROUTINE MIX"
               0
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE MOLIER;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0
               0  "COMPUTE MATERIAL INDEPENDENT MOLIERE DATA                         "
               0
               0  COMIN/MIMSD/;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER I,IS,J,L,JLR,ITOT,IDIF,N,I01,I02,ISWP,IFLG,IDA,INC,II,ISU,ISL,
               0  IUECHO,IPUN,MST;
               0  $REAL    BLCMIN,BLC,B,BOLD,B1,PTOT,PPP,PP;
               0  $REAL P(29,$MSSTEPS),Q(29,$MSSTEPS),BLCA($MSSTEPS),BA($MSSTEPS);
               0  $INTEGER IP1(29,$MSSTEPS),IP2(29),IXTR(29,$MSSTEPS),IALL(29);
               0  "     DATA FROM BETHE'S TABLE                                          "
               0  $REAL TH(29),DTH(29),F0(29),F1(29),F2(29);
               0  DATA TH/.05,.2,.4,.6,.8,1.,1.2,1.4,1.6,1.8,2.,2.2,2.4,2.6,2.8,
               0  3.,3.2,3.4,3.6,3.8,4.07,4.5,5.,5.5,6.13,7.,8.,9.,9.75/;
               0  DATA DTH/.1,19*0.2,0.35,3*0.5,0.75,3*1.0,0.5/;
               0  DATA F0/2.,1.9216,1.7214,1.4094,1.0546,.7338,.4738,.2817
               0  ,.1546,.0783,.0366,.01581,.0063,.00232,7.9E-4,2.5E-4,7.3E-5,
               0  1.9E-5,4.7E-6,1.1E-6,2.3E-7,3.E-9,2.E-11,2.E-13,5.E-16,1.E-21,
               0  3.E-28,1.E-35,$F0(29)/;
               0  DATA F1/.8456,.7038,.3437,-0.0777,-0.3981,-0.5285,-0.4770,
               0  -.3183,-.1396,-.0006,+0.0782,.1054,.1008,.08262,.06247,.0455,
               0  .03288,.02402,.01791,.01366,.010638,.00614,.003831,.002527,
               0  .001739,.000908,.0005211,.0003208,.0002084/;
               0  DATA F2/2.4929,2.0694,1.0488,-.0044,-.6068,-.6359,-.3086,.0525
               0  ,.2423,.2386,.1316,.0196,-.0467,-.0649,-.0546,-.03568,-.01923,
               0  -.00847,-.00264,5.E-5,.0010741,.0012294,.0008326,.0005368,
               0  .0003495,.0001584,7.83E-5,4.17E-5,2.37E-5/;
               0  save TH,DTH,F0,F1,F2;
               0
               0  "***THE PURPOSE OF THIS ROUTINE IS TO CALCULATE THE DISTRIBUTION OF  "
               0  "   THE MOLIERE REDUCED ANGLES FOR USE IN MULTIPLE SCATTERING        "
               0  "   THIS IS DONE FOR A SET OF $MSSTEPS STEPSIZES.  EACH STEPSIZE IS A"
               0  "   FIXED MULTIPLE OF T0,THE STEP SIZE WHICH GIVES MOLIERE'S UPPER CASE"
               0  "   B VARIABLE, B, ITS MINIMUM VALID VALUE BMIN.  BLC IS MOLIERE'S"
               0  "   LOWER CASE B, WHICH THEN ALSO HAS A MINIMUM VALUE BLCMIN, WHICH IS"
               0  "   RELATED TO BMIN BY THE TRANSCENDENTAL EQUATION LINKING B AND BLC,"
               0  "   I.E., BLC=B-ALOG(B);  AND BLCMIN=BMIN-ALOG(BMIN);"
               0  "   NOW BLC IS RELATED TO THE TRANSPORT DISTANCE THROUGH THE EQUATION"
               0  "   EXP(BLC) = BLCC * T/BETA**2;  (SEE NOTES IN SUBROUTINE MIX)"
               0  "   THUS IF WE DEFINE AN EFFECTIVE DISTANCE "
               0  "   TEFF=T/BETA**2;  AND ALSO  TEFF0=T0/BETA**2;"
               0  "   THEN THE ENERGY DEPENDENCE IF REMOVED FROM THE EQUATION,AND WE HAVE"
               0  "   EXP(BLC)=BLCC*TEFF;    FOR THE MINIMAL CONDITION THIS BECOMES"
               0  "   EXP(BLCMIN)=BLCC*TEFF0;"
               0  "   NOW SUPPOSE WE HAVE A TRANSPORT DISTANCE T WHOSE RATIO TO T0 IS"
               0  "   R = T/T0 = TEFF/TEFF0;     WE THEN HAVE"
               0  "   EXP(BLC)=BLCC*TEFF=BLCC*TEFF0*(TEFF/TEFF0)"
               0  "          =(BLCC*TEFF0)*R"
               0  "          = EXP(BLCMIN)*R;     HENCE WE OBTAIN"
               0  "   BLC = BLCMIN + ALOG(R); "
               0  "   AND THE CORESPONDING VALUE OF B CAN BE DETERMINED BY SOLVING THE"
               0  "   TRANSCENDENTAL EQUATION."
               0  "   IN WHAT FOLLOWS, FSTEP(IS) CONTAINS THE RATIO OF THE SIZE OF THE"
               0  "   IS THE STEPSIZE TO T0.  ITS VALUES ARE ALL INTEGERS.  WHEN USED BY"
               0  "   EGS THE RATIO R OF THE DESIRED STEP SIZE TO T0 IS COMPUTED,AND THEN"
               0  "   IT IS DESIRED TO FIND THE LARGEST FIXED STEP SIZE THAT IS LESS THAN"
               0  "   R*T0.  TO FACILITATE THIS, WE DEFINE AN ARRAY MSMAP, OF SIZE"
               0  "   $MXJREFF,SUCH THAT MSMAP(JR) IS THE INDEX OF THE LARGEST FIXED STEP"
               0  "   LESS THAN OR EQUAL TO JR.  THUS IN EGS THE SELECTION OF A STEP IS:"
               0  "   R=T/T0; JR=R; IS=MSMAP(JR) ; T=FSTEP(IS)*T0; "
               0  "   IN ADDITION IT IS REQUIRED TO KNOW THE RATIO OF MOLIERE REDUCING"
               0  "   ANGLE XRM=XC*SQRT(B) TO ITS MINIMUM VALUE XRMMIN=XCMIN*SQRT(BMIN);"
               0  "   SINCE AT FIXED ENERGY XC IS PROPORTIONAL TO T, THIS RATIO IS"
               0  "   FSQR(IS)= R*SQRT(B/BMIN);  THEN"
               0  "   XRM=FSQR*XRMMIN=FSQR*XCMIN*SQRT(BMIN)"
               0  "    =FSQR* (XCC*SQRT(T0)/(E*BETA**2)) * SQRT(BMIN) "
               0  "    =FSQR* (XCC*SQRT(TEFF0*BETA**2)/(E*BETA**2)) *SQRT(BMIN) "
               0  "    = (XCC*SQRT(TEFF0*BMIN)) * FSQR / (E*BETA) "
               0  "    = XR0 * FSQR / (E*BETA)"
               0  "   THIS LAST LINE IS THE FORM USED BY EGS.  XR0 CONTAINS THE MATERIAL"
               0  "   DEPENDENCE, FSQR THE STEP DEPENDENCE, AND 1/(E*BETA)"
               0  "   THE ENERGY DEPENDENCE."
               0  "   IN THE CASE WHEN R.LT.1., THE PROPOSED TRANSPORT DISTANCE IS"
               0  "   THAN THE SMALLEST VALID MOLIERE TRANSPORT DISTANCE, AND STRICTLY"
               0  "   SPEAKING MOLIERE'S THEORY IS NO LONGER APPLICABLE.  SINCE IN MOST"
               0  "   THE SCATTERING OVER THIS SHORT DISTANCE WILL NOT BE TOO SIGIFICANT,"
               0  "   WE CURRENTLY USE THE REDUCED ANGLE DISTRIBUTION FOR T0 IN THIS"
               0  "   CASE, AND LET FSQR=SQRT(R), I.E. IGNORE CHANGE IN B FROM BMIN."
               0
               0  OUTPUT (TH(I),DTH(I),F0(I),F1(I),F2(I),I=1,29);
               0  ('1BETHE TABLE USED FOR INPUT'/(1X,0P,2F10.2,1P,3E18.5));
               0
               0  "***NOW FILL UP MSMAP."
               0  FOR IS=1 TO MSTEPS-1 [
               1      FOR J=FSTEP(IS) TO FSTEP(IS+1)-1 [MSMAP(J)=IS;]]
               0  MSMAP(JRMAX)=MSTEPS;
               0
               0  BLCMIN = BMIN - ALOG(BMIN);
               0
               0  :STEP: DO IS=1,MSTEPS [ "LOOP OVER STEP SIZES"
               1      BLC=BLCMIN+ALOG(FSTEP(IS));
               1      "***NOW SOLVE FOR B"
               1      B=BLC+ALOG(BLC); "THIS IS FIRST GUESS"
               1      LOOP["UNTIL NEWTON'S METHOD CONVERGES"
               2          BOLD=B;
               2          B=BOLD - (BOLD-ALOG(BOLD)-BLC)/(1.0-1.0/BOLD);]
               1      UNTIL ABS((B-BOLD)/BOLD) .LT. 1.E-5 ;
               1      BLCA(IS)=BLC; BA(IS)=B; "SAVE BLC AND B FOR PRINTOUT"
               1      FSQR(IS)=SQRT(FSTEP(IS)*B/BMIN); "GET XRM RATIO"
               1      "***CALCULATE PROBABILITIES OF INPUT REDUCED ANGLES                  "
               1      B1=1.0/B;
               1      PTOT=0.0;
               1      DO I=1,29 [
               2          P(I,IS)=TH(I)*DTH(I)*(F0(I)+B1*(F1(I)+B1*F2(I)));
               2          "***THESE ANGLES CORRESPOND TO THE PROBABILITY ENTRIES               "
               2          PTOT=PTOT+P(I,IS);]
               1      DO I=1,29 [P(I,IS)=P(I,IS)/PTOT;] "NORMALIZE"
               1      "***MAKE ALL PROBABILITIES EITHER 0.0 OR GREATER THAN 0.001 IN THE   "
               1      "   MANNER NAGEL SUGGESTS.  NOTE THE PROBABILITY IS LUMPED INTO      "
               1      "   THE ENTRY FOR THE LARGEST REDUCED ANGLE WHEN INTERVALS ARE MERGED"
               1      DO I=1,29 [Q(I,IS)=P(I,IS);] "DON'T CHANGE EXACT PROBABILITIES"
               1      I=29;
               1      LOOP[ L=1;
               2          WHILE (Q(I,IS).LT.0.001).AND.(I.GT.L) [
               3              Q(I,IS)=Q(I,IS)+Q(I-L,IS); Q(I-L,IS)=0.0; L=L+1; ]
               2          I=I-L;]
               1      UNTIL I.LE.0 ;
               1      "***NOW TRY TO MAKE UP 1000 INTEGRAL PROBABILITIES FOR VERT TABLES"
               1      PPP=0.5; PP=0.5; "INITIALIZE ROUNDING PARAMETERS"
               1      DO JLR=1,10 [ "TRY FUDGING ROUNDING DOWN TO 2**-10"
               2          ITOT=0; "INITIALIZE TOTAL"
               2          DO I=1,29 [ "ROUND PROBABILITIES FOR THIS ANGLE"
               3              IP1(I,IS)=Q(I,IS)*1000.0+PP; ITOT=ITOT+IP1(I,IS); ]
               2          IDIF=ITOT-1000;
               2          IF (IDIF.EQ.0)NEXT :STEP:;
               2          PPP=PPP*0.5;
               2          IF (IDIF.LT.0)[PP=PP+PPP;]ELSE[PP=PP-PPP;]
               2          ] "END OF ROUNDING-FUDGING LOOP"
               1      "***GET 1000 ENTRIES WHEN ROUNDING ADJUSTMENT FAILS.  WE ADD OR      "
               1      "   SUBTRACT ONE FROM AS MANY OF THE LARGEST PROBABILITIES AS NEEDED "
               1      "   BUBBLE SORT THE PROBABILITIES TO RANK THEM BY SIZE               "
               1      DO I=1,29 [IP2(I)=1;]
               1      N=29;
               1      LOOP[ N=N-1; IFLG=0; "PREPARE FOR ONE PASS THOUGH BUBBLE SORT"
               2          DO J=1,N [
               3              I01=IP2(J);I02=IP2(J+1);IF (IP1(I01,IS).LT.IP1(I02,IS))["MUST SWAP"
               4                  ISWP=IP2(J);IP2(J)=IP2(J+1); IP2(J+1)=ISWP; IFLG=1;"SWAP&SET FLAG"]
               3              ] "END OF PASS"
               2          ]UNTIL IFLG.EQ.0 ;"LOOP UNTIL PASS HAS NO SWAPS"
               1      OUTPUT ITOT;
               1      (' ROUNDING FAILED, ITOT HAS',I6,' ENTRIES');
               1      IF (IDIF.LT.0)[IDA=-IDIF;INC=1;]ELSE[IDA=IDIF;INC=-1;]
               1      DO I=1,IDA [ I01=IP2(I); IP1(I01,IS)=IP1(I01,IS)+INC; ]
               1      ] "END OF :STEP: SIZE DO LOOP"
               0
               0  "***NOW FIND MINIMUM FREQUENCY FOR EACH ANGLE OVER ALL STEPS"
               0  MXV1=0;"MXV1 WILL BE SUM OF MINIMUMS"
               0  DO I=1,29 [ IALL(I)=IP1(I,1);
               1      DO IS=2,MSTEPS [IALL(I)=MIN0(IALL(I),IP1(I,IS));]
               1      MXV1=MXV1+IALL(I);"ADD IN MINIMUM FREQUENCY FOR THIS ANGLE"
               1      ] "END LOOP OVER ANGLES"
               0  MXV2=1000-MXV1;"THE VERT2 ARRAY HAS THE LEFT-OVERS"
               0  "***&&&&&&&&&&LATER ONLY PUT IALL,IXTR TO EGS"
               0  "   AND LET EGS FILL IN VERT1 AND VERT2. THIS REQUIRES LESS STORAGE"
               0  "***NOW FILL UP THE VERT ARRAYS."
               0  II=0;
               0  DO I=1,29 [ FOR J=1 TO IALL(I) [II=II+1;VERT1(II)=TH(I);] ]
               0  "***NOW DO VERT2"
               0  DO IS=1,MSTEPS [
               1      II=0;
               1      DO I=1,29 [
               2          IXTR(I,IS)=IP1(I,IS)-IALL(I);"GET NUMBER OF EXTRAS"
               2          FOR J=1 TO IXTR(I,IS) [ II=II+1;VERT2(II,IS)=TH(I);]
               2          ] "END ANGLE DO LOOP"
               1      ] "END STEP DO LOOP"
               0  "***WE HAVE NOW COMPUTED EVERYTHING THE USER NEEDS, SO NOW LIST IT OUT"
               0  OUTPUT BMIN,MSTEPS,JRMAX,MXV1,MXV2;(' BMIN,MSTEPS,JRMAX,MXV1,MXV2=',
               0  F11.5,4I8);
               0  ISU=0; "STARTING UPPER STEP LIMIT"
               0  LOOP[ "TAKE AS MANY STEPS AS WILL FIT ON A PAGE"
               1      ISL=ISU+1; ISU=MIN0(ISL+9,MSTEPS); "GET LOWER &UPPER STEPS LIMITS"
               1      OUTPUT ISL,ISU;('1 DATA FOR STEPS ',I3,' TO ',I3);
               1      OUTPUT (IS,IS=ISL,ISU);(11X,'ISTEP',I6,9I11);
               1      OUTPUT (FSTEP(IS),IS=ISL,ISU);(11X,'FSTEP',10F11.0);
               1      OUTPUT (FSQR(IS),IS=ISL,ISU);(11X,'FSQR ',10F11.5);
               1      OUTPUT (BLCA(IS),IS=ISL,ISU);(11X,'BLC  ',10F11.5);
               1      OUTPUT (BA  (IS),IS=ISL,ISU);(11X,'B    ',10F11.5);
               1      OUTPUT ;('0I  TH IALL');
               1      DO I=1,29 [
               2          IF ((I.EQ.11).OR.(I.EQ.23))[OUTPUT ;('1I  TH IALL');]
               2          OUTPUT I,TH(I),IALL(I),(P(I,IS),IS=ISL,ISU);
               2          (1X,I2,F5.2,I4,' PR ',10F11.8);
               2          OUTPUT(Q(I,IS),IS=ISL,ISU);(11X,'  Q  ',10F11.8);
               2          OUTPUT (IP1(I,IS),IS=ISL,ISU);(11X,' IP1 ',I7,9I11);
               2          OUTPUT (IXTR(I,IS),IS=ISL,ISU);(11X,'EXTRA',I7,9I11);  ]
               1      ]UNTIL ISU.GE.MSTEPS;
               0  "***NOW PUNCH OUT DATA NEEDED BY EGS"
               0  :INTG:FORMAT(1X,14I5);
               0  :FLTNG:FORMAT(1X,14F5.2);
               0  IUECHO=6; IPUN=7;
               0  "***FIRST MUST PUT OUT THE HEADER FOR WHICH SETUP SEARCHES."
               0  $ECHOWRITE(IPUN,:FMTA:) ;
               0  :FMTA: FORMAT(' MATERIAL INDEPENDENT MULTIPLE SCATTERING DATA');
               0  $ECHOWRITE(IPUN,:INTG:) JRMAX,MSTEPS,MXV1,MXV2;
               0  $ECHOWRITE(IPUN,:FMTB:) (FSTEP(I),FSQR(I),I=1,MSTEPS);
               0  :FMTB: FORMAT((1X,4(F5.0,F11.6)));
               0  $ECHOWRITE(IPUN,:INTG:) (MSMAP(I),I=1,JRMAX);
               0  $ECHOWRITE(IPUN,:FLTNG:) (VERT1(I),I=1,MXV1);
               0  DO MST=1,MSTEPS [ $UOUTPUT(IUECHO)MST;(' MST=',I5);
               1      $ECHOWRITE(IPUN,:FLTNG:) (VERT2(I,MST),I=1,MXV2);]"END MST DO"
               0  "***THIS COMPLETES THE OUTPUT OF MATERIAL INDEPENDENT MULTIPLE"
               0  "   SCATTERING DATA"
               0  RETURN;
               0  END; "END OF SUBROUTINE MOLIER"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE PLOT(IFUN,XP,IV,EL,EH,NPT,IDF);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0
               0  $INTEGER ifun,IV,NPT,IDF;
               0  $REAL    EL,EH;
               0
               0  "This version of PLOT played with at NRC  NOV 1988                 "
               0  "                                                                  "
               0  " This version does not work in the general case, but for stopping "
               0  " powers it converts the output to MeV / g /cm**3                  "
               0  " and outputs the results for a given energy grid to unit ??       "
               0  "                                                                  "
               0  " The original version is also in the code. The version called     "
               0  " PLOT will be the active one, that called PLOT1 is available to   "
               0  " be renamed.                                                      "
               0  "                                                                  "
               0  "                                                                  "
               0  "***ROUTINE TO PLOT FUNCTION NUMBER IFUN. IF NA IS NUMBER OF ARGUMENTS"
               0  "   THAT IFUN TAKES, THEN (XP(I),I=1,NA) ARE VALUES FOR THE ARGUMENTS"
               0  "   EXCEPT THAT THE IV'TH ARGUMENT IS VARIED FROM EL TO EH "
               0  "   DISTRIBUTED UNIFORMLY WITH RESPECT TO DISTRIBUTION FUNCT. NO. IDF."
               0  "   IDF+1 IS THE NUMBER OF THE INVERSE DISTRIBUTION FUNCTION."
               0  "   NOPTNS IS INCLUDED FOR FUTURE EXPANSION."
               0  ;
               0  COMIN/FUNCS,MOLVAR,DERCON,EPSTAR/; "NRC MOD NOV 1988"
               0  ;COMIN/FileNames/;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER IXTABF,NMAX,NUPL,ITAB,IXT1,IXT2,NU,IDFI,NA,IP,JA,IA,IBIN,J,I;
               0  $REAL    DFL,DFH,BDF,YMAX,X,DY;
               0  " IK: Function declarations for implicit none"
               0  $REAL    FI;
               0
               0  $TYPE PBUF(101),ID(5),ORDNL(3,4),ICOM,IRPAR,ICOL,IX,IBL;
               0  $REAL XTAB(200),XTABA(18),YSAV(200),XP(4),XQ(5); "NRC MOD NOV 1988"
               0  logical first_time;
               0  DATA XTABA /1. ,1.25 ,1.5 ,1.75 ,2. ,2.5 ,3. ,3.5
               0  ,4. ,4.5,4.9488  ,5.  ,5.5  ,6. ,7.  ,8. ,9. ,10./;
               0  DATA IXTABF/0/; "First call sets X table and flag"
               0  DATA ICOM/','/,IRPAR/')'/,ICOL/':'/,ORDNL/$S'1ST2ND3RD4TH'/;
               0  DATA PBUF/'I',100*' '/,NMAX/200/,NUPL/6/,IX/'X'/,IBL/' '/;
               0  DATA first_time/.true./;
               0  save XTABA,IXTABF,ICOM,IRPAR,ICOL,ORDNL,PBUF,NMAX,NUPL,IX,IBL,
               0  first_time;
               0
               0  IF( first_time ) [
               1      first_time = .false.;
               1      output_file(lenfn-7:lenfn) = 'plot    ';
               1      open(21,file=output_file,status='unknown');"
               1      ]
               0
               0  IF (IXTABF.EQ.0) [ "set up kinetic energy grid"
               1      ITAB= 0;
               1      DO IXT1=0,6["LOOP OVER DECADES"
               2          DO IXT2 = 1,17[
               3              IF(IXT2.NE.11)["WE ONLY WANT 49.488 MEV"
               4                  ITAB=ITAB+ 1;XTAB(ITAB)=XTABA(IXT2)*10.**(IXT1-3);]
               3              ELSEIF(IXT2.EQ.11 .AND. IXT1.EQ.4)["WE ONLY WANT 49.488 MEV"
               4                  ITAB=ITAB+ 1;XTAB(ITAB)=XTABA(IXT2)*10.**(IXT1-3);]
               3              ]
               2          ]
               1      "GET THE LAST ELEMENT"ITAB=ITAB+1;XTAB(ITAB)=XTABA(18)*10.**(6-3);
               1      IXTABF=1;NU=ITAB ] "energy grid done"
               0  IDFI=IDF+1;  NA=NFARG(IFUN); "NUMBER OF ARGS"
               0  DFL=FI(IDF,EL,0.,0.,0.);DFH=FI(IDF,EH,0.,0.,0.);
               0  BDF=(DFH-DFL)/FLOAT(NU-1); YMAX=0.0;
               0  DO IP=1,NU [
               1      X=XTAB(IP)+RM;XP(IV)=X; "SELECT AND SET UP VARIABLE ARG."
               1      YSAV(IP)=FI(IFUN,XP(1),XP(2),XP(3),XP(4))/(RLC*RHO);
               1      "NRC MOD NOV 1988 TO OUTPUT MEV PER G/CM**2 FOR STOPPING POWERS"
               1      "THIS WILL SCREW UP OTHER CROSS SECTIONS!!!! "
               1      YMAX=AMAX1(YSAV(IP),YMAX); ]
               0  DY=YMAX/100.;
               0  "***NOW CONSTRUCT THE CAPTION"
               0  JA=0; DO IA=1,NA [ JA=JA+1;
               1      IF (IA.NE.IV)[XQ(JA)=XP(IA); ID(JA)=ICOM; ]
               1      ELSE[ XQ(JA)=EL;ID(JA)=ICOL; JA=JA+1; XQ(JA)=EH;ID(JA)=ICOM; ]  ]
               0  ID(JA)=IRPAR; "CLOSE WITH RIGHT PAREN"
               0  $UOUTPUT(NUPL)(FNAME(I,IFUN),I=1,6),(XQ(I),ID(I),I=1,JA);
               0  ('1PLOT OF FUNCTION ',6A1,'(',5(1P,G15.6,1X,A1) );
               0  $UOUTPUT(NUPL)(ORDNL(I,IV),I=1,3),NU,EL,EH,
               0  (FNAME(I,IDF),I=1,6),(FNAME(I,IDFI),I=1,6),DY;
               0  (' THE ',3A1,' ARGUMENT IS CHOSEN AT ',I4, ' POINTS FROM ',1P,G15.6,
               0  ' TO ', 1P,G15.6/' USING DISTRIBUTION FUNCTION ',6A1,' AND INVERSE ',
               0  'DISTRIBUTION FUNCTION ',6A1,'.  EACH X=',1P,G15.6/
               0  '0    X(OR E)    Y1');
               0  $UOUTPUT(NUPL) RLC,RHO;
               0  (/' ***CHANGED VERSION OF PEGS WHICH HAS DIVIDED THE VALUES BY',
               0  ' RLC*RHO TO GET TO MeV/g/cm**2'/'  RLC=',E12.4,'  RHO=',E12.4);
               0
               0  "***NOW PLOT DATA"
               0  "list with KINETIC energy"
               0  DO IP=1,NU [
               1      X=XTAB(IP);
               1      IF (DY.NE.0.0)[IBIN=YSAV(IP)/DY+1.0;]ELSE[IBIN=1;]
               1      IF (IBIN.GE.2)PBUF(IBIN)=IX;
               1      $UOUTPUT(NUPL) IP,X,YSAV(IP),(PBUF(J),J=1,IBIN);
               1      (1X,I3,1P,2G13.6,1X,101A1);
               1      IF (IBIN.GE.2)PBUF(IBIN)=IBL;]
               0  WRITE(21,*) NU; WRITE(21,:PLTFMT:) (XTAB(IP),IP=1,NU);
               0  WRITE(21,*) NU; WRITE(21,:PLTFMT:) (YSAV(IP),IP=1,NU);
               0  :PLTFMT: FORMAT(5(1P,E15.7));
               0  RETURN;
               0  END;  "END OF SUBROUTINE PLOT1"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE PLOT1(IFUN,XP,IV,EL,EH,NPT,IDF);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***ROUTINE TO PLOT FUNCTION NUMBER IFUN. IF NA IS NUMBER OF ARGUMENTS"
               0  "   THAT IFUN TAKES, THEN (XP(I),I=1,NA) ARE VALUES FOR THE ARGUMENTS"
               0  "   EXCEPT THAT THE IV'TH ARGUMENT IS VARIED FROM EL TO EH "
               0  "   DISTRIBUTED UNIFORMLY WITH RESPECT TO DISTRIBUTION FUNCT. NO. IDF."
               0  "   IDF+1 IS THE NUMBER OF THE INVERSE DISTRIBUTION FUNCTION."
               0  "   NOPTNS IS INCLUDED FOR FUTURE EXPANSION."
               0  ;
               0  implicit none;
               0
               0  $INTEGER IFUN,IV,NPT,IDF;
               0  $REAL    EL,EH;
               0  COMIN/FUNCS/;
               0  $TYPE PBUF(101),ID(5),ORDNL(3,4),ICOM,IRPAR,ICOL,IX,IBL;
               0  $REAL YSAV(200),XP(4),XQ(5);
               0  $INTEGER NMAX,NUPL,NU,IDFI,NA,IP,I,JA,IA,IBIN,J;
               0  $REAL    DFL,FI,DFH,BDF,YMAX,DF,X,DY;
               0  DATA ICOM/','/,IRPAR/')'/,ICOL/':'/,ORDNL/$S'1ST2ND3RD4TH'/;
               0  DATA PBUF/'I',100*' '/,NMAX/200/,NUPL/6/,IX/'X'/,IBL/' '/;
               0  NU=MIN0(NPT,NMAX);
               0  IDFI=IDF+1;  NA=NFARG(IFUN); "NUMBER OF ARGS"
               0  DFL=FI(IDF,EL,0.,0.,0.);DFH=FI(IDF,EH,0.,0.,0.);
               0  BDF=(DFH-DFL)/FLOAT(NU-1); YMAX=0.0;
               0  DO IP=1,NU [I=IP-1;DF=DFL+BDF*FLOAT(I);
               1      X=FI(IDFI,DF,0.,0.,0.);  XP(IV)=X; "SELECT AND SET UP VARIABLE ARG."
               1      YSAV(IP)=FI(IFUN,XP(1),XP(2),XP(3),XP(4));
               1      YMAX=AMAX1(YSAV(IP),YMAX); ]
               0  DY=YMAX/100.;
               0  "***NOW CONSTRUCT THE CAPTION"
               0  JA=0; DO IA=1,NA [ JA=JA+1;
               1      IF (IA.NE.IV)[XQ(JA)=XP(IA); ID(JA)=ICOM; ]
               1      ELSE[ XQ(JA)=EL;ID(JA)=ICOL; JA=JA+1; XQ(JA)=EH;ID(JA)=ICOM; ]  ]
               0  ID(JA)=IRPAR; "CLOSE WITH RIGHT PAREN"
               0  $UOUTPUT(NUPL)(FNAME(I,IFUN),I=1,6),(XQ(I),ID(I),I=1,JA);
               0  ('1PLOT OF FUNCTION ',6A1,'(',5(1P,G15.6,1X,A1) );
               0  $UOUTPUT(NUPL)(ORDNL(I,IV),I=1,3),NU,EL,EH,
               0  (FNAME(I,IDF),I=1,6),(FNAME(I,IDFI),I=1,6),DY;
               0  (' THE ',3A1,' ARGUMENT IS CHOSEN AT ',I4, ' POINTS FROM ',1P,G15.6,
               0  ' TO ', 1P,G15.6/' USING DISTRIBUTION FUNCTION ',6A1,' AND INVERSE ',
               0  'DISTRIBUTION FUNCTION ',6A1,'.  EACH X=',1P,G15.6/
               0  '0    X(OR E)    Y1');
               0  "***NOW PLOT DATA"
               0  DO IP=1,NU [
               1      I=IP-1;X=FI(IDFI,DFL+BDF*FLOAT(I),0.,0.,0.);
               1      IF (DY.NE.0.0)[IBIN=YSAV(IP)/DY+1.0;]ELSE[IBIN=1;]
               1      IF (IBIN.GE.2)PBUF(IBIN)=IX;
               1      $UOUTPUT(NUPL) IP,X,YSAV(IP),(PBUF(J),J=1,IBIN);
               1      (1X,I3,1P,2G13.6,1X,101A1);
               1      IF (IBIN.GE.2)PBUF(IBIN)=IBL;  ]
               0  RETURN;
               0  END;  "END OF SUBROUTINE PLOT"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE PMDCON;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***SUBROUTINE TO ARRIVE AT PHYSICAL, MATHEMATICAL, AND DERIVED"
               0  "   CONSTANTS IN A VERY MNEMONIC WAY.                                  "
               0  ;
               0  implicit none;
               0  $REAL FSCI;
               0  COMIN/PMCONS,DERCON/;
               0  "***PHYSICAL AND MATHEMATICAL CONSTANTS                                "
               0  "     PI       CIRCUMFERANCE/DIAMETER.                                 "
               0  "     C        SPEED OF LIGHT(CM/SEC)                                  "
               0  "     RME      ELECTRON REST MASS(GRAMS)                               "
               0  "     HBAR     PLANCK'S CONSTANT/(2*PI)  (ERG SEC)                     "
               0  "     ECGS     ELECTRON CHARGE (ESU)                                   "
               0  "     EMKS     ELECTRON CHARGE (COULOMB)                               "
               0  "     AN       AVOGADRO'S NUMBER                                       "
               0  PI=3.1415926536;
               0  C=2.997925E+10;
               0  RME=9.1091E-28;
               0  HBAR=1.05450E-27;
               0  ECGS=4.80298E-10;
               0  EMKS=1.60210E-19;
               0  AN=6.02252E+23;
               0  "***DERIVED CONSTANTS                                                  "
               0  "     RADDEG   ONE RADIAN IN DEGREES                                   "
               0  "     FSC      FINE STRUCTURE CONSTANT                                 "
               0  "     ERGMEV   ONE MILLION ELECTRON VOLTS EXPRESSED IN ERGS            "
               0  "     R0       CLASSICAL ELECTRON RADIUS                               "
               0  "     RM       ELECTRON REST ENERGY IN MEV                             "
               0  RADDEG=180./PI;
               0  FSC = ECGS**2/(HBAR*C);
               0  FSCI=1./FSC;
               0  "     1.E+7 IS THE NUMBER OF ERGS PER JOULE                            "
               0  ERGMEV = (1.E+6)*(EMKS*1.E+7);
               0  R0 = (ECGS**2)/(RME*C**2);
               0  RM = RME*C**2/ERGMEV;
               0  RMT2 = RM*2.0;
               0  RMSQ = RM*RM;
               0  "OUTPUT;(' DERIVED CONSTANTS--RADDEG,FSC,FSCI,ERGMEV,R0,RM,RMT2,RMSQ"
               0  " ');"
               0  "OUTPUT RADDEG,FSC,FSCI,ERGMEV,R0,RM,RMT2,RMSQ;(1P,8E14.6);"
               0  "     CALCULATION OF SOME CONSTANTS - -                                "
               0  "     NAGEL HAD THE ANGLE 22.9 DEGREES IN HIS EXPRESSION FOR THE       "
               0  "     CHARACTERISTIC ANGLE,CHIC.  BELOW IS THE ORIGINATING EXPRESSION. "
               0  A22P9 = RADDEG*SQRT(4.*PI*AN)*ECGS**2/ERGMEV;
               0  "     IN ADDITION NAGEL USES THE NUMBER 6680 IN HIS EXPRESSION FOR     "
               0  "     EXP(B) AS OBTAINED BY BETHE(1953),PG 1259,EQN.229  ITS ORIGINATIN"
               0  "     EXPRESSION IS--                                                  "
               0  A6680 = 4.0*PI*AN*(HBAR/(RME*C))**2*(0.885**2/(1.167*1.13));
               0  "OUTPUT A22P9,A6680;(' A22P9=',F15.6,',A6680 = ',F15.4);"
               0  RETURN;
               0  END; "END OF SUBROUTINE PMDCON"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE PWLF1(NI,NIMX,XL,XU,XR,EP,ZTHR,ZEP,NIP,XFUN,XFI,
               0  AX,BX,NALM,NFUN,AF,BF,VFUNS);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***PWLF1 IS A ROUTINE WHICH WILL FIT UP TO 10(CURRENTLY) FUNCTIONS  "
               0  "   SIMULTANEOUSLY ON AN INTERVAL (XL,XU) OF THE INDEPENDENT VARIABLE"
               0  "   X OF THE FUNCTIONS. THE FIT IS A PIECEWISE LINEAR FUNCTION OF    "
               0  "   XFUN(X).  XFI IS THE INVERSE FUNCTION OF XFUN.  THE SUBINTERVALS "
               0  "   ARE CHOSEN OF UNIFORM WIDTH IN XFUN(X) AND SUFFICIENT OF THEM    "
               0  "   ARE CHOSEN SO THAT THE FIT GIVES A RELATIVE ERROR[EP FOR ALL     "
               0  "   THE FUNCTIONS OVER ALL THE SUBINTERVALS.                         "
               0  "   QFIT IS AN AUXILIARY FUNCTION.       "
               0  "   EXPLANATION OF THE ARGUMENTS:                                    "
               0  "   NI   ON RETURN IS NUMBER OF SUBINTERVALS USED FOR THE FIT.       "
               0  "   XL   LOWER LIMIT OF INTERVAL ON WHICH TO FIT THE FUNCTIONS.      "
               0  "   XU   UPPER LIMIT                                                 "
               0  "   XR   VALUE OF X WHICH WILL BE FORCED TO BE A SUBINTERVAL BOUNDARY"
               0  "        THE SIGNIFICANCE OF THIS IS THAT THE STRAIGHT LINES ON THE  "
               0  "        SUBINTERVALS ARE CHOSEN TO FIT EXACTLY AT THE SUBINTERVAL   "
               0  "        BOUNDARIES, THUS IF ONE WANTS AN EXACT FIT OF THE FUNCTIONS "
               0  "        AT A PARTICULAR POINT, XR SHOULD BE SET TO THAT VALUE.      "
               0  "        OTHERWISE XR SHOULD BE SET TO XH.  ANOTHER REQUIREMENT      "
               0  "        IS THAT XU SHOULD BE LARGER THAN XL.                        "
               0  "   EP   THE MAXIMUM RELATIVE ERROR ALLOWED THE FIT.                 "
               0  "   NIP  THE MINUIMUM NUMBER OF POINTS INTERIOR TO (XL,XU) AT WHICH  "
               0  "        THE FIT IS TO BE TESTED FOR RELATIVE ERROR VS. EP.          "
               0  "   XFUN A FUNCTION OF X OVER WHICH IT IS HOPED THE FUNCTIONS TO BE  "
               0  "        FIT ARE MORE LINEAR THAN OVER X.  XFUN IS EXPECTED TO BE    "
               0  "        MONOTONICALLY INCREASING IN X.                              "
               0  "   XFI  THE INVERSE OF XFUN. THAT IS XFI(XFUN(X))=X.                "
               0  "   AX,BX ARE COEFFICIENTS USED AS SHOWN BELOW TO DETERMINE WHICH    "
               0  "        SUBINTERVAL A VALUE OF X IS IN.                             "
               0  "   AF,BF ARE ARRAYS OF COEFFICIENTS USED TO GET VALUES OF THE FUNCS."
               0  "   THE PROCEDURE FOR FINDING THE FIT VALUE OF FUNCTION IFUN IS:     "
               0  "   INTERV=AX*XFUN(X)+BX                                             "
               0  "   VALUE=AF(INTERV,IFUN)*XFUN(X)+BF(INTERV,IFUN)                    "
               0  "   NALM  IS THE MAXIMUM NUMBER OF SUBINTERVALS FOR WHICH ARRAY SPACE"
               0  "         HAS BEEN ALLOCATED.                                        "
               0  "   NFUN  IS THE NUMBER OF FUNCTIONS TO BE FITTED(SIMULTANEOUSLY,I.E."
               0  "         ALL FUNCTIONS HAVE THE SAME XFUN AND SUBINTERVALS, AND ALL "
               0  "         ARE REQUIRED TO BE FIT WITH MAX REL ERR[EP)                "
               0  "   VFUNS IS A SUBROUTINE TO FILL AN ARRAY WITH THE VALUES OF THE    "
               0  "   FUNCTIONS TO BE FITTED.                                          "
               0  ;
               0  implicit none;
               0
               0  $INTEGER NI,NIMX,NIP,NALM,NFUN;
               0  $REAL    XL,XU,XR,EP,AX,BX;
               0
               0  "*************************"
               0  "Fix errors for gcc > 10.0"
               0  "*************************"
               0  $REAL XFUN,XFI;
               0  EXTERNAL XFUN,XFI,VFUNS;
               0  "*************************"
               0  $REAL AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN);
               0  "   QFIT IS A LOGICAL FUNCTION WHICH IS TRUE IF THE STATED NUMBER    "
               0  "   OF INTERVALS GIVES A SUFFICIENTLY CLOSE FIT.                     "
               0  LOGICAL QFIT;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER NL,NU,IPRN,NJ,NK;
               0  $REAL    REM;
               0  "   FIND # OF INTERVALS REQUIRED.                                    "
               0  NL=0;
               0  NU=1;
               0  IPRN=0;
               0  LOOP [NJ=MIN0(NU,NIMX);
               1      IF (QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               1      AX,BX,NALM,NFUN,AF,BF,VFUNS,0)) EXIT;
               1      IF (NU.GE.NIMX) [
               2          OUTPUT NIMX,EP;
               2          (' NUMBER OF ALLOCATED INTERVALS(=',I5,') WAS INSUFFICIENT'
               2          ,/ ,' TO GET MAXIMUM RELATIVE ERROR LESS THAN ',1P,G14.6);
               2          NI=NJ;RETURN;]
               1      NL=NU;
               1      NU=NU*2;]
               0  "   WE NOW HAVE AN UPPER AND LOWER LIMIT ON NI, REFINE IT.           "
               0  NU=NJ ; "SAVE SUCCESSFUL INDEX"
               0  WHILE(NU.GT.NL+1)["LOOP UNTIL CONVERGENCE"
               1      NJ=(NL+NU)/2;
               1      NK=NJ; "THIS IS NECESSARY BECAUSE QFIT MAY LOWER NJ,BUT NEED ORIGINAL"
               1      " FOR SETTING NL OR MAY GET INTO INFINITE LOOP."
               1      IF (QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               1      AX,BX,NALM,NFUN,AF,BF,VFUNS,0))[NU=NJ;]ELSE[NL=NK;]
               1      ]
               0  "     NU IS NOW THE SMALLEST NI WHICH FITS OK.                       "
               0  NI=NU;
               0  IF (NI.EQ.NJ)RETURN;"LAST TEST WAS SUCCESS"
               0  "     CALL IT ONCE MORE TO GET THE FITS.                             "
               0  IF (.NOT.QFIT(NI,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               0  AX,BX,NALM,NFUN,AF,BF,VFUNS,0)) OUTPUT NI;
               0  (' CATASTROPHE---DOES NOT FIT WHEN IT SHOULD,NI=',I5);
               0  RETURN;
               0  END;  "END OF SUBROUTINE PWLF1"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE RFUNS(E,V);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  "*****SUBROUTINE TO COMPUTE RAYLEIGH FUNCTIONS TO BE FIT           "
               0  "     IN A WAY THAT AVOIDS REPETITION.                             "
               0  ;
               0  implicit none;
               0  $REAL E,V(1),AINTP;
               0  COMIN/RAYLEI/;
               0  V(1)=AINTP(E,AFFI(1),87,XVAL(1),1,.TRUE.,.TRUE.);
               0  RETURN;
               0  END; "END OF SUBROUTINE RFUNS"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE SPINIT;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0
               0  COMIN/PMCONS,SPCOMM,DERCON,MOLVAR,MIXDAT,ELEMTB,LSPION,EPSTAR,THRESH/;
               0  "                                   MOD NOV 23,1988    =============="
               0
               0  $REAL IMEV;
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER IM,J,IZ,IE,I,ICHECK,IESPEL,IPEGEL;
               0  $REAL    VPLASM,ALIADG,EDENL,ALGASP,EPSTRH,V2930,V2950,V2970,V2990,
               0  V3050,V3070,V3090,TLRNCE,EPSTWT,V3010,V3030;
               0
               0  TOLN10=2.0*ALOG(10.0);IM=-100;
               0
               0  IF(EPSTFL < 0 | EPSTFL > 1) [EPSTFL = 0;"ERROR ON INPUT, IGNORE"]
               0  "ABOVE IS NRCC MOD DEC 1988"
               0
               0  IF(EPSTFL=0)["DEFAULT TO STANDARD PEGS4 METHODS"
               1
               1      IF(ISSB.NE.0) ["USER HAS SUPPLIED THE NECESSARY SSB-DATA"
               2
               2          "ENSURE USER HAS INPUT ALL REQUIRED PARAMETERS AND CBAR IS >0.0"
               2          IF( AFACT.EQ.0.0  .OR. CBAR.LE.0.0  .OR. SK.EQ.0.0  .OR. X0.EQ.0.0
               2          .OR. X1.EQ.0.0 .OR. IEV.EQ.0.0 )[
               3              "USER MUST INPUT ALL 6 PARAMETERS OR ELSE THERE IS A MISTAKE -SO QUIT"
               3              OUTPUT;(//'0*****USER ERROR -NOT ALL DENSITY EFFECT PARAMTERS INPUT',
               3              '   CODE STOPPED IN SPINIT****'//);  $CALL_EXIT(21);]
               2          IMEV=IEV*1.E-6;  "EV TO MEV"
               2          VPLASM=SQRT(EDEN/PI*R0*C**2);
               2          IM=-1; "USED AS A FLAG BELOW"
               2          ]
               1
               1      ELSE ["MATERIAL MUST BE FOUND IN THE SSB TABLE OR THE S-P"
               2          "      GENERAL FORMULA WILL BE USED.  HOWEVER, FIRST CHECK"
               2          "      TO BE SURE THAT USER HAS NOT INCORRECTLY ATTEMPTED"
               2          "      TO OVERRIDE THE SSB-DATA."
               2          IF(ISSB.EQ.0.AND.(AFACT.NE.0.0.OR.CBAR.NE.0.0.OR.SK.NE.0.0.
               2          OR.X0.NE.0.0.OR.X1.NE.0.0.OR.IEV.NE.0.0)) [OUTPUT ;
               3              (//,' STOPPED IN SPINIT: INCORRECT USER-OVERRIDE OF SSB-DATA');
               3              $CALL_EXIT(21);
               3              ]
               2
               2          "CHECK TO SEE IF MATERIAL IS A 'STERNHEIMER-SELTZER-BERGER' (SSB)"
               2          "MATERIAL, FOR WHICH THE DENSITY EFFECT PARAMETERS ARE ALREADY"
               2          "SPECIFIED.  IF IT IS NOT, THEN CALCULATE THEM USING THE GENERAL"
               2          "FORMULA BY STERNHEIMER-PEIERLS (S-P)."
               2
               2          "STERNHEIMER-SELTZER-BERGER (SSB) LOOKUP TABLE SECTION:"
               2          :TRY: DO IM=1,NMED [DO J=1,LMED
               3              [IF (IDSTRN(J).NE.MEDTBL(J,IM)) NEXT :TRY:;]
               3              "CALCULATION FOLLOWS IF A MATCH IS FOUND"
               3              AFACT=STDATA(1,IM); SK=STDATA(2,IM); X0=STDATA(3,IM);
               3              X1=STDATA(4,IM); IEV=STDATA(5,IM); CBAR=STDATA(6,IM);
               3              IMEV=IEV*1.0E-6; "EV TO MEV"
               3              VPLASM=SQRT(EDEN/PI*R0*C**2);
               3              GO TO :SSB-PARAMETERS-DEFINED:;]
               2
               2          "STERNHEIMER-PEIERLS (S-P) GENERAL FORMULA SECTION:"
               2          IM=0;
               2          "DETERMINE THE MEAN EXCITATION ENERGY, IMEV (IN MEV)"
               2          IF (NE.EQ.1) ["ELEMENT"
               3              IZ=Z(1);
               3              IF (IZ.EQ.1.OR.IZ.EQ.7.OR.IZ.EQ.8) ["I.E., DIATOMIC MOLECULE"
               4                  OUTPUT ; (' STOPPED IN SUBROUTINE SPINIT BECAUSE THIS',/,
               4                  ' ELEMENT (H, N, OR O) CAN ONLY EXIST AS A DIATOMIC MOLECULE.',/,
               4                  ' REMEDY:  USE COMP OPTION FOR H2, N2, OR O2 WITH NE=2,PZ=1,1'/,
               4                  '          AND, IN THE CASE OF A GAS, DEFINE STERNHEIMER ID',/,
               4                  '          (I.E., IDSTRN) LIKE H2-GAS');
               4                  $CALL_EXIT(21);]
               3              IEV=ITBL(IZ);     "EV"
               3              ]
               2
               2          ELSE ["COMPOUND/MIXTURE---USE BRAGG ADDITIVITY RULE"
               3              ALIADG=0.0;
               3              DO IE=1,NE [
               4                  IZ=Z(IE);
               4                  IF (IZ.EQ.1) [IEV=19.2;]   "EV"
               4                  ELSEIF (IZ.EQ.6) [IF (GASP.EQ.0.0) [IEV=81.0;] ELSE [IEV=70.0;]]
               4                  ELSEIF (IZ.EQ.7) [IEV=82.0;]
               4                  ELSEIF (IZ.EQ.8) [IF (GASP.EQ.0.0) [IEV=106.0;] ELSE [IEV=97.0;]]
               4                  ELSEIF (IZ.EQ.9) [IEV=112.0;]
               4                  ELSEIF (IZ.EQ.17) [IEV=180.0;]
               4                  ELSE [IEV=1.13*ITBL(IZ);]
               4                  "NRCC comment - above 7 lines reflect table 6 in ref 59 of SLAC-265"
               4                  "       Berger and Seltzer's fudge to get better agreement with expt"
               4                  ALIADG=ALIADG + PZ(IE)*Z(IE)*ALOG(IEV);
               4                  ]
               3              ALIADG=ALIADG/ZC;
               3              IEV=EXP(ALIADG);    "EV"
               3              ]
               2
               2          IMEV=IEV*1.0E-6;  "EV TO MEV"
               2          "COMPUTE VARIOUS STERNHEIMER CONSTANTS"
               2          IF (GASP.EQ.0.0) [EDENL=EDEN;]
               2          ELSE ["VPLASM MUST BE FOR NTP FOR A GAS, AND EDEN HAS"
               3              "      BEEN DEFINED IN MIX FOR THE ACTUAL PRESSURE"
               3              EDENL=EDEN/GASP;]
               2          VPLASM = SQRT(EDENL/PI*R0*C**2);
               2          "ABOVE PATCHED JAN 9,1989 TO REFLECT ERROR POINTED OUT BY"
               2          "PROF KAMAE, TOKYO UNIVERSITY, VIA HIDEO HIRAYAMA"
               2
               2          CBAR=1. + 2.*ALOG(IMEV/(HBAR*2*PI*VPLASM/ERGMEV));
               2
               2          IF (NE.EQ.1.AND.IFIX(Z(1)).EQ.2.AND.GASP.NE.0.0)["SPECIAL HE(GAS) CASE"
               3              X0=2.191; X1=3.0; SK=3.297;
               3              ]
               2
               2          ELSEIF (NE.EQ.2.AND.IFIX(Z(1)).EQ.1.AND.IFIX(Z(2)).EQ.1) [
               3              IF (GASP.EQ.0.0) ["SPECIAL H2(LIQUID) CASE"
               4                  X0=0.425; X1=2.0; SK=5.949;
               4                  ]
               3              ELSE ["SPECIAL H2(GAS) CASE"
               4                  X0=1.837; X1=3.0; SK=4.754;
               4                  ]
               3              ]
               2
               2          ELSE ["REGULAR CASES"
               3              SK=3.0;
               3              IF (GASP.EQ.0.0) ["SOLIDS AND LIQUIDS"
               4                  IF (IEV.LT.100.0) [
               5                      IF (CBAR.LT.3.681) [X0=0.2; X1=2.0;]
               5                      ELSE [X0=0.326*CBAR - 1.0; X1=2.0;]
               5                      ]
               4                  ELSE ["IEV GE 100.0"
               5                      IF (CBAR.LT.5.215) [X0=0.2; X1=3.0;]
               5                      ELSE [X0=0.326*CBAR - 1.5; X1=3.0;]
               5                      ]
               4                  IF (X0.GE.X1) [OUTPUT X0,X1,CBAR;
               5                      (' STOPPED IN SPINIT DUE TO X0.GE.X1 , X0,X1,CBAR=',3G15.5,/
               5                      ,' IF THIS IS GAS, YOU MUST DEFINE GASP(ATM)'); $CALL_EXIT(21);]
               4                  ]
               3              ELSE ["GASES---AT NTP AT THIS STAGE"
               4                  IF (CBAR.LT.10.0) [X0=1.6; X1=4.0;]
               4                  ELSEIF (CBAR.LT.10.5) [X0=1.7; X1=4.0;]
               4                  ELSEIF (CBAR.LT.11.0) [X0=1.8; X1=4.0;]
               4                  ELSEIF (CBAR.LT.11.5) [X0=1.9; X1=4.0;]
               4                  ELSEIF (CBAR.LT.12.25) [X0=2.0; X1=4.0;]
               4                  ELSEIF (CBAR.LT.13.804) [X0=2.0; X1=5.0;]
               4                  ELSE [X0=0.326*CBAR - 2.5; X1=5.0;]
               4                  ]
               3              ]  "END OF STERNHEIMER-PEIERLS (S-P) GENERAL FORMULA SECTION"
               2          ]  "FINISHED CALCULATING DENSITY EFFECT PARAMETERS"
               1
               1      :SSB-PARAMETERS-DEFINED:
               1
               1      "GAS PRESSURE CORRECTION COMES NEXT"
               1      IF (GASP.NE.0.0) [
               2          ALGASP=ALOG(GASP);
               2          CBAR=CBAR - ALGASP;
               2          X0=X0 - ALGASP/TOLN10;
               2          X1=X1 - ALGASP/TOLN10;
               2          ]
               1
               1      IF (IM.EQ.0) [AFACT=(CBAR - TOLN10*X0)/(X1 - X0)**SK;]
               1      ]"END OF EPSTFL=0 BLOCK"
               0
               0  ELSE[ "EPSTFL=1 BLOCK  I.E. READ IN THE INPUT FROM THE DENSITY"
               1      "INPUT FILE"
               1
               1      READ(20,:A:)EPSTTL;:A:  FORMAT(A);
               1      READ(20,*) NEPST,IEV,EPSTRH,NELEPS;
               1      READ(20,*) (ZEPST(I),WEPST(I),I=1,NELEPS);
               1      READ(20,*) (EPSTEN(I),EPSTD(I),I=1,NEPST);
               1
               1      IF(NEPST>150)[OUTPUT NEPST;
               2          (//' *****NEPST=',I4,' IS GREATER THAN THE 150 ALLOWED');$CALL_EXIT(22);]
               1      "CONVERT TO TOTAL ENERGIES"
               1      DO I=1,NEPST[EPSTEN(I) = EPSTEN(I) + RM;]
               1      IMEV = IEV*1.E-06;
               1
               1      "CHECK THAT WE HAVE COVERED ENERGY RANGES NEEDED"
               1      IF( AE < EPSTEN(1))[OUTPUT EPSTEN(1),AE;
               2          (//' ****LOWEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E10.3/
               2          T20,'WHICH IS HIGHER THAN THE VALUE OF AE=',1P,E10.3,' MEV'/
               2          ' ***IT HAS BEEN SET TO AE***'//);EPSTEN(1) = AE;]
               1      IF( UE > EPSTEN(NEPST))[ OUTPUT EPSTEN(NEPST),UE;
               2          (//' ****HIGHEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E10.3/
               2          T20,'WHICH IS LOWER THAN THE VALUE OF UE=',1P,E10.3,' MEV'/
               2          ' ***IT HAS BEEN SET TO UE***'//);EPSTEN(NEPST) = UE;]
               1
               1      "DO A CHECK ON THE COMPOSITION AND DENSITY TO INSURE THE RIGHT DELTA"
               1      "HAS BEEN PICKED UP. ALLOW A TOLERANCE OF 1 PERCENT ERROR ON THE"
               1      "COMPOSITION BY WEIGHT."
               1
               1      ICHECK=0; "FLAG GETS SET TO UNITY IF THE COMPOSITION DOES NOT MATCH"
               1      TLRNCE=0.01; "TOLERANCE ALLOWED ON FRACTION BY WEIGHT"
               1
               1      "FIRST CHECK THAT THE NUMBER OF ELEMENTS ARE THE SAME"
               1      IF(NELEPS.NE.NE) ICHECK=1;
               1
               1      "NOW CHECK THAT THE DENSITIES ARE THE SAME WITHIN TOLERANCE"
               1      IF( (ICHECK.EQ.0)  .AND.
               1      ( (EPSTRH.LT.((1.0-TLRNCE)*RHO)) .OR. (EPSTRH.GT.((1.0+TLRNCE)*RHO))
               1      ) ) ICHECK=1; "DENSITY IS OUT OF RANGE"
               1      "WE MUST FIRST NORMALIZE THE PEGS FRACTIONS BY WEIGHT TO ENSURE THEY"
               1      "ARE NORMALIZED TO UNITY"
               1      EPSTWT = 0.0;DO I=1,NE[ EPSTWT = EPSTWT + RHOZ(I);]
               1      IF(EPSTWT=0.0)[
               2          OUTPUT;(//' *****IN SPINIT***SOMETHING WRONG, MOLECULAR WEIGHT OF',
               2          'MOLECULE IS ZERO (I.E. SUM OF RHOZ)***'//);]
               1
               1      IF(ICHECK.EQ.0)[
               2          IESPEL=0;    "INITIALIZE ESP ELEMENT COUNTER"
               2          ICHECK=1;    "ASSUME FAILURE"
               2          LOOP["LOOP OVER ESP COMPONENTS"
               3              IESPEL=IESPEL+1;
               3              IPEGEL=0;    "INITIALIZE PEGS ELEMENT COUNTER"
               3              LOOP["LOOP OVER PEGS COMPONENTS"
               4                  IPEGEL=IPEGEL+1;
               4                  IF(IFIX(Z(IPEGEL)).EQ.ZEPST(IESPEL))[ICHECK=0;EXIT;]
               4                  ]WHILE(IPEGEL.LT.NE);
               3              IF( (ICHECK.EQ.0) "Z OF ELEMENT MATCHES"
               3              .AND.
               3              ( (WEPST(IESPEL).LT.((1.0-TLRNCE)*RHOZ(IPEGEL)/EPSTWT))
               3              .OR. (WEPST(IESPEL).GT.((1.0+TLRNCE)*RHOZ(IPEGEL)/EPSTWT))
               3              ) ) ICHECK=1; "MATCHED ELEMENT BUT WEIGHT FRACTION WRONG"
               3              ]WHILE(IESPEL.LT.NELEPS);
               2          ] "END OF TEST FOR ICHECK = 0"
               1
               1      IF(ICHECK.EQ.1)[ "PRINT MESSAGE AND STOP"
               2          OUTPUT;
               2          (////'0*** COMPOSITION IN INPUT DENSITY FILE DOES NOT MATCH ',
               2          ' THAT BEING USED BY PEGS'//' ***** QUITTING EARLY***'////);
               2          $CALL_EXIT(23); " ERRORS DETECTED";
               2          ]
               1
               1
               1      ]"END OF EPSTFL=1 BLOCK"
               0
               0
               0  SPC1=2.*PI*R0**2*RM*EDEN*RLC;
               0  SPC2=ALOG((IMEV/RM)**2/2.0);
               0
               0  OUTPUT;(//' PARAMETERS COMPUTED IN SPINIT.'//1X,64('-'));
               0  IF(IM.EQ.0) [OUTPUT ;
               1      (' STERNHEIMER-PEIERLS GENERAL FORMULA USED FOR THE DENSITY EFFECT,');]
               0  ELSEIF(IM.GT.0) [OUTPUT;
               1      (' STERNHEIMER-SELTZER-BERGER TABLE USED FOR DENSITY EFFECT');]
               0  ELSEIF(IM = -1) [OUTPUT;
               1      (' STERNHEIMER-SELTZER-BERGER DENSITY EFFECT DATA SUPPLIED BY USER');]
               0  ELSE[
               1      OUTPUT EPSTTL;(' DENSITY EFFECT READ IN DIRECTLY:'/T10,A);]
               0  OUTPUT;(1X,64('-')/);
               0  OUTPUT IEV;(/' ADJUSTED MEAN IONIZATION = ',F8.2,' EV'/1X,38('-')//);
               0  IF(EPSTFL = 0) [$DUMP IEV,VPLASM,CBAR,X0,X1,SK,AFACT;]
               0  "$DUMP SPC1,SPC2;"
               0
               0  RETURN;
               0  END;  "END OF SUBROUTINE SPINIT"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ADDMOL(X);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0  $REAL    X;
               0
               0  COMIN/DERCON/;
               0  "     DERIVATE OF ADFMOL-PROPORTIONAL TO APPROXIMATE P.D.F.          "
               0  ADDMOL=1.0/(X-RM)**2;
               0  RETURN;
               0  END; "END OF FUNCTION ADDMOL"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ADFMOL(X);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0  $REAL X;
               0
               0  COMIN/DERCON/;
               0  "     APPROXIMATE C.D.F. FOR MOLLER AND BHABHA                       "
               0  ADFMOL=-1.0/(X-RM);
               0  RETURN;
               0  END; "END OF FUNCTION ADFMOL"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ADIMOL(X);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0  $REAL X;
               0
               0  COMIN/DERCON/;
               0  "     INVERSE OF ADFMOL                                              "
               0  ADIMOL=-1.0/X+RM;
               0  RETURN;
               0  END; "END OF FUNCTION ADIMOL"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION AFFACT(X);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL X,AINTP;
               0  COMIN/RAYLEI/;
               0  AFFACT=AINTP(X,XVAL(1),100,AFAC2(1),1,.TRUE.,.TRUE.);
               0  RETURN;
               0  END; "END OF FUNCTION AFFACT"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION AINTP(X,XA,NX,YA,ISK,XLOG,YLOG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0
               0  "     LINEAR OR LOG INTERPOLATION FUNCTION.                          "
               0
               0  "CHANGED"
               0  "REAL XA(1),YA(ISK,1);"
               0  "TO"
               0  "REAL XA(NX),YA(ISK,NX);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  $INTEGER NX,ISK;
               0  $REAL    X;
               0  $REAL    XA(NX),YA(ISK,NX);
               0  LOGICAL XLOG,YLOG,XLOGL;
               0
               0  $INTEGER I,J;
               0  $REAL    XI,XJ,XV,YI,YJ;
               0  XLOGL=XLOG;  "SET LOCAL VARIABLE"
               0  "     FIND INTERVAL FOR X INTERPOLATION.                             "
               0  DO J=2,NX[
               1      IF (X.LT.XA(J))GO TO :NSTEP:;]
               0  J=NX;
               0  :NSTEP:    I=J-1;
               0  IF (XA(I).LE.0.0) [XLOGL=.FALSE.;]
               0  IF (.NOT.XLOGL)[ XI=XA(I); XJ=XA(J); XV=X;]
               0  ELSE [XI=ALOG(XA(I)); XJ=ALOG(XA(J)); XV=ALOG(X);]
               0  IF (YLOG.AND.(YA(1,I).EQ.0.0.OR.YA(1,J).EQ.0.0))
               0  [AINTP=0.0;]
               0  ELSE[
               1      IF(YLOG)[YI=ALOG(YA(1,I));YJ=ALOG(YA(1,J));
               2          IF(XJ.EQ.XI) [AINTP=YI;]
               2          ELSE [AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI);]
               2          AINTP=EXP(AINTP);]
               1      ELSE[YI=YA(1,I); YJ=YA(1,J);
               2          IF(XJ.EQ.XI) [AINTP=YI;]
               2          ELSE [AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI);]]
               1      ]
               0  RETURN;
               0  END; "END OF FUNCTION AINTP"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ALIN(X);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "     FUNCTION TO CALL IF LINEAR DISTRIBUTION FUNCTION IS DESIRED      "
               0  implicit none;
               0  $REAL x;
               0  ALIN=X;
               0  RETURN;
               0  END; "END OF FUNCTION ALIN"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ALINI(X);  "INVERSE OF ALIN"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0  $REAL x;
               0  ALINI=X;
               0  RETURN;
               0  END;  "END OF FUNCTION ALINI"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ALKE(E);"LOG OF KINETIC ENERGY"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL E;
               0  COMIN/DERCON/;
               0  ALKE=ALOG(E-RM);
               0  RETURN;
               0  END;  "END OF FUNCTION ALKE"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ALKEI(X);"INVERSE OF LOG OF KINETIC ENERGY"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL x;
               0  COMIN/DERCON/;
               0  ALKEI=EXP(X) + RM;
               0  RETURN;
               0  END;  "END OF FUNCTION ALKEI"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION AMOLDM(EN0,EN);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***DIFFERENTIAL MOLLER CROSS SECTION FOR INCIDENT ELECTRON OF TOTAL"
               0  "   ENERGY EN0 TO PRODUCE SCATTERED ELECTRON OF TOTAL ENERGY EN."
               0  ;
               0  implicit none;
               0  $REAL EN0,EN;
               0  $REAL TM,EM,BETASQ,AMOLFM;
               0  COMIN/PMCONS,DERCON,MOLVAR,LAMOLM/;
               0  T0=EN0-RM;
               0  TM=T0/RM;
               0  EM=TM+1.;
               0  C1=(TM/EM)**2;
               0  C2=(2.*TM+1.)/EM**2;
               0  BETASQ=1.-1./EM**2;
               0  CMOLL=RLC*EDEN*2.*PI*R0**2/(BETASQ*T0*TM);"CONSTANT FACTOR IN EQ.2.10.1"
               0  AMOLDM=AMOLFM(EN);
               0  RETURN;
               0  END;  "END OF FUNCTION AMOLDM"
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION AMOLFM(EN);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL    EN;
               0  $REAL    T,EPS,EPSP,EPSI,EPSPI;
               0  COMIN/DERCON,LAMOLM/;
               0  T=EN-RM;
               0  EPS=T/T0;
               0  EPSP=1.-EPS;
               0  EPSI=1./EPS;
               0  EPSPI=1./EPSP;
               0  AMOLFM=CMOLL*(C1+EPSI*(EPSI-C2)+EPSPI*(EPSPI-C2) ); "EQ.2.10.1"
               0  RETURN;
               0  END; "END OF FUNCTION AMOLFM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION AMOLRM(EN0,EN1,EN2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL    EN0,EN1,EN2;
               0  $REAL    T0,T1,T2,TM,EM,C1,C2,BETASQ,CMOLL2,EPS1,EPSP1,EPS2,EPSP2;
               0  "***MOLLER CROSS SECTION FOR INCIDENT ELECTRON OF TOTAL ENERGY EN0 TO"
               0  "   PRODUCE SECONDARY ELECTRON IN THE TOTAL ENERGY RANGE EN1 TO EN2."
               0  COMIN/PMCONS,DERCON,MOLVAR/;
               0  T0=EN0-RM;
               0  T1=EN1-RM;
               0  T2=EN2-RM;
               0  TM=T0/RM;
               0  EM=TM+1.;
               0  C1=(TM/EM)**2;
               0  C2=(2.*TM+1.)/EM**2;
               0  BETASQ=1.-1./EM**2;
               0  CMOLL2=RLC*EDEN*2.*PI*R0**2/(BETASQ*TM); "CONSTANT FACTOR IN EQ.2.10.3"
               0  EPS1=T1/T0;
               0  EPSP1=1.-EPS1;
               0  EPS2=T2/T0;
               0  EPSP2=1.-EPS2;
               0  AMOLRM=CMOLL2*(C1*(EPS2-EPS1)+1./EPS1-1./EPS2+1./EPSP2-1./EPSP1
               0  -C2*ALOG(EPS2*EPSP1/(EPS1*EPSP2))); "EQ.2.10.3"
               0  RETURN;
               0  END; "END OF FUNCTION AMOLRM"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION AMOLTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL    E0;
               0  $REAL    T0,AMOLRM;
               0  "***TOTAL CROSS SECTION FOR MOLLER SCATTERING WITH INCIDENT ELECTRON"
               0  "   ENERGY(TOTAL) OF E0."
               0  COMIN/THRESH,DERCON/;
               0  IF (E0.LE.THMOLL) [AMOLTM=0.; ]
               0  ELSE [T0=E0-RM;
               1      AMOLTM=AMOLRM(E0,AE,T0*0.5+RM);] "EQ.2.10.6"
               0  RETURN;
               0  END; "END OF FUNCTION AMOLTM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ANIHDM(E0,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***DIFFERENTIAL TWO-PHOTON ANNIHILATION CROSS SECTION FOR POSITRON OF"
               0  "   INCIDENT TOTAL ENERGY E0 TO PRODUCE SECONDARY PHOTON OF ENERGY K."
               0  ;
               0  implicit none;
               0  $REAL    E0,K;
               0  $REAL    GAM,T0P,ANIHFM;
               0  COMIN/PMCONS,DERCON,MOLVAR,LANIHM/;
               0  GAM=E0/RM; "EQ.2.12.3"
               0  A=GAM+1.;  "EQ.2.12.4"
               0  T0P=GAM-1.;  "EQ.2.12.5"
               0  C1=RLC*EDEN*PI*R0**2/(A*T0P*RM); "EQ.2.12.9"
               0  C2=A+2.0*GAM/A;  "2.12.10"
               0  ANIHDM=ANIHFM(K);
               0  RETURN;
               0  END;   "END OF FUNCTION ANIHDM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ANIHFM(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL    K;
               0  COMIN/DERCON,LANIHM/;
               0  $REAL KP,S1,X;
               0  S1(X)=C1*(-1.+(C2-1.0/X)/X);  "STATEMENT FUNCTION---EQ.2.12.8"
               0  KP=K/RM;  "EQ.2.12.7"
               0  ANIHFM=S1(KP)+S1(A-KP);  "EQ.2.12.1"
               0  RETURN;
               0  END; "END OF FUNCTION ANIHFM"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ANIHRM(E0,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***TWO-PHOTON ANNIHILATION CROSS SECTION FOR INCIDENT POSITRON OF"
               0  "   TOTAL ENERGY E0 TO PRODUCE SECONDARY PHOTON IN THE ENERGY RANGE"
               0  "   K1 TO K2."
               0  ;
               0  implicit none;
               0  $REAL  E0,K1,K2;
               0  COMIN/PMCONS,DERCON,MOLVAR/;
               0  $REAL KP1,KP2,S2,X,C1,C2,GAM,A,T0P;
               0  S2(X)=RM*C1*(-X+C2*ALOG(X)+1.0/X); "STATEMENT FUNCTION---EQ.2.12.13"
               0  GAM=E0/RM; "EQ.2.12.3"
               0  KP1=K1/RM; "EQ.2.12.12"
               0  KP2=K2/RM; "EQ.2.12.12"
               0  A=GAM+1.;   "EQ.2.12.4"
               0  T0P=GAM-1.;  "EQ.2.12.5"
               0  C1=RLC*EDEN*PI*R0**2/(A*T0P*RM); "EQ.2.12.9"
               0  C2=A+2.*GAM/A;  "EQ.2.12.10"
               0  ANIHRM=S2(KP2)-S2(KP1)+S2(A-KP1)-S2(A-KP2); "EQ.2.12.11"
               0  RETURN;
               0  END;  "END OF FUNCTION ANIHRM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ANIHTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***TOTAL CROSS SECTION FOR TWO-PHOTON POSITRON-ELECTRON ANNIHILATION"
               0  "   WITH INCIDENT POSITRON ENERGY(TOTAL) OF E0."
               0  ;
               0  implicit none;
               0  $REAL    E0;
               0  $REAL    GAM,P0P2,P0P,CANIH;
               0  COMIN/PMCONS,DERCON,MOLVAR/;
               0  GAM=E0/RM;   "EQ.2.12.3"
               0  P0P2=GAM*GAM-1.0;
               0  P0P=SQRT(P0P2);  "EQ.2.12.6"
               0  CANIH=RLC*EDEN*PI*R0**2/(GAM+1.); "CONSTANT FACTOR IN EQ.2.12.14"
               0  ANIHTM=CANIH*((GAM*GAM+4.*GAM+1.)/P0P2*ALOG(GAM+P0P)
               0  -(GAM+3.)/P0P);   "EQ.2.12.14"
               0  RETURN;
               0  END;  "END OF FUNCTION ANIHTM"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  %L                                                                             ;
               0  %I4      "INDENT MORTRAN"                                                      ;
               0  !INDENT F2;
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION APRIM(Z,E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "     EMPIRICAL CORRECTION FACTOR TO BREMS CROSS SECTION               "
               0
               0  " This version can be switched to use different values:                "
               0  "   IAPRIM = 0  equivalent to old PEGS4 (default)                      "
               0  "            1  reads in values from unit 22                           "
               0  "            2  sets APRIM to 1.0                                      "
               0  " Future changes can be accommodated by reading in                     "
               0  " different data on unit 22 and if necessary changing the array sizes: "
               0
               0  ;
               0  implicit none;
               0  $REAL Z,E;
               0  $INTEGER  napre,naprz,ie,iz;
               0  $REAL     EM,AINTP;
               0  REPLACE {$NAPRE} WITH {115} " Maximum number of energies ( > 18 )      "
               0  REPLACE {$NAPRZ} WITH {14}  " Maximum number of elements ( > 5 )       "
               0
               0  REPLACE {$NAPR1} WITH {{COMPUTE $NAPRE - 18}}
               0  REPLACE {$NAPR2} WITH {{COMPUTE $NAPRZ - 5}}
               0  REPLACE {$NAPR3} WITH {{COMPUTE $NAPRE * $NAPR2}}
               0  ;COMIN/DERCON,EPSTAR/; "NRC CHANGE NOV 88"
               0  REAL APRIMD($NAPRE,$NAPRZ),EPRIM($NAPRE),ZPRIM($NAPRZ),APRIMZ($NAPRE);
               0  DATA APRIMD/
               0  1.32,1.26,1.18,1.13,1.09,1.07,1.05,1.04,1.03, 1.02,8*1.0,$NAPR1*0.0,
               0  1.34,1.27,1.19,1.13,1.09,1.07,1.05,1.04,1.03,1.02, 8*1.0,$NAPR1*0.0,
               0  1.39,1.30,1.21,1.14,1.10,1.07,1.05,1.04,1.03,1.02,0.994,
               0  2*0.991,0.990,2*0.989,2*0.988,$NAPR1*0.0,
               0  1.46,1.34,1.23,1.15,1.11,1.08, 1.06,1.05,1.03,1.02,0.989,
               0  0.973,0.971,0.969,0.967,0.965,2*0.963,$NAPR1*0.0,
               0  1.55,1.40,1.26,1.17,1.12,1.09,1.07,1.05,1.03,1.02,0.955,0.935,
               0  0.930,0.925,0.920,0.915,2*0.911,$NAPR1*0.0,
               0  $NAPR3*0.0/,
               0  EPRIM /
               0  2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,21.,31.,41.,51.,61.,71.,81.,91.,
               0  $NAPR1*0.0/,
               0  ZPRIM /6.,13.,29.,50.,79.,$NAPR2*0.0/;
               0  save APRIMD,EPRIM,ZPRIM,APRIMZ,napre,naprz;
               0
               0  IF (IAPRIM.EQ.0) [ " PEGS4 default APRIM"
               1      IF(IAPRFL = 0)[IAPRFL=1;OUTPUT;
               2          ('0IAPRIM=0, i.e. uses KOCH AND MOTZ empirical corrections to',
               2          ' brem cross section'/);]
               1      IF (E.GE.50) [ APRIM=1.; ]
               1      ELSE [ " INTERPOLATE APRIM OVER Z "
               2          EM=E/RM;
               2          DO IE=1,18[
               3              APRIMZ(IE)=
               3              AINTP(Z,ZPRIM,5,APRIMD(IE,1),$NAPRE,.FALSE.,.FALSE.);
               3              ] " Z INTERPOLATION IS NOW COMPLETE. NOW DO ENERGY "
               2          APRIM=AINTP(EM,EPRIM,18,APRIMZ,1,.FALSE.,.FALSE.);
               2          ]
               1      ]
               0  ELSEIF (IAPRIM.EQ.1) [
               1      IF (IAPRFL.EQ.0) [ " read in data from APRIME.DATA"
               2          OUTPUT;('0IAPRIM=1, i.e. uses NRC(based on NIST/ICRU)',
               2          ' corrections to brem cross section'/);
               2          READ(22,*) NAPRZ, NAPRE;
               2          IF (NAPRZ.GT.$NAPRZ) [
               3              OUTPUT; (//,' TOO MANY ELEMENTS FOR APRIME INTERPOLATION:',
               3              /,'   CHANGE $NAPRZ AND RECOMPILE PEGS'); $CALL_EXIT(24);]
               2          IF (NAPRE.GT.$NAPRE) [
               3              OUTPUT; (//,' TOO MANY ENERGIES FOR APRIME INTERPOLATION:',
               3              /,'   CHANGE $NAPRE AND RECOMPILE PEGS'); $CALL_EXIT(24);]
               2          READ(22,*) (EPRIM(IE),IE=1,NAPRE);
               2          DO IE=1,NAPRE [ EPRIM(IE)=1.+EPRIM(IE)/RM; ]
               2          DO IZ=1,NAPRZ [READ(22,*)ZPRIM(IZ),(APRIMD(IE,IZ),IE=1,NAPRE);]
               2          IAPRFL=1;
               2          ]
               1      EM=E/RM;
               1      DO IE=1,NAPRE [ " INTERPOLATE APRIM OVER LOG(Z)                "
               2          APRIMZ(IE)=
               2          AINTP(Z,ZPRIM,NAPRZ,APRIMD(IE,1),$NAPRE,.TRUE.,.FALSE.);
               2          ]           " NOW DO ENERGY INTERPOLATION     "
               1      APRIM=AINTP(EM,EPRIM,NAPRE,APRIMZ,1,.FALSE.,.FALSE.);
               1      ]
               0  ELSEIF (IAPRIM.EQ.2) [
               1      IF(IAPRFL = 0)[IAPRFL=1;
               2          OUTPUT;('0IAPRIM = 2, i.e. uses NO corrections to brem',
               2          ' cross section'/);]
               1      APRIM=1.0]
               0  ELSE [ OUTPUT IAPRIM; (//,' ILLEGAL VALUE FOR IAPRIM: ',I4); $CALL_EXIT(24); ]
               0  RETURN;
               0  END; "END OF FUNCTION APRIM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION AREC(X);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "     FUNCTION TO CALL WHEN DERIVATIVE OF LOG IS DESIRED              "
               0  implicit none;
               0  $REAL x;
               0  AREC=1.0/X;
               0  RETURN;
               0  END; "END OF FUNCTION AREC"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BHABDM(EN0,EN);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***DIFFERENTIAL BHABHA CROSS SECTION FOR INCIDENT POSITRON OF TOTAL"
               0  "   ENERGY EN0 TO PRODUCE SCATTERED ELECTRON OF TOTAL ENERGY EN."
               0  ;
               0  implicit none;
               0  $REAL EN0,EN;
               0  $REAL TM,EM,Y,BHABFM;
               0  COMIN/PMCONS,DERCON,MOLVAR,LBHABM/;
               0  T0=EN0-RM;
               0  TM=T0/RM;
               0  EM=TM+1.;
               0  Y=1./(TM+2.);
               0  BETASI=1./(1.-1./EM**2);
               0  CBHAB=RLC*EDEN*2.*PI*R0**2/(T0*TM); "CONSTANT FACTOR IN EQ.2.11.1"
               0  B1=2.-Y**2;
               0  B2=3.-Y*(6.-Y*(1.-Y*2.));
               0  B3=2.-Y*(10.-Y*(16.-Y*8.));
               0  B4=1.-Y*(6.-Y*(12.-Y*8.));
               0  BHABDM=BHABFM(EN);
               0  RETURN;
               0  END;  "END OF FUNCTION BHABDM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BHABFM(EN);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL EN;
               0  $REAL T,EPS,EPSI;
               0  COMIN/DERCON,LBHABM/;
               0  T=EN-RM;
               0  EPS=T/T0;
               0  EPSI=1./EPS;
               0  BHABFM=CBHAB*(EPSI*(EPSI*BETASI-B1)+B2+EPS*(EPS*B4-B3)); "EQ.2.11.1"
               0  RETURN;
               0  END;  "END OF FUNCTION BHABFM"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BHABRM(EN0,EN1,EN2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***BHABHA CROSS SECTION FOR INCIDENT POSITRON OF TOTAL ENERGY EN0 TO"
               0  "   PRODUCE SECONDARY ELECTRON IN THE TOTAL ENERGY RANGE EN1 TO EN2."
               0  ;
               0  implicit none;
               0  $REAL EN0,EN1,EN2;
               0  $REAL T0,T1,T2,TM,EM,Y,BETASI,CBHAB2,B1,B2,B3,B4,EPS1,EPS2;
               0  COMIN/PMCONS,DERCON,MOLVAR/;
               0  T0=EN0-RM;
               0  T1=EN1-RM;
               0  T2=EN2-RM;
               0  TM=T0/RM;
               0  EM=TM+1.;
               0  Y=1./(TM+2.);
               0  BETASI=1./(1.-1./EM**2);
               0  CBHAB2=RLC*EDEN*2.*PI*R0**2/TM; "CONSTANT FACTOR IN EQ.2.11.2"
               0  B1=2.-Y**2;
               0  B2=3.-Y*(6.-Y*(1.-Y*2.));
               0  B3=2.-Y*(10.-Y*(16.-Y*8.));
               0  B4=1.-Y*(6.-Y*(12.-Y*8.));
               0  EPS1=T1/T0;
               0  EPS2=T2/T0;
               0  BHABRM=CBHAB2*(BETASI*(1./EPS1-1./EPS2)-B1*ALOG(EPS2/EPS1)
               0  +B2*(EPS2-EPS1)+EPS2*EPS2*(EPS2*B4/3.-0.5*B3)
               0  - EPS1*EPS1*(EPS1*B4/3.-0.5*B3));  "EQ.2.11.2"
               0  RETURN;
               0  END; "END OF FUNCTION BHABRM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BHABTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***TOTAL CROSS SECTION FOR BHABHA SCATTERING WITH INCIDENT POSITRON"
               0  "   ENERGY(TOTAL) OF E0."
               0  ;
               0  implicit none;
               0  $REAL E0,BHABRM;
               0  COMIN/THRESH,DERCON/;
               0  IF (E0.LE.AE) [BHABTM=0.;]
               0  ELSE [BHABTM=BHABRM(E0,AE,E0);]  "EQ.2.11.4"
               0  RETURN;
               0  END; "END OF FUNCTION BHABTM"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BREMDR(EA,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL EA,K;
               0  "***RUN TIME BREM D-SIGMA/D-K          "
               0
               0  "EVALUATES EQUATION 2.7.108 OF SLAC-265"
               0  ;
               0  $INTEGER LS;
               0  $REAL    BREMFR;
               0
               0  COMIN/LBREMR/;
               0  E=EA;
               0  IF (E.GE.50.) [LD=2; LS=3;]
               0  ELSE [LD=1;LS=0;]
               0  LA=LS+1;
               0  LB=LS+2;
               0  BREMDR=BREMFR(K);
               0  RETURN;
               0  END;   "END OF FUNCTION BREMDR"
               0
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BREMDZ(Z,E,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL    Z,E,K,BRMSDZ;
               0  "***ALL ENTRIES TO THIS FUNCTION GIVE THE CONTRIBUTION THAT ELEMENT Z"
               0  "   WOULD HAVE IF THERE WERE ONE PER MOLECULE.                      "
               0  "   ENTRIES STARTING WITH D DO THEIR OWN INITIALIZATION.             "
               0  "   ENTRIES STARTING WITH F RELY ON PREVIOUS D FOR INITIALIZATION.   "
               0  "   BREMDZ.. D-SIGMA/D-K FOR BREMS IN Z                              "
               0  "   BRMSDZ.. K*(D-SIGMA/D-K) FOR SOFT ENERGY LOSS FROM BREMS IN Z    "
               0
               0  "EVALUATES EQUATION 2.7.108 IN SLAC-265"
               0
               0  BREMDZ=BRMSDZ(Z,E,K)/K;
               0  RETURN;
               0  END;  "END OF FUNCTION BREMDZ"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BREMFR(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL K;
               0  $REAL EPS,DEL,DELTA,A,B;
               0  COMIN/BREMPR,DBRPR,LBREMR/;
               0  EPS=K/E;
               0  DEL=EPS/(E*(1-EPS));
               0  IF (DEL.GT.DELPOS(LD)) [BREMFR=0.0; RETURN;]
               0  DELTA=DELCM*DEL;
               0  IF (DELTA.LE.1.)[
               1      A=DL1(LA)+DELTA*(DL2(LA)+DELTA*DL3(LA));
               1      B =DL1(LB)+DELTA*(DL2(LB)+DELTA*DL3(LB));]
               0  ELSE [A=DL4(LA)+DL5(LA)*ALOG(DELTA+DL6(LA));
               1      B =DL4(LB)+DL5(LB)*ALOG(DELTA+DL6(LB));]
               0  BREMFR=(ALPHI(LD)*(1.-EPS)/EPS/AL2*A+0.5*(2.*EPS)*B)/E;
               0  RETURN;
               0  END;  "END OF FUNCTION BREMFR"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BREMFZ(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL K,BRMSFZ;
               0  BREMFZ=BRMSFZ(K)/K;
               0  RETURN;
               0  END;  "END OF FUNCTION BREMFZ"
               0
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BREMRR(E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL E,K1,K2;
               0  "*************************"
               0  "Fix errors for gcc > 10.0"
               0  "*************************"
               0  $REAL BREMFR;
               0  EXTERNAL BREMFR;
               0  "*************************"
               0  $REAL    DUMMY,QD,BREMDR;
               0  "     INITIALIZE BREMFR                                                "
               0
               0  "    CHANGED"
               0
               0  "    CALL BREMDR(E,K1);"
               0
               0  "    TO"
               0
               0  "    DUMMY=BREMDR(E,K1);"
               0
               0  "    FOR SUN COMATIBILITY AFB 89/12/27"
               0
               0  DUMMY=BREMDR(E,K1);
               0
               0  BREMRR=QD(BREMFR,K1,K2,'BREMFR');
               0  RETURN;
               0  END; "END OF FUNCTION BREMRR"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BREMRM(E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL E,K1,K2;
               0  $INTEGER I;
               0  $REAL    BREMRZ;
               0  COMIN/MIXDAT/;
               0  BREMRM=0.;
               0  DO I=1,NE [BREMRM=BREMRM+PZ(I)*BREMRZ(Z(I),E,K1,K2);]
               0  RETURN;
               0  END; "END OF FUNCTION BREMRM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BREMRZ(Z,E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL Z,E,K1,K2;
               0  "*************************"
               0  "Fix errors for gcc > 10.0"
               0  "*************************"
               0  $REAL BREMFZ;
               0  EXTERNAL BREMFZ;
               0  "*************************"
               0  $REAL  DUMMY,BREMDZ,QD;
               0  "     INITIALIZE BREMFZ                                                "
               0
               0  "    CHANGED"
               0
               0  "    CALL BREMDZ(Z,E,K1);"
               0
               0  "    TO"
               0
               0  "    DUMMY=BREMDZ(Z,E,K1);"
               0
               0  "    FOR SUN COMATIBILITY AFB 89/12/27"
               0
               0  DUMMY=BREMDZ(Z,E,K1);
               0
               0  BREMRZ=QD(BREMFZ,K1,K2,'BREMFZ');
               0  RETURN;
               0  END; "END OF FUNCTION BREMRZ"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BREMTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL E0,BREMRM;
               0  COMIN/THRESH,DERCON/;
               0  IF (E0.LE.AP+RM) [BREMTM=0.; ]
               0  ELSE [BREMTM=BREMRM(E0,AP,E0-RM);]
               0  RETURN;
               0  END; "END OF FUNCTION BREMTM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BREMTR(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL E0,BREMRR;
               0  COMIN/THRESH,DERCON/;
               0  IF (E0.LE.AP+RM) [BREMTR=0.; ]
               0  ELSE [BREMTR=BREMRR(E0,AP,E0-RM);]
               0  RETURN;
               0  END; "END OF FUNCTION BREMTR"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BRMSDZ(Z,EA,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL Z,EA,K;
               0  $REAL APRIM,XSIF,FCOULC,BRMSFZ;
               0  COMIN/PMCONS,DERCON,MOLVAR,LBREMZ/;
               0  E=EA;
               0  DELC=136.*Z**(-1./3.)*RM/E;
               0  CONST=APRIM(Z,E)*(AN*RHO/WM)*R0**2*FSC*Z*(Z+XSIF(Z))*RLC;
               0  XLNZ=4./3.*ALOG(Z);
               0  IF (E.GE.50)XLNZ=XLNZ+4.*FCOULC(Z);
               0  ".....DELTAM IS THE DELTA AT WHICH THE SQUARE BRACKETS GO TO ZERO      "
               0  DELTAM=EXP((21.12-XLNZ)/4.184)-0.952;
               0  BRMSDZ=BRMSFZ(K);
               0  RETURN;
               0  END;  "END OF FUNCTION BRMSDZ"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BRMSFZ(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL K;
               0  $REAL EMKLOC,DELTA,SB1,SB2,EE;
               0  COMIN/LBREMZ/;
               0  EMKLOC=E-K;
               0  IF(EMKLOC.EQ.0.0) [EMKLOC=1.E-25;]
               0  DELTA=DELC*K/EMKLOC;
               0  IF (DELTA.GE.DELTAM) [BRMSFZ=0.0;]
               0  ELSE [IF (DELTA.LE.1.)[
               2          SB1=20.867+DELTA*(-3.242+DELTA*0.625)-XLNZ;
               2          SB2=20.209+DELTA*(-1.930+DELTA*(-0.086))-XLNZ;]
               1      ELSE [SB1=21.12-4.184*ALOG(DELTA+0.952)-XLNZ;
               2          SB2=SB1;]
               1      EE=EMKLOC/E;
               1      BRMSFZ=CONST*((1.+EE*EE)*SB1-0.666667*EE*SB2);]
               0  RETURN;
               0  END; "END OF FUNCTION BRMSFZ"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BRMSRM(E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0  $REAL E,K1,K2,BRMSRZ;
               0  $INTEGER I;
               0  COMIN/MIXDAT/;
               0  BRMSRM=0.;
               0  DO I=1,NE[BRMSRM=BRMSRM+PZ(I)*BRMSRZ(Z(I),E,K1,K2);]
               0  RETURN;
               0  END; "END OF FUNCTION BRMSRM"
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BRMSRZ(Z,E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL Z,E,K1,K2;
               0  "*************************"
               0  "Fix errors for gcc > 10.0"
               0  "*************************"
               0  $REAL BRMSFZ;
               0  EXTERNAL BRMSFZ;
               0  "*************************"
               0  $REAL DUMMY,BRMSDZ,QD;
               0  "     INITIALIZE BRMSFZ                                                "
               0
               0  "    CHANGED"
               0
               0  "    CALL BRMSDZ(Z,E,K1);"
               0
               0  "    TO"
               0
               0  "    DUMMY=BRMSDZ(Z,E,K1);"
               0
               0  "    FOR SUN COMATIBILITY AFB 89/12/27"
               0
               0  DUMMY=BRMSDZ(Z,E,K1);
               0
               0  BRMSRZ=QD(BRMSFZ,K1,K2,'BRMSFZ');
               0  RETURN;
               0  END; "END OF FUNCTION BRMSRZ"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION BRMSTM(E0,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL E0,EG,BRMSRM,AU,zero;
               0  parameter (zero=0);
               0  COMIN/DERCON/;
               0  IF (E0.LE.RM) [BRMSTM=0.; ]
               0  ELSE [AU=AMIN1(EG,E0-RM);
               1      BRMSTM=BRMSRM(E0,zero,AU);]
               0  RETURN;
               0  END; "END OF FUNCTION BRMSTM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION COHETM(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL K,COHETZ;
               0  $INTEGER I;
               0  COMIN/MIXDAT/;
               0  COHETM=0.0;
               0  DO I=1,NE [
               1      COHETM=COHETM+PZ(I)*COHETZ(Z(I),K);]
               0  RETURN;
               0  END; "END OF FUNCTION COHETM"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION COHETZ(Z,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL Z,K;
               0  $INTEGER IZ;
               0  $REAL    PCON,AINTP;
               0  COMIN/MOLVAR,PHPAIR,PMCONS,RAYLEI/;
               0
               0  "PCON CONVERTS STORM AND ISRAEL CROSS SECTION IN BARNS/ATOM"
               0  "INTO 1/RLC FOR COHERENT SCATTERING "
               0  PCON= 1.E-24*(AN*RHO/WM)*RLC;
               0
               0  IZ=Z;
               0  COHETZ=PCON*AINTP(K,PHE(1,IZ),NPHE(IZ),COHE(1,IZ),1,.TRUE.,.TRUE.);
               0  RETURN;
               0  END; "END OF FUNCTION COHETZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION COMPDM(K0A,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***DIFFERENTIAL CROSS SECTION FOR INCIDENT PHOTON OF ENERGY K0A TO"
               0  "   COMPTON SCATTER TO SECONDARY ENERGY K."
               0  ;
               0  implicit none;
               0  $REAL K0A,K,K0P,COMPFM;
               0  COMIN/PMCONS,DERCON,MOLVAR,LCOMPM/;
               0  K0=K0A;
               0  K0P=K0/RM;
               0  CCOMP=RLC*EDEN*PI*R0**2/(K0*K0P);  "CONSTANT FACTOR IN EQ. 2.9.1"
               0  C1=1./K0P**2;
               0  C2=1.-(2.+2.*K0P)/K0P**2;
               0  C3=(1.+2.*K0P)/K0P**2;
               0  COMPDM=COMPFM(K);
               0  RETURN;
               0  END;  "END OF FUNCTION COMPDM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION COMPFM(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL K,EPS,EPSI;
               0  COMIN/LCOMPM/;
               0  EPS=K/K0;
               0  EPSI=1./EPS;
               0  COMPFM=CCOMP*( (C1*EPSI+C2)*EPSI+C3+EPS );  "EQ.2.9.1"
               0  RETURN;
               0  END; "END OF FUNCTION COMPFM"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION COMPRM(K0,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***COMPTON CROSS SECTION FOR INCIDENT PHOTON OF ENERGY K0 TO SCATTER"
               0  "   INTO THE ENERGY RANGE K1 TO K2."
               0  ;
               0  implicit none;
               0  COMIN/PMCONS,DERCON,MOLVAR/;
               0  $REAL K0,K1,K2,CCOMP2;
               0  REAL*8 C1,C2,C3,EPS1,EPS2,K0P;"FOR VERY LOW ENERGY PHOTONS"
               0  K0P=K0/RM;
               0  CCOMP2=RLC*EDEN*PI*R0**2/K0P; "CONSTANT FACTOR IN EQ.2.9.2"
               0  C1=1./K0P**2;
               0  C2=1.-(2.+2.*K0P)/K0P**2;
               0  C3=(1.+2.*K0P)/K0P**2;
               0  EPS1=K1/K0;
               0  EPS2=K2/K0;
               0  COMPRM=CCOMP2*(C1*(1./EPS1-1./EPS2)+C2*DLOG(EPS2/EPS1)+EPS2*
               0  (C3+0.5*EPS2) - EPS1*(C3+0.5*EPS1) );  "EQ. 2.9.2"
               0  RETURN;
               0  END; "END OF FUNCTION COMPRM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION COMPTM(K0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***TOTAL CROSS SECTION FOR COMPTON SCATTERING WITH INCIDENT PHOTON"
               0  "   ENERGY K0."
               0  ;
               0  implicit none;
               0  $REAL K0,K1,COMPRM;
               0  COMIN/DERCON/;
               0  K1=K0*RM/(RM+2.*K0);
               0  COMPTM=COMPRM(K0,K1,K0);  "EQ. 2.9.7"
               0  RETURN;
               0  END; "END OF FUNCTION COMPTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION CRATIO(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  "***RAYLEIGH CORRECTION FACTOR (I.E., COHERENT RATIO)"
               0  implicit none;
               0  $REAL E,PAIRTU,COMPTM,PHOTTE,TOT,COHETM;
               0  TOT=PAIRTU(E)+COMPTM(E)+PHOTTE(E);
               0  CRATIO=TOT/(TOT+COHETM(E));
               0  RETURN;
               0  END; "END OF FUNCTION CRATIO"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  !LABELS 10000; "AVOIDS MORTRAN-FORTRAN LABEL CONFUSION POSSIBILITY "
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  DOUBLE PRECISION FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER);
               0  implicit none;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  "                                                                  "
               0  "                                                                  "
               0  "------------------------------------------------------------------"
               0  "-DCADRE--------D-------LIBRARY 1----------------------------------"
               0  "------------------------------------------------------------------"
               0  "                                                                  "
               0  "FUNCTION:          - INTEGRATE F(X) FROM A TO B, USING CAUTIOUS   "
               0  "                     ADAPTIVE ROMBERG EXTRAPOLATION.              "
               0  "                                                                  "
               0  "USAGE:             - FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER)   "
               0  "                                                                  "
               0  "PARAMETERS: DCADRE - ESTIMATE OF THE INTEGRAL OF F(X) FROM A TO B."
               0  "                                                                  "
               0  "            F      - A SINGLE-ARGUMENT REAL FUNCTION SUBPROGRAM   "
               0  "                     SUPPLIED BY THE USER.  F MUST BE DECLARED    "
               0  "                     EXTERNAL IN THE CALLING PROGRAM.             "
               0  "                                                                  "
               0  "            A,B    - THE TWO ENDPOINTS OF THE INTERVAL OF         "
               0  "                     INTEGRATION (INPUT).                         "
               0  "                                                                  "
               0  "            AERR   - DESIRED ABSOLUTE ERROR IN THE ANSWER (INPUT)."
               0  "                                                                  "
               0  "            RERR   - DESIRED RELATIVE ERROR IN THE ANSWER (INPUT)."
               0  "                                                                  "
               0  "            ERROR  - ESTIMATED BOUND ON THE ABSOLUTE ERROR OF     "
               0  "                     THE OUTPUT NUMBER, DCADRE.                   "
               0  "                                                                  "
               0  "            IER    - ERROR PARAMETER                              "
               0  "                                                                  "
               0  "                     WARNING ERROR(WITH FIX) = 64 + N             "
               0  "                                                                  "
               0  "                       N = 1 IMPLIES THAT ONE OR MORE SINGULAR-   "
               0  "                             ITIES WERE SUCCESSFULLY HANDLED.     "
               0  "                                                                  "
               0  "                       N = 2 IMPLIES THAT, IN SOME SUBINTERVAL(S),"
               0  "                             THE ESTIMATE OF THE INTEGRAL WAS     "
               0  "                             ACCEPTED MERELY BECAUSE THE ESTIMATED"
               0  "                             ERROR WAS SMALL, EVEN THOUGH NO REG- "
               0  "                             ULAR BEHAVIOR WAS RECOGNIZED.        "
               0  "                                                                  "
               0  "                     TERMINAL ERROR = 128 + N                     "
               0  "                                                                  "
               0  "                       N = 3 FAILURE DUE TO INSUFFICIENT INTERNAL "
               0  "                             WORKING STORAGE.                     "
               0  "                                                                  "
               0  "                       N = 4 FAILURE.  THIS MAY BE DUE TO TOO MUCH"
               0  "                             NOISE IN THE FUNCTION (RELATIVE TO   "
               0  "                             THE GIVEN ERROR REQUIREMENTS) OR DUE "
               0  "                             TO AN ILL-BEHAVED INTEGRAND.         "
               0  "                                                                  "
               0  "                       N = 5 INDICATES THAT RERR IS GREATER THAN  "
               0  "                             0.1, OR RERR IS LESS THAN 0.0, OR    "
               0  "                             RERR IS TOO SMALL FOR THE PRECISION  "
               0  "                             OF THE MACHINE.                      "
               0  "                                                                  "
               0  "------------------------------------------------------------------"
               0  "VERSION DATE:      - 8 OCTOBER 1974                               "
               0  "                                                                  "
               0  "MORTRAN VERSION    - 4 OCTOBER 1984/1545 (W. R. NELSON)           "
               0  "------------------------------------------------------------------"
               0  "                                                                  "
               0  ; "NOTE: SEMI-COLON TO CLEAR MORTRAN BUFFER                        "
               0  "                                                                  "
               0  "ADDED"
               0  "EXTERNAL F;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  "*************************"
               0  "Fix errors for gcc > 10.0"
               0  "*************************"
               0  $REAL F;
               0  EXTERNAL F;
               0  "*************************"
               0  DIMENSION T(10,10),R(10),AIT(10),DIF(10),RN(4),TS(2049);
               0  DIMENSION IBEGS(30),BEGIN(30),FINIS(30),EST(30);
               0  DIMENSION REGLSV(30);
               0  LOGICAL H2CONV,AITKEN,RIGHT,REGLAR,REGLSV;
               0  DOUBLE PRECISION T,R,AIT,DIF,RN,TS,BEGIN,FINIS,EST,AITLOW;
               0  DOUBLE PRECISION H2TOL,AITTOL,LENGTH,JUMPTL,ZERO,P1,HALF,ONE;
               0
               0  "CHANGED"
               0  "DOUBLE PRECISION TWO,FOUR,FOURP5,TEN,HUN,CADRE,F,ERROR,A,B;"
               0  "TO"
               0  "DOUBLE PRECISION TWO,FOUR,FOURP5,TEN,HUN,CADRE,ERROR,A,B;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  DOUBLE PRECISION TWO,FOUR,FOURP5,TEN,HUN,CADRE,ERROR,A,B;
               0
               0  DOUBLE PRECISION AERR,RERR,STEPMN,STEPNM,STAGE,CUREST,FNSIZE;
               0  DOUBLE PRECISION PREVER,BEG,FBEG,END,FEND,STEP,ASTEP,TABS,HOVN;
               0  DOUBLE PRECISION FN,SUM,SUMABS,ABSI,VINT,TABTLM,ERGL,ERGOAL;
               0  DOUBLE PRECISION ERRA,ERRR,FEXTRP,ERRER,DIFF,SING,FEXTM1,ALG4O2;
               0  DOUBLE PRECISION H2NXT,SINGNX,SLOPE,FBEG2,ALPHA;
               0  DOUBLE PRECISION ERRET,H2TFEX,FI;
               0
               0  "ADDED"
               0  "REAL RVAL,F;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  "REAL RVAL,F;"
               0  REAL RVAL;
               0
               0  $INTEGER IBEGS,IER,ISTAGE,IBEG,IEND,L,N,LM1,N2,ISTEP,II,III,I,ISTEP2,IT,NNLEFT;
               0  $INTEGER MAXTS,MAXTBL,MXSTGE;
               0  DATA AITLOW,H2TOL,AITTOL,JUMPTL,MAXTS,MAXTBL,MXSTGE/1.1D0,.15D0,
               0  .1D0,.01D0,2049,10,30/;
               0  DATA RN(1),RN(2),RN(3),RN(4)/.7142005D0,.3466282D0,.843751D0,
               0  .1263305D0/;
               0  DATA ZERO,P1,HALF,ONE,TWO,FOUR,FOURP5,TEN,HUN/0.0D0,0.1D0,0.5D0,
               0  1.0D0,2.0D0,4.0D0,4.5D0,10.0D0,100.0D0/;
               0  save MAXTS,MAXTBL,MXSTGE;
               0  ALG4O2=DLOG10(TWO);
               0  /CADRE,ERROR,CUREST,VINT/=ZERO;
               0  IER=0;
               0  LENGTH=DABS(B-A);
               0  IF(LENGTH.EQ.ZERO) GO TO 215;
               0  IF(RERR.GT.P1.OR.RERR.LT.ZERO) GO TO 210;
               0  IF(AERR.EQ.ZERO.AND.(RERR+HUN).LE.HUN) GO TO 210;
               0  ERRR=RERR;
               0  ERRA=DABS(AERR);
               0  STEPMN=(LENGTH/FLOAT(2**MXSTGE));
               0  STEPNM=DMAX1(LENGTH,DABS(A),DABS(B))*TEN;
               0  STAGE=HALF;
               0  ISTAGE=1;
               0  FNSIZE=ZERO;
               0  PREVER=ZERO;
               0  REGLAR=.FALSE.;
               0  "                              THE GIVEN INTERVAL OF INTEGRATION   "
               0  "                                IS THE FIRST INTERVAL CONSIDERED. "
               0  BEG=A;
               0
               0  "CHANGED"
               0  "FBEG=F(BEG)*HALF;"
               0  "TO"
               0  "RVAL=BEG;FBEG=F(RVAL)*HALF;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=BEG;FBEG=F(RVAL)*HALF;
               0
               0  TS(1)=FBEG;
               0  IBEG=1;
               0  END=B;
               0
               0  "CHANGED"
               0  "FEND=F(END)*HALF;"
               0  "TO"
               0  "RVAL=END;FEND=F(RVAL)*HALF;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=END;FEND=F(RVAL)*HALF;
               0
               0  TS(2)=FEND;
               0  IEND=2;
               0  5 RIGHT=.FALSE.;
               0  "                              INVESTIGATION OF A PARTICULAR       "
               0  "                                SUBINTERVAL BEGINS AT THIS POINT. "
               0  10 STEP=END - BEG;
               0  ASTEP=DABS(STEP);
               0  IF(ASTEP.LT.STEPMN) GO TO 205;
               0  IF(STEPNM+ASTEP.EQ.STEPNM) GO TO 205;
               0  T(1,1)=FBEG + FEND;
               0  TABS=DABS(FBEG) + DABS(FEND);
               0  L=1;
               0  N=1;
               0  H2CONV=.FALSE.;
               0  AITKEN=.FALSE.;
               0  15 LM1=L;
               0  L=L + 1;
               0  "                              CALCULATE THE NEXT TRAPEZOID SUM,   "
               0  "                                T(L,1), WHICH IS BASED ON *N2* + 1"
               0  "                                EQUISPACED POINTS. HERE,          "
               0  "                                N2 = N*2 = 2**(L-1).              "
               0  N2=N + N;
               0  FN=N2;
               0  ISTEP=(IEND - IBEG)/N;
               0  IF(ISTEP.GT.1) GO TO 25;
               0  II=IEND;
               0  IEND=IEND + N;
               0  IF(IEND.GT.MAXTS) GO TO 200;
               0  HOVN=STEP/FN;
               0  III=IEND;
               0  FI=ONE;
               0  DO I=1,N2,2[
               1      TS(III)=TS(II);
               1
               1      "CHANGED"
               1      "TS(III-1)=F(END - FI * HOVN);"
               1      "TO"
               1      "RVAL=END-FI*HOVN;TS(III-1)=F(RVAL);"
               1      "FOR SUN AFB 89/12/27"
               1
               1      RVAL=END-FI*HOVN;TS(III-1)=F(RVAL);
               1
               1      FI=FI+TWO;
               1      III=III-2;
               1      II=II-1;]
               0  ISTEP=2;
               0  25 ISTEP2=IBEG + ISTEP/2;
               0  SUM=ZERO;
               0  SUMABS=ZERO;
               0  DO I=ISTEP2,IEND,ISTEP[
               1      SUM=SUM + TS(I);
               1      SUMABS=SUMABS + DABS(TS(I));]
               0  T(L,1)=T(L-1,1)*HALF+SUM/FN;
               0  TABS=TABS*HALF+SUMABS/FN;
               0  ABSI=ASTEP*TABS;
               0  N=N2;
               0  "                              GET PRELIMINARY VALUE FOR *VINT*    "
               0  "                                FROM LAST TRAPEZOID SUM AND UPDATE"
               0  "                                THE ERROR REQUIREMENT *ERGOAL*    "
               0  "                                FOR THIS SUBINTERVAL.             "
               0  IT=1;
               0  VINT=STEP*T(L,1);
               0  TABTLM=TABS*TEN;
               0  FNSIZE=DMAX1(FNSIZE,DABS(T(L,1)));
               0  ERGL=ASTEP*FNSIZE*TEN;
               0  ERGOAL=STAGE*DMAX1(ERRA,ERRR*DABS(CUREST+VINT));
               0  "                              COMPLETE ROW L AND COLUMN L OF *T*  "
               0  "                                ARRAY.                            "
               0  FEXTRP=ONE;
               0  DO I=1,LM1[
               1      FEXTRP=FEXTRP*FOUR;
               1      T(I,L)=T(L,I) - T(L-1,I);
               1      T(L,I+1)=T(L,I) + T(I,L)/(FEXTRP-ONE);]
               0  ERRER=ASTEP*DABS(T(1,L));
               0  "                              PRELIMINARY DECISION PROCEDURE      "
               0  "                                IF L = 2 AND T(2,1) = T(1,1),     "
               0  "                                GO TO 135 TO FOLLOW UP THE        "
               0  "                                IMPRESSION THAT INTERGRAND IS     "
               0  "                                STRAIGHT LINE.                    "
               0  IF(L.GT.2) GO TO 40;
               0  IF(TABS+P1*DABS(T(1,2)).EQ.TABS) GO TO 135;
               0  GO TO 15;
               0  "                              CACULATE NEXT RATIOS FOR            "
               0  "                                COLUMNS 1,...,L-2 OF T-TABLE      "
               0  "                                RATIO IS SET TO ZERO IF DIFFERENCE"
               0  "                                IN LAST TWO ENTRIES OF COLUMN IS  "
               0  "                                ABOUT ZERO                        "
               0  40 DO 45 I=2,LM1;
               0  DIFF=ZERO;
               0  IF(TABTLM+DABS(T(I-1,L)).NE.TABTLM) DIFF=T(I-1,LM1)/T(I-1,L);
               0  T(I-1,LM1)=DIFF;
               0  45 CONTINUE;
               0  IF(DABS(FOUR-T(1,LM1)).LE.H2TOL) GO TO 60;
               0  IF(T(1,LM1).EQ.ZERO) GO TO 55;
               0  IF(DABS(TWO-DABS(T(1,LM1))).LT.JUMPTL) GO TO 130;
               0  IF(L.EQ.3) GO TO 15;
               0  H2CONV=.FALSE.;
               0  IF(DABS((T(1,LM1)-T(1,L-2))/T(1,LM1)).LE.AITTOL) GO TO 75;
               0  50 IF(REGLAR) GO TO 55;
               0  IF(L.EQ.4) GO TO 15;
               0  55 IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175;
               0  GO TO 145;
               0  "                              CAUTIOUS ROMBERG EXTRAPOLATION      "
               0  60 IF(H2CONV) GO TO 65;
               0  AITKEN=.FALSE.;
               0  H2CONV=.TRUE.;
               0  65 FEXTRP=FOUR;
               0  70 IT=IT + 1;
               0  VINT=STEP*T(L,IT);
               0  ERRER=DABS(STEP/(FEXTRP-ONE)*T(IT-1,L));
               0  IF(ERRER.LE.ERGOAL) GO TO 160;
               0  IF(ERGL+ERRER.EQ.ERGL) GO TO 160;
               0  IF(IT.EQ.LM1) GO TO 125;
               0  IF(T(IT,LM1).EQ.ZERO) GO TO 70;
               0  IF(T(IT,LM1).LE.FEXTRP) GO TO 125;
               0  IF(DABS(T(IT,LM1)/FOUR-FEXTRP)/FEXTRP.LT.AITTOL)
               0  FEXTRP=FEXTRP*FOUR;
               0  GO TO 70;
               0  "                              INTEGRAND MAY HAVE X**ALPHA TYPE    "
               0  "                                SINGULARITY                       "
               0  "                                RESULTING IN A RATIO OF *SING*  = "
               0  "                                2**(ALPHA + 1)                    "
               0  75 IF(T(1,LM1).LT.AITLOW) GO TO 175;
               0  IF(AITKEN) GO TO 80;
               0  H2CONV=.FALSE.;
               0  AITKEN=.TRUE.;
               0  80 FEXTRP=T(L-2,LM1);
               0  IF(FEXTRP.GT.FOURP5) GO TO 65;
               0  IF(FEXTRP.LT.AITLOW) GO TO 175;
               0  IF(DABS(FEXTRP-T(L-3,LM1))/T(1,LM1).GT.H2TOL) GO TO 175;
               0  SING=FEXTRP;
               0  FEXTM1=ONE/(FEXTRP - ONE);
               0  AIT(1)=ZERO;
               0  DO 85 I=2,L;
               0  AIT(I)=T(I,1) + (T(I,1)-T(I-1,1))*FEXTM1;
               0  R(I)=T(1,I-1);
               0  DIF(I)=AIT(I) - AIT(I-1);
               0  85 CONTINUE;
               0  IT=2;
               0  90 VINT=STEP*AIT(L);
               0  ERRER=ERRER*FEXTM1;
               0  IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 95;
               0  ALPHA=DLOG10(SING)/ALG4O2 - ONE;
               0  IER=MAX0(IER,65);
               0  GO TO 160;
               0  95 IT=IT + 1;
               0  IF(IT.EQ.LM1) GO TO 125;
               0  IF(IT.GT.3) GO TO 100;
               0  H2NXT=FOUR;
               0  SINGNX=SING+SING;
               0  100 IF(H2NXT.LT.SINGNX) GO TO 105;
               0  FEXTRP=SINGNX;
               0  SINGNX=SINGNX+SINGNX;
               0  GO TO 110;
               0  105 FEXTRP=H2NXT;
               0  H2NXT=FOUR*H2NXT;
               0  110 DO 115 I=IT,LM1;
               0  R(I+1)=ZERO;
               0  IF(TABTLM+DABS(DIF(I+1)).NE.TABTLM) R(I+1)=DIF(I)/DIF(I+1);
               0  115 CONTINUE;
               0  H2TFEX=-H2TOL*FEXTRP;
               0  IF(R(L)-FEXTRP.LT.H2TFEX) GO TO 125;
               0  IF(R(L-1)-FEXTRP.LT.H2TFEX) GO TO 125;
               0  ERRER=ASTEP*DABS(DIF(L));
               0  FEXTM1=ONE/(FEXTRP - ONE);
               0  DO 120 I=IT,L;
               0  AIT(I)=AIT(I) + DIF(I)*FEXTM1;
               0  DIF(I)=AIT(I) - AIT(I-1);
               0  120 CONTINUE;
               0  GO TO 90;
               0  "                              CURRENT TRAPEZOID SUM AND RESULTING "
               0  "                                EXTRAPOLATED VALUES DID NOT GIVE  "
               0  "                                A SMALL ENOUGH *ERRER*.           "
               0  "                                NOTE -- HAVING PREVER .LT. ERRER  "
               0  "                                IS AN ALMOST CERTAIN SIGN OF      "
               0  "                                BEGINNING TROUBLE WITH IN THE FUNC"
               0  "                                TION VALUES. HENCE, A WATCH FOR,  "
               0  "                                AND CONTROL OF, NOISE SHOULD      "
               0  "                                BEGIN HERE.                       "
               0  125 FEXTRP=DMAX1(PREVER/ERRER,AITLOW);
               0  PREVER=ERRER;
               0  IF(L.LT.5) GO TO 15;
               0  IF(L-IT.GT.2.AND.ISTAGE.LT.MXSTGE) GO TO 170;
               0  ERRET=ERRER/(FEXTRP**(MAXTBL-L));
               0  IF(ERRET.GT.ERGOAL.AND.(ERGL+ERRET).NE.ERGL) GO TO 170;
               0  GO TO 15;
               0  "                              INTEGRAND HAS JUMP (SEE NOTES)      "
               0  130 IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 170;
               0  "                                NOTE THAT  2*FN=2**L              "
               0  DIFF=DABS(T(1,L))*(FN+FN);
               0  GO TO 160;
               0  "                              INTEGRAND IS STRAIGHT LINE          "
               0  "                                TEST THIS ASSUMPTION BY COMPARING "
               0  "                                THE VALUE OF THE INTEGRAND AT     "
               0  "                                FOUR *RANDOMLY CHOSEN* POINTS WITH"
               0  "                                THE VALUE OF THE STRAIGHT LINE    "
               0  "                                INTERPOLATING THE INTEGRAND AT THE"
               0  "                                TWO END POINTS OF THE SUB-INTERVAL"
               0  "                                IF TEST IS PASSED, ACCEPT *VINT*  "
               0  135 SLOPE=(FEND-FBEG)*TWO;
               0  FBEG2=FBEG+FBEG;
               0  DO 140 I=1,4;
               0
               0  "CHANGED"
               0  "DIFF=DABS(F(BEG+RN(I)*STEP) - FBEG2-RN(I)*SLOPE);"
               0  "TO"
               0  "RVAL=BEG+RN(I)*STEP;DIFF=DABS(F(RVAL) - FBEG2-RN(I)*SLOPE);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=BEG+RN(I)*STEP;DIFF=DABS(F(RVAL) - FBEG2-RN(I)*SLOPE);
               0
               0  IF(TABTLM+DIFF.NE.TABTLM) GO TO 155;
               0  140 CONTINUE;
               0  GO TO 160;
               0  "                              NOISE MAY BE DOMINANT FEATURE       "
               0  "                                ESTIMATE NOISE LEVEL BY COMPARING "
               0  "                                THE VALUE OF THE INTEGRAND AT     "
               0  "                                FOUR *RANDOMLY CHOSEN* POINTS WITH"
               0  "                                THE VALUE OF THE STRAIGHT LINE    "
               0  "                                INTERPOLATING THE INTEGRAND AT THE"
               0  "                                TWO ENDPOINTS. IF SMALL ENOUGH,   "
               0  "                                ACCEPT *VINT*                     "
               0  145 SLOPE=(FEND-FBEG)*TWO;
               0  FBEG2=FBEG+FBEG;
               0  I=1;
               0
               0  "CHANGED"
               0  "150 DIFF=DABS(F(BEG+RN(I)*STEP) - FBEG2-RN(I)*SLOPE);"
               0  "TO"
               0  "150 RVAL=BEG+RN(I)*STEP;DIFF=DABS(F(RVAL) - FBEG2-RN(I)*SLOPE);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  150 RVAL=BEG+RN(I)*STEP;DIFF=DABS(F(RVAL) - FBEG2-RN(I)*SLOPE);
               0
               0  155 ERRER=DMAX1(ERRER,ASTEP*DIFF);
               0  IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175;
               0  I=I+1;
               0  IF(I.LE.4) GO TO 150;
               0  IER=66;
               0  "                              INTERGRATION OVER CURRENT SUB-      "
               0  "                                INTERVAL SUCCESSFUL               "
               0  "                                ADD *VINT* TO *DCADRE* AND *ERRER*"
               0  "                                TO *ERROR*, THEN SET UP NEXT SUB- "
               0  "                                INTERVAL, IF ANY.                 "
               0  160 CADRE=CADRE + VINT;
               0  ERROR=ERROR + ERRER;
               0  IF(RIGHT) GO TO 165;
               0  ISTAGE=ISTAGE - 1;
               0  IF(ISTAGE.EQ.0) GO TO 220;
               0  REGLAR=REGLSV(ISTAGE);
               0  BEG=BEGIN(ISTAGE);
               0  END=FINIS(ISTAGE);
               0  CUREST=CUREST - EST(ISTAGE+1) + VINT;
               0  IEND=IBEG - 1;
               0  FEND=TS(IEND);
               0  IBEG=IBEGS(ISTAGE);
               0  GO TO 180;
               0  165 CUREST=CUREST + VINT;
               0  STAGE=STAGE+STAGE;
               0  IEND=IBEG;
               0  IBEG=IBEGS(ISTAGE);
               0  END=BEG;
               0  BEG=BEGIN(ISTAGE);
               0  FEND=FBEG;
               0  FBEG=TS(IBEG);
               0  GO TO 5;
               0  "                              INTEGRATION OVER CURRENT SUBINTERVAL"
               0  "                                IS UNSUCCESSFUL. MARK SUBINTERVAL "
               0  "                                FOR FURTHER SUBDIVISION. SET UP   "
               0  "                                NEXT SUBINTERVAL.                 "
               0  170 REGLAR=.TRUE.;
               0  175 IF(ISTAGE.EQ.MXSTGE) GO TO 205;
               0  IF(RIGHT) GO TO 185;
               0  REGLSV(ISTAGE+1)=REGLAR;
               0  BEGIN(ISTAGE)=BEG;
               0  IBEGS(ISTAGE)=IBEG;
               0  STAGE=STAGE*HALF;
               0  180 RIGHT=.TRUE.;
               0  BEG=(BEG+END)*HALF;
               0  IBEG=(IBEG+IEND)/2;
               0  TS(IBEG)=TS(IBEG)*HALF;
               0  FBEG=TS(IBEG);
               0  GO TO 10;
               0  185 NNLEFT=IBEG - IBEGS(ISTAGE);
               0  IF(IEND+NNLEFT.GE.MAXTS) GO TO 200;
               0  III=IBEGS(ISTAGE);
               0  II=IEND;
               0  DO 190 I=III,IBEG;
               0  II=II + 1;
               0  TS(II)=TS(I);
               0  190 CONTINUE;
               0  DO 195 I=IBEG,II;
               0  TS(III)=TS(I);
               0  III=III + 1;
               0  195 CONTINUE;
               0  IEND=IEND + 1;
               0  IBEG=IEND - NNLEFT;
               0  FEND=FBEG;
               0  FBEG=TS(IBEG);
               0  FINIS(ISTAGE)=END;
               0  END=BEG;
               0  BEG=BEGIN(ISTAGE);
               0  BEGIN(ISTAGE)=END;
               0  REGLSV(ISTAGE)=REGLAR;
               0  ISTAGE=ISTAGE + 1;
               0  REGLAR=REGLSV(ISTAGE);
               0  EST(ISTAGE)=VINT;
               0  CUREST=CUREST + EST(ISTAGE);
               0  GO TO 5;
               0  "                              FAILURE TO HANDLE GIVEN INTEGRA-    "
               0  "                                TION PROBLEM                      "
               0  200 IER=131;
               0  GO TO 215;
               0  205 IER=132;
               0  GO TO 215;
               0  210 IER=133;
               0  215 CADRE=CUREST + VINT;
               0  220 DCADRE=CADRE;
               0  9000 CONTINUE;
               0  9005 RETURN;
               0  END;  "END OF FUNCTION DCADRE"
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION EBIND(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***FUNCTION TO GET AN AVERAGE PHOTOELECTRIC BINDING ENERGY.         "
               0  ;
               0  implicit none;
               0  $REAL E;
               0  $INTEGER I,J;
               0  $REAL    PHOTTZ,STOT,PHOTTE;
               0
               0  COMIN/MIXDAT,PHPAIR/;
               0  EBIND=0.0;
               0  DO I=1,NE [J=Z(I);EBIND=EBIND+PZ(I)*PHOTTZ(Z(I),E)*EKEDGE(J)*0.001;]
               0  STOT=PHOTTE(E);
               0  IF (STOT.NE.0.0)EBIND=EBIND/STOT;
               0  RETURN;
               0  END; "END OF FUNCTION EBIND"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION EBR1(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***BRANCHING RATIO BREMS/(BREMS+MOLLER)                             "
               0  implicit none;
               0  $REAL E,BREMTM,BREM,TEBR,AMOLTM;
               0  BREM=BREMTM(E);
               0  TEBR=BREM+AMOLTM(E);
               0  IF (TEBR.GT.0.0) [EBR1=BREM/TEBR;]
               0  ELSE [EBR1=0.0;]
               0  RETURN;
               0  END;   "END OF FUNCTION EBR1"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION EDEDX(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***ELECTRON ENERGY LOST IN EDIST(2)                                 "
               0  ;
               0  implicit none;
               0  $REAL E,SPTOTE;
               0  COMIN/THRESH/;
               0  EDEDX=SPTOTE(E,AE,AP);
               0  RETURN;
               0  END;  "END OF FUNCTION EDEDX"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ESIG(E);  "ELECTRON(-) CROSS SECTION(1/RL)"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL E,BREMTM,AMOLTM;
               0  ESIG=BREMTM(E)+AMOLTM(E);
               0  RETURN;
               0  END;  "END OF FUNCTION ESIG"
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION FCOULC(Z);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "EVALUATES EQUATION 2.7.17 OF SLAC-265"
               0
               0  ;
               0  implicit none;
               0  $REAL Z,ASQ;
               0  COMIN/DERCON/;
               0  ASQ=(FSC*Z)**2;
               0  FCOULC = ASQ*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+
               0  ASQ*(0.0083+ASQ*(-0.002))));
               0  RETURN;
               0  END;  "END OF FUNCTION FCOULC"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION FI(I,X1,X2,X3,X4);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "implicit none;"
               0  "$INTEGER I;"
               0  "$REAL    X1,X2,X3,X4;"
               0  "***FUNCTION MULTIPLEXER                                             "
               0  "THIS IS MADE MUCH NICER BY THE MACRO CALL $FUNCTION #;"
               0  GO TO($FLIST$FNUMS),I;
               0  $FLIST$FCALLS
               0  END;  "END OF FUNCTION FI"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION GBR1(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***BRANCHING RATIO PAIR/(PAIR+COMPTON+PHOTO)                        "
               0  implicit none;
               0  $REAL E,PAIR,PAIRTU,COMPTM,PHOTTE;
               0  PAIR=PAIRTU(E);
               0  GBR1=PAIR/(PAIR+COMPTM(E)+PHOTTE(E));
               0  RETURN;
               0  END; "END OF FUNCTION GBR1"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION GBR2(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***BRANCHING RATIO (PAIR+COMPTON)/(PAIR+COMPTON+PHOTO)              "
               0  implicit none;
               0  $REAL E,PRCO,PAIRTU,COMPTM,PHOTTE;
               0  PRCO=PAIRTU(E)+COMPTM(E);
               0  GBR2=PRCO/(PRCO+PHOTTE(E));
               0  RETURN;
               0  END; "END OF FUNCTION GBR2"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION GMFP(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***GAMMA MEAN FREE PATH                                             "
               0  implicit none;
               0  $REAL E,PAIRTU,COMPTM,PHOTTE;
               0  GMFP=1.0/(PAIRTU(E)+COMPTM(E)+PHOTTE(E));
               0  RETURN;
               0  END;  "END OF FUNCTION GMFP"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $INTEGER FUNCTION IFUNT(NAME);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $INTEGER I,J;
               0  $TYPE NAME(6);
               0  COMIN/FUNCS/;
               0  :FUN: DO I=1,NFUNS [ DO J=1,6 [
               2          IF (NAME(J).NE.FNAME(J,I))NEXT:FUN:;]
               1      IFUNT=I; RETURN; "NAME MATCHES"       ]
               0  IFUNT=-1; OUTPUT NAME;(' FUNC=',6A1,' NOT MATCHED');
               0  RETURN;
               0  END;  "END OF FUNCTION IFUNT"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  LOGICAL FUNCTION QFIT(NJ,XL,XH,XR,EP,ZTHR,ZEP,REM,NJP,XFUN,XFI,
               0  AX,BX,NALM,NFUN,AF,BF,VFUNS,IPRN);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  "EXTERNAL XFUN,XFI,VFUNS;"
               0  EXTERNAL VFUNS;
               0  $REAL    XFUN,XFI;
               0  $INTEGER NJ,NALM,NFUN,NJP,IPRN;
               0  $REAL    XL,XH,XR,AX,BX,REM,EP;
               0  $REAL FSXL(10),FSXH(10),FIP(10),FFIP(10),AFIP(10),RE(10),AER(10);
               0  $REAL AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN);
               0  "     CONSTRUCT THE INTERVAL COEFFICIENTS.                             "
               0  "     XR SHOULD BE IN THE INTERVAL (XL,XH).  IF NOT IT WILL BE SE TO TH"
               0  "     NEAREST LIMIT.  SUBINTERVALS WILL BE ARRANGED SO                 "
               0  "     THAT XR IS ALWAYS ON A SUBINTERVAL BOUNDARY.   THE PURPOSE OF THI"
               0  "     FEATURE IS TO MORE EASILY FIT FUNCTIONS WHICH HAVE AN INTERIOR   "
               0  "     DISCONTINUITY IN SLOPE.  EXAMPLES ARE THE MOLLER AND PAIR        "
               0  "     CROSS SECTIONS WHICH CONTRIBUTE DISCONTINUITIES IN SLOPE         "
               0  "     TO THE ELECTRON AND PHOTON INTERACTION PROBABILITIES IN          "
               0  "     THE INTERIOR OF THE ENERGY RANGES FOR THESE PARTICLES.           "
               0  "     IN ABLE TO GIVE SOME VALUE FOR X'S WHICH MAY LIE SLIGHTLY OUTSIDE"
               0  "     THE INTERVAL (XL,XH) AN EXTRA SUBINTERVAL ON EACH SIDE OF (XL,XH)"
               0  "     IS PROVIDED, WHICH USED THE SAME STRAIGHT LINES AS THE ADJACENT  "
               0  "     INCLUDED SUBINTERVAL.  NJ IS THE TOTAL NUMBER OF SUBINTERVALS    "
               0  "     AND NI IS DEFINED TO BE THE NUMBER OF INTERNAL SUBINTERVALS=NJ-2."
               0  "     NJP IS THE MINUMUM NUMBER OF POINTS INTERIOR TO THE INTERVAL     "
               0  "     (XL,XH) AT WHICH THE FIT IS TO BE TESTED.  A NUMBER NIP WILL BE  "
               0  "     CHOSEN AS THE NUMBER OF INTERIOR POINTS WITHIN EACH SUBINTERVAL  "
               0  "     AT WHICH TO TEST SO THAT NIP*NI]=NJP.                        "
               0  $REAL    XS,XFL,XFH,XFS,XM,DX,W,XLL,SXFL,XSXF,SXFH,DSXF,WIP,
               0  SXFIP,XIP;
               0  $INTEGER NI,NIP,ISUB,IFUN,JSUB,IP;
               0  $INTEGER nkp;
               0  DATA NKP/3/;
               0  save nkp;
               0  IF (XH.LE.XL)[
               1      OUTPUT XL,XH;(' QFIT ERROR:XL SHOULD BE < XH. XL,XH=',2G14.6);
               1      QFIT=.FALSE.; RETURN;]
               0  XS=AMAX1(XL,AMIN1(XH,XR));
               0  "     GET NUMBER OF INTERNAL SUBINTERVALS ARE ALLOWED AND CHECK        "
               0  NI=NJ-2;
               0  "     AT LEAST 2 SUBINTERVALS ARE NEEDED IF XR(XS) IS NOT AN END POINT."
               0  IF (((XS.EQ.XL.OR.XS.EQ.XH).AND.NI.GE.1).OR.NI.GE.2) [XFL=XFUN(XL);]
               0  ELSE [QFIT=.FALSE.; RETURN;]
               0  XFH=XFUN(XH);
               0  XFS=XFUN(XS);
               0  "     SET SUBINTERVAL WIDTH.                                           "
               0  XM=AMAX1(XFH-XFS,XFS-XFL);
               0  DX=XFH-XFL;
               0  W=XM/AMAX1(1.,AINT(NI*XM/DX));
               0  "     RESET NI TO HOW MANY WE'RE ACTUALLY GOING TO USE.                "
               0  NI=NI-AINT(NI-DX/W);
               0  "     COMPUTE HOW MANY INTERIOR POINTS TO SAMPLE IN EACH SUBINTERVAL.  "
               0  NIP=MAX0(NKP,(NJP+NI-1)/NI);
               0  "     MAKE NIP ODD                                                     "
               0  NIP=(NIP/2)*2+1;
               0  "     SET ACTUAL LOWER LIMIT OF INTERVAL.                              "
               0  IF (XFH-XFS.LE.XFS-XFL) [XLL=XFL;]
               0  ELSE [XLL=XFH-NI*W;]
               0  "     COEFICIENTS FOR USER TO COMPUTE WHICH SUBINTERVAL TO USE.        "
               0  "     ISUBINT=AX*XFUN(X)+BX                                            "
               0  AX=1./W;
               0  BX=2.-XLL*AX;
               0  "     THE RIGHT BOUNDARY OF SUBINTERVAL I IS XFI(XLL+W*(I-1))          "
               0  "     NOW COMPUTE THE FIT COEFFICIENTS FOR THE SUBINTERVALS            "
               0  "     AND FIND MAXIMUM RELATIVE ERROR(REM).                            "
               0  REM=0.0;
               0  QFIT=.TRUE.;
               0  "     LOOP OVER SUBINTERVALS                                           "
               0  "     INITIALIZE LOWER BOUNDARY AND VALUE.                             "
               0  SXFL=AMAX1(XLL,XFL);
               0  ISUB=0;
               0  XSXF=XFI(SXFL);
               0  CALL VFUNS(XSXF,FSXL);
               0  IF (IPRN.NE.0) WRITE(6,:FMT:) ISUB,SXFL,XSXF,(FSXL(IFUN),IFUN=1,NFUN);
               0  :FMT: FORMAT(' QFIT:ISUB,SXF,XSXF,FSX()=',I4,1P,9G11.4/(1X,12G11.4));
               0  DO ISUB=1,NI[
               1      "     ALLOW FOR EXTRA SUBINTERVAL OUTSIDE THE MAIN INTERVAL            "
               1      JSUB=ISUB+1;
               1      SXFH=AMIN1(XLL+W*ISUB,XH);
               1      XSXF=XFI(SXFH);
               1      CALL VFUNS(XSXF,FSXH);
               1      IF (IPRN.NE.0)WRITE(6,:FMT:)ISUB,SXFH,XSXF,(FSXH(IFUN),IFUN=1,NFUN);
               1      DSXF=SXFH-SXFL;
               1      DO IFUN=1,NFUN[
               2          AF(JSUB,IFUN)=(FSXH(IFUN)-FSXL(IFUN))/DSXF;
               2          BF(JSUB,IFUN)=(FSXL(IFUN)*SXFH-FSXH(IFUN)*SXFL)/DSXF;] "END OF IFUN"
               1      "     LOOP OVER INTERIOR POINTS TO LOOK FOR MAX. REL.ERROR             "
               1      "     COMPUTE INTERIOR POINT SPACING.                                  "
               1      WIP=DSXF/(NIP+1);
               1      DO IP=1,NIP[
               2          "     VALUE OF XFUN AT THE INTERIOR POINT OF THIS SUBINTERVAL.         "
               2          SXFIP=SXFL+IP*WIP;
               2          XIP=XFI(SXFIP);
               2          "     COMPUTE FUNCTION AT INTERIOR POINT                               "
               2          CALL VFUNS(XIP,FIP);
               2          "     COMPUTE FITTED VALUES.                                           "
               2          DO IFUN=1,NFUN[
               3              FFIP(IFUN)=AF(JSUB,IFUN)*SXFIP+BF(JSUB,IFUN);
               3              AFIP(IFUN)=ABS(FIP(IFUN));
               3              AER(IFUN)=ABS(FFIP(IFUN)-FIP(IFUN));
               3              RE(IFUN)=0.0;
               3              IF (FIP(IFUN).NE.0.0) [RE(IFUN)=AER(IFUN)/AFIP(IFUN);]
               3              IF (AFIP(IFUN).GE.ZTHR(IFUN)) [REM=AMAX1(REM,RE(IFUN));]
               3              ELSEIF (AER(IFUN).GT.ZEP(IFUN)) [QFIT=.FALSE.;]
               3              ] "END OF IFUN"
               2          "*****WRITE OUT SO WE CAN SEE HOW WE ARE DOING.                        "
               2          IF (IPRN.NE.0) [
               3              OUTPUT ISUB,IP,SXFIP,XIP,REM,QFIT,(FIP(IFUN),FFIP(IFUN),
               3              RE(IFUN),AER(IFUN),IFUN=1,NFUN);
               3              (1X,2I4,1P,2G12.5,6P,F12.0,L2,1P,2G11.4,6P,F11.0,1P,G11.4/
               3              (1X,3(1P,2G11.4,6P,F11.0,1P,G11.4)));]
               2          ] "END OF IP"
               1      "     SAVE RIGHT BOUNDARY AND VALUE FOR NEXT SUBINTERVAL.              "
               1      SXFL=SXFH;
               1      DO IFUN=1,NFUN [FSXL(IFUN)=FSXH(IFUN);]
               1      ] "END OF ISUB"
               0  "     SET UP SKIRTING SUBINTERVALS(VIA EXTRAPOLATION)                  "
               0  DO IFUN=1,NFUN[
               1      AF(1,IFUN)=AF(2,IFUN);
               1      BF(1,IFUN)=BF(2,IFUN);
               1      AF(NI+2,IFUN)=AF(NI+1,IFUN);
               1      BF(NI+2,IFUN)=BF(NI+1,IFUN);] "END OF IFUN"
               0  QFIT=QFIT.AND.REM.LE.EP;
               0  NJ=NI+2; "TELL ACTUAL NO. OF SUBINTERVALS USED."
               0  RETURN;
               0  END; "END OF LOGICAL FUNCTION QFIT"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRDR(KA,E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***RUN TIME PAIR D-SIGMA/D-EMINUS                                   "
               0
               0  "EVALUATES EQUATION 2.7.109 OF SLAC-265"
               0  ;
               0  implicit none;
               0  $REAL KA,E,PAIRFR;
               0  $INTEGER LS;
               0  COMIN/LPAIRR/;
               0  K=KA;
               0  IF (K.LT.50.) [LE=1; LS=0;]
               0  ELSE [LE=2;LS=3;]
               0  LA=LS+1;
               0  LC=LS+3;
               0  PAIRDR=PAIRFR(E);
               0  RETURN;
               0  END;  "END OF FUNCTION PAIRDR"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRDZ(Z,KA,E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***ALL ENTRIES TO THIS FUNCTION GIVE THE CONTRIBUTION THAT ELEMENT Z"
               0  "   WOULD HAVE IF THERE WERE ONE PER MOLECULE.                      "
               0  "   ENTRIES STARTING WITH D DO THEIR OWN INITIALIZATION.             "
               0  "   ENTRIES STARTING WITH F RELY ON PREVIOUS D FOR INITIALIZATION.   "
               0
               0  "EVALUATES EQUATION 2.7.8 OF SLAC-265"
               0  ;
               0  implicit none;
               0  $REAL Z,KA,E;
               0  $REAL XSIF,FCOULC,PAIRFZ;
               0  COMIN/PMCONS,DERCON,MOLVAR,LPAIRZ/;
               0  K=KA;
               0  DELC=136.*Z**(-1./3.)*RM/K;
               0  CONST=(AN*RHO/WM)*R0**2*FSC*Z*(Z+XSIF(Z))*RLC/K**3;
               0  XLNZ=4./3.*ALOG(Z);
               0  IF (K.GE.50)XLNZ=XLNZ+4.*FCOULC(Z);
               0  ".....DELTAM IS THE DELTA AT WHICH THE SQUARE BRACKETS GO TO ZERO      "
               0  DELTAM=EXP((21.12-XLNZ)/4.184)-0.952;
               0  PAIRDZ=PAIRFZ(E);
               0  RETURN;
               0  END;  "END OF FUNCTION PAIRDZ"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRFR(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL E;
               0  $REAL EPS,DEL,DELTA,A,CC;
               0  COMIN/BREMPR,DBRPR,LPAIRR/;
               0  EPS=E/K;
               0  DEL=1./(K*EPS*(1.-EPS));
               0  IF (DEL.GT.DELPOS(LE)) [PAIRFR=0.0; ]
               0  ELSE [DELTA=DELCM*DEL;
               1      IF (DELTA.LE.1.)[
               2          A=DL1(LA)+DELTA*(DL2(LA)+DELTA*DL3(LA));
               2          CC=DL1(LC)+DELTA*(DL2(LC)+DELTA*DL3(LC));]
               1      ELSE [A=DL4(LA)+DL5(LA)*ALOG(DELTA+DL6(LA));
               2          CC=DL4(LC)+DL5(LC)*ALOG(DELTA+DL6(LC));]
               1      PAIRFR=(ALFP1(LE)*CC+ALFP2(LE)*12.*(E/K-0.5)**2*A)/K; ]
               0  RETURN;
               0  END; "END OF FUNCTION PAIRFR"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRFZ(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL E;
               0  $REAL EPS,ONEEPS,DELTA,SB1,SB2,EPLUS;
               0  COMIN/LPAIRZ/;
               0  EPS=E/K;
               0  ONEEPS=1.-EPS;
               0
               0  "CHANGED"
               0  "IF(ONEEPS.EQ.0.0) [ONEEPS=1.E-38;]"
               0  "TO"
               0  "IF(ONEEPS.EQ.0.0) [ONEEPS=1.18E-38;]"
               0  "FOR SUN AFB 89/12/27"
               0
               0  IF(ONEEPS.EQ.0.0) [ONEEPS=1.18E-38;]
               0
               0  DELTA=DELC/(EPS*ONEEPS);
               0  IF (DELTA.GE.DELTAM) [PAIRFZ=0.0; ]
               0  ELSE [IF (DELTA.LE.1.)[
               2          SB1=20.867+DELTA*(-3.242+DELTA*0.625)-XLNZ;
               2          SB2=20.209+DELTA*(-1.930+DELTA*(-0.086))-XLNZ;]
               1      ELSE [SB1=21.12-4.184*ALOG(DELTA+0.952)-XLNZ;
               2          SB2=SB1;]
               1      EPLUS=K-E;
               1      PAIRFZ=CONST*((E**2+EPLUS**2)*SB1+0.666667*E*EPLUS*SB2 );]
               0  RETURN;
               0  END;  "END OF FUNCTION PAIRFZ"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRRM(K,E1,E2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL K,E1,E2,PAIRRZ;
               0  $INTEGER I;
               0  COMIN/MIXDAT/;
               0  PAIRRM=0.;
               0  DO I=1,NE [PAIRRM=PAIRRM+PZ(I)*PAIRRZ(Z(I),K,E1,E2);]
               0  RETURN;
               0  END;  "END OF FUNCTION PAIRRM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRRR(K,E1,E2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL K,E1,E2;
               0  "EXTERNAL PAIRFR;"
               0  INTERFACE
               0  REAL FUNCTION PAIRFR(X)
               0  REAL, INTENT(IN) :: X
               0  END FUNCTION PAIRFR
               0  END INTERFACE
               0  $REAL DUMMY,PAIRDR,QD;
               0  "     INITIALIZE PAIRFR                                                "
               0
               0  "    CHANGED"
               0
               0  "    CALL PAIRDR(K,E1);"
               0
               0  "    TO"
               0
               0  "    DUMMY=PAIRDR(K,E1);"
               0
               0  "    FOR SUN COMATIBILITY AFB 89/12/27"
               0
               0  DUMMY=PAIRDR(K,E1);
               0
               0  PAIRRR=QD(PAIRFR,E1,E2,'PAIRFR');
               0  RETURN;
               0  END;  "END OF FUNCTION PAIRRR"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRRZ(Z,K,E1,E2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL Z,K,E1,E2;
               0  $REAL DUMMY,PAIRDZ,QD;
               0  "EXTERNAL PAIRFZ;"
               0  INTERFACE
               0  REAL FUNCTION PAIRFZ(X)
               0  REAL, INTENT(IN) :: X
               0  END FUNCTION PAIRFZ
               0  END INTERFACE
               0
               0  "     INITIALIZE PAIRFZ                                                "
               0
               0  "    CHANGED"
               0
               0  "    CALL PAIRDZ(Z,K,E1);"
               0
               0  "    TO"
               0
               0  "    DUMMY=PAIRDZ(Z,K,E1);"
               0
               0  "    FOR SUN COMATIBILITY AFB 89/12/27"
               0
               0  DUMMY=PAIRDZ(Z,K,E1);
               0
               0  PAIRRZ=QD(PAIRFZ,E1,E2,'PAIRFZ');
               0  RETURN;
               0  END;   "END OF FUNCTION PAIRRZ"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRTE(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***'E' FOR EMPIRICAL OR EXPERIMENTAL PAIR PROD CROSS-SECTION.       "
               0  "   THIS FUNCTION GIVE THE PROPER MIX OF PAIRTZ'S.                   "
               0  ;
               0  implicit none;
               0  $REAL K,PAIRTZ;
               0  $INTEGER I;
               0  COMIN/DERCON,MIXDAT/;
               0  PAIRTE=0.0;
               0  IF (K.LE.2.0*RM)RETURN;
               0  DO I=1,NE [PAIRTE=PAIRTE+PZ(I)*PAIRTZ(Z(I),K);]
               0  RETURN;
               0  END;  "END OF FUNCTION PAIRTE"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRTM(K0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL K0,PAIRRM;
               0  COMIN/DERCON/;
               0  IF (K0.LE.2.*RM) [PAIRTM=0.0; ]
               0  ELSE [PAIRTM=PAIRRM(K0,RM,K0-RM);]
               0  RETURN;
               0  END;  "END OF FUNCTION PAIRTM"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRTR(K0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL K0,PAIRRR;
               0  COMIN/DERCON/;
               0  IF (K0.LE.2.*RM) [PAIRTR=0.0; ]
               0  ELSE [PAIRTR=PAIRRR(K0,RM,K0-RM);]
               0  RETURN;
               0  END;  "END OF FUNCTION PAIRTR"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRTU(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***THIS IS THE TOTAL PAIR ROUTINE ACTUALLY USED FOR RUNNING.        "
               0  "   IT IS THE EMPIRICAL ROUTINE BELOW 50MEV AND THE THEORETICAL ABOVE"
               0  implicit none;
               0  $REAL K,PAIRTE,PAIRTM;
               0  IF (K.LT.50) [PAIRTU=PAIRTE(K); ]
               0  ELSE [PAIRTU=PAIRTM(K);]
               0  RETURN;
               0  END;  "END OF FUNCTION PAIRTU"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PAIRTZ(Z,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***FUNCTION TO GIVE INTERPOLATED TOTAL PAIR PROD CROSS-SECTION      "
               0  "   FROM TABULATED DATA USING LOG-LOG INTERPOLATION.                 "
               0  "   THIS CROSS-SECTION WILL BE THE CONTRIBUTION THIS Z ELEMENT       "
               0  "   WOULD MAKE IF THERE WERE ONE/MOLECULE,I.E., TO GET THE ACTUAL    "
               0  "   CONTRIBUTION ONE MUST MULTIPLY BY PZ(I).                         "
               0  ;
               0  implicit none;
               0  $REAL Z,K;
               0  $REAL PCON,AINTP;
               0  $INTEGER IZ;
               0  COMIN/DERCON/;
               0  "     COMMON WITH DATA FOR PHOTO AND PAIR.                             "
               0  COMIN/PHPAIR,PMCONS,MOLVAR/;
               0  "     PCON CONVERTS CROSS SECTION IN BARNS TO CROSS SECTION IN RLC**-1 "
               0  IF (K.LE.RMT2) [PAIRTZ=0.0; ]
               0  ELSE [PCON=1.E-24*(AN*RHO/WM)*RLC;
               1      IZ=Z;
               1      PAIRTZ=PCON*AINTP(K,PRE,17,PRD(1,IZ),1,.TRUE.,.FALSE.);]
               0  RETURN;
               0  END;  "END OF FUNCTION PAIRTZ"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PBR1(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***BRANCHING RATIO BREMS/(BREMS+BHABHA+ANNIHILATION)                "
               0  implicit none;
               0  $REAL E,BREM,BREMTM,BHABTM,ANIHTM;
               0  BREM=BREMTM(E);
               0  PBR1=BREM/(BREM+BHABTM(E)+ANIHTM(E));
               0  RETURN;
               0  END;  "END OF FUNCTION PBR1"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PBR2(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***BRANCHING RATIO (BREMS+BHABHA)/(BREMS+BHABHA+ANNIHILATION)       "
               0  implicit none;
               0  $REAL E,BRBH,BREMTM,BHABTM,ANIHTM;
               0  BRBH=BREMTM(E)+BHABTM(E);
               0  PBR2=BRBH/(BRBH+ANIHTM(E));
               0  RETURN;
               0  END;  "END OF FUNCTION PBR2"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PDEDX(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***POSITRON ENERGY LOSS IN EDIST(2)                                 "
               0  ;
               0  implicit none;
               0  $REAL E,SPTOTP;
               0  COMIN/THRESH/;
               0  PDEDX=SPTOTP(E,AE,AP);
               0  RETURN;
               0  END;   "END OF FUNCTION PDEDX"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PHOTTE(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***'E' FOR EMPIRICAL OR EXPERIMENTAL PHOTOEFFECT CROSS-SECTION.     "
               0  "   THIS FUNCTION GIVE THE PROPER MIX OF PHOTTZ'S.                   "
               0  ;
               0  implicit none;
               0  $REAL K,PHOTTZ;
               0  $INTEGER I;
               0  COMIN/MIXDAT/;
               0  PHOTTE=0.0;
               0  DO I=1,NE[PHOTTE=PHOTTE+PZ(I)*PHOTTZ(Z(I),K);]
               0  RETURN;
               0  END;   "END OF FUNCTION PHOTTE"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PHOTTZ(Z,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***FUNCTION TO GIVE INTERPOLATED TOTAL PHOTO EFFECT CROSS-SECTION   "
               0  "   FROM TABULATED DATA USING LOG-LOG INTERPOLATION.                 "
               0  "   THIS CROSS-SECTION WILL BE THE CONTRIBUTION THIS Z ELEMENT       "
               0  "   WOULD MAKE IF THERE WERE ONE/MOLECULE,I.E., TO GET THE ACTUAL    "
               0  "   CONTRIBUTION ONE MUST MULTIPLY BY PZ(I).                         "
               0  "   COMMON WITH DATA FOR PHOTO AND PAIR.                             "
               0  ;
               0  implicit none;
               0  $REAL Z,K,PCON,AINTP;
               0  $INTEGER IZ;
               0  COMIN/PHPAIR,PMCONS,MOLVAR/;
               0  "     PCON CONVERTS CROSS SECTION IN BARNS TO CROSS SECTION IN RLC**-1 "
               0  PCON=1.E-24*(AN*RHO/WM)*RLC;
               0  IZ=Z;
               0  PHOTTZ=PCON*AINTP(K,PHE(1,IZ),NPHE(IZ),PHD(1,IZ),1,.TRUE.,.TRUE.);
               0  RETURN;
               0  END;  "END OF FUNCTION PHOTTZ"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION PSIG(E); "POSITRON CROSS SECTION(1/RL)"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL E,BREMTM,BHABTM,ANIHTM;
               0  PSIG=BREMTM(E)+BHABTM(E)+ANIHTM(E);
               0  RETURN;
               0  END;   "END OF FUNCTION PSIG"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION QD(F,A,B,MSG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  ;COMIN/FileNames/;
               0  " QD appears to be the only place where it is being written to unit 10"
               0  "EXTERNAL F;"
               0  INTERFACE
               0  REAL FUNCTION F(X)
               0  REAL, INTENT(IN) :: X
               0  END FUNCTION F
               0  END INTERFACE
               0  "$REAL    F;"
               0  $REAL    A,B;
               0  CHARACTER*6 MSG;
               0  logical first_time;
               0  data first_time/.true./;
               0  save first_time;
               0
               0  "    CHANGED"
               0
               0  "    REAL*8 DCADRE,ADUM,BDUM,ERRDUM,MSG;"
               0
               0  "    TO"
               0
               0  "    DOUBLE PRECISION DCADRE,ADUM,BDUM,ERRDUM;"
               0  "    CHARACTER*6 MSG;"
               0
               0  "    FOR SUN COMPATIBILITY AFB 89/12/27"
               0
               0  DOUBLE PRECISION DCADRE,ADUM,BDUM,ERRDUM;
               0  $INTEGER IER;
               0
               0  ADUM=A; BDUM=B;
               0  QD=DCADRE(F,ADUM,BDUM,$AERR,$RERR,ERRDUM,IER);
               0  IF (IER.GT.66)[
               1      IF( first_time ) [
               2          first_time = .false.;
               2          output_file(lenfn-7:lenfn) = 'pegs4err';
               2          open(10,file=output_file,status='unknown');
               2          ]
               1      $UOUTPUT(10) IER,MSG,A,B,QD,ERRDUM;
               1      (' DCADRE CODE=',I4,' FOR INTEGRAL ',A6,' FROM ',1P,G14.6,' TO ',G14.6,
               1      ',QD=',G14.6,'+-',G14.6);
               1      ]
               0  RETURN;
               0  END;  "END OF FUNCTION QD"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION SPIONB(E0,EE,POSITR);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***STOPPING POWER FOR AN ELECTRON.  THIS FUNCTION ALSO HAS OTHER    "
               0  "   ENTRY POINTS. . .                                                "
               0  "   SPIONP(E0,EE) - STOPPING POWER FOR A POSITRON                    "
               0  "   SPINIT(MEDIUM) - DOES INITIALIZATION FOR THE OTHER ENTRY POINTS  "
               0  "   WHENEVER THE MEDIUM CHANGES.                                     "
               0  "   THIS FUNCTION IS FOR STOPPING POWER DUE TO COLLISIONS WITH LESS  "
               0  "   THAN EE-RM ENERGY TRANSFER AND DOES NOT INCLUDE SOFT BREMS LOSS. "
               0  "   WE USE BERGER AND SELTZER'S FORMULATION.                         "
               0  "   STOPPING POWER IS RETURNED IN UNITS OF MEV/R.L.                  "
               0  ;
               0  implicit none;
               0  $REAL   E0,EE;
               0  LOGICAL POSITR;
               0  $REAL   G,EEM,T,ETA2,BETA2,ALETA2,X,D,FTERM,TP2,D2,D3,D4,DELTA;
               0  $INTEGER I;
               0  COMIN/DERCON,LSPION,EPSTAR/; "MOD NOV 24,1988"
               0  "     COMMON POINT FOR E- AND E+ ENTRIES.                              "
               0  G=E0/RM;
               0  EEM=EE/RM-1.;
               0  "     T IS BERGER'S TAU                                                "
               0  T=G-1;
               0  ETA2=T*(G+1.);
               0  BETA2=ETA2/G**2;
               0  ALETA2=ALOG(ETA2);
               0  X=0.21715*ALETA2;
               0  "     0.21715=ALOG10(E)/2.   THIS FACTOR IS BECAUSE THE DEFINITION OF  "
               0  "     X IS ALOG10(P/(MC)) AND ETA2=ETA**2=(P/MC)**2                    "
               0  IF (.NOT.POSITR)["THIS IS ELECTRON CASE"
               1      "     COMPUTE F-TERM FOR ELECTRON.  MAXIMUM TRANSFER IS T/2            "
               1      "     D IS BERGER'S CAPITOL DELTA.                                     "
               1      D=AMIN1(EEM,0.5*T);
               1      "     EEM IS DEFINED AS EE/RM-1 IS ENERGY TRANSFER THRESHOLD FOR       "
               1      "     DISCRETE MOLLER AND BHABHA SCATTERING(IN UNITS OF RM.)           "
               1      FTERM=-1.-BETA2+ALOG((T-D)*D)+T/(T-D)
               1      +(D*D/2.+(2.*T+1.)*ALOG(1.-D/T))/(G*G);]
               0  "     COMPUTE F-TERM FOR POSITRON.  MAXIMUM TRANSFER IS T.             "
               0  ELSE ["THIS IS POSITRON CASE"
               1      D=AMIN1(EEM,T);
               1      TP2=T+2.;
               1      D2=D*D;
               1      D3=D*D2;
               1      D4=D*D3;
               1      FTERM=ALOG(T*D)-(BETA2/T)*( T + 2.*D - (3.*D2/2.)/TP2
               1      -(D-D3/3.)/(TP2*TP2)-(D2/2.-T*D3/3.+D4/4.)/TP2**3);]
               0
               0  "     NOW COMPUTE THE DENSITY CORRECTION TERM.                         "
               0
               0  IF(EPSTFL = 0) ["USE STANDARD PEGS4 METHOD"
               1      IF (X.LE.X0) [DELTA=0.0;]
               1      ELSEIF (X.LT.X1) [DELTA=TOLN10*X - CBAR + AFACT*(X1 - X)**SK;]
               1      ELSE [DELTA=TOLN10*X - CBAR;]]
               0
               0  ELSE ["USE LINEAR INTERPOLATION OF USER SUPPLIED INPUT TABLE"
               1
               1      "IEPST IS A POINTER SUCH THAT                              "
               1      "       EPSTEN(IEPST) <= E0 < EPSTEN(IEPST+1)              "
               1      "                                                          "
               1      "IEPST IS INITIALIZED IN BLOCK DATA TO 1. WE START FROM    "
               1      "THE PREVIOUS VALUE OF THE POINTER SINCE WE ASSUME THAT    "
               1      "THE CODE IS WORKING UP OR DOWN A GRID.                    "
               1      "  THIS CODING IS FAR FROM OPTIMAL                         "
               1
               1      IF(E0 >= EPSTEN(IEPST))["AT OR ABOVE PREVIOUS ENTRY"
               2          IF(E0 = EPSTEN(IEPST))["FOUND ENTRY, INCLUDING THE POSSIBILITY"
               3              "THAT WE ARE AT THE TOP OF THE TABLE"     GO TO :END-SEARCH:;]
               2
               2          DO I= IEPST,NEPST-1 [
               3              IF(E0<EPSTEN(I+1))["WE FOUND IT" IEPST = I; GO TO :END-SEARCH:]
               3              ]
               2          "IF WE FALL THRU TO HERE, WE MUST BE AT UPPER ENERGY"
               2          IEPST = NEPST; GO TO :END-SEARCH:;
               2          ]"END OF BLOCK E0>EPSTEN(IEPST)"
               1
               1      ELSE [ "E0<EPSTEN(IEPST)"
               2
               2          DO I = IEPST,2,-1 [
               3              IF(E0 >= EPSTEN(I-1)) [IEPST = I-1; GO TO :END-SEARCH:;]
               3              ]
               2          "   IF WE GET HERE WE MUST BE IN THE FIRST REGION"
               2          IEPST = 1;]
               1
               1      :END-SEARCH:
               1
               1      "NOW JUST INTERPOLATE LINEARLY IN THE ENERGY"
               1      IF(IEPST < NEPST) [
               2          DELTA = EPSTD(IEPST) + (E0 - EPSTEN(IEPST))/
               2          (EPSTEN(IEPST+1) - EPSTEN(IEPST)) * (EPSTD(IEPST+1) - EPSTD(IEPST));]
               1      ELSE [DELTA = EPSTD(NEPST);]
               1
               1      ]"END OF EPSTFL NON-ZERO BLOCK"
               0
               0  "     NOW PUT IT ALL TOGETHER                                          "
               0  SPIONB=(SPC1/BETA2)*(ALOG(T + 2.) - SPC2 + FTERM - DELTA);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONB"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION SPIONE(E0,EE);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL E0,EE,SPIONB;
               0  SPIONE=SPIONB(E0,EE,.FALSE.);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONE"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION SPIONP(E0,EE);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL E0,EE,SPIONB;
               0  SPIONP=SPIONB(E0,EE,.TRUE.);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONP"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION SPTOTE(E0,EE,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  " patched DWOR, Jan 1988 to correct IURST=2,3,4 and add 6 and 7    "
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0  $REAL E0,EE,EG;
               0  $REAL SPIONE,BRMSTM;
               0  COMIN/THRESH/;
               0  IF (IUNRST.EQ.0) ["RESTRICTED TOTAL STOPPING POWER I.E. NORMAL"
               1      SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRST.EQ.1)[SPTOTE=SPIONE(E0,E0);]"UNRESTRICTED COLLISION"
               0  ELSEIF(IUNRST.EQ.2)["UNRESTRICTED COLLISION AND RADIATIVE        "
               1      SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRST.EQ.3)["UNRESTRICTED COLLISION +RESTRICTED RADIATIVE"
               1      SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRST.EQ.4)["RESTRICTED COLLISION +UNRESTRICTED RADIATIVE"
               1      SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRST.EQ.5)[SPTOTE=BRMSTM(E0,E0);]"UNRESTRICTED RADIATIVE"
               0  ELSEIF(IUNRST.EQ.6)[SPTOTE=BRMSTM(E0,EG);]"RESTRICTED RADIATIVE  "
               0  ELSEIF(IUNRST.EQ.7)[SPTOTE=SPIONE(E0,EE);]"RESTRICTED COLLISON   "
               0  RETURN;
               0  END;  "END OF FUNCTION SPTOTE"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION SPTOTP(E0,EE,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "MODIFIED JAN 1989 DWOR AS SPTOTE                                  "
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL E0,EE,EG;
               0  $REAL SPIONP,BRMSTM;
               0  COMIN/THRESH/;
               0  IF (IUNRST.EQ.0) ["RESTRICTED TOTAL STOPPING POWER I.E. NORMAL"
               1      SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRST.EQ.1)[SPTOTP=SPIONP(E0,E0);]"UNRESTRICTED COLLISION"
               0  ELSEIF(IUNRST.EQ.2)["UNRESTRICTED COLLISION AND RADIATIVE        "
               1      SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRST.EQ.3)["UNRESTRICTED COLLISION +RESTRICTED RADIATIVE"
               1      SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRST.EQ.4)["RESTRICTED COLLISION +UNRESTRICTED RADIATIVE"
               1      SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRST.EQ.5)[SPTOTP=BRMSTM(E0,E0);]"UNRESTRICTED RADIATIVE"
               0  ELSEIF(IUNRST.EQ.6)[SPTOTP=BRMSTM(E0,EG);]"RESTRICTED RADIATIVE  "
               0  ELSEIF(IUNRST.EQ.7)[SPTOTP=SPIONP(E0,EE);]"RESTRICTED COLLISON   "
               0  RETURN;
               0  END;  "END OF FUNCTION SPTOTP"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION TMXB(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL E;
               0  "THIS FUNCTION FINDS THE TRANSPORT DISTANCE WHICH AT THIS ENERGY"
               0  "IS THE LARGEST CONSISTENT WITH BETHE'S CRITERION, NAMELY"
               0  "  XC**2*B.LE.1;   SINCE XC ANB B ARE INCREASING FUNCTIONS OF T"
               0  " THE TRANSPORT DISTANCE, THE CRITERION FOR TMXB IS THEN"
               0  "  XC**2*B=1;      OTHER RELATIONS USED IN THE DERIVATION ARE"
               0  "EXPLAINED IN SUBROUTINES MIX AND MOLIER.  THEY ARE:"
               0  "  XC=XCC*SQRT(T)/(E*BETA**2); "
               0  "  EXP(B)/B = BLCC*T/BETA**2;  "
               0  "FROM THESE IS DERIVED THE EQUATION THIS FUNCTION IS BASED ON:"
               0  "TMXB=(E**2*BETA**2/XCC**2)*BETA**2/ALOG(BLCC*(E**2*BETA**2/XCC**2));"
               0  ;
               0  $REAL ESQ,BETA2,PX2;
               0  COMIN/DERCON,MOLVAR/;
               0  ESQ=E**2;
               0  BETA2=1.0-RMSQ/ESQ;
               0  PX2=ESQ*BETA2/XCC**2;
               0  TMXB=PX2*BETA2/ALOG(BLCC*PX2);
               0  RETURN;
               0  END;   "END OF FUNCTION TMXB"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION TMXDE2(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL E,ESQ,BETASQ,TMXB;
               0  COMIN/DERCON/;
               0  ESQ=E**2;
               0  BETASQ=1.0-RMSQ/ESQ;
               0  TMXDE2=TMXB(E)/(ESQ*BETASQ**2);
               0  RETURN;
               0  END; "END OF FUNCTION TMXDE2"
               0
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION TMXS(E);"MAXIMUM STEP SIZE VALID FOR MULTIPLE SCATTERING"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL E,TMXB;
               0  $REAL SAFETY,TABSMX;
               0  DATA SAFETY/0.8/,TABSMX/10.0/;
               0  save SAFETY,TABSMX;
               0  TMXS=AMIN1(TMXB(E)*SAFETY,TABSMX);
               0  "THE FACTORE 'SAFETY' IS TO KEEP SOMEWHAT BELOW BETHE'S LIMIT"
               0  "TABSMX IS AN ABSOLUTE LIMIT TO SIZE OF ELECTRON TRANSPORT,"
               0  "  INDEPENDENT OF THE MULTIPLE SCATTERING LIMIT"
               0  RETURN;
               0  END;  "END OF FUNCTION TMXS"
               0
1              0  %E  "PEGS4 MORTRAN (Page Eject Control)"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION XSIF (Z);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "EVALUATES EQUATION 2.7.21a OF SLAC-265"
               0
               0  ;
               0  implicit none;
               0  $REAL Z,FCOULC;
               0  $INTEGER IZ;
               0  COMIN/RADLEN/;
               0  IF (Z.LE.4.0) [IZ=Z;
               1      XSIF=ALRADP(IZ)/(ALRAD(IZ)-FCOULC(Z));]
               0  ELSE [
               1      XSIF=ALOG(A1440*Z**(-2./3.))/(ALOG(A183*Z**(-1./3.))-FCOULC(Z));]
               0  RETURN;
               0  END;  "END OF FUNCTION XSIF"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL FUNCTION ZTBL(IASYM);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  COMIN/ELEMTB/;
               0  $TYPE IASYM,IA;
               0  $INTEGER ie;
               0  DATA IA/'A'/;
               0  save ia;
               0  IF (IASYM.EQ.IA)["ALTERNATE SYMBOL FOR ARGON" ZTBL=18.0;RETURN;]
               0  "     PUT IN THE REST LATER                                 "
               0  DO IE=1,NET[
               1      IF (IASYM.EQ.ASYMT(IE)) [ZTBL=IE; RETURN;]
               1      ]
               0  OUTPUT IASYM,NET;
               0  (1X,A2,' NOT AN ATOMIC SYMBOL FOR AN ELEMENT WITH Z LE ',I3);
               0  ZTBL=0.0;
               0  RETURN;
               0  "END OF FUNCTION ZTBL" END;
               0
               0  "*******************************************************************"
               0  subroutine open_units;
               0  "*******************************************************************"
               0
               0
               0  implicit none;
               0
               0  ;COMIN/FileNames/;
               0  integer narg, iargc;
               0  integer i,lnblnk1,l,l1;
               0  logical have_arg,is_there;
               0  character arg*256,arg1*256,inp_file*256,fn*512,hen_house*128;
               0  logical egs_isdir,append;
               0
               0  narg = iargc();
               0
               0  IF( narg = 0 ) [ "Assume I'm being run from a shell script that has set up "
               1      "symbolik links to fort.* files "
               1      using_sym_links = .true.;
               1      fn = 'fort.5';
               1      open(5,file='fort.5',status='old',err=:file-error:);
               1      open(7,file='fort.7',status='new',err=:data_file_error:);
               1      open(6,file='fort.6',status='unknown');
               1      open(10,file='fort.10',status='unknown');
               1      open(21,file='fort.21',status='unknown');
               1      inquire(file='fort.20',exist=is_there);
               1      IF( is_there ) [ open(20,file='fort.20',status='old'); ]
               1      fn = 'fort.8';
               1      open(8,file=fn,status='old',err=:no_xsection_file:);
               1      fn = 'fort.9';
               1      open(9,file=fn,status='old',err=:no_ffactor__file:);
               1      return;
               1      ]
               0
               0  "======================================"
               0  "Added option to print out a brief help"
               0  "    Ernesto Mainegra-Hing June 02,2004"
               0  "======================================"
               0  IF (narg = 1)[
               1      call getarg(1,arg); l = lnblnk1(arg);
               1      IF( ( l = 2 & arg(:l) = '-h' ) |
               1      ( l = 6  & arg(:l) = '--help' ) ) [
               2          call show_pegs4_help();
               2          $CALL_EXIT(0);
               2          ]
               1      ]
               0  "======================================"
               0
               0  using_sym_links = .false.;
               0
               0  " append "
               0  append = .false.;
               0  DO i=1,narg [
               1      call getarg(i,arg); l = lnblnk1(arg);
               1      IF( ( l = 2 & arg(:l) = '-a' ) |
               1      ( l = 8 & arg(:l) = '--append' ) ) [
               2          append = .true.; goto :found-append:;
               2          ]
               1      ]
               0  :found-append:;
               0
               0  " HEN_HOUSE: either command line argument or taken from machine.macros "
               0  REPLACE {$HEN-HOUSE} WITH { hen_house(:lnblnk1(hen_house)) };
               0  have_arg = .false.; l = 0;
               0  DO i=1,len(hen_house) [ hen_house(i:i) = ' '; ]
               0  have_arg = .false.; l = 0;
               0  DO i=1,narg-1 [
               1      call getarg(i,arg); l = lnblnk1(arg);
               1      IF ( ( l = 2 & arg(:l) = '-h' ) |
               1      ( l = 11 & arg(:l) = '--hen-house' ) ) [
               2          call getarg(i+1,hen_house); l = lnblnk1(hen_house);
               2          IF( egs_isdir(hen_house) ) [ have_arg = .true.; ]
               2          ]
               1      ]
               0  IF( ~have_arg ) [ hen_house = $HEN_HOUSE; ]
               0
               0  " EGS_HOME: either command line argument or taken from the environment "
               0  DO i=1,len(egs_home) [ egs_home(i:i) = ' '; ]
               0  DO i=1,narg-1 [
               1      call getarg(i,arg); l = lnblnk1(arg);
               1      IF ( ( l = 2 & arg(:l) = '-e' ) |
               1      ( l = 10 & arg(:l) = '--egs-home' ) ) [
               2          call getarg(i+1,egs_home); l = lnblnk1(egs_home);
               2          IF( egs_isdir(egs_home ) ) [ have_arg = .true.; ]
               2          ]
               1      ]
               0  IF( l = 0 | ~have_arg ) [
               1      call getenv('EGS_HOME',egs_home); l = lnblnk1(egs_home);
               1      IF( l = 0 ) [
               2          write(6,*);
               2          write(6,*) ' EGS_HOME was hot passed as an argument and also ';
               2          write(6,*) ' the environment variable EGS_HOME is not set! ';
               2          write(6,*) ' Quiting now.';
               2          write(6,*);
               2          $CALL_EXIT(1);
               2          ]
               1      ]
               0
               0  DO i=1,len(inp_file) [ inp_file(i:i) = ' '; ]
               0  DO i=1,len(output_file) [ output_file(i:i) = ' '; ]
               0  DO i=1,len(input_file) [ input_file(i:i) = ' '; ]
               0  DO i=1,len(density_file) [ density_file(i:i) = ' '; ]
               0  DO i=1,len(fn) [ fn(i:i) = ' '; ]
               0
               0  have_arg = .false.;
               0  DO i=1,narg-1 [
               1      call getarg(i,arg); l = lnblnk1(arg);
               1      IF ( ( l = 2 & arg(:l) = '-i' ) |
               1      ( l = 7 & arg(:l) = '--input' ) ) [
               2          call getarg(i+1,arg);
               2          l1 = lnblnk1(arg);
               2          arg1(:len(arg1)) = ' ';
               2          IF( l1 > 10 & arg(l1-8:l1) = '.pegs4inp' ) [
               3              arg1(:l1-9) = arg(:l1-9);
               3              arg(l1-8:l1) = '.pegs4lst';
               3              inp_file(:l1-9) = arg(:l1-9);
               3              ]
               2          ELSE [
               3              IF( l1 > 248 ) [
               4                  write(6,*) ' Input file name is too long! ';
               4                  $CALL_EXIT(1);
               4                  ]
               3              inp_file(:l1) = arg(:l1);
               3              arg1 = arg(:lnblnk1(arg)) // '.pegs4lst';
               3              arg(l1+1:l1+9) = '.pegs4inp'; l1 = l1 + 9;
               3              ]
               2          fn(:l1) = arg(:l1);
               2          inquire(file=fn,exist=is_there);
               2          IF ( is_there ) [
               3              have_arg = .true.; goto :found-input-file:;
               3              ]
               2          fn = $EGS_HOME // 'pegs4' // $file_sep // 'inputs' // $file_sep // arg;
               2          inquire(file=fn,exist=is_there);
               2          IF ( is_there ) [
               3              have_arg = .true.; goto :found-input-file:;
               3              ]
               2          fn = $HEN-HOUSE // 'pegs4' // $file_sep // 'inputs' // $file_sep // arg;
               2          inquire(file=fn,exist=is_there);
               2          IF ( is_there ) [
               3              have_arg = .true.; goto :found-input-file:;
               3              ]
               2          write(6,*) '******************** Error **************************';
               2          write(6,'(a,a)') ' you specified an input file named ',arg(:l1);
               2          write(6,'(a,a)') ' but the file does not exist in';
               2          write(6,'(a,a)') '     ',$EGS_HOME // 'pegs4/inputs/';
               2          write(6,'(a,a)') '     ',$HEN-HOUSE // 'pegs4/inputs/';
               2          write(6,'(a)')   '      the current working directory';
               2          write(6,'(a)') ' and is also not an existing absolute file name';
               2          write(6,*) '*****************************************************';
               2          $CALL_EXIT(1);
               2          ]
               1      ]
               0  :found-input-file:
               0  IF( have_arg ) [
               1      open(5,file=fn,status='old',err=:file-error:);
               1      DO i=1,lnblnk1(fn) [ input_file(i:i) = fn(i:i); ]
               1      DO i=lnblnk1(fn)+1,len(input_file) [ input_file(i:i) = ' '; ]
               1      ]
               0  ELSE [
               1      DO i=1,len(input_file) [ input_file(i:i) = ' '; ]
               1      write(6,'(/a/)') 'No input file. All input must come from the terminal';
               1      ]
               0
               0  have_arg = .false.;
               0  DO i=1,narg-1 [
               1      call getarg(i,arg);
               1      l = lnblnk1(arg);
               1      IF ( ( l = 2 & arg(:l) = '-o' ) |
               1      ( l = 8 & arg(:l) = '--output' ) ) [
               2          call getarg(i+1,arg); have_arg = .true.;
               2          goto :found-output-option:;
               2          ]
               1      ]
               0  :found-output-option:
               0  IF( have_arg ) [
               1      l1 = lnblnk1(arg);
               1      IF( l1 < 10 | arg(l1-8:l1) ~= '.pegs4dat' ) [
               2          arg = arg(:lnblnk1(arg)) // '.pegs4dat';
               2          ]
               1      ]
               0  ELSE [
               1      DO i=1,len(arg) [ arg(i:i) = ' '; ]
               1      arg(:lnblnk1(inp_file)) = inp_file(:lnblnk1(inp_file));
               1      call egs_strip_path(arg);
               1      l = lnblnk1(arg);
               1      IF( l = 0 ) [
               2          write(6,*) ' Without input file you must explicitly specify the ';
               2          write(6,*) ' output file';
               2          $CALL_EXIT(1);
               2          ]
               1      arg(l+1:l+10) = '.pegs4dat';
               1      ]
               0  fn = $EGS_HOME // 'pegs4' // $file_sep // 'data' // $file_sep // arg;
               0  IF( append ) [
               1      open(7,file=fn,status='old',access='append',err=:data1_file_error:);
               1      "LOOP [ read(7,*,err=:end-of-data:,end=:end-of-data:); ]"
               1      ":end-of-data:;"
               1      ]
               0  ELSE [
               1      open(7,file=fn,status='new',err=:data_file_error:);
               1      ]
               0
               0  fn = $EGS_HOME // 'pegs4' // $file_sep // 'inputs' // $file_sep // arg;
               0  output_file = $EGS_HOME // 'pegs4' // $file_sep // 'data' // $file_sep // arg;
               0  l = lnblnk1(fn); lenfn = l;
               0  IF( lnblnk1(inp_file) > 0 ) [
               1      fn(l-7:l) = 'pegs4lst';
               1      open(6,file=fn,status='unknown');
               1      ]
               0  "fn(l-7:l) = 'pegs4err'; open(10,file=fn,status='unknown');"
               0  "fn(l-7:l) = 'plot    '; open(21,file=fn,status='unknown');"
               0
               0  have_arg = .false.;
               0  fn(:len(fn)) = ' ';
               0  DO i=1,narg-1 [
               1      call getarg(i,arg);
               1      l = lnblnk1(arg);
               1      IF( ( l = 2 & arg(:l) = '-d' ) |
               1      ( l = 16 & arg(:l) = '--density-effect' ) ) [
               2          call getarg(i+1,arg);
               2          arg = arg(:lnblnk1(arg)) // '.density';
               2          fn = arg;
               2          inquire(file=fn,exist=is_there);
               2          IF( is_there ) [
               3              open(20,file=fn,status='old'); have_arg = .true.;
               3              goto :found_density_file:;
               3              ]
               2          fn = $EGS_HOME // 'pegs4/density_corrections/' // arg;
               2          inquire(file=fn,exist=is_there);
               2          IF( is_there ) [
               3              open(20,file=fn,status='old'); have_arg = .true.;
               3              goto :found_density_file:;
               3              ]
               2          fn = $EGS_HOME // 'pegs4/density_corrections/elements/' // arg;
               2          inquire(file=fn,exist=is_there);
               2          IF( is_there ) [
               3              open(20,file=fn,status='old'); have_arg = .true.;
               3              goto :found_density_file:;
               3              ]
               2          fn = $EGS_HOME // 'pegs4/density_corrections/compounds/' // arg;
               2          inquire(file=fn,exist=is_there);
               2          IF( is_there ) [
               3              open(20,file=fn,status='old'); have_arg = .true.;
               3              goto :found_density_file:;
               3              ]
               2          fn = $HEN-HOUSE // 'pegs4/density_corrections/elements/' // arg;
               2          inquire(file=fn,exist=is_there);
               2          IF( is_there ) [
               3              open(20,file=fn,status='old'); have_arg = .true.;
               3              goto :found_density_file:;
               3              ]
               2          fn = $HEN-HOUSE // 'pegs4/density_corrections/compounds/' // arg;
               2          inquire(file=fn,exist=is_there);
               2          IF( is_there ) [
               3              open(20,file=fn,status='old'); have_arg = .true.;
               3              goto :found_density_file:;
               3              ]
               2          ]
               1      ]
               0  :found_density_file:
               0  IF( have_arg ) [
               1      write(6,'(/a,a/)') '************ Using density file ',fn(:lnblnk1(fn));
               1      DO i=1,lnblnk1(fn) [ density_file(i:i) = fn(i:i); ]
               1      ]
               0
               0  have_arg = .false.; fn(:len(fn)) = ' ';
               0  DO i=1,narg-1 [
               1      call getarg(i,arg); l = lnblnk1(arg);
               1      IF( ( l = 2 & arg(:l) = '-x' ) |
               1      ( l = 10  & arg(:l) = '--xsection' ) ) [
               2          call getarg(i+1,arg); l = lnblnk1(arg);
               2          fn(:l) = arg(:l); inquire(file=fn,exist=is_there);
               2          IF( is_there ) [ goto :found_xsection_file:; ]
               2          fn = $HEN-HOUSE // 'pegs4/' // arg;
               2          inquire(file=fn,exist=is_there);
               2          IF( is_there ) [ goto :found_xsection_file:; ]
               2          arg = arg(:l) // '.dat'; l = l + 4;
               2          fn = arg; inquire(file=fn,exist=is_there);
               2          IF( is_there ) [ goto :found_xsection_file:; ]
               2          fn = $HEN-HOUSE // 'pegs4/' // arg;
               2          inquire(file=fn,exist=is_there);
               2          IF( is_there ) [ goto :found_xsection_file:; ]
               2          ]
               1      ]
               0  fn = $HEN-HOUSE // 'pegs4/pgs4pepr.dat';
               0  :found_xsection_file:
               0  DO i=1,len(xsection_file) [ xsection_file(i:i) = ' '; ]
               0  DO i=1,lnblnk1(fn) [ xsection_file(i:i) = fn(i:i); ]
               0  open(8,file=fn,status='old',err=:no_xsection_file:);
               0  write(6,'(a,a/)') '************ Using cross section data file ',
               0  fn(:lnblnk1(fn));
               0
               0
               0  have_arg = .false.; fn(:len(fn)) = ' ';
               0  DO i=1,narg-1 [
               1      call getarg(i,arg); l = lnblnk1(arg);
               1      IF( ( l = 2 & arg(:l) = '-f' ) |
               1      ( l = 13  & arg(:l) = '--form-factor' ) ) [
               2          call getarg(i+1,arg); l = lnblnk1(arg);
               2          fn(:l) = arg(:l); inquire(file=fn,exist=is_there);
               2          IF( is_there ) [ goto :found_ffactor__file:; ]
               2          fn = $HEN-HOUSE // 'pegs4/' // arg;
               2          inquire(file=fn,exist=is_there);
               2          IF( is_there ) [ goto :found_ffactor__file:; ]
               2          arg = arg(:l) // '.dat'; l = l+4;
               2          fn = arg; inquire(file=fn,exist=is_there);
               2          IF( is_there ) [ goto :found_ffactor__file:; ]
               2          fn = $HEN-HOUSE // 'pegs4/' // arg;
               2          inquire(file=fn,exist=is_there);
               2          IF( is_there ) [ goto :found_ffactor__file:; ]
               2          ]
               1      ]
               0  fn = $HEN-HOUSE // 'pegs4/pgs4form.dat';
               0  :found_ffactor__file:
               0  DO i=1,len(formf_file) [ formf_file(i:i) = ' '; ]
               0  DO i=1,lnblnk1(fn) [ formf_file(i:i) = fn(i:i); ]
               0  open(9,file=fn,status='old',err=:no_ffactor__file:);
               0  write(6,'(a,a/)') '************ Using form factor data file ',
               0  fn(:lnblnk1(fn));
               0
               0  fn = $HEN-HOUSE // 'pegs4/aprime.data';
               0  open(22,file=fn,status='old',err=:no_aprime_file:);
               0
               0  return;
               0
               0  :file-error:
               0  write(6,'(//a,a//)') ' Failed to open file ',fn(:lnblnk1(fn));
               0  $CALL_EXIT(1);
               0
               0  :data_file_error:
               0  write(6,'(//a,a)') ' Data file ',fn(:lnblnk1(fn)),' exists.';
               0  write(6,'(a//)') ' Remove or rename it and retry ';
               0  $CALL_EXIT(2);
               0
               0  :data1_file_error:
               0  write(6,'(//a/,a/,a)') ' You have specified the append option, but file ',
               0  fn(:lnblnk1(fn)),' does not exist ';
               0  $CALL_EXIT(6);
               0
               0  :no_xsection_file:
               0  write(6,'(//a,a//)') ' Failed to open x-section file ',fn(:lnblnk1(fn));
               0  $CALL_EXIT(3);
               0
               0  :no_ffactor__file:
               0  write(6,'(//a,a//)') ' Failed to open form-factor file ',fn(:lnblnk1(fn));
               0  $CALL_EXIT(4);
               0
               0  :no_aprime_file:
               0  write(6,'(//a,a//)') ' Failed to open Aprime data file ',fn(:lnblnk1(fn));
               0  $CALL_EXIT(5);
               0
               0  end;
               0
               0  integer function lnblnk1(string);
               0  character*(*) string;
               0  integer i,j;
               0  DO i=len(string),1,-1 [
               1      j = ichar(string(i:i));
               1      IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
               2          lnblnk1 = i; return;
               2          ]
               1      ]
               0  lnblnk1 = 0;
               0  return; end;
               0  ;
               0
               0  "==============================================================================
               0  subroutine egs_strip_path(fname);
               0  "==============================================================================
               0  " Strip the path name from fname (if any)
               0  implicit none;
               0  character*(*) fname;
               0  $INTEGER i,l,l1,lnblnk1,j;
               0  l = lnblnk1(fname);
               0  DO i=l,1,-1 [
               1      IF( fname(i:i) = $file_sep ) [
               2          l1 = l-i;
               2          fname(:l1) = fname(i+1:l);
               2          DO j=l1+1,len(fname) [ fname(j:j) = ' '; ]
               2          return;
               2          ]
               1      ]
               0  return; end;
               0  ;
               0
               0  subroutine show_pegs4_help();
               0
               0  write(*,*) 'The usage is somewhat different from the previous';
               0  write(*,*) 'EGSnrc or EGS4 environments since all parameters';
               0  write(*,*) 'are now passed on the command line.';
               0  write(*,*) 'To run the code it is best to go to the directory';
               0  write(*,*) 'where the input file is stored (ifile.pegs4inp has';
               0  write(*,*) 'the same format as defined in the EGSnrc manual)';
               0  write(*,*) 'and issue the command:'; write(*,*);
               0  write(*,'(a,$)') 'pegs4.exe -i ifile [-o ofile] [-a] [-d density]';
               0  write(*,*) '[-x CrossSectData] [-e HEN_HOUSE]'; write(*,*);
               0
               0
               0  write(*,*) '-i ifile         => ifile.pegs4inp is the input file';
               0  write(*,*) '-o ofile         => if present output file is';
               0  write(*,*) '                    $EGS_HOME/pegs4/data/ofile.pegs4dat';
               0  write(*,*) '                    & if not present output  is';
               0  write(*,*) '                    $EGS_HOME/pegs4/data/ifile.pegs4dat';
               0  write(*,*) '-a               => if present that output is appended to';
               0  write(*,*) '                    [i|o]file.pegs4dat';
               0  write(*,*) '-d density       => if present density effect is in';
               0  write(*,*) '                    density.density';
               0  write(*,*) '-x CrossSectData => if present use';
               0  write(*,*) '                    $HEN_HOUSE/pegs4/CrossSectData as';
               0  write(*,*) '                    cross section file instead of';
               0  write(*,*) '                    $HEN_HOUSE/pegs4/pgs4pepr.dat';
               0  write(*,*) '-e HEN_HOUSE     => if present store data on';
               0  write(*,*) '                    $HEN_HOUSE/pegs4/data';
               0  write(*,*) '                    rather than $EGS_HOME/pegs4/data';
               0  write(*,*) '-h or --help     => print this help screen';
               0  return; end;
               0  ;
               0  C##############################################################################
               0  C
               0  C   This file was automatically generated by configure version 2.0
               0  C   It contains various subroutines and functions for date, time,
               0  C   CPU time, host name, etc.
               0  C
               0  C   Attention: all changes will be lost the next time you run configure!
               0  C
               0  C##############################################################################
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_system subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C egs_system(command)  runs a system command and returns the status
               0  C                      command must be null-terminated
               0  C*****************************************************************************
               0  integer function egs_system(command)
               0  character*(*) command
               0  integer system, istat
               0  istat = system(command)
               0  egs_system = istat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_isdir subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C  egs_isdir(file_name)  Returns .true., if the string file_name points to
               0  C                        an existing directory. This version uses the lstat
               0  C                        intrinsic and then tests for bit 14 being set in
               0  C                        the mode element. This works on all Unix systems
               0  C                        that I have access to (Linux, Aix, HP-UX, OSF1,
               0  C                        Solaris, IRIX)
               0  C
               0  C*****************************************************************************
               0
               0  logical function egs_isdir(file_name)
               0  implicit none
               0  character*(*) file_name
               0  integer*4 lnblnk1, res, array(13), l, lstat
               0  logical btest
               0  egs_isdir = .false.
               0  l = lnblnk1(file_name)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
               0  ! On some systems lstat only works if the string is 0-terminated
               0  res = lstat(file_name,array)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
               0  if( res.eq.0 ) then
               0  ! Amost all compilers that have the lstat intrinsic return the
               0  ! file mode in the 3rd array element. But the PGI compiler has
               0  ! its own opinion on the subject and returns it in the 5th element
               0  ! That's why the relevant element is written as 3
               0  ! here, 3 gets replaced by the appropriate element
               0  ! by the configure script.
               0  if( btest(array(3),14) ) egs_isdir = .true.
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C***************************************************************************
               0  C
               0  C   egs_fdate(out):  print a 24 char date and time string in the form
               0  C                         'Tue Mar 18 08:16:42 2003'
               0  C                    to the unit specified by out without end of line
               0  C                    i.e. the sequence
               0  C                    write(6,'(a,$)') 'Today is '
               0  C                    call egs_fdate(6)
               0  C                    write(6,'(a)') '. Have a nice date'
               0  C                    should result in something like
               0  C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
               0  C                    printed to unit 6.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_fdate(ounit)
               0  integer ounit
               0  character*24 string
               0  call fdate(string)
               0  write(ounit,'(a,$)') string
               0  end
               0
               0  C***************************************************************************
               0  C
               0  C   egs_get_fdate(string) assignes a 24 char date and time string to string
               0  C                         string must be at least 24 chars long, otherwise
               0  C                         this subroutine has no effect.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_get_fdate(string)
               0  character*(*) string
               0  if( len(string).ge.24 ) call fdate(string)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date_and_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  subroutine egs_date_and_time(vnow)
               0  integer vnow(8)
               0  character dat*8,tim*10,zon*5
               0  call date_and_time(dat,tim,zon,vnow)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*************************************************************************
               0  C
               0  C egs_date(ounit): print a 11 char string in the form
               0  C                     '18-Mar-2003'
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_date(ounit)
               0  integer ounit
               0  character string*24, dat*11
               0  call fdate(string)
               0  dat(1:2) = string(9:10)
               0  dat(3:3) = '-'
               0  dat(4:6) = string(5:7)
               0  dat(7:7) = '-'
               0  dat(8:11) = string(21:24)
               0  write(ounit,'(a,$)') dat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
               0  C*************************************************************************
               0  C
               0  C egs_time(ounit): print a 8 char string in the form hh:mm:ss
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_time(ounit)
               0  integer ounit
               0  character string*24
               0  call fdate(string)
               0  write(ounit,'(a,$)') string(12:19)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc seconds timing subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_secnds(t0): returns seconds passed since midnight minus t0
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_secnds(t0)
               0  real t0,t1
               0  character dat*8,tim*10,zon*5
               0  integer values(8)
               0  call date_and_time(dat,tim,zon,values)
               0  t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
               0  egs_secnds = t1 - t0
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_tot_time()
               0  C
               0  C   On first call returns seconds passed since 1/1/1970
               0  C   On subsequent calls returns
               0  C     - seconds since last call, if flag = 0
               0  C     - seconds since first call, else
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_tot_time(flag)
               0  integer flag
               0  character dat*8,tim*10,zon*5
               0  integer vnow(8), vlast(8),i
               0  real t,egs_time_diff,t0
               0  data vlast/1970,1,1,5*0/,t0/-1/
               0  save vlast,t0
               0  call date_and_time(dat,tim,zon,vnow)
               0  t = egs_time_diff(vlast,vnow)
               0  do i=1,8
               0  vlast(i)=vnow(i)
               0  end do
               0  if( t0.lt.0 ) then
               0  t0 = 0
               0  egs_tot_time = t
               0  else
               0  t0 = t0 + t
               0  if(flag.eq.0) then
               0  egs_tot_time = t
               0  else
               0  egs_tot_time = t0
               0  end if
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date and time subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C****************************************************************************
               0  C
               0  C Returns the time difference between vstart and vend
               0  C vstart and vend are integer arrays of dimension 8 with elements
               0  C corresponding to the specification of the data_and_time routine, i.e.
               0  C   array(1) = year
               0  C   array(2) = month of the year   (1...12)
               0  C   array(3) = day of the month    (1...31)
               0  C   array(4) = difference in minutes from UTC
               0  C   array(5) = hour of the day     (1...23)
               0  C   array(6) = minute of the hour  (1...59)
               0  C   array(7) = seconds of the minute (1...59)
               0  C   array(8) = miliseconds of the second (1...999)
               0  C
               0  C Note: this implementation ignores the time difference from UTC field
               0  C
               0  C*****************************************************************************
               0  real function egs_time_diff(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  real       egs_time_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_time_diff = -egs_time_diff_o(vend,vstart)
               0  else
               0  egs_time_diff = egs_time_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C day difference between the dates specified by the integer arrays vstart and
               0  C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
               0  C
               0  C******************************************************************************
               0  integer function egs_day_diff(vstart,vend)
               0  integer vstart(3),vend(3),egs_day_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_day_diff = -egs_day_diff_o(vend,vstart)
               0  else
               0  egs_day_diff = egs_day_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns a 3-letter abreviation of the day of the week in the string day,
               0  C given a day specified by the integer array values
               0  C   values(1)=year, values(2)=month, values(3)=day
               0  C
               0  C******************************************************************************
               0  subroutine egs_weekday(values,day)
               0  character*(*) day
               0  integer       values(3)
               0  integer       days,vtmp(3),egs_day_diff,aux
               0  character*3   wdays(7)
               0  data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
               0  vtmp(1) = 1970
               0  vtmp(2) = 1
               0  vtmp(3) = 1
               0  days = egs_day_diff(vtmp,values)
               0  aux = mod(days,7)
               0  days = 4 + aux
               0  if( days.gt.7 ) days = days - 7
               0  day(:len(day)) = ' '
               0  aux = min(len(day),3)
               0  day(:aux) = wdays(days)(:aux)
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Same as egs_day_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C*****************************************************************************
               0  integer function egs_day_diff_o(vstart,vend)
               0  integer vstart(3),vend(3)
               0  integer    days
               0  logical    next_month
               0  integer    tm,m,ty,y
               0  integer    mdays(12)
               0  data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
               0  days = 0
               0  ty = vstart(1)
               0  y  = vend(1)
               0  tm = vstart(2)
               0  m  = vend(2)
               0  next_month = .true.
               0  do while(next_month)
               0  if( tm.eq.m.and.ty.eq.y ) then
               0  next_month = .false.
               0  else
               0  days = days + mdays(tm)
               0  if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
               0  tm = tm + 1
               0  if( tm.gt.12 ) then
               0  ty = ty + 1
               0  tm = 1
               0  end if
               0  end if
               0  end do
               0  days = days + vend(3) - vstart(3)
               0  egs_day_diff_o = days
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Same as egs_time_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C******************************************************************************
               0  real function egs_time_diff_o(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  integer    days,hours,minutes,secs,msecs
               0  integer    egs_day_diff_o
               0  days = egs_day_diff_o(vstart,vend)
               0  hours = vend(5) - vstart(5)
               0  minutes = vend(6) - vstart(6)
               0  secs = vend(7) - vstart(7)
               0  msecs = vend(8) - vstart(8)
               0  egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
               0  &                  0.001*msecs
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns in month a 3-letter abreviation of the month specified by mo, if
               0  C mo is between 1 and 12, or an empty string otherwise.
               0  C
               0  C******************************************************************************
               0  subroutine egs_month(mo,month)
               0  integer mo
               0  character*(*) month
               0  integer iaux
               0  character*3   months(12)
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  iaux = min(len(month),3)
               0  month(:len(month)) = ' '
               0  if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Converts a 3-letter abreviation of a month to its corresponding integer
               0  C value, if the string month is a valid month, or -1 otherwise.
               0  C
               0  C******************************************************************************
               0  integer function egs_conver_month(month)
               0  character*3 month
               0  character*3 months(12)
               0  integer i
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  do i=1,12
               0  if( month.eq.months(i) ) then
               0  egs_conver_month = i
               0  return
               0  end if
               0  end do
               0  egs_conver_month = -1
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_etime subroutine
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_etime(): returns CPU time consumed since the start of
               0  C                            the program
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_etime()
               0  real tarray(2),etime
               0  egs_etime = etime(tarray)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc canonical system name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_canonical_system(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_canonical_system(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('x86_64-unknown-linux-gnu')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'x86_64-unknown-linux-gnu'
               0  else
               0  res(:l2) = 'x86_64-unknown-linux-gnu'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc configuration name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the configuration name as specified suring the configuration
               0  C process to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_configuration_name(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'linux'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the configuration name as specified suring the configuration
               0  C process to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_configuration_name(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('linux')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'linux'
               0  else
               0  res(:l2) = 'linux'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc hostname subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C Print the host name to the unit specified by ounit without inserting
               0  C a new line character.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_hostnm(ounit)
               0  integer ounit
               0  character*256 string
               0  integer res,hostnm,lnblnk1
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  write(ounit,'(a,$)') string(:lnblnk1(string))
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Assign the host name to the string pointed to be hname.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_get_hostnm(hname)
               0  character*(*) hname
               0  character*256 string
               0  integer res,hostnm,lnblnk1,l1,l2,l
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  l1 = lnblnk1(string)
               0  l2 = len(hname)
               0  hname(:l2) = ' '
               0  l = min(l1,l2)
               0  hname(:l) = string(:l)
               0  return
               0  end
               0
               0
          END OF MORTRAN INPUT
  95      PERCENT RULE CAPACITY REMAINING
          NO MORTRAN ERRORS DETECTED
