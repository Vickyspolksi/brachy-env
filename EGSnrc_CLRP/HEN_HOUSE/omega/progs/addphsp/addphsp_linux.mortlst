Mortran 3.2 Tue Aug 19 16:00:06 2025
               0  %L                                                                     ;
1              0  %E
               0  %I4                                                                    ;
               0  !INDENT F2;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  "#############################################################################"
               0  "                                                                             "
               0  " EGSnrc machine dependent macro file for linux                               "
               0  "                                                                             "
               0  " Created by configure version 2.0 on mar 19 ago 2025 15:59:50 -03            "
               0  "                                                                             "
               0  " You may add your own machine dependent macros to this file,                 "
               0  " but be carefull to not overwrite it if you re-run configure.                "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0  REPLACE {$MACHINE} WITH
               0  {,'linux',};
               0  REPLACE {$HEN_HOUSE} WITH
               0  {'/home/usuario/EGSnrc_CLRP/HEN_HOUSE/'};
               0  REPLACE {$CANONICAL_SYSTEM} WITH
               0  {'x86_64-unknown-linux-gnu'};
               0  REPLACE {$CONFIGURATION_NAME} WITH
               0  {'linux'};
               0  REPLACE {$EGS_CONFIG} WITH
               0  {'/home/usuario/EGSnrc_CLRP/HEN_HOUSE/specs/linux.conf'};
               0
               0  REPLACE {$CONFIG_TIME} WITH
               0  {'2025-08-19 18:59:50 UTC'};
               0
               0  " System dependent stuff "
               0  "========================================"
               0  " Unfortunately, there appears to be no reliable way of copying files "
               0  " under Fortran => we use a system call for this"
               0  REPLACE {$copy_file} WITH {'cp '};
               0
               0  " Although one can move files using Fortran's intrinsic rename, "
               0  " we don't know whether the user has not created additional files in "
               0  " the temporary working directory => it is easiest to use a system call "
               0  " to move all files from the temporary working directory to the user-code "
               0  " directory. "
               0  REPLACE {$move_file} WITH {'mv -f '};
               0
               0  " There appears to be no way of removing a directory from Fortran "
               0  " => we use a system call for this. "
               0  REPLACE {$remove_directory} WITH {'rm -rf '};
               0
               0  " The directory separator "
               0  REPLACE {$file_sep} WITH {'/'};
               0
               0  REPLACE {$LONG_INT} WITH { integer*8 };
               0  REPLACE {$SHORT_INT} WITH { integer*2 };
               0  "$MAX_INT SET TO 2^63-1 in egsnrc.macros"
               0  "The machine byte order"
               0  REPLACE {$BYTE_ORDER} WITH {'1234'};
               0  ;
               0  REPLACE {$RECL-FACTOR} WITH {4};
               0  ;
               0  REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
               0  ;
               0  " If you want your user-code to return an exit status, use the "
               0  " following macro to terminate execution"
               0  REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
               0  ;
               0  " mortran3 gets confused by the # char => we need to pass it as an "
               0  " argument to the macro. "
               0  REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
               0  ;
               0  REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros                                                              "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                   Victor Malkov                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0  "but this DOES NOT apply withing macro definitions!!
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  %L          "Turn on listing                                                   ;
               0
               0
               0  "=================================================================="
               0  " Macros to implement implicit data types                          "
               0  "=================================================================="
               0
               0  REPLACE {$LOGICAL} WITH {;logical}
               0  REPLACE {$REAL}    WITH {;real*8}
               0  REPLACE {$INTEGER} WITH {;integer*4}
               0  REPLACE {$LONG_INT} WITH {;integer*8} "change this to integer*4 for compilers"
               0  "that do not support integer*8"
               0  REPLACE {$SHORT_INT} WITH {;integer*2} "change this to integer*4 for compilers"
               0  "that do not support integer*2"
               0  "the above is not used in EGSnrc but is used in the NRC user codes,
               0  "especially related to number of histories"
               0  "Note that the HP compiler does not support *8 integers so the above"
               0  " should be changed for HP"
               0
               0  REPLACE {$IMPLICIT-NONE;} WITH {;}
               0  REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}
               0
               0  "=================================================================="
               0  "SELECT THE FORTRAN STANDARD TO BE USED (1966 OR 1977)             "
               0  REPLACE {$FORTVER} WITH {1977}
               0  "=================================================================="
               0
               0  "******************************************************************"
               0  REPLACE {$TYPE} WITH {
            {  0  {SETR F=$FORTVER}
            {  0  [IF] {COPY F}=1977 [CHARACTER*4] [ELSE] [INTEGER*4]
            {  0  }
               0  "******************************************************************"
               0
               0  "******************************************************************"
               0  SPECIFY ALPHA    AS (0...$);
               0  SPECIFY SYMBOL   AS (0...?);
               0  SPECIFY NAME     AS LETTER(0,5)[ALPHA];
               0  SPECIFY <COMMA>  AS [','|''];
               0  SPECIFY <NAME>   AS [NAME|''];
               0  SPECIFY LABEL    AS ':'NAME':';
               0  SPECIFY <LABEL>  AS [LABEL|''];
               0  SPECIFY <*>      AS ['*'|''];
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {NEWLABEL} WITH {@LG}
               0  REPLACE {%'{ARB}'={<*>}'{ARB}'}
               0  WITH {[IF] '{P2}'='*' [APPEND'{P3}'TO'{P1}']
            {  0  [ELSE] [ REPLACE {{P1}}WITH{{P3}}]}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "RULES TO GENERALIZE MORTRAN'S INPUT AND OUTPUT"
               0  REPLACE {;$UINPUT(#)#;}
               0  WITH {;{SETR A=NEWLABEL}
            {  0  READ({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$UOUTPUT(#)#;}
               0  WITH {;{SETR A=NEWLABEL}
            {  0  WRITE({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$ECHO#({NAME}{<COMMA>}#)#;}
               0  WITH {;{SETR X=NEWLABEL}
            {  0  WRITE(IUECHO,{COPY X});{COPY X}FORMAT(' ECHO {P1}:{P5}');
            {  0  [IF] {EXIST 3} [{P1}({P2},{P4}){P5};
            {  0  WRITE(IUECHO,{P4}){P5};]
            {  0  [ELSE] [{SETR Y=NEWLABEL}{P1}({P2},{COPY Y}){P4};
            {  0  WRITE(IUECHO,{COPY Y}){P5};{COPY Y}FORMAT]
            {  0  }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  REPLACE {;IUECHO=#;} WITH { REPLACE {IUECHO} WITH {{P1}};}
               0  "INITALIZE" ;IUECHO=6;
               0
               0  "MACRO TO SPLIT STRING INTO A LIST SEPARATED BY COMMAS"
               0  REPLACE {$S'{SYMBOL}#'}
               0  WITH {'{P1}'[IF]{EXIST 2}[,$S'{P2}']}
               0
               0  "SOME DEBUGGING MACROS"
               0  REPLACE {$LIST#/#/#;} WITH
               0  {;OUTPUT {P3};('LIST/{P2}/{P3}:'/(1X,{P1}));}
               0  APPEND{;COMMON/QDEBUG/QDEBUG;LOGICAL QDEBUG;} TO {;COMIN/DEBUG/;}
               0
               0  REPLACE {$TRACE#;} WITH
               0  {REPLACE {;{P1}={WAIT {ARB}};}  WITH
            {  0  {{EMIT;{P1}}={WAIT {P1}};
            {  0  IF QDEBUG [OUTPUT{P1};
            {  0  (' {P1} ASSIGNED {WAIT {P1}} ',G25.18);] }; }
               0  REPLACE {$S1TRACE#;} WITH
               0  {{SETR A=NEWLABEL}
            {  0  REPLACE {;{P1}({WAIT {ARB}})={WAIT {ARB}};}
            {  0  WITH {{EMIT ;{P1}({WAIT {P1}})}={WAIT {P2}};
            {  0  IF QDEBUG [I{COPY A}={WAIT {P1}};
            {  0  OUTPUT I{COPY A},{P1}(I{COPY A});
            {  0  (' {P1}(',I6,') ASSIGNED {WAIT {P2}} ' ,
            {  0  G25.18);] } ;}
               0
               0  REPLACE {$TRACE#,#;} WITH {$TRACE{P1};$TRACE{P2};}
               0  REPLACE {$S1TRACE#,#;} WITH {$S1TRACE{P1};$S1TRACE{P2};}
               0
               0  SPECIFY DELIM AS ['('|';'];
               0  REPLACE {$CALLTRACE;} WITH
               0  {REPLACE {;CALL{NAME}{DELIM}} WITH
            {  0  {;IF (QDEBUG)[OUTPUT;
            {  0  (' SUBROUTINE {WAIT {P1}} CALLED.');]
            {  0  {WAIT {EMIT CALL} {P1}{P2}} };}
               0
               0  REPLACE {$DUMP#,#;} WITH
               0  {;{SETR A=NEWLABEL}
            {  0  V{COPY A}={P1};OUTPUT V{COPY A};(' {P1}=',1PG15.7);
            {  0  [IF] {EXIST 2} [$DUMP{P2};] ;}
               0  "NOTICE: THE LIST OF VARIABLES MUST BE FOLLOWED BY A COMMA"
               0  "FOR EXAMPLE $DUMP S,T(U,V),W,; OR $DUMP A,;"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MORTRAN MACRO DEFINITIONS FOR EGS."
               0
               0  REPLACE {$CONFIG_TIME} WITH {'unknown'}
               0
               0  "FIRST SOME PARAMETERS"
               0  REPLACE {PARAMETER #=#;} WITH
               0  { REPLACE {{P1}} WITH {{P2}}}
               0
               0  PARAMETER $MXMED=10;      "MAX. NO. OF DIFFERENT MEDIA (EXCL. VAC.)"
               0  PARAMETER $MXREG=2000;    "MAXIMUM NO. OF REGIONS ALLOCATED"
               0  PARAMETER $MXSTACK=40;    "STACK SIZE"
               0  PARAMETER $MXVRT1=1000;   "NO. OF REPRESENTATIVE ANGLES IN VERT1"
               0  PARAMETER $FMXVRT1=1000.; "FLOATING $MXVRT1"
               0  PARAMETER $MXPWR2I=50;    "SIZE OF TABLE OF INVERSE POWERS OF TWO"
               0  PARAMETER $MXJREFF=200;   "SIZE OF MULTIPLE SCATTERING JREFF MAP"
               0  PARAMETER $MSSTEPS=16;    "NO. OF MULTIPLE SCATTERING STEP SIZES"
               0  PARAMETER $MXVRT2=100;    "DISTRBTN OF NONOVERLAPPING PARTS OF VERT"
               0
               0  ;
               0  "FOLLOWING DEFINE MAX. NO. OF INTERVALS FOR FIT TO FUNCTIONS"
               0  PARAMETER $MXSGE=400;     "GAMMA SMALL ENERGY INTERVALS"
               0  PARAMETER $MXGE=2000;     "GAMMA MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXSEKE=300;    "ELECTRON SMALL ENERGY INTERVALS"
               0  PARAMETER $MXEKE=500;     "ELECTRON MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXEL=50;       "MAXIMUM # OF ELEMENTS IN A MEDIUM"
               0  PARAMETER $MXLEKE=100;    "ELECTRON ENERGY INTERVALS BELOW EKELIM"
               0  PARAMETER $MXCMFP=100;    "CUMULATIVE ELECTRON MEAN-FREE-PATH"
               0  PARAMETER $MXRANGE=100;   "ELECTRON RANGE"
               0  PARAMETER $MXBLC=20;      "MOLIERE'S LOWER CASE B"
               0  PARAMETER $MXRNTH=20;     "RANDOM NUMBER FOR SUBMEDIAN ANGLES"
               0  PARAMETER $MXRNTHI=20;    "RANDOM NUMBER FOR SUPERMEDIAN ANGLES"
               0  PARAMETER $MXRAYFF=100;   "RAYLEIGH ATOMIC FORM FACTOR"
               0  PARAMETER $RAYCDFSIZE=100;"CDF from RAYLEIGH FORM FACTOR SQUARED"
               0  PARAMETER $MXSINC=1002;   "ANGLE INTERVALS IN (0,5*PI/2) FOR SINE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE PARAMETERS FOR AUSGAB CALLS:"
               0  PARAMETER $MXAUS=35;       "CHANGE IF MORE AUSGAB CALLS ARE ADDED"
               0  PARAMETER $MXAUSM5=30;     "SET THIS TO $MXAUS VALUE LESS 5"
               0
               0  "FIRST FIVE AUSGAB CALLS BELOW TURNED ON IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSB=0;    "BEFORE TRANSPORT"
               0  PARAMETER $EGSCUTAUS=1;   "ENERGY BELOW ECUT OR PCUT"
               0  PARAMETER $PEGSCUTAUS=2;  "ENERGY BELOW AE OR AP"
               0  PARAMETER $USERDAUS=3;    "USER REQUESTED DISCARD"
               0  PARAMETER $PHOTXAUS=4;    "FLUORESCENT PHOTON DISCARD"
               0
               0  "THE REMAINING 23 ARE TURNED OFF IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSA=5;    "AFTER TRANSPORT"
               0  PARAMETER $BREMAUSB=6;    "BEFORE BREMS CALL"
               0  PARAMETER $BREMAUSA=7;    "AFTER BREMS CALL"
               0  PARAMETER $MOLLAUSB=8;    "BEFORE MOLLER CALL"
               0  PARAMETER $MOLLAUSA=9;    "AFTER MOLLER CALL"
               0  PARAMETER $BHABAUSB=10;   "BEFORE BHABHA CALL"
               0  PARAMETER $BHABAUSA=11;   "AFTER BHABHA CALL"
               0  PARAMETER $ANNIHFAUSB=12; "BEFORE ANNIH CALL"
               0  PARAMETER $ANNIHFAUSA=13; "AFTER ANNIH CALL"
               0  PARAMETER $ANNIHRAUSB=28; "BEFORE POSITRON ANNIH AT REST"
               0  PARAMETER $ANNIHRAUSA=14; "POSITRON ANNIHILATED AT REST"
               0  PARAMETER $PAIRAUSB=15;   "BEFORE PAIR CALL"
               0  PARAMETER $PAIRAUSA=16;   "AFTER PAIR CALL"
               0  PARAMETER $COMPAUSB=17;   "BEFORE COMPT CALL"
               0  PARAMETER $COMPAUSA=18;   "AFTER COMPT CALL"
               0  PARAMETER $PHOTOAUSB=19;  "BEFORE PHOTO CALL"
               0  PARAMETER $PHOTOAUSA=20;  "AFTER PHOTO CALL"
               0  PARAMETER $UPHIAUSB=21;   "ENTERED UPHI"
               0  PARAMETER $UPHIAUSA=22;   "LEFT UPHI"
               0  PARAMETER $RAYLAUSB=23;   "BEFORE RAYLEIGH EVENT"
               0  PARAMETER $RAYLAUSA=24;   "AFTER RAYLEIGH EVENT"
               0  PARAMETER $FLUORTRA=25;   "A fluorescent transition just occurred"
               0  PARAMETER $COSKROTRA=26;  "A Coster-Kronig transition just occurred"
               0  PARAMETER $AUGERTRA=27;   "An Auger transition just occurred"
               0  "Ali:photonuc, 2 lines"
               0  " note that 28 is already used for positron annih at rest - see above"
               0  PARAMETER $PHOTONUCAUSB=29; "BEFORE PHOTONUCLEAR EVENT"
               0  PARAMETER $PHOTONUCAUSA=30; "AFTER PHOTONUCLEAR EVENT"
               0  PARAMETER $EIIB=31;   "Before EII"
               0  PARAMETER $EIIA=32;   "After EII"
               0  PARAMETER $SPHOTONA=33;   "After sub-threshold photon energy deposition"
               0  PARAMETER $SELECTRONA=34;   "After sub-threshold electron energy deposition"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$AUSCALL(#);} WITH
               0  {IARG={P1} ;  IF (IAUSFL(IARG+1).NE.0) [CALL AUSGAB(IARG);]} ;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "TEMPORARY OVER-RIDES FOR SOME OF THE ABOVE"
               0  PARAMETER $MXSGE=1;
               0  PARAMETER $MXSEKE=1;
               0  PARAMETER $MXLEKE=1;
               0  PARAMETER $MXCMFP=1;
               0  PARAMETER $MXRANGE=1;
               0  PARAMETER $MXBLC=1;
               0  PARAMETER $MXRNTH=1;
               0  PARAMETER $MXRNTHI=1;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING DEFINE PRECISION USED IN ENERGY COMPUTATIONS"
               0  "THE LATTER OF THE TWO WILL BE IN EFFECT"
               0  REPLACE {$ENERGYPRECISION} WITH {;REAL }"SINGLE PRECISION"
               0  REPLACE {$ENERGYPRECISION} WITH {;DOUBLE PRECISION }
               0  REPLACE {$MAX_INT} WITH {2147483647} "2^31-1"
               0  "^--- limits number of particles and hence phase space file size"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS TO MAKE CHANGES IN THE DEGREE OF FIT EASIER"
               0  "ALSO USEFUL FOR ABBREVIATING LISTS OF SUBSCRIPTED VARIABLES"
               0  "$LGN STANDS FOR 'LIST GENERATOR'"
               0  "$RSC MEANS THAT THE EXPANDED LIST SHOULD RESCANNED FOR FURTHER"
               0  "OPERATIONS.  MACROS EXPECTING TO DO RESCANS SHOULD BE"
               0  "DEFINED AFTER THE FOLLOWING MACRO"
               0  REPLACE {$RSC(#)} WITH {{P1}}
               0  "IF NOT MATCHED BY ANYTHING ELSE, REMOVE $RSC()"
               0  REPLACE {$RSC(#),#$LSCALEBY#;} WITH
               0  {{P1}={P1}*{P3};{P2}$LSCALEBY{P3};}
               0  REPLACE {$RSC(#)$LSCALEBY#;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$LGN(#/#/)} WITH {$RSC({P1}{P2})}
               0  REPLACE {$LGN(#(#)/#/)} WITH {$RSC({P1}{P3}({P2}))}
               0  REPLACE {$LGN(#(#))} WITH {$RSC({P1}({P2}))}
               0  REPLACE {$LGN(#/#,#/)} WITH
               0  {$LGN({P1}/{P2}/),$LGN({P1}/{P3}/)}
               0  REPLACE {$LGN(#,#/#/)} WITH
               0  {$LGN({P1}/{P3}/),$LGN({P2}/{P3}/)}
               0  REPLACE {$LGN(#(#)/#,#/)} WITH
               0  {$LGN({P1}({P2})/{P3}/),$LGN({P1}({P2})/{P4}/)}
               0  REPLACE {$LGN(#,#(#)#)} WITH
               0  {$LGN({P1}({P3}){P4}),$LGN({P2}({P3}){P4})}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR SCALING REQUIRED BY CHANGE IN DISTANCE UNIT"
               0  REPLACE {$SCALE# BY #;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$SCALE#,# BY #;} WITH
               0  {{P1}={P1}*{P3};$SCALE{P2} BY {P3};}
               0  REPLACE {$SCALE$LGN(#) BY #;} WITH
               0  {$LGN({P1})$LSCALE BY {P2};}
               0  REPLACE {$SCALE$LGN(#),# BY #;} WITH
               0  {$LGN({P1})$LSCALE BY {P3};$SCALE{P2} BY {P3};}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------
               0  " Macros related to bit setting
               0  "------------------------------------------------------------------
               0  ""
               0  "Macro to set bit {P2} in {P1}  to 1
               0  REPLACE {$IBSET(#,#);} WITH {ibset({P1},{P2});}
               0
               0  "Macro to set test bit {P2} in {P1}
               0  "Note this may require a LOGICAL declaration wherever used
               0  REPLACE {$BTEST(#,#)} WITH {btest({P1}, {P2})}
               0
               0  "Macro to set bit {P2} in {P1}  to 0
               0  REPLACE {$IBCLR(#,#);} WITH {ibclr({P1},{P2});}
               0  "Above used by RW_PH_SP routine - (read_write_phase_space for BEAM)
               0
               0
               0  "COMMON BLOCK INSERTION MACROS"
               0  REPLACE {;COMIN/#,#/;} WITH {;COMIN/{P1}/;COMIN/{P2}/;}
               0
               0  "NOW FOR SOME SPECIFIC COMMON BLOCKS"
               0
               0  "------------------------------------------------------------------"
               0  "*** BOUNDS--CUTOFF ENERGIES & VACUUM TRANSPORT DISTANCE           "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/BOUNDS/;} WITH
               0  {
            {  0  ;COMMON/BOUNDS/ECUT($MXREG),PCUT($MXREG),VACDST;
            {  0  $REAL         ECUT,   "Minimum electron transport energy"
            {  0  PCUT,   "Minimum photon transport energy"
            {  0  VACDST; "Infinity (1E8)"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** BREMPR--BREMSSTRAHLUNG AND PAIR PRODUCTION DATA               "
               0  "------------------------------------------------------------------"
               0
               0  ;
               0  REPLACE {$MXBREN} WITH {57}
               0  REPLACE {$MXBRXX} WITH {54}
               0  REPLACE {$MXBREL} WITH {100}
               0  REPLACE {$MXGAUSS} WITH {64}
               0  REPLACE {$MXBRES} WITH {100}
               0  REPLACE {$MXBRXS} WITH {50}
               0  REPLACE {$NIST-ENERGY-SCALE} WITH {1.0}
               0
               0  REPLACE {$NIST-DATA-UNIT} WITH {i_nist_data}
               0  ;
               0
               0  REPLACE {$COMIN-INIT-NIST-BREMS;} WITH {;
            {  0  ;COMIN/MEDIA,BREMPR,ELECIN,THRESH,USEFUL,NIST-BREMS,Spin-Data,EGS-IO/;
            {  0  };
               0
               0  REPLACE {;COMIN/BREMPR/;} WITH
               0  {
            {  0  ;COMMON/BREMPR/
            {  0  $LGN(DL(8,$MXMED)/1,2,3,4,5,6/),
            {  0  $LGN(ALPHI,BPAR,DELPOS(2,$MXMED)),
            {  0  $LGN(WA,PZ,ZELEM,RHOZ($MXMED,$MXEL)),
            {  0  PWR2I($MXPWR2I),
            {  0  $LGN(DELCM,ZBRANG,LZBRANG,NNE($MXMED)),
            {  0  IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet,
            {  0  ASYM($MXMED,$MXEL,2);
            {  0  $TYPE     ASYM;
            {  0  $REAL     $LGN(DL/1,2,3,4,5,6/), "Parameter for the fit of the screening"
            {  0  "rejection function, eq. (2.7.14 and 15)"
            {  0  ALPHI,  "Prob. for the (1-BR)/BR part in BREMS, eq. (2.7.64)"
            {  0  BPAR,   "Prob. for the 12*(BR-1/2)**2 part in PAIR, eq. (2.7.105)"
            {  0  DELPOS, "maximum delta, eq. (2.7.31)"
            {  0  WA,     "atomic weight"
            {  0  PZ,     "atomic fraction of an element in a compound"
            {  0  ZELEM,  "Z for a given component"
            {  0  RHOZ,   "density of an element in a compound"
            {  0  PWR2I,  "powers of 1/2 (used for sampling (1-BR)/BR"
            {  0  DELCM,  "136*m*exp(Zg), eq. (2.7.51)"
            {  0  ZBRANG, "composite factor for angular distributions"
            {  0  LZBRANG;"-Log(ZBRANG)"
            {  0  $INTEGER  NNE,    "number of elements/compound"
            {  0  IBRDST, "flag to switch on bremsstrahlung angular distributions"
            {  0  IPRDST, "flag to switch on pair angular distributions"
            {  0  ibr_nist,  "use the NIST bremsstrahlung cross sections"
            {  0  itriplet,  "if set to 1, explicitely simulate triplet events"
            {  0  pair_nrc;  "=0 => use Bethe-Heitler pair cross sections"
            {  0  "=1 => use the NRC pair cross sections"
            {  0  };
               0
               0  REPLACE {;COMIN/NIST-BREMS/;} WITH {;
            {  0
            {  0  common/nist_brems/ nb_fdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0  nb_xdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0  nb_wdata($MXBRXS,$MXBRES,$MXMED),
            {  0  nb_idata($MXBRXS,$MXBRES,$MXMED),
            {  0  nb_emin($MXMED),nb_emax($MXMED),
            {  0  nb_lemin($MXMED),nb_lemax($MXMED),
            {  0  nb_dle($MXMED),nb_dlei($MXMED),
            {  0  log_ap($MXMED);
            {  0  $REAL    nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lemax,
            {  0  nb_dle,nb_dlei,log_ap;
            {  0  $INTEGER nb_idata;
            {  0  };
               0
               0  REPLACE {$NRC-PAIR-NXX} WITH {65};
               0  REPLACE {$NRC-PAIR-NEE} WITH {84};
               0  REPLACE {$NRC-PAIR-NX-1} WITH {64};
               0  REPLACE {$NRC-PAIR-NE-1} WITH {83};
               0
               0  REPLACE {;COMIN/NRC-PAIR-DATA/;} WITH {;
            {  0  common/nrc_pair/ nrcp_fdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0  nrcp_wdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0  nrcp_idata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0  nrcp_xdata($NRC-PAIR-NXX),
            {  0  nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0  $REAL            nrcp_fdata,nrcp_wdata,nrcp_xdata,
            {  0  nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0  $INTEGER         nrcp_idata;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** TRIPLET DATA                                                        "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MAX_TRIPLET} WITH {250}
               0  REPLACE {;COMIN/TRIPLET-DATA/;} WITH {;
            {  0  common/triplet_data/ a_triplet($MAX_TRIPLET,$MXMED),
            {  0  b_triplet($MAX_TRIPLET,$MXMED),
            {  0  dl_triplet, dli_triplet, bli_triplet, log_4rm;
            {  0  $REAL                a_triplet,b_triplet,dl_triplet, dli_triplet,
            {  0  bli_triplet, log_4rm;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** COMPTON-DATA -- Incoherent scattering data                          "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MXTOTSH}   WITH {1538} "Total number of shells for Z=1..100    "
               0  REPLACE {$MXMDSH}    WITH {200}   "Max. number of shells per medium       "
               0  REPLACE {$INCOHUNIT} WITH {i_incoh}   "Unit number for compton data           "
               0
               0  REPLACE {;COMIN/COMPTON-DATA/;} WITH
               0  {
            {  0  ;common/compton_data/ iz_array($MXTOTSH), "Atomic number for each shell"
            {  0  be_array($MXTOTSH), "Shell binding energies      "
            {  0  Jo_array($MXTOTSH), "Compton profile parameter   "
            {  0  erfJo_array($MXTOTSH),"needed for the calculation"
            {  0  "of the incoherent scattering"
            {  0  "function                    "
            {  0  ne_array($MXTOTSH), "Occupation number           "
            {  0  shn_array($MXTOTSH),"shell type                  "
            {  0  "(=1     for K,              "
            {  0  " =2,3,4 for L1,L2,L3        "
            {  0  " =5     for M               "
            {  0  " =6     for N               "
            {  0  " =7     for all others      "
            {  0  shell_array($MXMDSH,$MXMED),
            {  0  eno_array($MXMDSH,$MXMED),
            {  0  eno_atbin_array($MXMDSH,$MXMED),
            {  0  n_shell($MXMED),
            {  0  radc_flag,          "flag for radiative corrections"
            {  0  ibcmp($MXREG);      "flag to turn on binding effects"
            {  0  $INTEGER             iz_array,ne_array,shn_array,eno_atbin_array,
            {  0  shell_array,n_shell,radc_flag;
            {  0  $REAL                be_array,Jo_array,erfJo_array,eno_array;
            {  0  $SHORT_INT           ibcmp;
            {  0  }
               0
               0
               0  "------------------------------------------------------------------ "
               0  "*** EDGE -- Containes binding energies for K,L1,L2,L3,             "
               0  "             'average' M and 'average' N shells; photo-absorption  "
               0  "             interaction probabilities with these shells;          "
               0  "             + fluorescence, Auger, Coster-Kronig transition       "
               0  "             probabilities                                         "
               0  "             IEDGFL is a flag for turning on/off atomic relaxations"
               0  "             IPHTER is a flag for turning on/off photo-lectron     "
               0  "                    angular distribution                           "
               0  "             both are left-overs from the previous coding          "
               0  "             Have put now also data to calculate elemental PE      "
               0  "             cross sections needed to sample the element the photon"
               0  "             is interacting with.
               0  "------------------------------------------------------------------ "
               0  REPLACE {$MXELEMENT} WITH {100}  " Number of elements               "
               0  REPLACE {$MXSHXSEC}  WITH {30}   " Number of shells available       "
               0  REPLACE {$MXSHELL}   WITH {6}    " Number of shells treated         "
               0  REPLACE {$MXINTER}   WITH {5}    " $MXSHELL-1                       "
               0  REPLACE {$MXTRANS}   WITH {39}   " Number of possible transitions   "
               0  REPLACE {$MXEDGE}    WITH {16}   " max. number of edges above 1 keV "
               0  REPLACE {$PHOTOUNIT} WITH {i_photo_relax} " unit number for photo_relax.data "
               0  REPLACE {$PHOCSUNIT} WITH {i_photo_cs}   " unit number for photo_cs.data    "
               0
               0  REPLACE {;COMIN/EDGE/;} WITH
               0  {;
            {  0  COMMON/EDGE/binding_energies($MXSHXSEC,$MXELEMENT),
            {  0  interaction_prob($MXSHELL,$MXELEMENT),
            {  0  relaxation_prob($MXTRANS,$MXELEMENT),
            {  0  edge_energies($MXEDGE,$MXELEMENT),
            {  0  edge_number($MXELEMENT),
            {  0  edge_a($MXEDGE,$MXELEMENT),
            {  0  edge_b($MXEDGE,$MXELEMENT),
            {  0  edge_c($MXEDGE,$MXELEMENT),
            {  0  edge_d($MXEDGE,$MXELEMENT),
            {  0  IEDGFL($MXREG),IPHTER($MXREG);
            {  0  $REAL       binding_energies, " K,L1,L2,L3,M,N binding energies  "
            {  0  interaction_prob, " prob. for interaction with one of"
            {  0  " the above shells (provided photon"
            {  0  " energy is above be)              "
            {  0  relaxation_prob,  " relaxation probabilities         "
            {  0  edge_energies,    " photo-absorption edge energies   "
            {  0  edge_a,edge_b,edge_c,edge_d;
            {  0  " photo cross section fit parameters "
            {  0  $SHORT_INT  IEDGFL,  "flag for switching on fluorscent emission"
            {  0  IPHTER;  "flag for switching on photo-electron angular distr."
            {  0  $INTEGER    edge_number; " number of `edges' for each element"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** ELECIN--ELECTRON TRANSPORT INPUT                              "
               0  "        MODIFIED 1989/12/19 TO INCLUDE IUNRST,EPSTFL AND IAPRIM   "
               0  "        NRC DWOR                                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/ELECIN/;} WITH
               0  {;
            {  0  COMMON/ELECIN/
            {  0  esig_e($MXMED),psig_e($MXMED),
            {  0  esige_max, psige_max,
            {  0  range_ep(0:1,$MXEKE,$MXMED),
            {  0  E_array($MXEKE,$MXMED),
            {  0  $LGN(etae_ms,etap_ms,q1ce_ms,q1cp_ms,q2ce_ms,q2cp_ms,
            {  0  blcce($MXEKE,$MXMED)/0,1/),
            {  0  $LGN(EKE($MXMED)/0,1/),
            {  0  $LGN(XR0,TEFF0,BLCC,XCC($MXMED)),
            {  0  $LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,TMXS($MXEKE,$MXMED)/0,1/),
            {  0  expeke1($MXMED),
            {  0  IUNRST($MXMED),EPSTFL($MXMED),IAPRIM($MXMED),
            {  0  sig_ismonotone(0:1,$MXMED);
            {  0  $REAL    esig_e,        "maximum electron cross section per energy loss"
            {  0  "for each medium"
            {  0  psig_e,        "maximum positron cross section per energy loss"
            {  0  "for each medium"
            {  0  esige_max,     "maximum electron cross section per energy loss"
            {  0  psige_max,     "maximum electron cross section per energy loss"
            {  0  range_ep,      "electron (0) or positron (1) range"
            {  0  E_array,       "table energies"
            {  0  etae_ms0,etae_ms1,
            {  0  "for interpolation of screening parameter (e-)"
            {  0  etap_ms0,etap_ms1,
            {  0  "for interpolation of screening parameter (e+)"
            {  0  q1ce_ms0,q1ce_ms1,
            {  0  "for interpolation of q1 correction due to spin (e-)"
            {  0  q1cp_ms0,q1cp_ms1,
            {  0  "for interpolation of q1 correction due to spin (e+)"
            {  0  q2ce_ms0,q2ce_ms1,
            {  0  "for interpolation of q2 correction due to spin (e-)"
            {  0  q2cp_ms0,q2cp_ms1,
            {  0  "for interpolation of q2 correction due to spin (e+)"
            {  0  blcce0,blcce1,"for interpolation of scattering power correction   "
            {  0  "necessary to account for scattering already taken  "
            {  0  "into account in discrete Moller/Bhabha             "
            {  0  expeke1,       "Exp(1/eke1)-1"
            {  0  $LGN(EKE/0,1/),"table for kinetic energy indexing"
            {  0  XR0,           "unused, but read in HATCH"
            {  0  TEFF0,         "unused, but read in HATCH"
            {  0  BLCC,          "b lower case sub c"
            {  0  XCC,           "chi sub-c-c"
            {  0  ESIG0,ESIG1,   "used for electron cross section interpolation"
            {  0  PSIG0,PSIG1,   "used for positron cross section interpolation"
            {  0  EDEDX0,EDEDX1, "used for electron dE/dx interpolation"
            {  0  PDEDX0,PDEDX1, "used for positron dE/dx interpolation"
            {  0  EBR10,EBR11,   "used for e- branching into brems interpolation"
            {  0  PBR10,PBR11,   "used for e+ branching into brems interpolation"
            {  0  PBR20,PBR21,   "used for e+ branching into Bhabha interpolation"
            {  0  TMXS0,TMXS1;   "used for maximum step-size interpolation"
            {  0  $INTEGER IUNRST,        "flag for type of stopping power (see PEGS4)"
            {  0  EPSTFL,        "flag for ICRU37 collision stopping powers"
            {  0  IAPRIM;        "flag for ICRU37 radiative stopping powers"
            {  0  $LOGICAL sig_ismonotone;"true, if cross section is an increasing function"
            {  0  "of energy, false otherwise"
            {  0  }
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common block for EII data -----------------                  "
               0  "
               0  " Added by Iwan Kawrakow, March 20 2004.
               0  "                                                                           "
               0  "****************************************************************************
               0
               0  REPLACE {$MAX_EII_SHELLS} WITH {40};  "Maximum number of shells participating"
               0  "in EII in a simulation                "
               0  REPLACE {$N_EII_BINS} WITH {250};     "Number of bins for EII x-section      "
               0  "interpolations                        "
               0  REPLACE {$MAX_EII_BINS} WITH {{COMPUTE $N_EII_BINS*$MAX_EII_SHELLS}};
               0  "We store the EII x-section interpolation coefficients in 1D arrays  "
               0  "The above is the dimension of these arrays required to hold the data"
               0  REPLACE {;COMIN/EII-DATA/;} WITH {;
            {  0  common/eii_data/
            {  0  eii_xsection_a($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0  eii_xsection_b($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0  eii_cons($MXMED),
            {  0  eii_a($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0  eii_b($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0  eii_L_factor,                  "L-shell EII xsection scaling factor"
            {  0  eii_z($MAX_EII_SHELLS),        "Z of each shell                   "
            {  0  eii_sh($MAX_EII_SHELLS),       "shell type (1=K, 2=LI, eyc.)      "
            {  0  eii_nshells($MXELEMENT),       "No. of EII shells for each element"
            {  0  eii_nsh($MXMED),               "No. of EII shells for each medium "
            {  0  eii_first($MXMED,$MXEL),       "First EII shell in the list of shells"
            {  0  eii_no($MXMED,$MXEL),          "N. of EII shells                  "
            {  0  eii_flag;                      "EII flag                          "
            {  0  "         = 0 => no EII            "
            {  0  "         = 1 => simple EII        "
            {  0  "         > 1 => future use        "
            {  0  $REAL     eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_factor;
            {  0  $INTEGER  eii_z,eii_sh,eii_nshells;
            {  0  $INTEGER  eii_first,eii_no;
            {  0  $INTEGER  eii_elements,eii_flag,eii_nsh;
            {  0  };
               0
               0  REPLACE {$COMIN-EII-SAMPLE;} WITH {
            {  0  ;COMIN/EPCONT,EII-DATA,EGS-VARIANCE-REDUCTION,RANDOM,STACK,THRESH,
            {  0  UPHIOT,USEFUL,EGS-IO,RELAX-DATA/;
            {  0  };
               0  REPLACE {$COMIN-EII-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,EII-DATA,ELECIN,MEDIA,THRESH,USEFUL/;
            {  0  };
               0
               0  REPLACE {;COMIN/EMF-INPUTS/;} WITH {;
            {  0  common/emf_inputs/ExIN,EyIN,EzIN, "E field"
            {  0  EMLMTIN,         "Ekin, u, E fractional maximum change"
            {  0  BxIN, ByIN, BzIN,       "B field: initial region"
            {  0  Bx, By, Bz,             "B field: current region"
            {  0  Bx_new, By_new, Bz_new, "B field: in new region"
            {  0  emfield_on;             "true if EM fields not null"
            {  0
            {  0  $REAL    ExIN,EyIN,EzIN,
            {  0  EMLMTIN,
            {  0  BxIN,ByIN,BzIN,
            {  0  Bx,By,Bz,
            {  0  Bx_new,By_new,Bz_new;
            {  0  $LOGICAL emfield_on;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " The following common block is made available to the user so that  "
               0  " he/she knows which shell was being relaxed when the call to ausgab"
               0  " occured                                                           "
               0  " Added by Iwan Kawrakow, March 22 2004.                            "
               0
               0  REPLACE {;COMIN/RELAX-USER/;} WITH {;
            {  0  common/user_relax/ u_relax,ish_relax,iZ_relax;
            {  0  $REAL              u_relax;
            {  0  $INTEGER           ish_relax, iZ_relax;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common blocks for EADL relaxation data -----------------     "
               0  "
               0  " Added by Ernesto Mainegra, June 1st 2011.                                 "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "shell in one long list, avoiding repetition (i.e. if an element is present"
               0  "in different materials, its shell structure and information will be stored"
               0  "only once in the list). The array shell_eadl(Z,i) tells us the position of"
               0  "the i'th shell of element Z in the long shell list.                       "
               0  "***************************************************************************"
               0
               0  REPLACE {$MXESHLL} WITH {30}     "max. number of shells for an element"
               0  REPLACE {$MAXSHELL} WITH {3000}  "max. number of shells"
               0  REPLACE {$MAXRELAX} WITH {10000} "max. number of relaxations channels"
               0  REPLACE {$MAXVAC} WITH {100}     "max. number of vacancies"
               0  REPLACE {$MAXTRANS} WITH {300}   "max. number of transitions per element"
               0  "============================================================"
               0  " Set input key 'Atomic relaxations' to 'simple' to recover original
               0  " implementation which allows photoelectric interactions with <M> and
               0  " <N> shells. See below for details on the shells considered by different
               0  " interactions depending on the value of eadl_relax:
               0  "
               0  "      Interaction        .false.             .true.
               0  "      -----------------------------------------
               0  "      Compton                all available shells
               0  "      EII                K,L1..L3            K,L1..L3
               0  "      Photoeffect        K,L1..L3,<M>,<N>    K,L1..L3
               0  "      Shellwise
               0  "      Photoeffect             N/A      All shells > $RELAX-CUTOFF
               0  "      Relaxation
               0  "        initial vacancy  K,L1..L3,<M>        K,L1..L3
               0  "        (for new photoeffect)                K, L1..L3, M1..M5, N1..N4
               0  "        final vacancy    L1..L3,<M>,<N>      L1..L3,M1..M5,N1..N7...
               0  "
               0  "============================================================"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/SHELL-DATA/;} WITH {;
            {  0
            {  0  common/shell_data/
            {  0  shell_be($MAXSHELL),      "binding energies"
            {  0  shell_type($MAXSHELL),    "shell type according to EADL notation"
            {  0  shell_num($MAXSHELL),     "the shell position in the element"
            {  0  shell_Z($MAXSHELL),       "Z of the element the shell belongs to"
            {  0  shell_eadl($MXELEMENT,$MXESHLL), "global index for a shell of element Z"
            {  0  shell_ntot;               "total number of shells in the list"
            {  0  $REAL    shell_be;
            {  0  $INTEGER shell_type,shell_Z,shell_ntot,shell_num,shell_eadl;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-DATA/;} WITH {;
            {  0
            {  0  common/relax_data/
            {  0  relax_first($MAXSHELL),    "first transition"
            {  0  relax_ntran($MAXSHELL),    "number of transitions"
            {  0  relax_state($MAXRELAX),    "final state of the transition"
            {  0  relax_prob($MAXRELAX),     "probability"
            {  0  relax_atbin($MAXRELAX),    "used for alias sampling"
            {  0  relax_ntot;                "total number of transitions in the list"
            {  0  $REAL     relax_prob;
            {  0  $INTEGER  relax_first, relax_ntran, relax_state, relax_atbin, relax_ntot;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-FOR-USER/;} WITH {;
            {  0  common/relax_for_user/
            {  0  rfu_E0, "binding energy of vacancy that initiated cascade"
            {  0  rfu_E,  "binding energy of current vacancy"
            {  0  rfu_Z,  "Atomic number of the element the relaxing shell belongs to"
            {  0  rfu_j0, "shell numb. of vacancy that initiated cascade in the list"
            {  0  rfu_n0, "same but number is shell number in the element"
            {  0  rfu_t0, "same but number is shell type according to EADL notation"
            {  0  rfu_j,  "shell number of current vacancy"
            {  0  rfu_n,  "same but number is shell number in the element"
            {  0  rfu_t;  "same but number is shell type according to EADL notation"
            {  0  $INTEGER rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t;
            {  0  $REAL    rfu_E0,rfu_E;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0  RELAX-DATA,SHELL-DATA/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-EADL;} WITH {
            {  0  ;COMIN/RELAX-DATA,RELAX-FOR-USER,SHELL-DATA,
            {  0  STACK,THRESH,EPCONT,USEFUL,UPHIOT,RANDOM,BOUNDS,EGS-IO,MISC,MEDIA,
            {  0  X-OPTIONS/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " -------------- shell-wise photoelectric cross section data ------------   "
               0  "
               0  " Cross sections taken from Sabbatucci and Salvat,                          "
               0  " Theory and calculation of the atomic photoeffect                          "
               0  " Radiat. Phys. and Chem., Volume 121, April 2016, Pages 122-140            "
               0  "                                                                           "
               0  "***************************************************************************"
               0  " Shell-wise photoelectric cross sections from 50 eV up to 1 GeV for elements
               0  " from Z=1 up to Z=99. All K, L, M, and N shells are included. One can define
               0  " a threshold energy separating inner from outer shells. By default this
               0  " energy is set to 1 keV, but for accurate calculation of quantities that  "
               0  " require knowledge of which particle deposited the energy, one might need to
               0  " use the a lower threshold.
               0  "***************************************************************************"
               0  "============================================================"
               0  REPLACE {$RELAX-CUTOFF} WITH {0.001D0"threshold energy for outer shells"}
               0  REPLACE {$MXPESHELL} WITH {16} "K,L1..L3,M1..M5,N1..N7 + outer shell"
               0  REPLACE {$MXNE} WITH {500}     "number of energy points per shell "
               0  "============================================================"
               0  REPLACE {;COMIN/PE-SHELL-DATA/;} WITH {;
            {  0
            {  0  common/pe_shell_data/
            {  0  pe_xsection($MXNE,$MXELEMENT,0:$MXPESHELL),  "shellwise cross sections"
            {  0  pe_elem_prob($MXNE,$MXELEMENT,$MXMED), "prob. of interaction with an"
            {  0  "element of a medium"
            {  0  pe_energy($MXNE,$MXELEMENT),    "energy grid"
            {  0  pe_zsorted($MXELEMENT,$MXMED),"sorted array of Z for each medium"
            {  0  pe_be($MXELEMENT,$MXPESHELL),      "binding energies"
            {  0  pe_nshell($MXELEMENT),       "number of shells for each element"
            {  0  pe_zpos($MXELEMENT),       "position of each Z element"
            {  0  pe_nge($MXELEMENT),       "number of energy points for each element"
            {  0  pe_ne;                    "number of elements in the simulation"
            {  0  $REAL    pe_be, pe_energy, pe_xsection, pe_elem_prob;
            {  0  $INTEGER pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-SHELLWISE-PE-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0  PE-SHELL-DATA/;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " Some macros for C-style syntax in mortran "
               0  " Unfortunately, /= doesn't work because of /v1,v2,...,vn/=value;"
               0
               0  REPLACE {;#+=#;} WITH { ;{P1} = {P1} + {P2}; }
               0  REPLACE {[#+=#;} WITH { {P1} = {P1} + {P2}; }
               0
               0  REPLACE {;#-=#;} WITH { ;{P1} = {P1} - {P2}; }
               0  REPLACE {[#-=#;} WITH { {P1} = {P1} - {P2}; }
               0
               0  REPLACE {;#*=#;} WITH { ;{P1} = {P1}*{P2}; }
               0  REPLACE {[#*=#;} WITH { {P1} = {P1}*{P2}; }
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/ET-Control/;} WITH  "ET stands for Electron Transport"
               0  {
            {  0  ;common/ET_control/
            {  0  smaxir($MXREG),estepe,ximax,
            {  0  "ximin_for_bca,"
            {  0  skindepth_for_bca,transport_algorithm,
            {  0  bca_algorithm,exact_bca,spin_effects;
            {  0  $REAL     smaxir,             "geom. step-size constrain for each region"
            {  0  estepe,             "global energy loss constrain"
            {  0  ximax,              "max. first GS moment per step"
            {  0  "(roughly half the average MS angle squared"
            {  0  "ximin_for_bca,"
            {  0  "min. first GS moment per step for boundary"
            {  0  "crossing in VMC mode"
            {  0  skindepth_for_bca;  "distance from a boundary (in elastic MFP)"
            {  0  "to switch to one of the BCAs "
            {  0  $INTEGER  transport_algorithm,"=$PRESTA-II or $PRESTA--I"
            {  0  bca_algorithm;      "will be used if other inexact BCAs"
            {  0  "implemented in the future"
            {  0  $LOGICAL  exact_bca,          "if .true. => BCA in single scattering mode"
            {  0  spin_effects;       "if .true. electron/positron spin effects"
            {  0  "are taken into account in the single and"
            {  0  "multiple elasting scattering routines"
            {  0  }
               0  ;
               0
               0  " ======================== multiple scattering commons ================= "
               0
               0  " Screened Rutherford MS data "
               0
               0  REPLACE {$MAXL_MS}    WITH {63}
               0  REPLACE {$MAXQ_MS}    WITH {7}
               0  REPLACE {$MAXU_MS}    WITH {31}
               0  REPLACE {$0-MAXL_MS}  WITH {0:63}
               0  REPLACE {$0-MAXQ_MS}  WITH {0:7}
               0  REPLACE {$0-MAXU_MS}  WITH {0:31}
               0  REPLACE {$LAMBMIN_MS} WITH {1.}
               0  REPLACE {$LAMBMAX_MS} WITH {1e5}
               0  REPLACE {$QMIN_MS}    WITH {1e-3}
               0  REPLACE {$QMAX_MS}    WITH {0.5}
               0
               0  REPLACE {COMIN/MS-Data/;} WITH {
            {  0  common/ms_data/
            {  0  ums_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0  fms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0  wms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0  ims_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0  llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0  real*4      ums_array,fms_array,wms_array,
            {  0  llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0  $SHORT_INT  ims_array;
            {  0  }
               0  ;
               0
               0  " spin effect data used in an additional rejection loop "
               0
               0  REPLACE {$MAXE_SPIN}   WITH {15}
               0  REPLACE {$MAXE_SPI1}   WITH {{COMPUTE 2*$MAXE_SPIN+1}}
               0  REPLACE {$MAXQ_SPIN}   WITH {15}
               0  REPLACE {$MAXU_SPIN}   WITH {31}
               0  REPLACE {$0-MAXE_SPI1} WITH {0:$MAXE_SPI1}
               0  REPLACE {$0-MAXQ_SPIN} WITH {0:$MAXQ_SPIN}
               0  REPLACE {$0-MAXU_SPIN} WITH {0:$MAXU_SPIN}
               0
               0  REPLACE {COMIN/Spin-Data/;} WITH {
            {  0  common/spin_data/
            {  0  spin_rej($MXMED,0:1,$0-MAXE_SPI1,$0-MAXQ_SPIN,$0-MAXU_SPIN),
            {  0  espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0  dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i,
            {  0  fool_intel_optimizer;
            {  0  real*4      spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0  dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i;
            {  0  $LOGICAL    fool_intel_optimizer;
            {  0  }
               0  ;
               0
               0  REPLACE {COMIN/CH-Steps/;} WITH
               0  {
            {  0  common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step;
            {  0  real*8           count_pII_steps,count_all_steps;
            {  0  $LOGICAL         is_ch_step;
            {  0  }
               0  ;
               0  "------------------------------------------------------------------"
               0  "*** EPCONT--ELECTRON-PHOTON CONTROL VARIABLES                     "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/EPCONT/;} WITH
               0  {;
            {  0  COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP,
            {  0  RHOF,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE,
            {  0  x_final,y_final,z_final,
            {  0  u_final,v_final,w_final,
            {  0  IDISC,IROLD,IRNEW,IAUSFL($MXAUS);
            {  0  $ENERGY PRECISION EDEP,   "energy deposition in MeV"
            {  0  EDEP_LOCAL; "local energy deposition in MeV"
            {  0  $REAL             TSTEP,  "distance to a discrete interaction"
            {  0  TUSTEP, "intended step length, befor check with geometry"
            {  0  USTEP,  "transport distance calculated from TUSTEP"
            {  0  VSTEP,  "transport distance after truncation by HOWFAR"
            {  0  TVSTEP, "curved path-length calculated from TVSTEP"
            {  0  RHOF,   "mass density ratio"
            {  0  EOLD,   "energy before deduction of energy loss"
            {  0  ENEW,   "energy after  deduction of energy loss"
            {  0  EKE,    "kinetic energy"
            {  0  ELKE,   "Log(EKE)"
            {  0  GLE,    "Log(energy) in PHOTON"
            {  0  E_RANGE,"range of electron before an iarg=0 ausgab call"
            {  0  x_final,y_final,z_final, "position at end of step"
            {  0  u_final,v_final,w_final; "direction at end of step"
            {  0  "only set (and relevant) "
            {  0  "for electrons"
            {  0  $INTEGER          IDISC,  "flag indicating user discard"
            {  0  IROLD,  "region before transport"
            {  0  IRNEW,  "region after transport"
            {  0  IAUSFL; "flags for AUSGAB calls"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MEDIA--NAMES OF MEDIA CURRENTLY BEING USED                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MEDIA/;} WITH
               0  {;
            {  0  COMMON/MEDIA/
            {  0  "Ali:photonuc, 4 lines (order matters because of padding issues)"
            {  0  $LGN(RLC,RLDU,RHO,MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,
            {  0  IRAYLM,IPHOTONUCM($MXMED)),
            {  0  MEDIA(24,$MXMED), photon_xsections, comp_xsections,
            {  0  photonuc_xsections,eii_xfile,IPHOTONUC,NMED;
            {  0  $TYPE    MEDIA;"media names"
            {  0  $REAL    RLC,  "radiation length in centimeters for a given medium"
            {  0  RLDU, "radiation length after user scaling over-ride"
            {  0  RHO,  "mass density of a given medium"
            {  0  apx, upx;"new photon xsection data thresholds"
            {  0  $INTEGER MSGE, "??? "
            {  0  MGE,  "number of photon mapped energy intervals for a given medium"
            {  0  MSEKE,"??? "
            {  0  MEKE, "number of e mapped energy intervals for a given medium"
            {  0  MLEKE,"??? "
            {  0  MCMFP,"??? "
            {  0  MRANGE,"??? "
            {  0  IRAYLM,"Rayleigh switch for a given medium"
            {  0  "Ali:photonuc, 2 lines"
            {  0  IPHOTONUCM,"photonuclear switch for a given medium"
            {  0  IPHOTONUC,"set to 1 if any IPHOTONUCM is set to 1"
            {  0  NMED;  "number of media"
            {  0  character*16 eii_xfile;
            {  0  "Defaults to eii_ik.data if On or Off options selected"
            {  0  "which is the EII implemented by Iwan for EGSnrc"
            {  0  "else, following options available: "
            {  0  "  eii_'casnati'.data    "
            {  0  "  eii_'kolbenstvedt'.data "
            {  0  "  eii_'gryzinski'.data"
            {  0  "these must be in $HEN_HOUSE/data"
            {  0  character*16 photon_xsections;
            {  0  "If photon_xsections is not empty, photon cross sections will be"
            {  0  "re-initialized using data files  "
            {  0  "  'photon_xsection'_photo.data   "
            {  0  "  'photon_xsection'_pair.data    "
            {  0  "  'photon_xsection'_triplet.data "
            {  0  "  'photon_xsection'_rayleigh.data"
            {  0  "that must be placed in $HEN_HOUSE/data"
            {  0  character*16 comp_xsections;
            {  0  "If comp_xsections is not empty or not set to 'default' and"
            {  0  "bound Compton scattering is On, then total Compton cross sections"
            {  0  "will be taken from 'comp_xsections'_compton.data"
            {  0  "instead of being computed from the theoretical expressions"
            {  0  "Ali:photonuc, 5 lines"
            {  0  character*16 photonuc_xsections;
            {  0  "If photonuc_xsections is not empty or not set to 'default',"
            {  0  "the photonuclear cross sections will be taken from"
            {  0  "'photonuc_xsections'_photonuc.data instead of using the data"
            {  0  "in the default file iaea_photonuc.data."
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MISC--MISCELLANEOUS COMMON                                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MISC/;} WITH
               0  {;
            {  0  COMMON/MISC/
            {  0  "Ali:photonuc, 1 line"
            {  0  DUNIT,KMPI,KMPO,$LGN(RHOR,MED,IRAYLR,IPHOTONUCR($MXREG));
            {  0  $REAL    DUNIT,   "unit scaling factor"
            {  0  RHOR;    "density of a given region"
            {  0  $INTEGER KMPI,    "fortran unit number of the pegs4 datafile"
            {  0  KMPO;    "fortran unit number of pegs4 echo file"
            {  0  $SHORT_INT MED,   "medium number for a given region"
            {  0  IRAYLR,"Rayleigh switch for a given region"
            {  0  "Ali:photonuc, 1 line"
            {  0  IPHOTONUCR;"photonuclear switch for a given region"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** PHOTIN--PHOTON TRANSPORT DATA                                 "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/PHOTIN/;} WITH
               0  {;
            {  0  COMMON/PHOTIN/
            {  0  EBINDA($MXMED),
            {  0  $LGN(GE($MXMED)/0,1/),
            {  0  $LGN(GMFP,GBR1,GBR2($MXGE,$MXMED)/0,1/),
            {  0  $LGN(RCO($MXMED)/0,1/),
            {  0  $LGN(RSCT($MXRAYFF,$MXMED)/0,1/),
            {  0  $LGN(COHE($MXGE,$MXMED)/0,1/),
            {  0  "Ali:photonuc, 1 line"
            {  0  $LGN(PHOTONUC($MXGE,$MXMED)/0,1/),
            {  0  DPMFP,
            {  0  MPGEM($MXSGE,$MXMED),
            {  0  NGR($MXMED);
            {  0  $REAL
            {  0  EBINDA,      "energy of the K-edge for a given medium"
            {  0  GE0,GE1,     "used for indexing in logarithmic interpolations"
            {  0  GMFP0,GMFP1, "used for gamma MFP interpolation"
            {  0  GBR10,GBR11, "used for branching into pair interpolation"
            {  0  GBR20,GBR21, "used for branching into Compton interpolation"
            {  0  RCO0,RCO1,   "used for indexing in momentum trans. sampling in Rayleigh"
            {  0  RSCT0,RSCT1, "used for interpolation of momentum trans. func. in R"
            {  0  COHE0,COHE1, "used for Rayleigh modification interpolation"
            {  0  "Ali:photonuc, 1 line"
            {  0  PHOTONUC0,PHOTONUC1, "used for photonuclear modification interpolation"
            {  0  DPMFP;       "number of MFP's to go to the next interaction"
            {  0  $INTEGER
            {  0  MPGEM,       "??? "
            {  0  NGR;         "array size for Rayleigh scattering data"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** RANDOM - DECLARATIONS FOR RANDOM NUMBER GENERATOR             "
               0  "------------------------------------------------------------------"
               0
               0  " Note that the definition of the COMIN/RANDOM/ was taken out of   "
               0  " the egsnrc.macros file. The current philosophy is that the user  "
               0  " has to provide a random number generator in a separate file.     "
               0  " Two commonly used RNGs are provided in separate files:           "
               0  "  RANLUX: ranlux.macros and ranlux.mortran                        "
               0  "  RANMAR: ranmar.macros and ranmar.mortran                        "
               0
               0
               0  "------------------------------------------------------------------"
               0  "*** STACK--INFORMATION KEPT ABOUT CURRENT PARTICLES               "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/STACK/;} WITH
               0  {;
            {  0  COMMON/STACK/
            {  0  $LGN(E,X,Y,Z,U,V,W,DNEAR,WT,IQ,IR,LATCH($MXSTACK)),
            {  0  LATCHI,NP,NPold;
            {  0  $ENERGY PRECISION
            {  0  E;     "total particle energy"
            {  0  $REAL
            {  0  X,Y,Z, "particle co-ordinates"
            {  0  U,V,W, "particle direction cosines"
            {  0  DNEAR, "perpendicular distance to nearest boundary"
            {  0  WT;    "particle weight"
            {  0  $INTEGER
            {  0  IQ,    "charge, -1 for electrons, 0 for photons, 1 for positrons"
            {  0  IR,    "current region"
            {  0  LATCH, "extra phase space variable"
            {  0  LATCHI,"needed because shower does not pass latch-BLOCK DATA sets 0"
            {  0  NP,    "stack pointer"
            {  0  NPold; "stack pointer before an interaction"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** THRESH--THRESHOLD (AND OTHER) ENERGIES                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/THRESH/;} WITH
               0  {;
            {  0  COMMON/THRESH/RMT2,RMSQ,
            {  0  $LGN(AP,AE,UP,UE,TE,THMOLL($MXMED));
            {  0  $REAL         RMT2,  "2*electron mass in MeV"
            {  0  RMSQ,  "electron mass squared in MeV**2"
            {  0  AP,    "photon creation threshold energy"
            {  0  AE,    "electron creation threshold energy (total)"
            {  0  UP,    "upper photon energy in PEGS4 data set"
            {  0  UE,    "upper electron energy in PEGS4 data set"
            {  0  TE,    "electron creation threshold energy (kinetic)"
            {  0  THMOLL;"Moller threshold = AE + TE"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIIN--SINE TABLES FOR UPHI                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIIN/;} WITH
               0  {;
            {  0  COMMON/UPHIIN/SINC0,SINC1,$LGN(SIN($MXSINC)/0,1/);
            {  0  $REAL         SINC0,SINC1,SIN0,SIN1;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIOT--UPHI'S INPUT/OUTPUT WITH ITS USERS                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIOT/;} WITH
               0  {;
            {  0  COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI,
            {  0  COSPHI,PI,TWOPI,PI5D2;
            {  0  $REAL         THETA,  "polar scattering angle"
            {  0  SINTHE, "sin(THETA)"
            {  0  COSTHE, "cos(THETA)"
            {  0  SINPHI, "sine of the azimuthal scattering angle"
            {  0  COSPHI, "cosine of the azimuthal scattering angle"
            {  0  PI,TWOPI,PI5D2;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USEFUL--HEAVILY USED VARIABLES                                "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USEFUL/;} WITH
               0  {;
            {  0  COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD;
            {  0  $ENERGY PRECISION PZERO,   "precise zero"
            {  0  PRM,     "precise electron mass in MeV"
            {  0  PRMT2;   "2*PRM"
            {  0  $REAL             RM;      "electron mass in MeV"
            {  0  $INTEGER          MEDIUM,  "medium index of current region"
            {  0  MEDOLD;  "medium index of previous region"
            {  0  " The rest mass value is as recommended by CODATA 2014"
            {  0  " http://physics.nist.gov/cgi-bin/cuu/Value?mec2mev"
            {  0  DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D0/;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USER--A COMMON FOR THE 'USER' TO 'USE'                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USER/;} WITH {
            {  0  ;}  "DEFAULT IS NULL"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/X-OPTIONS/;} WITH {
            {  0  ;
            {  0  common/x_options/eadl_relax,       "Use EADL relaxation"
            {  0  mcdf_pe_xsections;"Use Sabbatucci and Salvat PE xsections"
            {  0  $LOGICAL  eadl_relax, mcdf_pe_xsections;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** MACROS TO DEFINE THE COMMONS USED IN EACH SUBPROGRAM.         "
               0  "------------------------------------------------------------------"
               0  REPLACE {$COMIN-ANNIH;} WITH {
            {  0  ;COMIN/DEBUG,STACK, UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-ANNIH-ATREST;} WITH {
            {  0  ;COMIN/DEBUG,STACK,RANDOM,USEFUL,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-BHABHA;} WITH {
            {  0  ;COMIN/DEBUG,STACK, THRESH,UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,
            {  0  EGS-IO/;}
               0  REPLACE {$COMIN-BREMS;} WITH {
            {  0  ;COMIN/DEBUG,BREMPR,EPCONT,NIST-BREMS,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0  EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-COMPT;} WITH {
            {  0  ;COMIN/COMPTON-DATA,DEBUG,EPCONT,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0  EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;}
               0  REPLACE {$COMIN-ELECTR;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,ELECIN,EPCONT,MEDIA,MISC,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,CH-Steps,EGS-IO,
            {  0  EGS-VARIANCE-REDUCTION,EMF-INPUTS/;}
               0  REPLACE {$COMIN-HATCH;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,BREMPR,ELECIN,MEDIA,MISC,PHOTIN,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,EGS-IO,X-OPTIONS,
            {  0  EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-MOLLER;} WITH {
            {  0  ;COMIN/DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM,EGS-IO,
            {  0  EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-PAIR;} WITH {
            {  0  ;COMIN/DEBUG,BREMPR,NRC-PAIR-DATA,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0  EPCONT,TRIPLET-DATA,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-PHOTO;} WITH {
            {  0  ;COMIN/BOUNDS,BREMPR,DEBUG,EDGE,EPCONT,MEDIA,PHOTIN,RANDOM,
            {  0  STACK,UPHIOT,USEFUL,EGS-IO,X-OPTIONS,
            {  0  EGS-VARIANCE-REDUCTION,RELAX-DATA/;}
               0  REPLACE {$COMIN-PHOTON;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,UPHIOT,
            {  0  USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-SHOWER;} WITH {
            {  0  ;COMIN/DEBUG,STACK,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-UPHI;} WITH {
            {  0  ;COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-BLOCK;} WITH {
            {  0  ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,
            {  0  EPCONT,CH-Steps,ET-Control,MEDIA,MISC,PHOTIN,RANDOM,STACK,
            {  0  THRESH, UPHIIN,UPHIOT,USEFUL,EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-RELAX;} WITH {
            {  0  ;COMIN/EPCONT,STACK,BOUNDS,USEFUL,RANDOM,EDGE,EGS-IO,RELAX-DATA,X-OPTIONS/;}
               0  REPLACE {$COMIN-SET-DEFAULTS;} WITH {
            {  0  ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,EPCONT,CH-Steps,ET-Control,
            {  0  MEDIA,MISC,PHOTIN,RANDOM,STACK,THRESH, UPHIIN,UPHIOT,USEFUL,
            {  0  EGS-VARIANCE-REDUCTION,EGS-IO,Spin-Data,EII-DATA,rayleigh_inputs,
            {  0  EMF-INPUTS,X-OPTIONS/;};
               0  REPLACE {$COMIN-INIT-COMPT;} WITH {
            {  0  ;COMIN/COMPTON-DATA,BREMPR,EDGE,MEDIA,MISC,USEFUL,EGS-IO,X-OPTIONS/;};
               0  REPLACE {$COMIN-MSCATI;} WITH {
            {  0  ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL,EGS-IO/;};
               0  REPLACE {$COMIN-INIT-TRIPLET;} WITH {
            {  0  ;COMIN/BREMPR,EGS-IO,MEDIA,TRIPLET-DATA,USEFUL/;};
               0  REPLACE {$COMIN-GET-TRANSPORTP;} WITH {
            {  0  ;COMIN/GetInput,BOUNDS,ET-Control,EDGE,COMPTON-DATA,MEDIA,MISC,
            {  0  BREMPR,EII-DATA,EGS-IO,rayleigh_inputs,EMF-INPUTS,X-OPTIONS/;};
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$COMIN-PHOTONUC;} WITH {;COMIN/STACK,EPCONT,USEFUL/;};
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {ILOG2(#)} WITH {
            {  0  IFIX(1.44269*LOG({P1}))} "1.44269=1/LN(2)"
               0
               0  REPLACE {$SETINTERVAL#,#;} WITH {
            {  0  [IF] '{P2}'=SNAME  [L{P1}={P2}1*{P1}+{P2}0;]
            {  0  [ELSE]  [L{P1}={P2}1(MEDIUM)*{P1}+{P2}0(MEDIUM);]}
               0  "TWO ARGUMENT SET INTERVAL CALL (ABOVE) CURRENTLY MEANS"
               0  "INTERVAL INDEX IS LINEAR FUNCTION OF THE LINEAR VARIABLE,"
               0  "WITH NO MAPPING.  {P1} IS THE LINEAR VARIABLE AND {P2} IS"
               0  "THE NAME OF THE INTERVAL(WHICH IS USED TO CONSTRUCT THE"
               0  "COEFFICIENTS USED IN COMPUTING THE INTERVAL INDEX)."
               0  "BUT, IF {P2} IS SINC OR BLC OR RTHR OR RTHRI, IT DOES"
               0  "NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#);} WITH {
            {  0  [IF] '{P2}'=SNAME1
            {  0  [{P1}={P2}1(L{P3})*{P3}+{P2}0(L{P3});] [ELSE]
            {  0  [{P1}={P2}1(L{P3},MEDIUM)*{P3}+{P2}0(L{P3},MEDIUM);]}
               0  "{P1} IS VARIABLE TO BE ASSIGNED VALUE."
               0  "{P2} IS THE FUNCTION BEING APPROXIMATED."
               0  "{P3} IS THE ARGUMENT OF THE FUNCTION. IN THE CURRENT"
               0  "PWLF METHOD, THE ARGUMENT DETERMINES AN INTERVAL USING THE"
               0  "$SET INTERVAL MACROS.   WITH IN THIS INTERVAL THE"
               0  "FUNCTION IS APPROXIMATED AS A LINEAR FUNCTION OF"
               0  "THE ARGUMENT. BUT"
               0  "IF {P2}=SIN IT DOES NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#,#);} WITH {
            {  0  {P1}={P2}0(L{P3},L{P4})+{P2}1(L{P3},L{P4})*{P3}+
            {  0  {P2}2(L{P3},L{P4})*
            {  0  {P4};}"2-D APPROXIMATION INDEPENDENT OF MEDIUM"
               0  SPECIFY SNAME AS ['sinc'|'blc'|'rthr'|'rthri'|'SINC'|'BLC'|'RTHR'|'RTHRI'];
               0  SPECIFY SNAME1 AS ['sin'|'SIN'];
               0
               0  "The following circumvent the above table look up method for sin"
               0  "functions.  Modern machines do sines very quickly so the large saving"
               0  "in time from the above no longer exists for sines (was 40% on some"
               0  "machines for the overall computing time! (for example it makes a
               0  "20% effect on an SGI R4400)"
               0  "To recover the use of tables, just comment out the following two"
               0  "macros"
               0
               0  REPLACE {$EVALUATE#USING SIN(#);} WITH {{P1}=sin({P2});}
               0  REPLACE {$SET INTERVAL#,SINC;} WITH {;}
               0
               0
               0  "MACRO TO ALLOW USER TO ADD TO PROPERTIES THAT ARE"
               0  "PASSED TO NEW PARTICLES"
               0  REPLACE {$TRANSFERPROPERTIESTO#FROM#;} WITH {
            {  0  X{P1}=X{P2};Y{P1}=Y{P2};Z{P1}=Z{P2};IR{P1}=IR{P2};
            {  0  WT{P1}=WT{P2};DNEAR{P1}=DNEAR{P2};LATCH{P1}=LATCH{P2};}
               0  "IN THE USAGE OF THE ABOVE MACRO, '(IP)' WILL REFER TO THE"
               0  "PARTICLE WHOSE STACK INDEX IS 'IP'. 'NP' IS THE TOP OF THE STACK."
               0  "JUST PLAIN 'I' WILL REFER TO THE INITIAL VALUES SUPPLIED"
               0  "AS ARGUMENTS TO SHOWER, OR SUPPLIED IN COMMON BLOCKS OR"
               0  "DATA STATEMENTS IN SHOWER."
               0
               0  "Macro to check that the stack size is not exceeded"
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0  IF( {P1} > $MXSTACK ) [
            {  0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
            {  0  $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
            {  0  ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
            {  0  ' Increase $MXSTACK and try again ');
            {  0  ]
            {  0  };
               0
               0
               0
               0
               0
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0  IF( {P1} > $MXSTACK ) [
            {  0  $egs_fatal('(//,3a,/,2(a,i9))',' In subroutine ',{P2},
            {  0  ' stack size exceeded! ',' $MAXSTACK = ',$MXSTACK,' np = ',{P1});
            {  0  ]
            {  0  };
               0
               0  "MACRO FOR RE-EVALUATING DEDX IN SUBROUTINE ELECTR"
               0  REPLACE {$DEDX-RE-EVALUATION;} WITH {
            {  0  ;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING MACROS ARE USED IN SUBROUTINE ELECTR IN ORDER TO MAKE"
               0  "PATH LENGTH CORRECTIONS AND RESTRICTIONS:"
               0  REPLACE {$SET-USTEP;} WITH
               0  {
            {  0  ekems = eke - 0.5*tustep*dedx; "Use mid-point energy to calculate"
            {  0  "energy dependent quantities"
            {  0  $CALCULATE-XI(tustep);
            {  0  IF ( xi < 0.1 )
            {  0  [
            {  0  ustep = tustep*(1 - xi*(0.5 - xi*0.166667));
            {  0  ]
            {  0  ELSE
            {  0  [
            {  0  ustep = tustep*(1 - Exp(-xi))/xi;
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$CALCULATE-XI(#);} WITH
               0  {
            {  0  p2 = ekems*(ekems+rmt2); beta2 = p2/(p2 + rmsq);
            {  0  chia2 = xccl/(4*blccl*p2);
            {  0  "Note that our chia2 is Moliere chia2/4"
            {  0  "Note also that xcc is now old egs xcc**2"
            {  0  xi = 0.5*xccl/p2/beta2*{P1};
            {  0  IF( spin_effects ) [
            {  0  elkems = Log(ekems);
            {  0  $SET INTERVAL elkems,eke;
            {  0  IF(lelec < 0) [
            {  0  $EVALUATE etap USING etae_ms(elkems);
            {  0  $EVALUATE xi_corr USING q1ce_ms(elkems);
            {  0  ]
            {  0  ELSE          [
            {  0  $EVALUATE etap USING etap_ms(elkems);
            {  0  $EVALUATE xi_corr USING q1cp_ms(elkems);
            {  0  ]
            {  0  chia2 = chia2*etap; xi = xi*xi_corr;
            {  0  $EVALUATE ms_corr USING blcce(elkems);
            {  0  blccl = blccl*ms_corr;
            {  0  ]
            {  0  ELSE [ xi_corr = 1; etap = 1; ]
            {  0  xi = xi*(Log(1+1./chia2)-1/(1+chia2));
            {  0  }
               0
               0  REPLACE {$SET-TVSTEP;} WITH
               0  "        ===========                 "
               0  {
            {  0  ;IF ( vstep < ustep0 )
            {  0  [
            {  0  ekems = eke - 0.5*tustep*vstep/ustep0*dedx;
            {  0  "This estimates the energy loss to the boundary."
            {  0  "tustep was the intended curved path-length,"
            {  0  "ustep0 is the average transport distance in the initial direction"
            {  0  "       resulting from tustep"
            {  0  "vstep = ustep is the reduced average transport distance in the "
            {  0  "              initial direction due to boundary crossing"
            {  0  $CALCULATE-XI(vstep);
            {  0  IF ( xi < 0.1 )
            {  0  [
            {  0  tvstep = vstep*(1 + xi*(0.5 + xi*0.333333));
            {  0  ]
            {  0  ELSE
            {  0  [
            {  0
            {  0  IF ( xi < 0.999999 )
            {  0  [
            {  0  tvstep = -vstep*Log(1 - xi)/xi;
            {  0  ]
            {  0  ELSE
            {  0  [
            {  0  "This is an error condition because the average transition "
            {  0  "in the initial direction of motion is always smaller than 1/Q1"
            {  0  $egs_info(*,' Stoped in SET-TVSTEP because xi > 1! ');
            {  0  $egs_info(*,' Medium: ',medium);
            {  0  $egs_info(*,' Initial energy: ',eke);
            {  0  $egs_info(*,' Average step energy: ',ekems);
            {  0  $egs_info(*,' tustep: ',tustep);
            {  0  $egs_info(*,' ustep0: ',ustep0);
            {  0  $egs_info(*,' vstep:  ',vstep);
            {  0  $egs_info(*,' ==> xi = ',xi);
            {  0  $egs_fatal(*,'This is a fatal error condition');
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ELSE
            {  0  [
            {  0  tvstep = tustep;
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$ENEPS} WITH {0.0001}
               0  "DIFFERENCE BETWEEN ECUT AND END POINT ENERGY FOR"
               0  "RANGE CALCULATION"
               0
               0  REPLACE {$EPSEMFP} WITH {1.E-8}  "SMALLEST ELECTRON MFP VALUE"
               0  REPLACE {$EPSGMFP} WITH {1.E-8}  "SMALLEST GAMMA MFP VALUE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE UTILITY AND OTHER MACROS FOR THE USER"
               0
               0  "ETALY1---COMMON BLOCK FOR ENERGY CONSERVATION PURPOSES"
               0  REPLACE {;COMIN/ETALY1/;} WITH {
            {  0  ;COMMON/ETALY1/ESUM(4,$MXREG,5);
            {  0  $ENERGY PRECISION ESUM;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "NTALY1---COMMON BLOCK FOR KEEPING COUNT OF ETALY1-EVENTS"
               0  REPLACE {;COMIN/NTALY1/;} WITH {
            {  0  ;COMMON/NTALY1/NSUM(4,$MXREG,5);
            {  0  $INTEGER NSUM;
            {  0  }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACRO TO ALLOW USER TO INITIALIZE IN SUBROUTINE HATCH"
               0  REPLACE {$HATCH-USER-INPUT-INIT;} WITH {;
            {  0  " $RNG-INITIALIZATION; "
            {  0  " Have taken this out, (IK, Jan 2000). If the user does not initilize the"
            {  0  " rng before the first call to shower, the rng will initialize itself    "
            {  0  " using the default seed and the default luxury level (which is defined  "
            {  0  " via $DEFAULT-LL).                                                      "
            {  0
            {  0  DO J=1,$MXREG [
            {  0  IF(SMAXIR(J)<=0.0) [SMAXIR(J)=1E10;]
            {  0  ]
            {  0  ;}
               0
               0  "MACRO FOR CONTROLLING NEGATIVE USTEP"
               0  REPLACE {$USER-CONTROLS-NEGATIVE-USTEP;} WITH {
            {  0  "         ============================"
            {  0  ;IF(USTEP<-1.E-4)[ IERUST=IERUST+1;OUTPUT IERUST,USTEP,IR(NP),IRNEW,
            {  0  IROLD,X(NP),Y(NP),Z(NP),SQRT(X(NP)**2+Y(NP)**2);
            {  0  (I6,' NEGATIVE USTEP=',E14.6,' IR,IRNEW,IROLD=',3I4,' X,Y,Z,R=',
            {  0  4E14.6);
            {  0  IF(IERUST>10)[OUTPUT;(///'0STOP, TOO MANY USTEP ERRORS'///); STOP;]]
            {  0  USTEP=0.0;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$CHECK-NEGATIVE-USTEP;} WITH {;
            {  0  IF(ustep <= 0) [
            {  0  "Negative ustep---probable truncation problem at a"
            {  0  "boundary, which means we are not in the region we think"
            {  0  "we are in.  The default macro assumes that user has set"
            {  0  "irnew to the region we are really most likely to be"
            {  0  "in.  A message is written out whenever ustep is less than -1.e-4"
            {  0  IF(ustep < -1e-4) [
            {  0  ierust = ierust + 1;
            {  0  OUTPUT ierust,ustep,dedx,e(np)-prm,
            {  0  ir(np),irnew,irold,x(np),y(np),z(np);
            {  0  (i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=',F8.4,
            {  0  ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3);
            {  0  IF(ierust > 1000) [
            {  0  OUTPUT;(////' Called exit---too many ustep errors'///);
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  ]
            {  0  ustep = 0;
            {  0  ]
            {  0  };
               0
               0  "MACRO FOR INTRODUCING FLUCTUATIONS IN THE ENERGY LOSS BY"
               0  "CHARGED PARTICLES (E.G., 'LANDAU FLUCTUATIONS')---DEFAULT IS NULL"
               0  REPLACE {$DE-FLUCTUATION;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "Macro for production of annihilation quanta whenever"
               0  "the energy is greater than AE but less than or equal to ECUT."
               0  "photons are always produced in EGSnrc."
               0
               0  REPLACE {$POSITRON-ECUT-DISCARD;} WITH {EDEP=PEIE-PRM;}
               0  "NOTE: TO GET THE EGS3 VERSION SIMPLY USE EDEP=PEIE+PRM"
               0  "      AS THE REPLACEMENT PART OF THE MACRO."
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR PARTICLE SELECTION (E.G., LEADING PARTICLE,"
               0  "SPLITTING, ETC.).  DEFAULT IS ULTIMATELY 'NULL'"
               0  "     -----IN SUBROUTINE ELECTR-----                 "
               0  REPLACE {$PARTICLE-SELECTION-ELECTR;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIH;} WITH {
            {  0  $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIHREST;} WITH {
            {  0  $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BHABHA;} WITH {
            {  0  $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BREMS;} WITH {
            {  0  $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-MOLLER;}
               0  WITH {$PARTICLE-SELECTION-ELECTR;}
               0  "     -----IN SUBROUTINE PHOTON-----                 "
               0  REPLACE {$PARTICLE-SELECTION-PHOTON;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-COMPT;} WITH {
            {  0  $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PAIR;} WITH {
            {  0  $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PHOTO;} WITH {
            {  0  $PARTICLE-SELECTION-PHOTON;}
               0
               0  "MACRO FOR SELECTION OF THE ELECTRON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-ELECTRON-MFP;} WITH {
            {  0  $RANDOMSET RNNE1; IF(RNNE1.EQ.0.0) [RNNE1=1.E-30;]
            {  0  DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);}
               0
               0  "MACRO FOR SELECTION OF THE PHOTON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-PHOTON-MFP;} WITH {
            {  0  $RANDOMSET RNNO35; IF(RNNO35.EQ.0.0) [RNNO35=1.E-30;]
            {  0  DPMFP=-LOG(RNNO35);}
               0
               0  "MACRO to do range rejection on a region by region basis"
               0  "      if the user requests it.  The variables e_max_rr and i_do_rr"
               0  "      are in COMIN ET-CONTROL.  This macro is called immediately"
               0  "      after $USER-RANGE-DISCARD in ELECTR and everytime called"
               0  "      the electrons current range has been computed and stored in"
               0  "      range and the distance to the nearest boundary has just been"
               0  "      computed and is in tperp.  e_max_rr and i_do_rr are initialized"
               0  "      to zero in BLOCK DATA so range rejection is not done unless"
               0  "      Since option must be turned on by the user, it is considered a"
               0  "      USER-ELECTRON-DISCARD."
               0  "      Note this technique implies an approximation because the particle"
               0  "      is not allowed to create a brem particle which might escape"
               0  "      the region.  This is why  e_max_rr is used, to allow high"
               0  "      energy electrons to be tracked in case they give off brem."
               0
               0  REPLACE {$RANGE-DISCARD;} WITH {
            {  0  ;IF( i_do_rr(irl) = 1 & e(np) < e_max_rr(irl) ) [
            {  0  IF(tperp >= range) ["particle cannot escape local region"
            {  0  idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
            {  0  go to :USER-ELECTRON-DISCARD: ;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0
               0  "MACRO TO ALLOW USER TO DISCARD IF AT OR NEAR END OF RANGE"
               0  REPLACE {$USER-RANGE-DISCARD;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "RAYLEIGH (COHERENT) SCATTERING MACROS"
               0
               0  "custom form factor file names"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {COMIN/rayleigh_inputs/;} WITH
               0  "        ================"
               0  {
            {  0  ;COMMON/rayleigh_inputs/iray_ff_media($MXMED),iray_ff_file($MXMED);
            {  0  ;character*24 iray_ff_media;
            {  0  ;character*128 iray_ff_file;
            {  0  }
               0
               0  REPLACE {COMIN/rayleigh_sampling/;} WITH
               0  "        ================"
               0  {;COMMON/rayleigh_sampling/xgrid($MXRAYFF,$MXMED),
            {  0  fcum($MXRAYFF,$MXMED),
            {  0  b_array($MXRAYFF,$MXMED),
            {  0  c_array($MXRAYFF,$MXMED),
            {  0  i_array($RAYCDFSIZE,$MXMED),
            {  0  $LGN(pmax($MXGE,$MXMED)/0,1/);
            {  0  $REAL xgrid, fcum, b_array, c_array,pmax0, pmax1;
            {  0  $INTEGER i_array;
            {  0  }
               0
               0  REPLACE {$RAYLEIGH-CORRECTION;} WITH {
            {  0  ;IF(IRAYLR(IRL).EQ.1) [$EVALUATE COHFAC USING COHE(GLE);
            {  0  GMFP=GMFP*COHFAC];}
               0
               0  REPLACE {$OLD_RAYLEIGH-SCATTERING;} WITH {
            {  0  ;IF(IRAYLR(IRL).EQ.1) [
            {  0  $RANDOMSET RNNO37;
            {  0  IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0  $AUSCALL($RAYLAUSB);
            {  0  NPold = NP;
            {  0  :SAMPLING-LOOP: LOOP [$RANDOMSET XXX;
            {  0  $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
            {  0  Q2=X2*RMSQ/(20.60744*20.60744);
            {  0  COSTHE=1.-Q2/(2.*E(NP)*E(NP));
            {  0  IF (ABS(COSTHE).GT.1.0) GO TO :SAMPLING-LOOP:;
            {  0  CSQTHE=COSTHE*COSTHE;
            {  0  REJF=(1.0+CSQTHE)/2.0;
            {  0  $RANDOMSET RNNORJ;
            {  0  ] UNTIL (RNNORJ <= REJF);
            {  0  SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
            {  0  $AUSCALL($RAYLAUSA);
            {  0  GOTO :PNEWENERGY:;]]
            {  0  }
               0  REPLACE {$RAYLEIGH-SCATTERING;} WITH {
            {  0  ;IF(IRAYLR(IRL).EQ.1) [
            {  0  $RANDOMSET RNNO37;
            {  0  IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0  $AUSCALL($RAYLAUSB);
            {  0  NPold = NP;
            {  0  call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINTHE);
            {  0  CALL UPHI(2,1);
            {  0  $AUSCALL($RAYLAUSA);
            {  0  GOTO :PNEWENERGY:;]]
            {  0  }
               0
               0  "Ali:photonuc, 2 blocks"
               0  REPLACE {$PHOTONUC-CORRECTION;} WITH {
            {  0  ;IF(IPHOTONUCR(IRL).EQ.1) [$EVALUATE PHOTONUCFAC USING PHOTONUC(GLE);
            {  0  GMFP=GMFP*PHOTONUCFAC];}
               0
               0  REPLACE {$PHOTONUCLEAR;} WITH {
            {  0  ;IF(IPHOTONUCR(IRL).EQ.1) [
            {  0  $RANDOMSET RNNO39;
            {  0  IF (RNNO39.LE.(1.0-PHOTONUCFAC)) [
            {  0  $AUSCALL($PHOTONUCAUSB);
            {  0  call PHOTONUC;
            {  0  $AUSCALL($PHOTONUCAUSA);
            {  0  GOTO :PNEWENERGY:;
            {  0  ]
            {  0  ]
            {  0  }
               0
               0  "DENSITY RATIO SCALING MACRO (TO OVER-RIDE DENSITY IN A PARTICULAR"
               0  "REGION)  NOTE: THIS MACRO REPLACES SUBROUTINE RHOSET OF EGS3"
               0
               0  REPLACE {$SET-RHOF;} WITH {RHOF=RHOR(IRL)/RHO(MEDIUM);}  "DEFAULT"
               0
               0  "TEMPLATES FOR PERFORMING CHARGED PARTICLE TRANSPORT IN EM FIELD"
               0  REPLACE {$SET-TUSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-USTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$VACUUM-ADD-WORK-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-ANGLES-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-TVSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$ADD-WORK-EM-FIELD;} WITH {;}
               0  REPLACE {$EMFIELD_INITIATE_SET_TUSTEP;} WITH {;}
               0  REPLACE {;COMIN/EM/;} WITH {;}
               0  REPLACE {$EMFIELD_PII;} WITH {;}
               0  REPLACE{$EMFIELD_PI;}WITH{;}
               0  REPLACE{$EM_FIELD_SS;}WITH{;}
               0  REPLACE{$ADD_WORK_EM_FIELD;}WITH{;}
               0  REPLACE{$EMFieldInVacuum;}WITH{;}
               0  REPLACE{$EM_MACROS_ACTIVE}WITH{.false.}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        EGS4/EGSnrc GEOMETRY MACROS: AN EXTENSION TO EGS MACROS   "
               0  "------------------------------------------------------------------"
               0
               0  "   NOTE1: CYLNDR IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/80-78, 25 NOV. 1980)"
               0
               0  "   NOTE2: CONE IS A NEW MACRO BY H.HIRAYAMA OF KEK. "
               0  "          MACRO REPLACEMENT OF CERN VERSION SUBROUTINE CONE"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE3: SPHERE IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE4: $PLAN2X AND $PLAN2P ARE TWO NEW MACROS BY W.R.NELSON."
               0  "          $PLAN2P WAS FORMERLY CALLED $PLANE2 AND IS STILL THE"
               0  "          SAME (CALLS TO $PLANE2 WILL AUTOMATICALLY DEFAULT TO"
               0  "          TO $PLAN2P).  $PLAN2X, HOWEVER, WILL CORRECTLY HANDLE"
               0  "          THE CASE OF TWO, NON-PARALLEL PLANES."
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINES FOR PLANE GEOMETRY  (SLAC VERSION)         "
               0  "------------------------------------------------------------------"
               0  ;
               0  PARAMETER $MXPLNS=100;     "MAX. NO. OF PLANES"
               0
               0  "PLADTA---COMMON BLOCK FOR $PLANE1 AND $PLANE2 MACROS"
               0  REPLACE {;COMIN/PLADTA/;} WITH {
            {  0  ;COMMON/PLADTA/PCOORD(3,$MXPLNS),PNORM(3,$MXPLNS);
            {  0  $REAL PCOORD, PNORM;
            {  0  }
               0
               0  "$PLANE1---MACRO REPLACEMENT FOR SUBROUTINE PLANE1"
               0  REPLACE {$PLANE1(#,#,#,#);} WITH {
            {  0  UDOTA=PNORM(1,{P1})*U(NP)+PNORM(2,{P1})*
            {  0  V(NP)+PNORM(3,{P1})*W(NP); UDOTAP={P2}*UDOTA;
            {  0  IF(UDOTA.EQ.0.0)[{P3}=2;]ELSEIF(UDOTAP.LT.0.0)
            {  0  [{P3}=0;] ELSE [{P3}=1;{P4}=(PNORM(1,{P1})*
            {  0  (PCOORD(1,{P1})-X(NP))+ PNORM(2,{P1})*
            {  0  (PCOORD(2,{P1})-Y(NP))+PNORM(3,{P1})*
            {  0  (PCOORD(3,{P1})-Z(NP)))/UDOTA;]}
               0  "NOTE:   EVERYWHERE $PLANE1 IS USED ONE MUST"
               0  "        INCLUDE COMIN/PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLANE2---MACRO REPLACEMENT FOR SUBROUTINE PLANE2"
               0  "          NOTE: $PLANE2 HAS BEEN SUPERCEDED BY $PLAN2P (BELOW),"
               0  "                WHICH IS AUTOMATICALLY TAKEN CARE OF BY THE"
               0  "                FOLLOWING MACRO STATEMENT."
               0  REPLACE {$PLANE2} WITH {$PLAN2P}
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2P---MACRO REPLACEMENT FOR SUBROUTINE PLAN2P (OR $PLANE2)"
               0  "          (I.E., TWO PARALLEL PLANES)"
               0  REPLACE {$PLAN2P(#,#,#,#,#,#);} WITH {
            {  0  $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1)
            {  0  [ $CHGTR(TVAL,{P2});] ELSEIF(IHIT.EQ.0)
            {  0  [$PLANE1({P4},{P6},IHIT,TVAL);$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2P ($PLANE2) IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2X---MACRO REPLACEMENT FOR SUBROUTINE PLAN2X"
               0  "          (I.E., TWO, NON-PARALLEL (CROSSING) PLANES)"
               0  REPLACE {$PLAN2X(#,#,#,#,#,#);} WITH {
            {  0  $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1) [
            {  0  $CHGTR(TVAL,{P2});]   $PLANE1({P4},{P6},IHIT,TVAL);
            {  0  IF(IHIT.EQ.1) [$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2X IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "      MACRO-ROUTINE FOR CYLINRICAL GEOMETRY  (CERN VERSION)       "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCYLS=75;      "MAX. NO. OF CYLINDERS"
               0  PARAMETER $DELCYL=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CYLDTA---COMMON BLOCK FOR $CYLNDR MACRO"
               0  REPLACE {;COMIN/CYLDTA/;} WITH {
            {  0  ;COMMON/CYLDTA/CYRAD2($MXCYLS);
            {  0  $REAL CYRAD2;
            {  0  }
               0
               0  "$CYLNDR---MACRO REPLACEMENT FOR SUB CYLNDR GRS VERSION 14 11 80"
               0  REPLACE {$CYLNDR(#,#,#,#);} WITH {
            {  0  {P3}=1;{P4}=0.0;ACYL=SQRT(U(NP)*U(NP)+V(NP)*V(NP));
            {  0  IF(ACYL.EQ.0.0)[{P3}=0;]  ELSE [
            {  0  BCYL=(X(NP)*U(NP)+Y(NP)*V(NP))/ACYL;CCYL=X(NP)*X(NP)+Y(NP)*Y(NP)
            {  0  -CYRAD2({P1});  ARGCY=BCYL*BCYL-CCYL;
            {  0  IF(ARGCY.LT.0.0) [{P3}=0;]   ELSE [
            {  0  IF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.0.AND.BCYL.GE.0.0)[{P3}=0;]
            {  0  ELSEIF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.1.AND.BCYL.LT.0.0)[
            {  0  {P4}=-2.0*BCYL/ACYL;]
            {  0  ELSE [ IF({P2}.EQ.1.AND.CCYL.GE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0  ELSEIF({P2}.EQ.0.AND.CCYL.LE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0  ELSE  [  ROOTCY=SQRT(ARGCY); IF(CCYL.LT.0.0)
            {  0  [{P4}=(-BCYL+ROOTCY)/ACYL;]
            {  0  ELSEIF(BCYL.LT.0.0) [{P4}=(-BCYL-ROOTCY)/ACYL;]
            {  0  ELSE [{P3}=0;]]]]]}
               0  "NOTE:   EVERYWHERE $CYLNDR IS USED ONE MUST"
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  "$CYL2--MACRO EQUIVALENT FOR CYLNDR OF $PLANE2  GRS 17.11.80"
               0  REPLACE {$CYL2(#,#,#,#);} WITH {
            {  0  $CYLNDR({P1},0,IHIT,TCYL);IF(IHIT.EQ.1)[
            {  0  $CHGTR(TCYL,{P2});]ELSE[$CYLNDR({P3},1,IHIT,TCYL);
            {  0  IF(IHIT.EQ.1)[ $CHGTR(TCYL,{P4});]]}
               0  "NOTE:   EVERYWHERE $CYL2 IS USED ONE MUST
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE FOR CERN CONICAL GEOMETRY  (SLAC VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCONES=75;     "MAXIMUM NUMBER OF CONES"
               0  PARAMETER $DELCON=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CONDTA---COMMON BLOCK FOR $CONE MACRO"
               0  REPLACE {;COMIN/CONDTA/;} WITH {
            {  0  ;COMMON/CONDTA/COTAL2($MXCONES),SMALLL($MXCONES);
            {  0  $REAL COTAL2, SMALLL;
            {  0  }
               0
               0  "$CONE---MACRO REPLACEMENT FOR CERN VERSION SUBROUTINE CONE"
               0  REPLACE {$CONE(#,#,#,#);} WITH {
            {  0  {P3}=0;ITWOPR=0;CPCON=COTAL2({P1});SGNCON=SIGN(1.0,CPCON);
            {  0  CPCON=ABS(CPCON);ZNP=SGNCON*(Z(NP)-SMALLL({P1}));
            {  0  WNP=SGNCON*W(NP);CPCON1=1.0+CPCON;
            {  0  CPCON2=SQRT(CPCON1);DCON1=X(NP)*X(NP)+Y(NP)*Y(NP);
            {  0  DCON2=SQRT(DCON1); IF((ZNP.GE.0.0).OR.(WNP.GE.0.0)) [
            {  0  ACON=(U(NP)*U(NP)+V(NP)*V(NP))*CPCON-WNP*WNP;
            {  0  BCON1=(X(NP)*U(NP)+Y(NP)*V(NP))*CPCON;BCON=BCON1-ZNP*WNP;
            {  0  CCON=DCON1*CPCON-ZNP*ZNP;
            {  0  IF(ACON.EQ.0.0)[IF(BCON.NE.0.0)
            {  0  [IF(ABS(CCON).LT.$DELCON.AND.ZNP.GE.0.0)[
            {  0  IF(({P2}.EQ.1.AND.BCON.GE.0.0).OR.({P2}.EQ.0.AND.BCON.LE.0.0))[
            {  0  TCON1=-CCON/(2*BCON);IF(TCON1.GE.0.0)[IF((ZNP+TCON1*WNP).GE.0.0)
            {  0  [{P4}=TCON1;{P3}=1;]]]]]
            {  0  ELSE[TCON1=CPCON2*ZNP*SIGN(1.0,-WNP);
            {  0  IF(TCON1.GE.0.0)[{P4}=TCON1;{P3}=1;]]]
            {  0  ELSEIF((ABS(CCON).LT.$DELCON).AND.(ZNP.GE.0.0))
            {  0  [BPRIM=BCON1-WNP*DCON2;
            {  0  IF({P2}.EQ.1.AND.BPRIM.LT.0.0)[TCON1=-2*BCON/ACON;
            {  0  IF(TCON1.GE.0.0) [{P4}=TCON1;{P3}=1;]]]
            {  0  ELSEIF({P2}.EQ.1.AND.CCON.GT.0.0) [{P4}=$DELCON;{P3}=1;]
            {  0  ELSEIF({P2}.EQ.0.AND.CCON.LT.0.0.AND.ZNP.GE.0.0)
            {  0  [{P4}=$DELCON;{P3}=1;] ELSE[CCON1=BCON*BCON-ACON*CCON;
            {  0  IF(CCON1.GE.0.0)[ROOT=SQRT(CCON1);
            {  0  IF(BCON.GT.0.0)[TCON11=-(BCON+ROOT)/ACON;]
            {  0  ELSE[TCON11=-CCON/(BCON-ROOT);]
            {  0  IF(BCON.LT.0.0)[TCON22=-(BCON-ROOT)/ACON;]
            {  0  ELSE[TCON22=-CCON/(BCON+ROOT);]
            {  0  IF((TCON11.GE.0.0).OR.(TCON22.GE.0.0))[
            {  0  IF(TCON11.LT.0.0)[TCON1=TCON22;]
            {  0  ELSE[IF(TCON22.LT.0.0)[TCON1=TCON11;] ELSE[ITWOPR=1;
            {  0  TCON1=min(TCON11,TCON22);TCON2=max(TCON11,TCON22);]]
            {  0  IF((ZNP+TCON1*WNP).GE.0.0)[{P4}=TCON1;{P3}=1;]
            {  0  ELSEIF((ITWOPR.EQ.1).AND.((ZNP+TCON2*WNP).GE.0.0))
            {  0  [{P4}=TCON2;{P3}=1;]]]]]}
               0  "NOTE:   EVERYWHERE $CONE IS USED ONE MUST
               0  "         INCLUDE COMIN/CONDTA,STACK/"
               0
               0  "$CON2--MACRO EQUIVALENT FOR CONE OF $PLANE2            "
               0  REPLACE {$CON2(#,#,#,#);} WITH {
            {  0  $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0  $CHGTR(TCON,{P2});]ELSE[$CONE({P3},1,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0  $CHGTR(TCON,{P4});]]}
               0
               0  "$CON21--MACRO EQUIVALENT FOR CONE OF $PLANE2 (IN THE CASE  "
               0  "OF OUTSIDE TWO CONE SURFACE)                               "
               0  REPLACE {$CON21(#,#,#,#);} WITH {
            {  0  $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0  $CHGTR(TCON,{P2});]ELSE[$CONE({P3},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0  $CHGTR(TCON,{P4});]]}
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR SPHERICAL GEOMETRY  (CERN VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXSPHE=75;      "MAX. NO. OF SPHERES"
               0  PARAMETER $DELSPH=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "SPHDTA------COMMON BLOCK FOR $SPHERE MACRO"
               0  REPLACE {;COMIN/SPHDTA/;} WITH {
            {  0  ;COMMON/SPHDTA/SPRAD2($MXSPHE);
            {  0  $REAL SPRAD2;
            {  0  }
               0
               0  "$SPHERE---MACRO REPLACEMENT FOR SUB SPHERE GRS VERSION 08 12 80"
               0  REPLACE {$SPHERE(#,#,#,#);} WITH {
            {  0  {P3}=1;{P4}=0.0;ASPH=1.0;
            {  0  BSPH=(X(NP)*U(NP)+Y(NP)*V(NP)+Z(NP)*W(NP))/ASPH;CSPH=X(NP)*X(NP)
            {  0  +Y(NP)*Y(NP)+Z(NP)*Z(NP)  -SPRAD2({P1});  ARGSP=BSPH*BSPH-CSPH;
            {  0  IF(ARGSP.LT.0.0) [{P3}=0;]   ELSE [
            {  0  IF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.0.AND.BSPH.GE.0.0)[{P3}=0;]
            {  0  ELSEIF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.1.AND.BSPH.LT.0.0)[
            {  0  {P4}=-2.0*BSPH/ASPH;]
            {  0  ELSE [ IF({P2}.EQ.1.AND.CSPH.GE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0  ELSEIF({P2}.EQ.0.AND.CSPH.LE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0  ELSE [ROOTSP=SQRT(ARGSP); IF(CSPH.LT.0.0)
            {  0  [{P4}=(-BSPH+ROOTSP)/ASPH;] ELSEIF(BSPH.LT.0.0)
            {  0  [{P4}=(-BSPH-ROOTSP)/ASPH;] ELSE [{P3}=0;]]]]}
               0  "NOTE:   EVERYWHERE $SPHERE IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  "$SPH2--MACRO EQUIVALENT FOR SPHERE OF $PLANE2  GRS 08.12.80"
               0  REPLACE {$SPH2(#,#,#,#);} WITH {
            {  0  $SPHERE({P1},0,IHIT,TSPH);IF(IHIT.EQ.1)[
            {  0  $CHGTR(TSPH,{P2});]ELSE[$SPHERE({P3},1,IHIT,TSPH);
            {  0  IF(IHIT.EQ.1)[ $CHGTR(TSPH,{P4});]]}
               0  "NOTE:   EVERYWHERE $SPH2 IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR CHANGING REGIONS  (SLAC VERSION)        "
               0  "------------------------------------------------------------------"
               0
               0  "$CHGTR---MACRO REPLACEMENT FOR SUBROUTINE CHGTR"
               0  REPLACE {$CHGTR(#,#);} WITH {
            {  0  ;IF({P1}.LE.USTEP) [USTEP={P1}; IRNEW={P2};]}
               0  "NOTE:   EVERYWHERE $CHGTR IS USED ONE MUST
               0  "         INCLUDE COMIN/EPCONT/"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE TO OBTAIN FINAL COORDINATES (SLAC VERSION)     "
               0  "------------------------------------------------------------------"
               0
               0  "$FINVAL---MACRO REPLACEMENT FOR SUBROUTINE FINVAL"
               0  REPLACE {$FINVAL(#,#,#,#);} WITH {
            {  0  {P2}=X(NP)+{P1}*U(NP); {P3}=Y(NP)+{P1}*V(NP);
            {  0  {P4}=Z(NP)+{P1}*W(NP);}
               0  "NOTE:   EVERYWHERE $FINVAL IS USED ONE MUST
               0  "         INCLUDE COMIN/STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "                 END OF GEMOETRY MACRO EXTENSION                  "
               0  "------------------------------------------------------------------"
               0
               0  "******************************************************************"
               0  "                                                                  "
               0  "                    NRC EXTENSIONS                                "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  ; "BUFFER FLUSH"
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           PHOTOELECTRON ANGLE SELECTION                      "
               0  "           =============================                      "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to select the photoelectron direction  "
               0
               0  REPLACE {$SELECT-PHOTOELECTRON-DIRECTION;} WITH {
            {  0  "        ================================"
            {  0  ;IF(IPHTER(IR(NP)).EQ.1)[
            {  0  EELEC=E(NP);
            {  0  IF(EELEC.GT.ECUT(IR(NP)))[
            {  0  BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC;
            {  0  GAMMA=EELEC/RM;
            {  0  ALPHA=0.5*GAMMA-0.5+1./GAMMA;
            {  0  RATIO=BETA/ALPHA;
            {  0  LOOP[
            {  0  $RANDOMSET RNPHT;RNPHT=2.*RNPHT-1.;
            {  0  IF(RATIO.LE.0.2)[
            {  0  FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT);
            {  0  IF( gamma < 100 ) [
            {  0  COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA);
            {  0  ]
            {  0  ELSE [
            {  0  IF( fkappa > 0 ) [
            {  0  costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gamma-1)**3);
            {  0  ]
            {  0  ELSE [ COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA); ]
            {  0  ]
            {  0  "XI=1./(1.-BETA*COSTHE); <-- this numerically problematic "
            {  0  "                            at high energies, IK"
            {  0  xi = (1+beta*fkappa)*gamma*gamma;
            {  0  ]
            {  0  ELSE[
            {  0  XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO))-1.));
            {  0  COSTHE=(1.-1./XI)/BETA;
            {  0  ]
            {  0  SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE));
            {  0  $RANDOMSET RNPHT2;
            {  0  ]WHILE(RNPHT2.GT.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA);
            {  0  SINTHE=SQRT(SINTH2);
            {  0  CALL UPHI(2,1);]]
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           TSTEP RECURSION IN ELECTR                          "
               0  "           =========================                          "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to control TSTEP recursion in ELECTR   "
               0
               0  REPLACE {$USER_CONTROLS_TSTEP_RECURSION;} WITH {;}
               0
               0  ; "BUFFER FLUSH"
               0
               0  %C80                                                                           ;
               0  "------------------------------------------------------------------"
               0  "  BREMSSTRAHLUNG ANGLE SELECTION MACROS                           "
               0  "------------------------------------------------------------------"
               0
               0
               0  "These macros are explained in NRCC REPORT #PIRS0203"
               0  "by Bielajew, Mohan and Chui                        "
               0
               0  "Macro to initialize data for bremsstrahlung production               "
               0  "The quantity ZBRANG is ( (1/111)*Zeff**(1/3) )**2                    "
               0  "where Zeff is defined in equation (7) OF PIRS0203                    "
               0  "This macro goes in SUBROUTINE HATCH                                  "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-BREMS-ANGLE;} WITH {
            {  0  ; IF(IBRDST.EQ.1)[
            {  0  DO IM=1,NMED[
            {  0  ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0  DO IE=1,NNE(IM)[
            {  0  ZBRANG(IM)=
            {  0  ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0  PZNORM=PZNORM+PZ(IM,IE);
            {  0  ]
            {  0  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0  LZBRANG(IM)=-log(ZBRANG(IM));
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  ;
               0
               0  " Following is associated with the selection of bremsstrahlung photon"
               0  " angle.  This has been implemented directly into the BREMS subroutine"
               0  " and changed slightly. Nonetheless, this macro is still used."
               0
               0  "This is the function G(X) of PIRS0203               "
               0  "The result is returned in {P1} as a function of {P2}"
               0  "i.e. {P1}=G({P2}) where {P2}=X                      "
               0  "                                                    "
               0  REPLACE {$SET-BREM-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; Y2TST1=(1.+{P2})**2;
            {  0  {P1}= (4.+LOG(RJARG3+ZTARG/Y2TST1))*(4.*ESEDEI*{P2}/Y2TST1-RJARG1)+RJARG2;
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "  PAIR ANGLE SELECTION MACROS                                     "
               0  "------------------------------------------------------------------"
               0
               0  "These macros are explained in NRCC REPORT # PIRS0287 by Bielajew     "
               0
               0  ;
               0  "Macro to initialize data for PAIR PRODUCTION                         "
               0  "THE QUANTITY ZBRANG IS ( (1/111)*Zeff**(1/3) )**2                    "
               0  "WHERE Zeff IS DEFINED IN EQUATION (7) OF PIRS0287                    "
               0  "THIS MACRO GOES IN SUBROUTINE HATCH                                  "
               0  "THIS MACRO IS IDENTICAL TO THE $INITIALIZE-BREMS-ANGLE DEFINED ABOVE "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-PAIR-ANGLE;} WITH {
            {  0  ;    IF(IPRDST.GT.0)[
            {  0  DO IM=1,NMED[
            {  0  ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0  DO IE=1,NNE(IM)[
            {  0  ZBRANG(IM)=
            {  0  ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0  PZNORM=PZNORM+PZ(IM,IE);
            {  0  ]
            {  0  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0  "THRESHOLD BELOW WHICH ONLY LOWEST ORDER ANGULAR DISTRIBUTION OF THE  "
               0  "PAIR ANGLE IS EMPLOYED. SCALE IS ENERGY (MeV).                       "
               0  "USERS MAY OVERRIDE THIS WITH A HIGHER VALUE BUT A LOWER VALUE WILL   "
               0  "CAUSE NON-PHYSICAL SAMPLING                                          "
               0  "                                                                     "
               0  REPLACE {$BHPAIR} WITH {4.14}
               0  ;
               0  "THIS MACRO ENABLES VERY SMALL ANGLE SAMPLING TO BE     "
               0  "ACCUMULATED. THE LIMIT OF 1.0E-10 BREAKS DOWN AROUND   "
               0  "50 GEV OR SO (THETA=RM/E, FOR BOTH PAIR AND BREM).     "
               0  "THIS MACRO REPLACES CODE IN UPHI AND IN THE PRESTA     "
               0  "MACROS FOR THE LATERAL CORRELATION PART $PRESTA-LCDV.  "
               0  ;
               0  REPLACE {(SINPS2.LT.1.0E-10)} WITH {(SINPS2.LT.1.0E-20)}
               0  ;
               0  "THE FOLLOWING REPLACES THE EGS4 DEFAULT $SET-PAIR-ANGLE MACRO    "
               0  "IT'S USE REQUIRES AN ASSOCIATE MACRO $SET-PAIR-REJECTION-FUNCTION"
               0  "DEFINED BELOW                                                    "
               0  "                                                                 "
               0  "USAGE: IPRDST=0 => EGS4 DEFAULT ANGLE SELECTION                  "
               0  "       IPRDST=1 => LOWEST ORDER ANGULAR DISTRIBUTION             "
               0  "                                                                 "
               0  "              d(Probability)            sin(theta)               "
               0  "              -------------- = -------------------------------   "
               0  "                 d(theta)      2*P*[E_total - P*cos(theta)]**2   "
               0  "                                                                 "
               0  "       IPRDST=2 => MOTZ, OLSEN AND KOCH (1969) EQ. 3D-2003       "
               0  "                   IF IPRDST IS NON-ZERO AND E_PHOTON < $BHPAIR  "
               0  "                   THE IPRDST=1 DISTRIBUTION IS USED             "
               0  "                                                                 "
               0  REPLACE {$SET-PAIR-ANGLE;} WITH {;
            {  0  IF( iprdst > 0 ) [
            {  0  IF( iprdst = 4 ) [
            {  0  $RANDOMSET rtest;
            {  0  "gbeta = (1-rmt2/eig)**8;"
            {  0  gbeta = PESE1/(PESE1+10);
            {  0  IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0  ELSE [ iprdst_use = 4; ]
            {  0  ]
            {  0  ELSEIF ( iprdst = 2 & eig < $BHPAIR ) [ iprdst_use = 1; ]
            {  0  ELSE [ iprdst_use = iprdst; ]
            {  0  DO ichrg = 1,2 [
            {  0  IF(ICHRG.EQ.1)[ESE=PESE1;]ELSE[
            {  0  ESE=ESE2;
            {  0  IF( iprdst = 4 ) [
            {  0  gbeta = ESE/(ESE+10);
            {  0  $RANDOMSET rtest;
            {  0  IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0  ELSE [ iprdst_use = 4; ]
            {  0  ]
            {  0  ]
            {  0  IF( iprdst_use = 1 ) [
            {  0  PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)));
            {  0  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0  SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE);
            {  0  COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE);
            {  0  ]
            {  0  ELSE IF( iprdst_use = 2 ) [
            {  0  "ZBRANG=( (1/111)*Zeff**(1/3) )**2"
            {  0  ZTARG=ZBRANG(MEDIUM);
            {  0  "TTEIG=TOTAL INITIAL PHOTON ENERGY IN ELECTRON REST MASS UNITS"
            {  0  TTEIG=EIG/RM;
            {  0  "TTESE=TOTAL FINAL ELECTRON ENERGY IN ELECTRON REST MASS UNITS"
            {  0  TTESE=ESE/RM;
            {  0  "TTPSE=TOTAL FINAL ELECTRON MOMENTUM IN rm UNITS"
            {  0  TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0));
            {  0  "THIS IS THE RATIO (r IN PIRS0287)"
            {  0  ESEDEI=TTESE/(TTEIG-TTESE);
            {  0  ESEDER=1.0/ESEDEI;
            {  0  "DETERMINE THE NORMALIZATION "
            {  0  XIMIN=1.0/(1.0+(3.141593*TTESE)**2);
            {  0  $SET-PAIR-REJECTION-FUNCTION(REJMIN,XIMIN);
            {  0  YA=(2.0/TTEIG)**2;
            {  0  XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))));
            {  0  GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2);
            {  0  GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2);
            {  0  GALPHA=GALPHA-GBETA*(XITRY-0.5);
            {  0  XIMID=GALPHA/(3.0*GBETA);
            {  0  IF(GALPHA.GE.0.0)[
            {  0  XIMID=0.5-XIMID+SQRT(XIMID**2+0.25);
            {  0  ]
            {  0  ELSE[
            {  0  XIMID=0.5-XIMID-SQRT(XIMID**2+0.25);
            {  0  ]
            {  0  XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)));
            {  0  $SET-PAIR-REJECTION-FUNCTION(REJMID,XIMID);
            {  0  "ESTIMATE MAXIMUM OF THE REJECTION FUNCTION"
            {  0  "FOR LATER USE BY THE REJECTION TECHNIQUE  "
            {  0  REJTOP=1.02*MAX(REJMIN,REJMID);
            {  0  LOOP[
            {  0  $RANDOMSET XITST;
            {  0  $SET-PAIR-REJECTION-FUNCTION(REJTST,XITST);
            {  0  $RANDOMSET RTEST;
            {  0  "CONVERT THE SUCCESSFUL CANDIDATE XITST TO AN ANGLE"
            {  0  THETA=SQRT(1.0/XITST-1.0)/TTESE;
            {  0  "LOOP UNTIL REJECTION TECHNIQUE ACCEPTS XITST"
            {  0  REJTST_on_REJTOP   = REJTST/REJTOP;
            {  0  ]UNTIL((RTEST <= REJTST_on_REJTOP) & (THETA < PI) );
            {  0  SINTHE=SIN(THETA);COSTHE=COS(THETA);
            {  0  ]
            {  0  ELSE IF( iprdst_use = 3 ) [
            {  0  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0  sinthe=(1-costhe)*(1+costhe);
            {  0  IF( sinthe > 0 ) [ sinthe = sqrt(sinthe); ] ELSE [ sinthe = 0; ]
            {  0  ]
            {  0  ELSE [
            {  0  "PSE=SQRT(MAX(1e-10,(ESE-RM)*(ESE+RM)));"
            {  0  "$RANDOMSET costhe;"
            {  0  "costhe=(ese-(ese+pse)*exp(-2*costhe*log((ese+pse)/rm)))/pse;"
            {  0  $RANDOMSET costhe;
            {  0  costhe=1-2*sqrt(costhe);
            {  0  sinthe=(1-costhe)*(1+costhe);
            {  0  IF( sinthe > 0 ) [ sinthe=sqrt(sinthe); ] ELSE [ sinthe=0; ]
            {  0  ]
            {  0  IF( ichrg = 1 ) [CALL UPHI(2,1);]
            {  0  ELSE [ sinthe=-sinthe; NP=NP+1; CALL UPHI(3,2); ]
            {  0  ]
            {  0  iq(np) = iq2; iq(np-1) = iq1; return;
            {  0  ]
            {  0  ELSE[
            {  0  THETA=0; "THETA=RM/EIG; "
            {  0  ]
            {  0  }
               0  ;
               0  "THIS IS THE FUNCTION d[G(XI)]/(d XI) OF PIRS0287    "
               0  "THE RESULT IS RETURNED IN {P1} AS A FUNCTION OF {P2}"
               0  "I.E. {P1}=G({P2}) WHERE {P2}=XI                     "
               0  "                                                    "
               0  REPLACE {$SET-PAIR-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; {P1} = 2.0+3.0*(ESEDEI+ESEDER) -
            {  0  4.00*(ESEDEI+ESEDER+1.0-4.0*({P2}-0.5)**2)*(
            {  0  1.0+0.25*LOG(
            {  0  ((1.0+ESEDER)*(1.0+ESEDEI)/(2.*TTEIG))**2+ZTARG*{P2}**2
            {  0  )
            {  0  )
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$SELECT-LOW-ENERGY-PAIR-PRODICTION;} WITH
               0  {
            {  0  $RANDOMSET RNNO30; $RANDOMSET rnno34;
            {  0  PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM); PESE1 = PEIG - PESE2;
            {  0  IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
            {  0  }
               0  " IK introduced this macro because uniform energy distribution"
               0  " is probably a better approximation than a zero energy 'electron'"
               0  " for low energy pair production"
               0
               0  ;
               0
               0  "THIS MACRO EXCHANGES TWO POSITIONS ON THE STACK"
               0  "NB: LATCH IS A NON-STANDARD STACK VARIABLE     "
               0  "    REMOVE IT IF IT CAUSES PROBLEMS            "
               0  "                                               "
               0  REPLACE {$EXCHANGE-STACK(#,#);} WITH {
            {  0  ;
            {  0  FDUMMY = U({P2});     U({P2})     = U({P1});     U({P1})     = FDUMMY;
            {  0  FDUMMY = V({P2});     V({P2})     = V({P1});     V({P1})     = FDUMMY;
            {  0  FDUMMY = W({P2});     W({P2})     = W({P1});     W({P1})     = FDUMMY;
            {  0  FDUMMY = E({P2});     E({P2})     = E({P1});     E({P1})     = FDUMMY;
            {  0  FDUMMY = WT({P2});    WT({P2})    = WT({P1});    WT({P1})    = FDUMMY;
            {  0  IDUMMY = IQ({P2});    IQ({P2})    = IQ({P1});    IQ({P1})    = IDUMMY;
            {  0  "LATCH IS NOW STANDARD"
            {  0  IDUMMY = LATCH({P2}); LATCH({P2}) = LATCH({P1}); LATCH({P1}) = IDUMMY;
            {  0  }
               0  ;
               0
               0  REPLACE {;OUTPUT61#;#;} WITH {
            {  0  "       ==============="
            {  0  ;{SETR A=@LG}
            {  0  WRITE(6,{COPY A}){P1};WRITE(1,{COPY A}){P1};{COPY A}FORMAT{P2};}
               0  ;
               0
               0  " The following macro provides a second order evaluation of the   "
               0  " stopping power. The parameter is half of the initial estimate of"
               0  " the energy loss fraction. IK Oct 97                             "
               0  REPLACE {$RE-EVALUATE-DEDX(#);} WITH
               0  {
            {  0  ;
            {  0  elktmp = elke + Log(1 - {P1});
            {  0  $SET INTERVAL elktmp,eke;
            {  0  lelktmp = max(1,lelktmp);
            {  0  IF(lelec < 0)[$EVALUATE dedxmid USING ededx(elktmp);]
            {  0  ELSE         [$EVALUATE dedxmid USING pdedx(elktmp);]
            {  0  dedx = rhof*dedxmid*(1+0.17408298*({P1}/(1-{P1})/(eke+PRM))**2);
            {  0  "0.17408298 is 2/3*m**2"
            {  0  {P1} = 2*{P1};
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0
1              0  %E    "egsnrc.macros"
               0  "******************************************************************"
               0  "                                                                  "
               0  "       transport algorithm related stuff                          "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  "Macros to denote the various transport algorithms"
               0  "These numbers just have to be distinct"
               0  "Note that the distributed version of EGSnrc does not include the VMC option"
               0  REPLACE {$PRESTA-II} WITH {0}
               0  REPLACE {$PRESTA--I} WITH {1}
               0  REPLACE {$VMC}       WITH {2}
               0
               0  REPLACE {$CALL-USER-ELECTRON} WITH {;}
               0
               0  ;
               0  REPLACE {$MSCAT-DATAFILE} WITH {i_mscat}
               0  "Fortran unit number used to read in new MS"
               0  ;
               0  REPLACE {$RANDOMIZE-TUSTEP} WITH {.false.}
               0  "Switches tustep randomization off"
               0  ;
               0  REPLACE {$SKIN-DEPTH-FOR-BCA} WITH {3}
               0  ;
               0  REPLACE {$PRESTA-DEBUG} WITH {.false.}
               0  ;
               0  REPLACE {$EXACT-BCA-XIMAX} WITH {0.5}
               0  ;
               0  REPLACE {$INEXACT-BCA-XIMAX} WITH {0.5} "this is not realy neccessary, "
               0  "it remained from Alex's coding"
               0  ;
               0  REPLACE {$MAX-ELOSS} WITH {0.25}
               0  ;
               0  REPLACE {$SUBSTEP-ELOSS-EVALUATION} WITH {.false.}
               0  ;
               0  REPLACE {$MAX-SMAX} WITH {1e10}
               0  ;
               0  REPLACE {$GLOBAL-ECUT} WITH {0.}
               0  ;
               0  REPLACE {$GLOBAL-PCUT} WITH {0.}
               0  ;
               0  REPLACE {$IBRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBR-NIST-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PAIR-NRC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$TRIPLET-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$IPRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBCMP-DEFAULT} WITH {3} "set to norej"
               0  ;
               0  REPLACE {$IEDGFL-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IPHTER-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$TRANSPORT-ALGORITHM-DEFAULT} WITH {$PRESTA-II}
               0  ;
               0  REPLACE {$BCA-ALGORITHM-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$EXACT-BCA-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$SPIN-EFFECTS-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$IRAYLR-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$AP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$UP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$XSEC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$XDATA-DEFAULT} WITH {'xcom'}
               0  ;
               0  REPLACE {$COMP-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EADL relaxation is now the default"
               0  REPLACE {$EADL-RELAX-DEFAULT} WITH {.true.}
               0  ;
               0  "Uniform Run Control (URC) is false by default"
               0  REPLACE {$URC-DEFAULT} WITH {.false.}
               0  ;
               0  "SLEEP INTERVAL for URC (1 s by default)"
               0  "Time to wait for jobs to complete after last job finished"
               0  REPLACE {$URC-SLEEP} WITH {1}
               0  "Times to check for jobs to complete after last job finished"
               0  REPLACE {$URC-INTERVALS} WITH {1}
               0  ;
               0  "Sabbatucci and Salvat PE xsections not the default yet"
               0  REPLACE {$MCDF-PE-DEFAULT} WITH {.false.}
               0  ;
               0  "Ali:photonuc, 2 lines"
               0  REPLACE {$IPHOTONUCR-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PHOTONUC-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EMH:emf, 7 lines"
               0  REPLACE {$ExDEF} WITH {0}
               0  ;
               0  REPLACE {$EyDEF} WITH {0}
               0  ;
               0  REPLACE {$EzDEF} WITH {0}
               0  ;
               0  REPLACE {$BxDEF} WITH {0}
               0  ;
               0  REPLACE {$ByDEF} WITH {0}
               0  ;
               0  REPLACE {$BzDEF} WITH {0}
               0  ;
               0  REPLACE {$EMLMTDEF} WITH {0.02}
               0  ;
               0
               0  "This macro sets the minimum step size for a condensed"
               0  "history (CH) step. When the exact BCA is used, the minimum"
               0  "CH step is determined by efficiency considerations only"
               0  "At about 3 elastic MFP's single scattering becomes more"
               0  "efficient than CH and so the algorithm switches off CH"
               0  "If one of the various inexact BCA's is invoked, this macro"
               0  "provides a simple way to include more sophisticated"
               0  "decisions about the maximum acceptable approximated CH step"
               0
               0  "The parameters passed to the macro in ELECTR are  eke and elke "
               0
               0  REPLACE {$SET-SKINDEPTH(#,#);} WITH
               0  "        =================                  "
               0  {
            {  0  $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});
            {  0  skindepth = skindepth_for_bca*ssmfp;
            {  0  }
               0  ;
               0
               0  "This macro calculates the elastic scattering MFP"
               0  "If spin_effects is .false., the screened Rutherford cross section"
               0  "is used, else the the elastic MFP is based on PWA cross sections"
               0
               0  REPLACE {$CALCULATE-ELASTIC-SCATTERING-MFP(#,#,#);} WITH
               0  "        =======================================           "
               0  {
            {  0  blccl = rhof*blcc(medium);
            {  0  xccl  = rhof*xcc(medium);
            {  0  p2 = {P2}*({P2}+rmt2); beta2 = p2/(p2 + rmsq);
            {  0  IF ( spin_effects ) [
            {  0  IF(lelec < 0) [ $EVALUATE etap USING etae_ms({P3}); ]
            {  0  ELSE          [ $EVALUATE etap USING etap_ms({P3}); ]
            {  0  $EVALUATE ms_corr USING blcce({P3});
            {  0  blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr;
            {  0  ]
            {  0  {P1}=beta2/blccl;
            {  0  }
               0  ;
               0
               0  REPLACE {$SINGLE-SCATTERING(#);} WITH
               0  "        ======================                     "
               0  {
            {  0  $SET-SCREENING-ANGLE({P1});
            {  0  call sscat(chia2,costhe,sinthe);
            {  0  }
               0  ;
               0
               0  "The following macro will allow the use of better single scattering"
               0  "cross sections (PWA) and/or to take into account double counting  "
               0  "of the contribution of atomic electrons to the scattering power   "
               0
               0  REPLACE {$SET-SCREENING-ANGLE(#);} WITH
               0  "        ========================                   "
               0  {
            {  0  chia2   = xcc(medium)/(4*{P1}*({P1} + rmt2)*blcc(medium));
            {  0  }
               0  ;
               0
               0  REPLACE {$HARD-SCATTERING;} WITH {;}
               0  ;
               0
               0  REPLACE {$TURN_OFF_SCATTERING} WITH {;}
               0  ;
               0  "If the above is redefined in a user code or uncommented here                 "
               0  "REPLACE {$TURN_OFF_SCATTERING} WITH {;cost = 1.000; sint = 0.000; return;}   "
               0  "this will turn off all single and multiple scattering                        "
               0  "DR April 2012   see corresponding 2 additions to egsnrc,mortran in           "
               0  "                subroutines sscat and mscat
               0
1              0  %E "egsnrc.macros"
               0
               0  REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;
            {  0  IF(callhowfar | wt(np) <= 0) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
            {  0  IF( ustep > dnear(np) | wt(np) <= 0 ) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWNEAR(#);} WITH
               0  {
            {  0  OUTPUT 35; "35 in decimal is ascii code for the pound sign"
            {  0  (
            {  0  ' '/
            {  0  ' '/
            {  0  ' ***************************************************************'/
            {  0  ' ***************************************************************'/
            {  0  ' '/
            {  0  ' PRESTA-II is aborting execution because you have not defined   '/
            {  0  ' the HOWNEAR macro for your geometry.                           '/
            {  0  ' '/
            {  0  ' You MUST either do so or employ a limited form of PRESTA-II    '/
            {  0  ' which does not attempt the refined boundary crossing or lateral'/
            {  0  ' correlation features of the algorithm.                         '/
            {  0  ' '/
            {  0  ' If you include the following macro in your usercode:           '/
            {  0  ' '/
            {  0  ' REPLACE {$CALL-HOWNEAR(',a,');} WITH {;}                       '/
            {  0  ' '/
            {  0  ' you can choose between single scattering mode (very slow) and  '/
            {  0  ' standard EGS4 mode (no PRESTA enhancments) by the appropriate  '/
            {  0  ' choice of the parameters in your input file (see the PRESTA-II '/
            {  0  ' manual)                                                        '/
            {  0  ' '/
            {  0  ' ***************************************************************'/
            {  0  ' ***************************************************************'/
            {  0  ' '/
            {  0  ' '/
            {  0  );
            {  0  stop;
            {  0  }
               0
               0  "For compability with user codes with PRESTA-I implemented"
               0  REPLACE {$PRESTA-INPUT-SUMMARY;} WITH {;}
               0  REPLACE {$PRESTA-INPUTS;}        WITH {;}
               0
               0  "If you want to read P-II inputs using the get_input() routine by "
               0  "A. Merovitz and D.W.O.R. you need to either place the following  "
               0  "three macros at the top of your user code, or after the default"
               0  "definitions given below"
               0
               0  ;
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.true.} "To not use get_input replace this "
               0  "with .false.                      "
               0
               0  "The following are the ones used by default"
               0
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.false.}
               0
               0
               0  ;
1              0  %E    "egsnrc.macros"
               0
               0  "Macro for azimuthal angle selection
               0  "using a sampling within a box method
               0  "Choose a point randomly within a box such that
               0  "-1 <= x <= 1 and 0 <= y < = 1
               0  "Reject the set if it lies without the inscribed unit semicircle centered
               0  "at (x,y) = (0,0)
               0  "once out of the loop, use the trigonimetric relations (TeX notation)
               0  "\cos 2\phi = (x^2 - y^2)/(x^2 + y^2)
               0  "\sin 2\phi = 2xy/(x^2 + y^2)
               0  REPLACE {$SELECT-AZIMUTHAL-ANGLE(#,#);} WITH
               0  {
            {  0  ;
            {  0  LOOP
            {  0  [
            {  0  $RANDOMSET xphi;
            {  0  xphi  = 2*xphi - 1;
            {  0  xphi2 = xphi*xphi;
            {  0  $RANDOMSET yphi;
            {  0  yphi2  = yphi*yphi;
            {  0  rhophi2 = xphi2 + yphi2;
            {  0  ]WHILE(rhophi2 > 1);
            {  0  rhophi2 = 1/rhophi2;
            {  0  {P1}  = (xphi2 - yphi2)*rhophi2;
            {  0  {P2}  = 2*xphi*yphi*rhophi2;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;} WITH {;
            {  0  $REAL xphi,xphi2,yphi,yphi2,rhophi2;
            {  0  };
               0
1              0  %E     "egsnrc.macros"
               0  "************************************************************************"
               0  "                                                                        "
               0  "                 Definitions of local variables                         "
               0  "                                                                        "
               0  "************************************************************************"
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ANNIH;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0  PAVIP,    "precise total energy in the laboratory frame"
            {  0  PESG1,    "precise energy of 1st annihilation photon"
            {  0  PESG2;    "precise energy of 2nd annihilation photon"
            {  0  $REAL AVIP,     "total energy in the laboratory frame"
            {  0  A,        "total energy in units of the electron's rest energy"
            {  0  G,T,P,    "energy, kinetic energy and momentum in units of RM"
            {  0  POT,      "P/T"
            {  0  EP0,      "minimum fractional energy"
            {  0  WSAMP,    "to avoid un-necessary calc. of Log((1-ep0)/ep0)"
            {  0  RNNO01,   "random numbers"
            {  0  RNNO02,
            {  0  EP,       "fractional energy of the more energetic photon"
            {  0  REJF,     "rejection function"
            {  0  ESG1,     "energy of the more energetic photon"
            {  0  ESG2,     "energy of the less energetic photon"
            {  0  aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi;
            {  0  "for inline rotations"
            {  0  $INTEGER
            {  0  ibr;
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BHABHA;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0  PEIP,     "precise total energy of incident positron"
            {  0  PEKIN,    "precise kinetic energy of incident positron"
            {  0  PEKSE2,   "precise kinetic energy of second 'electron'"
            {  0  PESE1,    "precise total energy of first 'electron'"
            {  0  PESE2,    "precise total energy of second 'electron'"
            {  0  H1,       "used in direction cosine calculations"
            {  0  DCOSTH;   "polar scattering angle for more energetic 'electron'"
            {  0  $REAL EIP,      "total energy of incident positron"
            {  0  EKIN,     "kinetic energy of incident positron"
            {  0  T0,       "kinetic energy of incident positron in units of RM"
            {  0  E0,       "total energy of incident positron in units of RM"
            {  0  E02,      "E0**2"
            {  0  YY,       "1/(T0+2)"
            {  0  Y2,YP,YP2,"various functions of YY"
            {  0  BETA2,    "incident positron velocity in units of c"
            {  0  EP0,      "minimum fractional energy of a secondary 'electron'"
            {  0  EP0C,     "1-EP0"
            {  0  B1,B2,B3,B4,  "used in rejection function calculation"
            {  0  RNNO03,RNNO04,"random numbers"
            {  0  BR,       "kinetic energy fraction of the 2nd 'electron'"
            {  0  REJF2,    "rejection function"
            {  0  ESE1,     "total energy of 1st 'electron'"
            {  0  ESE2;     "total energy of 2nd 'electron'"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BREMS;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0  PEIE,   "precise incident electron energy"
            {  0  PESG,   "presice energy of emitted photon"
            {  0  PESE;   "precise total energy of scattered electron"
            {  0  $REAL
            {  0  EIE,    "total incident electron energy"
            {  0  EKIN,   "kinetic incident energy"
            {  0  brmin,  " ap(medium)/ekin"
            {  0  waux,   "for faster sampling of 1/br"
            {  0  aux,    "ese/eie"
            {  0  r1,     "a random number"
            {  0  ajj,    "for energy bin determination if alias sampling is employed"
            {  0  alias_sample1,
            {  0  RNNO06, "random number"
            {  0  RNNO07, "random number"
            {  0  BR,     "energy fraction of secondary photon"
            {  0  ESG,    "energy of secondary photon"
            {  0  ESE,    "total energy of secondary electron"
            {  0  DELTA,  "scaled momentum transfer"
            {  0  phi1,   "screening function"
            {  0  phi2,   "screening function"
            {  0  REJF;   "screening rejection function"
            {  0
            {  0  "Brems angle selection variables"
            {  0  $REAL
            {  0  a,b,c,  "direction cosines of incident `electron'"
            {  0  sinpsi, sindel, cosdel, us, vs,
            {  0  "all used for rotations"
            {  0  ztarg,  "(Zeff**1/3/111)**2, used for 2BS angle sampling"
            {  0  tteie,  "total energy in units of rest energy"
            {  0  beta,   "electron velocity in units of speed of light"
            {  0  y2max,  "maximum possible scaled angle"
            {  0  y2maxi, "inverse of the above"
            {  0  ttese,  "new electron energy in units of rm"
            {  0  rjarg1,rjarg2,rjarg3,rejmin,rejmid,rejmax,rejtop,rejtst,
            {  0  "all of them used for angle rejection function calcs"
            {  0  esedei, "new total energy over old total energy"
            {  0  y2tst,  "scaled angle, costhe = 1 - 2*y2tst/y2max"
            {  0  y2tst1,
            {  0  rtest,  "random number for rejection"
            {  0  xphi,yphi,xphi2,yphi2,rhophi2,cphi,sphi;
            {  0  "all of the above is for azimuthal angle sampling"
            {  0
            {  0  $INTEGER
            {  0  L,L1,ibr,jj,j;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-BREMS-ANGLE;} WITH
               0  {;
            {  0  "Local variables for photon angle selection"
            {  0  $REAL ZTARG,  "( (1/111)*Zeff**(1/3) )**2"
            {  0  TTEIE,  "total incident electron energy in units of RM"
            {  0  TTESE,  "total scattered electron energy in units of RM"
            {  0  ESEDEI, "TTESE/TTEIE"
            {  0  beta,   "electron speed in units of c"
            {  0  Y2MAX,  "maximum value of the scaled angle"
            {  0  RJARG1,RJARG2,RJARG3,
            {  0  "arguments for which the rejection function is calculated"
            {  0  REJMIN,REJMID,REJMAX,
            {  0  "corresponding values of the rejection function"
            {  0  REJTOP, "max(REJMIN,REJMID,REJMAX)"
            {  0  Y2TST,  "random number and candidate for a scaled angle"
            {  0  REJTST, "rejection function at Y2TST"
            {  0  Y2TST1, "aux. variable for rejection function calculation"
            {  0  REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0  RTEST;  "random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0  PEIG,   "precise energy of incident photon"
            {  0  PESG,   "precise energy of scattered photon"
            {  0  PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0  broi,   "1+2*ko"
            {  0  broi2,  "broi*broi"
            {  0  bro,    "1/broi"
            {  0  bro1,   "1-bro"
            {  0  alph1,  "probability for the 1/BR part"
            {  0  alph2,  "probability for the BR part"
            {  0  alpha,  "alpha1/(alph1+alph2)"
            {  0  rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0  "random numbers"
            {  0  br,     "scattered photon energy fraction"
            {  0  temp,   "aux. variable for polar angle calculation"
            {  0  rejf3,  "rejection function"
            {  0  rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0  Uj,     "binding energy of the selected shell"
            {  0  Jo,     "the Compton profile parameter"
            {  0  br2,    "br*br"
            {  0  fpz,fpz1,"used for limited pz-range rejection"
            {  0  qc,     "momentum transfer corresponding to the Compton line energy"
            {  0  qc2,    "qc squared"
            {  0  af,     "for calculating F"
            {  0  Fmax,   "maximum of F"
            {  0  frej,   "used for F-rejection"
            {  0  eta_incoh, eta, "random numbers"
            {  0  aux,aux1,aux2,aux3,aux4, "aux. variables"
            {  0  pzmax,  "max. possible z-component of the initial electron momentum"
            {  0  pz,     "initial electron momentum projection"
            {  0  pz2,    "pz*pz"
            {  0  rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0  irl,    "local region number"
            {  0  i,      "loop variable for shell sampling (and then shell sampled)"
            {  0  j,      "pointer to the shell in the shell data list"
            {  0  iarg,   "argument for ausgab call"
            {  0  ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT-old;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0  PEIG,   "precise energy of incident photon"
            {  0  PESG,   "precise energy of scattered photon"
            {  0  PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0  broi,   "1+2*ko"
            {  0  broi2,  "broi*broi"
            {  0  bro,    "1/broi"
            {  0  bro1,   "1-bro"
            {  0  alph1,  "probability for the 1/BR part"
            {  0  alph2,  "probability for the BR part"
            {  0  alpha,  "alpha1/(alph1+alph2)"
            {  0  rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0  "random numbers"
            {  0  br,     "scattered photon energy fraction"
            {  0  temp,   "aux. variable for polar angle calculation"
            {  0  rejf3,  "rejection function"
            {  0  rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0  Uj,     "binding energy of the selected shell"
            {  0  br2,    "br*br"
            {  0  aux,aux1,aux2,"aux. variables"
            {  0  pzmax2, "max. possible momentum transfer squared"
            {  0  pz,     "momentum transfer prejection"
            {  0  pz2,    "pz*pz"
            {  0  rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0  irl,    "local region number"
            {  0  i,      "loop variable for shell sampling (and then shell sampled)"
            {  0  j,      "pointer to the shell in the shell data list"
            {  0  iarg,   "argument for ausgab call"
            {  0  ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ELECTR;} WITH
               0  {;
            {  0  " Local ELECTR variables"
            {  0  $ENERGY PRECISION "($ENERGY PRECISION means double precision)"
            {  0  demfp,        "differential electron mean free path"
            {  0  peie,         "precise energy of incident electron"
            {  0  total_tstep,  "total path-length to next discrete interaction"
            {  0  total_de      "total energy loss to next discrete interaction"
            {  0  ;
            {  0  $REAL
            {  0  ekems,      "kinetic energy used to sample MS angle (normally midpoint)"
            {  0  elkems,     "Log(ekems)"
            {  0  chia2,      "Multiple scattering screening angle"
            {  0  etap,       "correction to Moliere screening angle from PWA cross sections"
            {  0  lambda,     "number of mean free paths (elastic scattering cross section)"
            {  0  blccl,      "blcc(medium)*rhof"
            {  0  xccl,       "xcc(medium)*rhof"
            {  0  xi,         "used for PLC calculations (first GS moment times path-length)"
            {  0  xi_corr,    "correction to xi due to spin effects"
            {  0  ms_corr,
            {  0  p2,         "electron momentum times c, squared"
            {  0  beta2,      "electron speed in units of c, squared"
            {  0  de,         "energy loss to dedx"
            {  0  save_de,    "de saved before $DE-FLUCTUATION"
            {  0  dedx,       "stopping power after density scaling"
            {  0  dedx0,      "stopping power before density scaling"
            {  0  dedxmid,    "stopping power at mid-step before density scaling"
            {  0  ekei,       "used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0  elkei,      "Log(ekei), used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0  aux,        "aux. variable"
            {  0  ebr1,       "e- branching ratio into brem"
            {  0  eie,        "energy of incident electron"
            {  0  ekef,       "kinetic energy after a step"
            {  0  elkef,      "Log(ekef)"
            {  0  ekeold,     "kinetic energy before a step"
            {  0  eketmp,     "used to evaluate average kinetic energy of a step"
            {  0  elktmp,     "log(eketmp)"
            {  0  fedep,      "fractional energy loss used in stopping power calculation"
            {  0  tuss,       "sampled path-length to a single scattering event"
            {  0  pbr1,       "e+ branching ratio into brem"
            {  0  pbr2,       "e+ branching ratio into brem or Bhabha"
            {  0  range,      "electron range"
            {  0  rfict,      "rejection function for fictitious cross section"
            {  0  rnne1,      "random number"
            {  0  rnno24,     "random number"
            {  0  rnno25,     "random number"
            {  0  rnnotu,     "random number"
            {  0  rnnoss,     "random number"
            {  0  sig,        "cross section after density scaling but before a step"
            {  0  sig0,       "cross section before density scaling but before a step"
            {  0  sigf,       "cross section before density scaling but after a step"
            {  0  skindepth,  "skin depth employed for PRESTA-II boundary crossing"
            {  0  ssmfp,      "distance of one single elastic scattering mean free path"
            {  0  tmxs,       "electron step-size restriction"
            {  0  tperp,      "perpendicular distance to the closest boundary"
            {  0  ustep0,     "temporary storage for ustep"
            {  0  uscat,      "x-axis direction cosine for scattering"
            {  0  vscat,      "y-axis direction cosine for scattering"
            {  0  wscat,      "z-axis direction cosine for scattering"
            {  0  xtrans,     "final x-axis position after transport"
            {  0  ytrans,     "final y-axis position after transport"
            {  0  ztrans,     "final z-axis position after transport"
            {  0  cphi,sphi;  "for azimuthal angle selection for annih at rest"
            {  0
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0
            {  0  $INTEGER
            {  0  iarg,      "calling code for ausgab"
            {  0  idr,       "calling code for ausgab"
            {  0  ierust,    "error counter for negative ustep errors"
            {  0  irl,       "region number"
            {  0  lelec,     "charge of electron"
            {  0  qel,       " = 0 for electrons, = 1 for positrons "
            {  0  lelke,     "index into the energy grid of tabulated functions"
            {  0  lelkems,   "index into the energy grid of tabulated functions"
            {  0  lelkef,    "index into the energy grid of tabulated functions"
            {  0  lelktmp,   "index into the energy grid of tabulated functions"
            {  0  ibr;       "a loop variable"
            {  0
            {  0  $LOGICAL
            {  0  "BCA = boundary crossing algorithm"
            {  0  callhowfar, "= .true.  => BCA requires a call to howfar"
            {  0  "= .false. => BCA does not require a call to howfar"
            {  0  domultiple, "= .true.  => inexact BCA requires multiple scattering"
            {  0  dosingle,   "= .true.  => exact BCA requires single scattering"
            {  0  "= .false. => exact BCA requires no single scattering"
            {  0  callmsdist, "= .true.  => normal condensed-history transport"
            {  0  "= .false. => one of the BCA's will be invoked"
            {  0  findindex,  "used for mscat"
            {  0  spin_index, "used for mscat with spin effects"
            {  0  compute_tstep
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-HATCH;} WITH
               0  {;
            {  0  "Local HATCH variables in alphabetical order"
            {  0
            {  0  $TYPE MBUF(72),MDLABL(8);
            {  0
            {  0  $REAL
            {  0  ACD   , "used to test goodness of sine-table look-up"
            {  0  ADEV  , "absolute deviation in sine-table look-up"
            {  0  ASD   , "used to test goodness of sine-table look-up"
            {  0  COST  , "cos(theta) from instrinsic library function"
            {  0  CTHET , "use to calculate cos(theta) according to look-up tables"
            {  0  DEL   , "leat squares delta for sine-table look-up"
            {  0  DFACT , "converts rl to dunits"
            {  0  DFACTI, "converts rl**-1 to dunits**-1"
            {  0  DUNITO, "units scaling varable"
            {  0  DUNITR, "saved value of dunit"
            {  0  FNSSS , "real form of integer nsinss"
            {  0  P     , "counter used in the pwr2i(i) = 1/2**(i - 1) construction"
            {  0  PZNORM, "used in $INITIALIZE-BREMS-ANGLE"
            {  0  RDEV  , "relative deviation in sine-table look-up"
            {  0  S2C2  , "sinthe**2 + costhe**2, used to test look-up table"
            {  0  S2C2MN, "min(s2c2)"
            {  0  S2C2MX, "max(s2c2)"
            {  0  SINT  , "sin(theta) from instrinsic library function"
            {  0  SX    , "sum of angles for least squared analysis of look-up table errors"
            {  0  SXX   , "sum**2 of angles for least square analysis of look-up table errors"
            {  0  SXY   , "sum of angle*sin(angle) for least squared analysis of look-up"
            {  0  "table errors"
            {  0  SY    , "sum of sin(angle) for least squared analysis of look-up table "
            {  0  "errors"
            {  0  WID   , "width of sine-table mesh sub-interval (sine-table algorithm)"
            {  0  XS    , "angle value in a sub-sub-interval (sine-table algorithm)"
            {  0  XS0   , "lower limit of a sub-sub-interval (sine-table algorithm)"
            {  0  XS1   , "upwer limit of a sub-sub-interval (sine-table algorithm)"
            {  0  XSI   , "beginning angle of a sun-interval (sine-table algorithm)"
            {  0  WSS   , "width of a sub-sub-interval (sine-table algorithm)"
            {  0  YS    , "sin(angle) for least squared analysis of look-up table errors"
            {  0  ZEROS(3); "zeros of sine, 0,pi,twopi"
            {  0
            {  0  $INTEGER
            {  0  I     , "generic do-loop variable"
            {  0  I1ST  , "flag = 0 on first pass"
            {  0  IB    , "do-loop variable used for reading the medium type"
            {  0  ID    , "integer value of -dunit, when dunit is negative"
            {  0  IE    , "do-loop variable for reading over elements in a compound/mixture"
            {  0  IL    , "do-loop variable used for reading the medium type"
            {  0  IM    , "do-loop variable looping over nmed, number of media"
            {  0  IRAYL , "Rayleigh switch read in from PEGS"
            {  0  IRN   , "do-loop variable over random set of sine-table look-ups"
            {  0  ISTEST, "flag that switches on test of sine function fit"
            {  0  ISUB  , "do-loop variable over sub-intervals of the sine look-up table"
            {  0  ISS   , "do-loop variable over sub-sub-intervals of the sine look-up table"
            {  0  IZ    , "used to locate an exact zero of a sun-interval mesh point in the"
            {  0  "sine-table look-up"
            {  0  IZZ   , "do-loop variable over the exact zeros of the sine-table look-up"
            {  0  J     , "do-loop variable looping over nmed, number of media"
            {  0  JR    , "do-loop variable looping over number of regions"
            {  0  LCTHET, "$SET INTERVAL index for cos(theta) from look-up table"
            {  0  LMDL  , "character width of medium header ' MEDIUM='"
            {  0  LMDN  , "character width of medium description"
            {  0  LTHETA, "$SET INTERVAL index for sin(theta) from look-up table"
            {  0  MD    , "temporary storage for the medium number"
            {  0  MXSINC, "number of intervals approximating the sine function"
            {  0  NCMFP , "array size input from PEGS. Currently 0, but probably intended"
            {  0  "to be cumulative electron mean free path. Presently unused."
            {  0  NEKE  , "array size input from PEGS."
            {  0  "Number of electron mapped energy intervals."
            {  0  NGE   , "array size input from PEGS."
            {  0  "Number of photon mapped energy intervals."
            {  0  NGRIM , "Rayleigh cross section array size."
            {  0  NISUB , "mxsinc - 2. Size of array with endpoints removed."
            {  0  NLEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0  "to be number of electron energy intervals below threshold."
            {  0  "Presently unused."
            {  0  NM    , "number of media found in the "
            {  0  NRANGE, "array size input from PEGS. Currently 0, but probably intended"
            {  0  "to be number of intervals in an array giving the electron range."
            {  0  "Presently unused."
            {  0  NRNA  , "number of random angles testing sine function fit"
            {  0  NSEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0  "to be number of electron small energy intervals. Presently unused."
            {  0  NSGE  , "array size input from PEGS. Currently 0, but probably intended"
            {  0  "to be number of gamma small energy intervals. Presently unused."
            {  0  NSINSS, "number of sub-intervals for each sine function interval"
            {  0  LOK($MXMED); "flag indicating that medium has been found in the PEGS "
            {  0  "datafile"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-MOLLER;} WITH
               0  {;
            {  0  "Local MOLLER variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0  PEIE,   "precise total energy of incident electron"
            {  0  PEKSE2, "precise kinetic energy of 2nd secondary electron"
            {  0  PESE1,  "precise total energy of 1st secondary electron"
            {  0  PESE2,  "precise total energy of 2nd secondary electron"
            {  0  PEKIN,  "precise kinetic energy of incident electron"
            {  0  H1,     "used for polar scattering angle calculation"
            {  0  DCOSTH; "polar scattering angle squared"
            {  0  $REAL EIE,    "total energy of incident electron"
            {  0  EKIN,   "kinetic energy of incident electron"
            {  0  T0,     "kinetic energy of incident electron in units of RM"
            {  0  E0,     "total energy of incident electron in units of RM"
            {  0  EXTRAE, "energy above the Moller threshold"
            {  0  E02,    "E0**2"
            {  0  EP0,    "minimum alowed kinetic energy fraction"
            {  0  G2,G3,  "used for rejection function calculation"
            {  0  GMAX,   "maximum value of the rejection function"
            {  0  BR,     "kinetic energy fraction to lowew energy electron"
            {  0  R,      "(1-BR)/BR"
            {  0  REJF4,  "rejection function"
            {  0  RNNO27, "random number for BR sampling"
            {  0  RNNO28, "random number for rejection"
            {  0  ESE1,   "energy of 1st secondary electron"
            {  0  ESE2;   "energy of 2nd secondary electron"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PAIR;} WITH
               0  {;
            {  0  "Local PAIR variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0  PEIG,      "precise energy of incident photon"
            {  0  PESE1,     "precise energy of 1st 'electron'"
            {  0  PESE2;     "precise energy of 2nd 'electron'"
            {  0
            {  0  $REAL EIG,       "energy of incident photon"
            {  0  ESE2,      "total energy of lower energy 'electron'"
            {  0  RNNO30,RNNO31,rnno32,rnno33,rnno34,
            {  0  "random numbers"
            {  0  DELTA,     "scaled momentum transfer"
            {  0  REJF,      "screening rejection function"
            {  0  rejmax,    "the maximum of rejf"
            {  0  aux1,aux2, "auxilary variables"
            {  0  Amax,      "Maximum of the screening function used with (br-1/2)**2"
            {  0  Bmax,      "Maximum of the screening function used with the uniform part"
            {  0  del0,      "delcm*eig"
            {  0  br,        "fraction of the available energy (eig-rmt2) going to the"
            {  0  "lower energy `electron'"
            {  0  Eminus,Eplus,Eavail,rnno_RR;
            {  0
            {  0  $INTEGER
            {  0  L,L1;  "flags for high/low energy distributions"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;} WITH
               0  {;
            {  0  $REAL ESE,   "total energy of one of the 'electrons'"
            {  0  PSE,   "momentum corresponding to ESE"
            {  0  ZTARG, "( (1/111)*Zeff**(1/3) )**2"
            {  0  TTEIG, "incident photon energy in units of RM"
            {  0  TTESE, "energy of one of the 'electrons' in units of RM"
            {  0  TTPSE, "momentum of one of the 'electrons' in units of RM"
            {  0  ESEDEI,"TTESE/(TTEIG-TTESE) = ratio of secondary electron energies"
            {  0  ESEDER,"1/ESEDEI"
            {  0  XIMIN, "1st argument where rejection function might have a maximum"
            {  0  XIMID, "2nd argument where rejection function might have a maximum"
            {  0  REJMIN,"rejection function at XIMIN"
            {  0  REJMID,"rejection function at XIMID"
            {  0  REJTOP,"max(REJMIN,REJMID)"
            {  0  YA,XITRY,GALPHA,GBETA,
            {  0  "aux. variables for XIMID calculation"
            {  0  XITST, "random number for pair angle sampling"
            {  0  REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0  REJTST,"rejection function at XITST"
            {  0  RTEST; "random number for rejection"
            {  0  $INTEGER
            {  0  ICHRG; "loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTO;} WITH
               0  {;
            {  0  "Local PHOTO variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0  PEIG;         "precise energy of incident photon"
            {  0  $REAL BR,           "random number"
            {  0  sigma,        "elemental cross section"
            {  0  aux,aux1,     "aux. variables"
            {  0  probs($MXEL), "probability for an interaction with a given element"
            {  0  sigtot,       "total cross section"
            {  0  e_vac,        "shell binding energy"
            {  0  rnno_RR;      "for playing Russian Roulette"
            {  0  $INTEGER
            {  0  IARG,         "AUSGAB calling switch"
            {  0  iZ,           "Atomic number of the element the photon is "
            {  0  "interactiong with"
            {  0  irl,          "local region number"
            {  0  ints($MXEL),  "energy interval number for a given element"
            {  0  j,ip,         "loop variables"
            {  0  n_warning,    "a warning counter"
            {  0  k;            "shell number"
            {  0
            {  0  $LOGICAL
            {  0  do_relax;
            {  0  save  n_warning;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;} WITH
               0  {;
            {  0  "Photo-electron angle selection variables"
            {  0  $REAL EELEC, "total energy of photo-electron"
            {  0  BETA,  "velocity of electron in units of c"
            {  0  GAMMA, "total energy of photo-electron in units of RM"
            {  0  ALPHA, "kinematic factor"
            {  0  RATIO, "=BETA/ALPHA"
            {  0  RNPHT, "random number"
            {  0  FKAPPA,"aux. variable for COSTHE calculation"
            {  0  XI,    "used in rejection function calculation"
            {  0  SINTH2,"SINTHE**2"
            {  0  RNPHT2;"random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-EDGSET;} WITH
               0  {;
            {  0  "Local EDGSET variables in order of their appearance"
            {  0  $REAL EALF(100),EBET(100),OMEG(100),PHOTOK(100),PKA(100);
            {  0  "see the data statements in EDGSETfor definition of these arrays"
            {  0  $INTEGER JJ,IZ,IMED,I;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTON;} WITH
               0  {;
            {  0  "Local PHOTON variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0  PEIG;   "precise photon energy"
            {  0  ;
            {  0  $REAL
            {  0  EIG,    "photon energy"
            {  0  RNNO35, "random number for default MFP selection"
            {  0  GMFPR0, "photon MFP before density scaling and coherent correction"
            {  0  GMFP,   "photon MFP after density scaling"
            {  0  COHFAC, "Rayleigh scattering correction"
            {  0  RNNO37, "random number for Rayleigh scattering selection"
            {  0  XXX,    "random number for momentum transfer sampling in Rayleigh"
            {  0  X2,     "scaled momentum transfer in Rayleigh scattering event"
            {  0  Q2,     "momentum transfer squared in Rayleigh scattering event"
            {  0  CSQTHE, "COSTHE**2"
            {  0  REJF,   "Rayleigh scattering rejection function"
            {  0  RNNORJ, "random number for rejection in Rayleigh scattering"
            {  0  RNNO36, "random number for interaction branching"
            {  0  GBR1,   "probability for pair production"
            {  0  GBR2,   "probability for pair + compton"
            {  0  T,      "used for particle exchange on the stack"
            {  0  "Ali:photonuc, 2 lines"
            {  0  PHOTONUCFAC, "photonuclear correction"
            {  0  RNNO39; "random number for photonuclear selection (RNNO38 is taken)"
            {  0  ;
            {  0  $INTEGER
            {  0  IARG,   "parameter for AUSGAB"
            {  0  IDR,    "parameter for AUSGAB"
            {  0  IRL,    "region number"
            {  0  LGLE,   "index for GMFP interpolation"
            {  0  LXXX;   "index for Rayleigh scattering cummulative distribution int."
            {  0  }
               0  ;
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTONUC;} WITH {;}
               0  ;
               0
               0  " Handling track-ends "
               0  " By default, just call AUSGAB and drop energy on the spot"
               0
               0  REPLACE {$ELECTRON-TRACK-END;} WITH {; $AUSCALL(idr); }
               0  REPLACE {$PHOTON-TRACK-END;}   WITH {; $AUSCALL(IDR); }
               0  ;
               0
               0  " Macros for the fictitious method  "
               0  "==================================="
               0
               0  " The following version uses sub-threshold energy loss "
               0  " as a measure of path-length => cross section is actual "
               0  " cross section divided by restricted stopping power "
               0  " The global maximum of this quantity called esig_e (electrons) or "
               0  " psig_e (positrons) and is determined in HATCH "
               0
               0  REPLACE {$EVALUATE-SIG0;} WITH
               0  "        ==============="
               0  {;
            {  0  IF( sig_ismonotone(qel,medium) ) [
            {  0  $EVALUATE-SIGF; sig0 = sigf;
            {  0  ]
            {  0  ELSE [
            {  0  IF( lelec < 0 ) [sig0 = esig_e(medium);]
            {  0  ELSE            [sig0 = psig_e(medium);]
            {  0  ]
            {  0  }
               0
               0  REPLACE {$EVALUATE-SIGF;} WITH
               0  "        ==============="
               0  {;
            {  0  IF(lelec < 0)
            {  0  [
            {  0  $EVALUATE sigf USING esig(elke);
            {  0  $EVALUATE dedx0 USING ededx(elke);
            {  0  sigf = sigf/dedx0;
            {  0  ]
            {  0  ELSE
            {  0  [
            {  0  $EVALUATE sigf USING psig(elke);
            {  0  $EVALUATE dedx0 USING pdedx(elke);
            {  0  sigf = sigf/dedx0;
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$EVALUATE-EBREM-FRACTION;} WITH {
            {  0  $EVALUATE ebr1 USING ebr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-PBREM-FRACTION;} WITH {
            {  0  $EVALUATE pbr1 USING pbr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-BHABHA-FRACTION;} WITH {
            {  0  $EVALUATE pbr2 USING pbr2(elke);
            {  0  };
               0
               0
               0  " Because the cross section is interactions per energy loss, no "
               0  " rhof-scaling is required "
               0  REPLACE {$SCALE-SIG0;} WITH
               0  "        ============"
               0  {
            {  0  sig = sig0;
            {  0  }
               0  ;
               0
               0  " Once the sub-threshold processes energy loss to the next discrete "
               0  " interaction is determined, the corresponding path-length has to be"
               0  " calculated. This is done by the macro below. This macro           "
               0  " assumes the energy at the begining to be eke, the logarithm of it "
               0  " elke, lelke - the corresponding interpolation index and makes     "
               0  " use of $COMPUTE-DRANGE(#,#,#,#,#,#)                               "
               0
               0  REPLACE {$CALCULATE-TSTEP-FROM-DEMFP;} WITH
               0  "        ============================"
               0  {;
            {  0  IF( compute_tstep ) [
            {  0  total_de = demfp/sig; fedep = total_de;
            {  0  ekef  = eke - fedep;
            {  0  IF( ekef <= E_array(1,medium) ) [ tstep = vacdst; ]
            {  0  ELSE
            {  0  [
            {  0  elkef = Log(ekef);
            {  0  $SET INTERVAL elkef,eke;
            {  0  IF( lelkef = lelke )
            {  0  [       " initial and final energy are in the same interpolation bin "
            {  0  $COMPUTE-DRANGE(eke,ekef,lelke,elke,elkef,tstep);
            {  0  ]
            {  0  ELSE
            {  0  [   " initial and final energy are in different interpolation bins, "
            {  0  " calc range from ekef to E(lelkef+1) and from E(lelke) to eke  "
            {  0  " and add the pre-calculated range from E(lelkef+1) to E(lelke) "
            {  0  ekei = E_array(lelke,medium);
            {  0  elkei = (lelke - eke0(medium))/eke1(medium);
            {  0  $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,tuss);
            {  0  ekei = E_array(lelkef+1,medium);
            {  0  elkei = (lelkef + 1 - eke0(medium))/eke1(medium);
            {  0  $COMPUTE-DRANGE(ekei,ekef,lelkef,elkei,elkef,tstep);
            {  0  tstep=tstep+tuss+
            {  0  range_ep(qel,lelke,medium)-range_ep(qel,lelkef+1,medium);
            {  0  ]
            {  0  ]
            {  0  total_tstep = tstep;
            {  0  compute_tstep = .false.;
            {  0  ]
            {  0  tstep = total_tstep/rhof;  " non-default density scaling "
            {  0  }
               0  ;
               0
               0  " The following macro computes the path-length traveled while going from  "
               0  " energy {P1} to energy {P2}, both energies being in the same             "
               0  " interpolation bin, given by {P3}. {P4} and {P5} are the logarithms of   "
               0  " {P1} and {P2}. The expression is based on logarithmic interpolation as  "
               0  " used in EGSnrc (i.e. dedx = a + b*Log(E) ) and a power series expansion "
               0  " of the ExpIntegralEi function that is the result of the integration.    "
               0  " The result is returned in {P6}.                                         "
               0
               0  REPLACE {$COMPUTE-DRANGE(#,#,#,#,#,#);} WITH
               0  "        ============================="
               0  {
            {  0  fedep = 1 - {P2}/{P1};
            {  0  elktmp = 0.5*({P4}+{P5}+0.25*fedep*fedep*(1+fedep*(1+0.875*fedep)));
            {  0  " the above evaluates the logarithm of the midpoint energy"
            {  0  lelktmp = {P3};
            {  0  IF(lelec < 0) [
            {  0  $EVALUATE dedxmid USING ededx(elktmp);
            {  0  dedxmid = 1/dedxmid;
            {  0  aux = ededx1(lelktmp,medium)*dedxmid;
            {  0  "aux = ededx1(lelktmp,medium)/dedxmid;"
            {  0  ]
            {  0  ELSE [
            {  0  $EVALUATE dedxmid USING pdedx(elktmp);
            {  0  dedxmid = 1/dedxmid;
            {  0  aux = pdedx1(lelktmp,medium)*dedxmid;
            {  0  "aux = pdedx1(lelktmp,medium)/dedxmid;"
            {  0  ]
            {  0  aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6;
            {  0  "{P6} = fedep*{P1}/dedxmid*(1+aux);"
            {  0  {P6} = fedep*{P1}*dedxmid*(1+aux);
            {  0  }
               0  ;
               0
               0  " The following macro computes the range to the minimum table energy "
               0  " It uses $COMPUTE-DRANGE                                            "
               0  " Note that range_ep array is precomputed in subroutine mscati and   "
               0  " gives the range from the energy interval end points to AE for each "
               0  " medium.
               0
               0  REPLACE {$COMPUTE-RANGE;} WITH
               0  "        ==============="
               0  {
            {  0  ;
            {  0  ekei = E_array(lelke,medium);
            {  0  elkei = (lelke - eke0(medium))/eke1(medium);
            {  0  $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
            {  0  range = (range + range_ep(qel,lelke,medium))/rhof;
            {  0  }
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  " The following macro updates demfp. As energy loss is used as the  "
               0  " 'path-length' variable (see above), it just substracts the energy "
               0  " loss for the step.                                                "
               0  REPLACE {$UPDATE-DEMFP;} WITH
               0  "        =============="
               0  {
            {  0  demfp = demfp - save_de*sig;
            {  0  total_de = total_de - save_de;
            {  0  total_tstep = total_tstep - tvstep*rhof;
            {  0  IF( total_tstep < 1e-9 ) [ demfp = 0; ]
            {  0  }
               0  ;
               0
               0  " The following macro computes the energy loss due to sub-threshold "
               0  " processes for a path-length {P1}. The energy at the beginning of  "
               0  " the step is {P2}, {P3}=Log({P2}), {P4} is the interpolation index "
               0  " The formulae are based on the logarithmic interpolation for dedx  "
               0  " used in EGSnrc. The result is returned in {P5}. Assumes that      "
               0  " initial and final energy are in the same interpolation bin.       "
               0
               0  REPLACE {$COMPUTE-ELOSS(#,#,#,#,#);} WITH
               0  "        =========================="
               0  {;
            {  0  IF( lelec < 0 ) [
            {  0  $EVALUATE dedxmid USING ededx({P3});
            {  0  aux = ededx1({P4},medium)/dedxmid;
            {  0  ]
            {  0  ELSE [
            {  0  $EVALUATE dedxmid USING pdedx({P3});
            {  0  aux = pdedx1({P4},medium)/dedxmid;
            {  0  ]
            {  0
            {  0
            {  0
            {  0  {P5} = dedxmid*{P1}*rhof; "IK: rhof scaling bug, June 9 2006"
            {  0  "rhof scaling must be done here and NOT in "
            {  0  "$COMPUTE-ELOSS-G below!"
            {  0  fedep = {P5}/{P2};
            {  0  {P5} = {P5}*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1-
            {  0  0.25*fedep*(2-aux*(4-aux)))));
            {  0  }
               0  ;
               0
               0  " The following is a generalized version of $COMPUTE-ELOSS.        "
               0
               0  REPLACE {$COMPUTE-ELOSS-G(#,#,#,#,#);} WITH
               0  "        ============================"
               0  {
            {  0  tuss = range - range_ep(qel,{P4},medium)/rhof;
            {  0  " here tuss is the range between the initial energy and the next lower "
            {  0  " energy on the interpolation grid "
            {  0  IF( tuss >= {P1} ) [  " Final energy is in the same interpolation bin "
            {  0  $COMPUTE-ELOSS({P1},{P2},{P3},{P4},{P5});
            {  0
            {  0  "IK: rhof scaling bug, June 9 2006. rhof scaling is done in "
            {  0  "    $COMPUTE-ELOSS above!                                  "
            {  0  ]
            {  0  ELSE [ " Must find first the table index where the step ends using "
            {  0  " pre-calculated ranges                                     "
            {  0  lelktmp = {P4};
            {  0  tuss = (range - {P1})*rhof;
            {  0  " now tuss is the range of the final energy electron "
            {  0  " scaled to the default mass density from PEGS4      "
            {  0  IF( tuss <= 0 ) [ {P5} = {P2} - TE(medium)*0.99; ]
            {  0  " i.e., if the step we intend to take is longer than the particle "
            {  0  " range, the particle energy goes down to the threshold "
            {  0  "({P2} is the initial particle energy)  "
            {  0  "originally the entire energy was lost, but msdist_xxx is not prepared"
            {  0  "to deal with such large eloss fractions => changed July 2005."
            {  0  ELSE [
            {  0  WHILE ( tuss < range_ep(qel,lelktmp,medium) ) [
            {  0  lelktmp = lelktmp - 1; ]
            {  0  elktmp = (lelktmp+1-eke0(medium))/eke1(medium);
            {  0  eketmp = E_array(lelktmp+1,medium);
            {  0  "tuss = range_ep(qel,lelktmp+1,medium) - tuss;"
            {  0  "IK: rhof scaling bug, June 9 2006: because of the change in "
            {  0  "    $COMPUTE-ELOSS above, we must scale tuss by rhof        "
            {  0  tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof;
            {  0  $COMPUTE-ELOSS(tuss,eketmp,elktmp,lelktmp,{P5});
            {  0  {P5} = {P5} + {P2} - eketmp;
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "
               0  "   The following is related to use of the NRC auxilliary get_inputs
               0  "   routine which is part of the standard NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "
               0  "============================================================================"
               0  "
               0  " Input stuff for the get_inputs() routine.                                  "
               0  " As the expirience has shown that get_inputs() is frequently used in several"
               0  " subroutines, I changed the parameter passed to get_inputs() to a common    "
               0  " block. Otherwise, the parameters have to be defined in each subroutine using"
               0  " get_inputs() and, with static variables, this lead to a memory use         "
               0  " explosion (e.g. 8 MB for CAVRZ vs. 0.8 MB without get_inputs()!)           "
               0  " IK, Dec. 1998                                                              "
               0
               0  REPLACE {$NMAX} WITH {100};
               0  REPLACE {$NVALUE} WITH {100};
               0  REPLACE {$STRING80} WITH {80};
               0  REPLACE {$STRING32} WITH {64};
               0  REPLACE {$STRING40} WITH {40};
               0  REPLACE {$STRING256} WITH {256};
               0  REPLACE {$MXALINP} WITH {5};
               0
               0  REPLACE {COMIN/GetInput/;} WITH
               0  "        ================"
               0  {
            {  0  ;COMMON/GetInput/
            {  0  ALLOWED_INPUTS($NMAX,0:$MXALINP), "Associates a name with each second "
            {  0  "array index(0:4) for a value sought"
            {  0  VALUES_SOUGHT($NMAX),      "Name of each input                 "
            {  0  CHAR_VALUE($NMAX,$NVALUE), "For returning character inputs     "
            {  0  VALUE($NMAX,$NVALUE),      "For returning int. or real inputs  "
            {  0  DEFAULT($NMAX),            "Default value, only for type 0 & 1 "
            {  0  VALUE_MIN($NMAX),          "Min and max value defining         "
            {  0  VALUE_MAX($NMAX),          "the acceptable input range         "
            {  0  NVALUE($NMAX),             "Number of values per value sought  "
            {  0  TYPE($NMAX),               "Type of the value sought           "
            {  0  "0 for integer                      "
            {  0  "1 for real                         "
            {  0  "2 for character                    "
            {  0  "3 for character with allowed_inputs"
            {  0  ERROR_FLAGS($NMAX),        "An error flag for each of the      "
            {  0  "attempted inputs                   "
            {  0  i_errors,                  "Unit no. for .errors output file   "
            {  0  NMIN, NMAX,                "Minimum and maximum index number of"
            {  0  "the values sought                  "
            {  0  ERROR_FLAG,                "0 for no errors, 1 for errors      "
            {  0  DELIMETER;                 "Name of the delimeter              "
            {  0  character ALLOWED_INPUTS*$STRING32,VALUES_SOUGHT*$STRING32,
            {  0  CHAR_VALUE*$STRING256,DELIMETER*$STRING32;
            {  0  $REAL     VALUE,DEFAULT,VALUE_MIN,VALUE_MAX;
            {  0  $INTEGER  NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors;
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_INPUT(#);} WITH { NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT; }
               0  ;
               0
               0  REPLACE {$GET_INPUTS(#,#);} WITH { NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT; }
               0  ;
               0
               0  "The following macro is used in the egs_init1 subroutine (in the file
               0  "egs_utilities.mortran.  Here it is replaced by null so that we insist that
               0  "the .egsinp file be opened with unit=5 (standard input) and the .egslog
               0  "file (if required) be opened with unit=6 (standard output).  This is
               0  "replaced by a search for available units in beamnrc_lib.mortran to avoid
               0  "unit collisions with BEAM shared library sources
               0
               0  REPLACE {$AVAILABLE_UNIT(#,#)} WITH {;}
               0
               0  " The following two macros are defined so that if the nrcaux.mortran file
               0  " is included in the configuration file these are defined at least.
               0  " If the NRC statistics routine  SIGMA is to be used these must have realistic
               0  " definitions in the user-code.
               0
               0  REPLACE {$MXDATA} WITH {1};
               0  REPLACE {$STAT} WITH {2};
               0
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "   The following is related to use of the NRC auxilliary
               0  "   routine xvgrplot which is called from some of the standard
               0  "   NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "============================================================================"
               0  REPLACE{$PLTDIM} WITH {300};"Unique array dimension for XVGRPLOT and PLOTSN"
               0  "Suppresses warnings from Intel compiler on Windows"
               0  "when arrays have different dimensions in diff. routines"
               0
1              0  %E   "egsnrc.macros"
               0  "***************************************************************************"
               0  "                                                                           "
               0  "         EGSnrc internal Variance Reduction Macros                         "
               0  "                                                                           "
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/EGS-VARIANCE-REDUCTION/;} WITH {;
            {  0
            {  0  common/egs_vr/
            {  0  e_max_rr($MXREG), "max energy at which to do range rejection (RR)"
            {  0  prob_RR,          "probability for survival in R. Roulette"
            {  0  nbr_split,        "do brems splitting if > 1"
            {  0  i_play_RR,        "0=>don't play Russian Roulette,1=>play Russian Roulette"
            {  0  i_survived_RR,    "0=> all particles survive RR, n=> n partilces were"
            {  0  "eliminated by RR in this interaction"
            {  0  n_RR_warning,     "a counter for user errors"
            {  0  i_do_rr($MXREG);  "0=>no RR, region by region, 1=>there is RR"
            {  0  $REAL          e_max_rr,prob_RR;
            {  0  $INTEGER       nbr_split,i_play_RR,i_survived_RR,n_RR_warning;
            {  0  $SHORT_INT     i_do_rr;
            {  0  };
               0
               0  REPLACE {$MAX-RR-WARNING} WITH {50}
               0
               0  "This macro implements Russian Roulette (most useful  with brems splitting)"
               0  "It is more efficient than having the user do it via AUSGAB since it avoids"
               0  "considerable handling of the particles by ELECTR"
               0  "The user must set i_play_RR (defaults to 0) and prob_RR"
               0  "Both are in COMIN EGS-VARIANCE-REDUCTION"
               0  ""
               0  "Note that this macro is called as $PLAY RUSSIAN ROULETTE WITH ELECTRONS..."
               0  "Note also that subroutine pair has its own, internal version"
               0
               0  REPLACE {$PLAYRUSSIANROULETTEWITHELECTRONSFROM#;} WITH {;
            {  0
            {  0  i_survived_RR = 0;   "flag all survive"
            {  0  ;IF( i_play_RR = 1 ) [
            {  0  IF( prob_RR <= 0 ) [
            {  0  IF( n_RR_warning < $MAX-RR-WARNING ) [
            {  0  n_RR_warning = n_RR_warning + 1;
            {  0  OUTPUT prob_RR;
            {  0  ('**** Warning, attempt to play Roussian Roulette with prob_RR<=0! ',g14.6);
            {  0  ]
            {  0  ]
            {  0  ELSE [
            {  0  ip = {P1};
            {  0  LOOP [     "handle all particles from p1 to np"
            {  0  IF( iq(ip) ~= 0 ) [   "i.e. charged particles"
            {  0  $RANDOMSET rnno_RR;
            {  0  IF( rnno_RR < prob_RR ) [ "particle survives"
            {  0  wt(ip) = wt(ip)/prob_RR;
            {  0  ip = ip + 1; "increase local pointer"
            {  0  ]
            {  0  ELSE [                    "particle killed"
            {  0  ;i_survived_RR = i_survived_RR + 1;
            {  0  ;IF(ip < np) [
            {  0  "=>replace it with last particle on stack"
            {  0  e(ip) = e(np); iq(ip) = iq(np); wt(ip) = wt(np);
            {  0  u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
            {  0  ]
            {  0  np = np-1; "reduce stack by one=> particle gone"
            {  0  ] "end of kill particle block"
            {  0  ] ELSE [ "this is a photon, leave it. Change pointer" ip = ip+1; ]
            {  0  ] UNTIL (ip > np);
            {  0  "loops until either np is decreased to ip, or ip increased to np"
            {  0  IF( np = 0 ) [ " we need at least one particle on the stack "
            {  0  " so that the transport routines can exit properly"
            {  0  np = 1; e(np) = 0; iq(np) = 0; wt(np) = 0;
            {  0  ]
            {  0  ] "end of russian roulette block"
            {  0  ] "end of flag set block"
            {  0  };
               0
               0  "*********************************************************************"
               0  "  Stuff related to radiative corrections for Compton scattering      "
               0  "                                                                     "
               0  "  For now we exclude such corrections by default. They can be        "
               0  "  included by adding the file rad_compton.mortran to the list of     "
               0  "  files used to build EGSnrc just before egsnrc.mortran              "
               0  "  The reason is that there is a fairly large amount of data needed   "
               0  "  and this would be wasteful if the effect turns out to be small     "
               0  "*********************************************************************"
               0
               0  REPLACE {$RADC_CHECK;} WITH {;}
               0  REPLACE {$RADC_REJECTION;} WITH {;}
               0  REPLACE {$RADC_WARNING;} WITH {;
            {  0  IF( radc_flag = 1 ) [
            {  0  $egs_warning(*,'You are trying to use radiative Compton corrections');
            {  0  $egs_info(*,'without having included rad_compton1.mortran');
            {  0  $egs_info('(a//)','Turning radiative Compton corrections OFF ...');
            {  0  radc_flag = 0;
            {  0  ]
            {  0  };
               0  REPLACE {$RADC_HATCH;} WITH {$RADC_WARNING;}
               0  REPLACE {$COMIN-RADC-INIT;} WITH {
            {  0  ;COMIN/RAD_COMPTON,EGS-IO,COMPTON-DATA,MEDIA,PHOTIN,USEFUL/;
            {  0  };
               0  REPLACE {$COMIN-RADC-SAMPLE;} WITH {
            {  0  ;COMIN/RAD_COMPTON,RANDOM,STACK,USEFUL,EGS-IO/;
            {  0  };
               0
               0
               0  "*********************************************************************"
               0  "  I/O, parallel processing, string manipulations, etc.
               0  "*********************************************************************"
               0
               0  "how many chunks do we want to split the parallel run into
               0  REPLACE {$N_CHUNKS} WITH {10};
               0
               0  " String manipulations, error messages, etc. "
               0  REPLACE {$cstring(#)} WITH {{P1}(:lnblnk1({P1}))};
               0  REPLACE {$set_string(#,#);} WITH {;
            {  0  DO i=1,len({P1}) [ {P1}(i:i) = {P2}; ] ;
            {  0  };
               0
               0  REPLACE {$egs_debug(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_fatal(#,#,#);} WITH {
            {  0  $warning('(/a)','***************** Error: ');
            {  0  $warning({P1},{P2});
            {  0  $warning('(/a)','***************** Quiting now.');
            {  0  $CALL_EXIT({P3});
            {  0  };
               0  REPLACE {$egs_fatal(#,#);} WITH {
            {  0  $warning('(/a)','***************** Error: ');
            {  0  $warning({P1},{P2});
            {  0  $warning('(/a)','***************** Quiting now.');
            {  0  $CALL_EXIT(1);
            {  0  };
               0  REPLACE {$egs_warning(#,#);} WITH {
            {  0  $warning('(/a)','***************** Warning: ');
            {  0  $warning({P1},{P2});
            {  0  };
               0  REPLACE {$warning(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_info(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$declare_write_buffer;} WITH {;};
               0  "****************************************************************"
               0  " Useful output macros that do not rely on standard output unit. "
               0  " Useful for debugging code after egs_finish call which closes   "
               0  " all open units (for instance after a parallel job finishes).   "
               0  "****************************************************************"
               0  REPLACE {$egs_track2(#,#,#,#);} WITH {
            {  0  open({P1},file={P2},action='write',position='append');
            {  0  write({P1},{P3}) {P4};
            {  0  $FLUSH_UNIT({P1});
            {  0  close({P1});
            {  0  };
               0  REPLACE {$egs_track1(#,#,#);} WITH {
            {  0  open(666,file={P1},action='write',position='append');
            {  0  write(666,{P2}) {P3};
            {  0  $FLUSH_UNIT(666);
            {  0  close(666);
            {  0  };
               0  REPLACE {$egs_track0(#,#);} WITH {
            {  0  open(666,file='track.log',action='write',position='append');
            {  0  write(666,{P1}) {P2};
            {  0  $FLUSH_UNIT(666);
            {  0  close(666);
            {  0  };
               0  "************************************************************"
               0
               0  " Common block containing various directories, file names, etc. "
               0  REPLACE {$mx_units} WITH {20};
               0  REPLACE {$max_extension_length} WITH {10};
               0  REPLACE {;COMIN/EGS-IO/;} WITH {;
            {  0  common /egs_io/ file_extensions($mx_units),
            {  0  file_units($mx_units),
            {  0  user_code,  "The name of the user code"
            {  0  input_file, "The input file name with path but no extension"
            {  0  output_file,"Same as above but for output"
            {  0  pegs_file,  "The pegs file name with path and extension"
            {  0  hen_house,  "The HEN_HOUSE directory"
            {  0  egs_home,   "The EGS_HOME directory"
            {  0  work_dir,   "The working directory within the user code dir."
            {  0  host_name,  "The name of the host"
            {  0  n_parallel, "if >0, number of parallel jobs"
            {  0  i_parallel, "if >0, parallel job number"
            {  0  first_parallel,"first parallel job (default is 1)"
            {  0  n_max_parallel,"if parallel run, max. number of running jobs"
            {  0  n_chunk,    "Histories per calculation chunk"
            {  0  n_files,
            {  0  i_input,    "unit no. for .egsinp if required"
            {  0  i_log,      "unit no. for .egslog if required"
            {  0  i_incoh,    "unit no. for Compton data"
            {  0  i_nist_data, "unit no. for NIST data"
            {  0  i_mscat,     "unit no. for multiple scattering data"
            {  0  i_photo_cs,  "unit no. for photon cross-section data"
            {  0  i_photo_relax,  "unit no. for photon relaxation data"
            {  0  xsec_out,       "switches on/off xsection file output"
            {  0  is_batch,       "True for batch mode"
            {  0  is_uniform_run, "True for uniform parallel run control"
            {  0  is_pegsless;    "true if you are running without pegs file"
            {  0  character input_file*256, output_file*256, pegs_file*256,
            {  0  file_extensions*$max_extension_length,
            {  0  hen_house*128, egs_home*128, work_dir*128, user_code*64,
            {  0  host_name*64;
            {  0  $INTEGER  n_parallel, i_parallel, first_parallel,n_max_parallel,
            {  0  n_chunk, file_units, n_files,i_input,i_log,i_incoh,
            {  0  i_nist_data,i_mscat,i_photo_cs,i_photo_relax, xsec_out;
            {  0  $LOGICAL  is_batch, is_pegsless, is_uniform_run;
            {  0  };
               0
               0  "The following macro sets the EGS_HOME directory               "
               0  "The defualt implementation is to use the environment variable "
               0  "EGS_HOME. But at the NRC EGS_HOME is set using the macro      "
               0  "$EGS_HOME defined in machine.macros.                          "
               0  REPLACE {$set_egs_home;} WITH {;
            {  0  $set_string(egs_home,' ');
            {  0  call getenv('EGS_HOME',egs_home);
            {  0  };
               0
               0
               0  " Initialization of various variables on a region-by-region basis "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$set-region-by-region-defaults;} WITH {;
            {  0  DO i=1,$MXREG [
            {  0  ecut(i) = $GLOBAL-ECUT; pcut(i) = $GLOBAL-PCUT; "cut-off energies"
            {  0  ibcmp(i) = $IBCMP-DEFAULT;    "Compton "
            {  0  iedgfl(i) = $IEDGFL-DEFAULT;  "Relaxations"
            {  0  iphter(i) = $IPHTER-DEFAULT;  "photo-electron angular distribution"
            {  0  smaxir(i) = $MAX-SMAX;        "maximum step size"
            {  0  i_do_rr(i) = 0;               "range rejection flag"
            {  0  e_max_rr(i) = 0;              "`save' energy for range rejection"
            {  0  med(i) = 1;                   "default medium"
            {  0  rhor(i) = 0;                  "default mass density"
            {  0  iraylr(i) = $IRAYLR-DEFAULT;  "Rayleigh flag"
            {  0  "Ali:photonuc, 1 line"
            {  0  iphotonucr(i) = $IPHOTONUCR-DEFAULT;  "photonuclear flag per region"]
            {  0  };
               0
               0  " Make sure ecut and pcut are at least ae/ap and set default densities "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$adjust_rhor_ecut_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0  MD=MED(JR);
            {  0  IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0  ECUT(JR)=max(ECUT(JR),AE(MD));
            {  0  PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0  "   USE STANDARD DENSITY FOR REGIONS NOT SPECIALLY SET UP"
            {  0  IF (RHOR(JR).EQ.0.0)[RHOR(JR)=RHO(MD);]
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$adjust_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0  MD=MED(JR);
            {  0  IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0  PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$start_new_particle;} WITH { medium = med(irl); };
               0
               0  REPLACE {$electron_region_change;} WITH {
            {  0  ir(np) = irnew; irl = irnew; medium = med(irl);
            {  0  };
               0  REPLACE {$photon_region_change;} WITH { $electron_region_change; }
               0
               0  REPLACE {$declare_max_medium;} WITH {;};
               0
               0  REPLACE {$need_bound_compton_data(#);} WITH {
            {  0  {P1} = .false.;
            {  0  DO j=1,$MXREG [
            {  0  medium = med(j);
            {  0  IF( medium > 0 & medium <= nmed) [
            {  0  IF( ibcmp(j) > 0 ) [ {P1} = .true.; EXIT; ]
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$need_relaxation_data(#);} WITH {
            {  0  {P1} = .false.;
            {  0  DO j=1,$MXREG [
            {  0  IF( iedgfl(j) > 0 & iedgfl(j) <= $MXELEMENT ) [ {P1} = .true.; EXIT; ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$need_rayleigh_data;} WITH {;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS:  DO I=1,$MXREG [
            {  0  IF(IRAYLR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT RAYLEIGH SCATTERING, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IRAYLM(J)=1; EXIT :LOOP-OVER-REGIONS:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$need_photonuc_data;} WITH {;
            {  0  IPHOTONUC=0;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS-PHOTONUC: DO I=1,$MXREG [
            {  0  IF(IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT PHOTONUCLEAR, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IPHOTONUCM(J)=1; IPHOTONUC=1; EXIT :LOOP-OVER-REGIONS-PHOTONUC:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  REPLACE {$set_ecutmn;} WITH {
            {  0  ecutmn = 1e30;
            {  0  DO i=1,$MXREG [
            {  0  IF( med(i) > 0 & med(i) <= nmed ) [
            {  0  ecutmn = Min(ecutmn,ecut(i));
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  " default numer of media. "
               0  REPLACE {$default_nmed} WITH {1}
               0
               0  REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH {;
            {  0  $egs_fatal('(a/a)',' Code cannot be run in pegsless mode.',
            {  0  ' Compile with required files and try again.');
            {  0  ;
            {  0  }
               0
               0  REPLACE {$INIT-PEGS4-VARIABLES;} WITH {;}
               0
               0  REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {;}
               0
               0  " The following macro is defined to fool the Intel Fortran compiler "
               0  " version 8.0, which miscompiles init_spin when certain optimizations"
               0  " are turned on and the code is run on an Athlon CPU. "
               0  REPLACE {$FOOL-INTEL-OPTIMIZER(#) #;} WITH {;
            {  0  IF( fool_intel_optimizer ) [ write({P1},*) {P2}; ]
            {  0  }
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros to read and write phase space files                          "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Blake Walters, 1999                                       "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Macros required to read from and write to phase space files. These macros  "
               0  "  replace the old calls to the subroutine rw_ph_sp.mortran and any           "
               0  "  manipulations of phase space files that were hard-coded. Currently, these  "
               0  "  macros are used by BEAM, DOSXYZ, BEAMDP, and readphsp. The beam            "
               0  "  configuration script looks for this file in the following directories, in  "
               0  "  this order                                                                 "
               0  "                                                                             "
               0  "  $HOME/egs4/BEAM_accelerator                                                "
               0  "  $HOME/egs4/beam                                                            "
               0  "  $OMEGA_HOME/beam                                                           "
               0  "                                                                             "
               0  "  All other configuration or compile scripts only use the version of this    "
               0  "  file in $OMEGA_HOME/beam. These macros can be used with any code provided  "
               0  "  that this file is concatenated before any codes that use the macros.       "
               0  "  Detailed description of what each macro does is provided at the top of     "
               0  "  the macro.                                                                 "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  ;
               0  REPLACE {;COMIN/RWPHSP/;} WITH {
            {  0  "RWPHSP must be included in the common block of main in any code that uses"
            {  0  "any of these phase space macros and also in the common block of"
            {  0  "any subroutine that uses any phase space macros.  Note that the macro"
            {  0  "$MAX_SC_PLANES(=the max. number of scoring planes) must have been defined"
            {  0  "somewhere in the code before the first use of COMIN/RWPHSP.  In the case of"
            {  0  "DOSXYZ, BEAMDP and readphsp, $MAX_SC_PLANES is a dummy value, set to 1,"
            {  0  "at the beginning of main.  Note that, since, IHSTRY_PHSP is a $LONG_INT"
            {  0  "variable, you must have the macro REPLACE {$LONG_INT} WITH {INTEGER*8} at"
            {  0  "the top of any code that uses these macros.  If your compiler has trouble"
            {  0  "with INTEGER*8, use INTEGER*4 in the $LONG_INT macro."
            {  0
            {  0  ;COMMON/RWPHSP/
            {  0  STRING_TEMP_ZLAST_OUT,
            {  0  "holds output phsp data for up to 1000 particles, with ZLAST"
            {  0  STRING_TEMP_OUT, "holds output phsp data for up to 1000 particles, no ZLAST"
            {  0  IHSTRY_PHSP, "history number (from primary non-phase space source) of"
            {  0  "particle being scored"
            {  0  iaea_dummy_long, "used to store INTEGER*8 values temporarily"
            {  0  NHSTRY_DOS, "passed to NHSTRY in beam when this actually comes from"
            {  0  "dosxyznrc source 20"
            {  0  ESHORT,    "single precision E read from/written to phsp"
            {  0  WEIGHTTMP, "modified version of WT to be written to phsp"
            {  0  WT_PHSP_SHORT, "single precision wt read from phsp"
            {  0  X_PHSP_SHORT, "single precision x read from phsp"
            {  0  Y_PHSP_SHORT, "single precision y read from phsp"
            {  0  Z_PHSP_SHORT, "single precision Z--for iaea format only"
            {  0  U_PHSP_SHORT, "single precision u read from phsp"
            {  0  V_PHSP_SHORT, "single precision v read from phsp"
            {  0  W_PHSP_SHORT, "single precision w--for iaea format only"
            {  0  ZLAST_PHSP_SHORT, "single precision zlast read from phsp"
            {  0  MUIDX_PHSP_SHORT, "MU_INDEX--iaea phsp files only"
            {  0  EKMAX_PHSP_SHORT, "max ke of particles in phsp file"
            {  0  EKMINE_PHSP_SHORT, "min ke of electrons in phsp file"
            {  0  NINC_PHSP_SHORT, "no. of particles from original primary source"
            {  0  dosxyz2beam_index, "stores MU index passed to beam from dosxyz"
            {  0  iaea_extra_floats, "array of extra floats in IAEA phsp file"
            {  0  NUM_PHSP_TOT, "tot no of particles in phsp file"
            {  0  PHOT_PHSP_TOT,"no. of photons in phsp file"
            {  0  iaea_result,  "<0 if an error finding an available array index for IAEA"
            {  0  "phsp file"
            {  0  iaea_n_stat,  ">=1 if a new primary history is scoring, 0 otherwise"
            {  0  iaea_q_typ,    "array to convert from charge to IAEA type"
            {  0  iaea_typ_q,   "array to convert from IAEA type to charge"
            {  0  iaea_q_index, "array index"
            {  0  I_PHSP,    "loop counter"
            {  0  IERR_PHSP, "=0 if open/read okay ~=0 if not okay"
            {  0  LATCHTMP,  "modified version of LATCH to be written to phsp"
            {  0  WRITE_PHSP_COUNTER, "counter up to 1000 used for group write"
            {  0  WRITE_PHSP_SOFAR, "how many particles written so far to file"
            {  0  PHSP_RESTART, "set to 1 if this is a restart"
            {  0  PHSP_RECL, "the record length"
            {  0  PHSP_RECL_OLD, "saves record length"
            {  0  iaea_extra_ints, "array in which LATCH will be stored for iaea format"
            {  0  iaea_extra_int_types,iaea_extra_float_types, "returns the types of"
            {  0  "extra int and float variables in an IAEA phsp file"
            {  0  iaea_i_zlast,"index of iaea_extra_floats in which Zlast is stored for IAEA"
            {  0  "phsp files read IN"
            {  0  iaea_i_latch,"index of iaea_extra_int in which LATCH is stored for IAEA"
            {  0  "phsp files read IN"
            {  0  iaea_i_muidx,"index of iaea_extra_floats in which MU_INDEX is stored for"
            {  0  "IAEA phsp files read IN"
            {  0  iaea_n_extra_ints, "no. of extra ints stored in IAEA phsp file read IN"
            {  0  iaea_n_extra_floats, "no. of extra floats stored in IAEA phsp file read IN"
            {  0  i_iaea_open_for_write, "set to 1 if the macro IAEA_OPEN_FOR_WRITE"
            {  0  "was used"
            {  0  iaea_i_zlast_out,"index of iaea_extra_floats in which Zlast is stored for"
            {  0  " IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  iaea_i_latch_out,"index of iaea_extra_int in which LATCH is stored for IAEA"
            {  0  "phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  iaea_i_muidx_out,"index of iaea_extra_floats in which MU_INDEX is stored"
            {  0  " for IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  dosxyz2beam_izscore, "set to 1 if Z scored for each particle (IAEA only)"
            {  0  MODE_RW;   "mode of phsp file (0 with ZLAST, 2 without), writing only"
            {  0
            {  0  CHARACTER*32000 STRING_TEMP_ZLAST_OUT($MAX_SC_PLANES);
            {  0  CHARACTER*28000 STRING_TEMP_OUT($MAX_SC_PLANES);
            {  0  $LONG_INT IHSTRY_PHSP($MAX_SC_PLANES),iaea_dummy_long,NHSTRY_DOS;
            {  0  REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  Z_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHORT,
            {  0  MUIDX_PHSP_SHORT,
            {  0  EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT,dosxyz2beam_index,
            {  0  iaea_extra_floats(10);
            {  0  INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT,
            {  0  iaea_result,iaea_n_stat,iaea_q_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP,
            {  0  IERR_PHSP,LATCHTMP,
            {  0  WRITE_PHSP_COUNTER($MAX_SC_PLANES),WRITE_PHSP_SOFAR($MAX_SC_PLANES),
            {  0  PHSP_RESTART,PHSP_RECL,PHSP_RECL_OLD,iaea_extra_ints(10),
            {  0  iaea_extra_int_types(10),iaea_extra_float_types(10),iaea_i_zlast,
            {  0  iaea_i_latch,iaea_i_muidx,iaea_n_extra_ints,iaea_n_extra_floats,
            {  0  i_iaea_open_for_write,iaea_i_zlast_out,iaea_i_latch_out,
            {  0  iaea_i_muidx_out,dosxyz2beam_izscore;
            {  0  CHARACTER*5 MODE_RW;
            {  0
            {  0  "variables below are not part of the common block but are used locally"
            {  0  "by the $WRITE_PHSP, $WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros"
            {  0
            {  0  INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP;
            {  0  REAL*4 REAL_TEMP_OUT(7);
            {  0  CHARACTER*32 REC_TEMP_OUT;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$INITIALIZE_PHSP_VARIABLES;} WITH{;
            {  0  "Must be placed after the variable declarations in any subroutine"
            {  0  "where $WRITE_PHSP and/or $WRITE_PHSP_RECORD is used.  Note, though, that"
            {  0  "it does not necessarily have to be put at the top of main, unless one or"
            {  0  "both of these macros are used in main."
            {  0  "It equivalences the character string REC_TEMP_OUT with the phase space data"
            {  0  "for 1 particle. REC_TEMP_OUT is then used to fill the character array"
            {  0  "STRING_TEMP_(ZLAST_)OUT, which holds the phase space data in blocks of 1000"
            {  0  "particles before writing."
            {  0
            {  0  EQUIVALENCE(REC_TEMP_OUT(1:4),LATCH_TEMP_OUT);
            {  0  EQUIVALENCE(REC_TEMP_OUT(5:8),REAL_TEMP_OUT(1));
            {  0  EQUIVALENCE(REC_TEMP_OUT(9:12),REAL_TEMP_OUT(2));
            {  0  EQUIVALENCE(REC_TEMP_OUT(13:16),REAL_TEMP_OUT(3));
            {  0  EQUIVALENCE(REC_TEMP_OUT(17:20),REAL_TEMP_OUT(4));
            {  0  EQUIVALENCE(REC_TEMP_OUT(21:24),REAL_TEMP_OUT(5));
            {  0  EQUIVALENCE(REC_TEMP_OUT(25:28),REAL_TEMP_OUT(6));
            {  0  EQUIVALENCE(REC_TEMP_OUT(29:32),REAL_TEMP_OUT(7));
            {  0  }
               0  ;
               0
               0  REPLACE {$INIT_PHSP_COUNTERS;} WITH {;
            {  0  "This macro initializes counters and flags that are used by the"
            {  0  "$WRITE_PHSP/$WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros.  It is only"
            {  0  "used once and should be placed after the variable declarations in main."
            {  0
            {  0  DO I_PHSP=1,$MAX_SC_PLANES[
            {  0  WRITE_PHSP_COUNTER(I_PHSP)=0;
            {  0  WRITE_PHSP_SOFAR(I_PHSP)=0;
            {  0  IHSTRY_PHSP(I_PHSP)=0;
            {  0  ]
            {  0  PHSP_RESTART=0;
            {  0  PHSP_RECL_OLD=0;
            {  0
            {  0  iaea_q_typ(1)=2;iaea_q_typ(2)=1;iaea_q_typ(3)=3;
            {  0  iaea_typ_q(1)=0;iaea_typ_q(2)=-1;iaea_typ_q(3)=1;
            {  0
            {  0  iaea_n_extra_ints=0;iaea_n_extra_floats=0;
            {  0
            {  0  iaea_i_zlast=-99;iaea_i_latch=-99;iaea_i_muidx=-99;
            {  0
            {  0  i_iaea_open_for_write=0;
            {  0
            {  0  iaea_i_zlast_out=-99;iaea_i_latch_out=-99;iaea_i_muidx_out=-99;
            {  0
            {  0  }
               0  ;
               0
               0
               0  REPLACE {$GET_E_NPASS_IQ(#,#,#,#);} WITH {;
            {  0  "Macro gets NPASS, IQ from the LATCH value read in and then restores LATCH"
            {  0  "by clearing the bits that store this information.  It also puts the"
            {  0  "single precision energy, ESHORT, read in into double precision form."
            {  0  "This macro is called by $READ_PHSP."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=NPASS"
            {  0  "{P2}=IQ"
            {  0  "{P3}=LATCH"
            {  0  "{P4}=E"
            {  0
            {  0  {P4}=ESHORT;
            {  0
            {  0  IF($BTEST({P3},31)) [ {P1} = 1; {P3} = $IBCLR({P3},31); ]
            {  0  ELSE [ {P1} = 0; ]
            {  0
            {  0  IF($BTEST({P3},30)) [
            {  0  {P2} = -1;
            {  0  {P3} = $IBCLR({P3},30); {P3} = $IBCLR({P3},29);
            {  0  ]
            {  0  ELSE [
            {  0  IF($BTEST({P3},29)) [
            {  0  {P2} = 1; {P3} = $IBCLR({P3},29);
            {  0  ]
            {  0  ELSE [ {P2} = 0; ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_W_WT(#,#,#,#,#,#);} WITH {;
            {  0  "This macro calculates W, based on U and V and the sign of WT as read in from"
            {  0  "the phase space file.  Once the sign of WT is determined, WT is set equal"
            {  0  "to its absolute value, since there cannot be a negative particle weight."
            {  0  "This macro is called by $READ_PHSP."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=W"
            {  0  "{P2}=WT"
            {  0  "{P3}=X"
            {  0  "{P4}=Y"
            {  0  "{P5}=U"
            {  0  "{P6}=V"
            {  0
            {  0  {P1} = min( 1., {P5}**2 + {P6}**2);
            {  0  {P1} = sqrt(1. - {P1});
            {  0  {P1} = SIGN({P1},{P2});  "This transfers sign of WT to W"
            {  0
            {  0  {P2}=ABS({P2}); "WT is always positive"
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_PHSP_RECORD(#,#,#,#);} WITH {;
            {  0  "macro used by READ_PHSP_RECORD to put single precision x, y, u, v"
            {  0  "read from phase space file into (potentially) double precision"
            {  0  "x, y, u, v passed to READ_PHSP_RECORD macro"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=X"
            {  0  "{P2}=Y"
            {  0  "{P3}=U"
            {  0  "{P4}=V"
            {  0
            {  0  {P1}=X_PHSP_SHORT;
            {  0  {P2}=Y_PHSP_SHORT;
            {  0  {P3}=U_PHSP_SHORT;
            {  0  {P4}=V_PHSP_SHORT;
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_RECORD(#,#,#:#,#,#,#,#,#);} WITH {;
            {  0  "Note that a colon is required  ^  between the third and fourth"
            {  0  "input parameters."
            {  0  "This macro actually reads the phase space data for a single particle."
            {  0  "It is called by $READ_PHSP, but can also be used as a stand-alone macro."
            {  0  "If the energy, E, is < 0.0, then this is the first particle scored"
            {  0  "from a new primary (ie non-phsp source) history, and NHSTRY is incremented"
            {  0  "and E is set to ABS(E)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=record number"
            {  0  "{P4}=NHSTRY"
            {  0  "{P5}=ZLAST"
            {  0  "{P6}=LATCH"
            {  0  "{P7}=E"
            {  0  "{P8}=WT"
            {  0  "{P9}=X,Y,U,V"
            {  0
            {  0  IF({P1}~=0)["must read in ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT,ZLAST_PHSP_SHORT;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT;
            {  0  ]
            {  0
            {  0  IF({P3}=76695869)[
            {  0  write(*,*)' x,y,u,v,wt,eshort,latch',
            {  0  X_PHSP_SHORT,Y_PHSP_SHORT,U_PHSP_SHORT,V_PHSP_SHORT,
            {  0  WT_PHSP_SHORT,ESHORT,{P6};
            {  0  ]
            {  0
            {  0  "first particle from new primary history"
            {  0  IF(ESHORT<0.0)[
            {  0  {P4}={P4}+1;
            {  0  ESHORT=ABS(ESHORT);
            {  0  ]
            {  0
            {  0  {P7}=ESHORT;
            {  0  {P8}=WT_PHSP_SHORT;
            {  0  $PARSE_PHSP_RECORD({P9});
            {  0
            {  0  IF({P1}~=0) {P5}=ZLAST_PHSP_SHORT;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_RECORD_ENEGATIVE(#,#,#:#,#,#,#,#);} WITH {;
            {  0  "Note that a colon is required            ^  between the third and fourth"
            {  0  "input parameters."
            {  0  "This macro is the similar to $READ_PHSP_RECORD above, but it preserves"
            {  0  "the -E marker in the phase space file and does not advance NHSTRY"
            {  0  "It is only used in readphsp before byte swapping"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=record number"
            {  0  "{P4}=ZLAST"
            {  0  "{P5}=LATCH"
            {  0  "{P6}=E"
            {  0  "{P7}=WT"
            {  0  "{P8}=X,Y,U,V"
            {  0
            {  0  IF({P1}~=0)["must read in ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7},{P4};
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7};
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP(#:#,#,#,#,#,#,#,#);} WITH {;
            {  0  "Note colon          ^  required between the first and second"
            {  0  "input parameters (third and fourth input variables)"
            {  0
            {  0  "This macro reads the phase space data for a single particle.  It finds"
            {  0  "the value of IQ and NPASS from the LATCH variable read in and then"
            {  0  "restores the LATCH variable.  It calculates W from U, V and the sign"
            {  0  "of WT and then restores WT to its absolute value.  And it puts the"
            {  0  "single-precision energy, ESHORT, read in into double-precision format."
            {  0  "If ESHORT is < 0, it sets E=ABS(ESHORT) and increments NHSTRY, taking"
            {  0  "this as the first particle scored from a new primary history."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST,unit number for phase space file,record number reading from"
            {  0  "{P2}=NHSTRY"
            {  0  "{P3}=NPASS"
            {  0  "{P4}=IQ"
            {  0  "{P5}=W"
            {  0  "{P6}=ZLAST"
            {  0  "{P7}=LATCH"
            {  0  "{P8}=E"
            {  0  "{P9}=WT,X,Y,U,V"
            {  0
            {  0  $READ_PHSP_RECORD({P1}:{P2},{P6},{P7},{P8},{P9});
            {  0
            {  0  IF(IERR_PHSP=0)[
            {  0  $GET_E_NPASS_IQ({P3},{P4},{P7},{P8});
            {  0  $GET_W_WT({P5},{P9});
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_LATCHTMP_ESHORT_WEIGHTTMP(#,#,#,#,#,#);} WITH {;
            {  0  "This macro converts LATCH into LATCHTMP, which stores NPASS and IQ"
            {  0  "for a particle and is the form of LATCH written to the phase space file."
            {  0  "It puts double precision energy, E, into single precision format, ESHORT,"
            {  0  "for writing to the phase space file.  This macro is called from $READ_PHSP"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=NPASS"
            {  0  "{P2}=IQ"
            {  0  "{P3}=W"
            {  0  "{P4}=LATCH"
            {  0  "{P5}=E"
            {  0  "{P6}=WT"
            {  0
            {  0  LATCHTMP={P4};
            {  0
            {  0  IF({P1} = 0) [ LATCHTMP = $IBCLR(LATCHTMP,31); ]
            {  0  ELSE [ LATCHTMP = $IBSET(LATCHTMP,31); ]
            {  0
            {  0  IF({P2} = -1) [ LATCHTMP = $IBSET(LATCHTMP,30);]
            {  0  ELSEIF({P2} = 0) [
            {  0  LATCHTMP = $IBCLR(LATCHTMP,30);
            {  0  LATCHTMP = $IBCLR(LATCHTMP,29);
            {  0  ]
            {  0  ELSE [
            {  0  LATCHTMP = $IBCLR(LATCHTMP,30);
            {  0  LATCHTMP = $IBSET(LATCHTMP,29);
            {  0  ]
            {  0
            {  0  ESHORT={P5};
            {  0
            {  0  WEIGHTTMP=SIGN({P6},{P3});"transfer sign of W to WEIGHTTMP"
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$SET_NEGATIVE_E(#,#,#,#);} WITH {;
            {  0  "Macro to set E to -E if this is the first particle scored from a new"
            {  0  "primary (non-phsp source) history.  This macro is called from"
            {  0  "$WRITE_PHSP_RECORD."
            {  0
            {  0  "Input parameters"
            {  0  "{P1}=phase space scoring plane no."
            {  0  "{P2}=IHSTRY"
            {  0  "{P3}=E"
            {  0  "{P4}=WT,X,Y,U,V"
            {  0
            {  0  IF({P2}~=IHSTRY_PHSP({P1}))[
            {  0  {P3}=-{P3};
            {  0  IHSTRY_PHSP({P1})={P2};
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_TEMP_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
            {  0  "Macro to store the output phase space data for one particle in the"
            {  0  "variables LATCH_TEMP_OUT and REAL_TEMP_OUT.  These variables are"
            {  0  "equivalenced to the string variable REC_TEMP_OUT, which stores the"
            {  0  "phase space for one particle in string form and which, in turn, is"
            {  0  "used to transfer the data to the string variable STRING_TEMP(_ZLAST)_OUT"
            {  0  "which stores output phase space data for up to 1000 particles at a time."
            {  0  "This macro is called from $WRITE_PHSP_RECORD."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=ZLAST"
            {  0  "{P3}=LATCH"
            {  0  "{P4}=E"
            {  0  "{P5}=WT"
            {  0  "{P6}=X"
            {  0  "{P7}=Y"
            {  0  "{P8}=U"
            {  0  "{P9}=V"
            {  0
            {  0  LATCH_TEMP_OUT={P3};
            {  0  REAL_TEMP_OUT(1)={P4};
            {  0  REAL_TEMP_OUT(2)={P6};
            {  0  REAL_TEMP_OUT(3)={P7};
            {  0  REAL_TEMP_OUT(4)={P8};
            {  0  REAL_TEMP_OUT(5)={P9};
            {  0  REAL_TEMP_OUT(6)={P5};
            {  0  IF({P1}~=0) REAL_TEMP_OUT(7)={P2};
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$WRITE_PHSP_RECORD(#,#,#,#,#:#,#,#,#);} WITH {;
            {  0  "Note that a colon is required       ^  between the fifth and sixth"
            {  0  "input parameters"
            {  0
            {  0  "This macro is used to output phase space data 1000 particles at a time."
            {  0  "For every particle, the phase space data to be output is stored in"
            {  0  "the string variable STRING_TEMP(_ZLAST)_OUT.  If it is the 1000th particle"
            {  0  "STRING_TEMP(_ZLAST)_OUT is written to the phase space file.  The phase"
            {  0  "space header info is considered to occupy the space of 1 particle in the"
            {  0  "first block of 1000 particles, however, it will be overwritten with nulls."
            {  0  "This is fine since the header info should be recalculated and rewritten at"
            {  0  "the top of the file after all data has been written out anyway."
            {  0  "Also note that restarting with this writing scheme requires that any"
            {  0  "blocks of N (N<1000) particles at the end of a phase space file from"
            {  0  "the previous run must immediately be read into the first N spaces of"
            {  0  "STRING_TEMP(_ZLAST)_OUT before continuing on with outputting the data"
            {  0  "for new particles.  Finally, after all phase space data has been output,"
            {  0  "there will probably be info for M (M<1000) particles still in"
            {  0  "STRING_TEMP(_ZLAST)_OUT that has not been written to the phase space file"
            {  0  "because the write counter did not reach 1000.  These are output using"
            {  0  "the $PHSP_BUFFER_FLUSH macro described below."
            {  0
            {  0  "Group writing reduces network traffic and saves a lot of time when the"
            {  0  "one of the main CPU-intensive activities is the writing of phase space data."
            {  0  "Group reading has also been considered, but preliminary studies have shown"
            {  0  "that it does not reduce CPU time significantly."
            {  0
            {  0  "Using the macro $SET_NEGATIVE_E, $WRITE_PHSP_RECORD also takes care of setting"
            {  0  "E to -E if this is the first particle scored from a new primary"
            {  0  "(non-phsp source) history."
            {  0
            {  0  "This macro is called by $WRITE_PHSP, but can also be used as a stand-"
            {  0  "alone macro.  However, use of $WRITE_PHSP_RECORD, will always require"
            {  0  "use of $PHSP_BUFFER_FLUSH (see below)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number for phase space file"
            {  0  "{P3}=name of phase space file"
            {  0  "{P4}=record number writing to"
            {  0  "{P5}=scoring plane number"
            {  0  "{P6}=IHSTRY"
            {  0  "{P7}=ZLAST"
            {  0  "{P8}=LATCH"
            {  0  "{P9}=E,WT,X,Y,U,V"
            {  0
            {  0  IF({P4}>2 & WRITE_PHSP_COUNTER({P5})=0 & WRITE_PHSP_SOFAR({P5})=0)[
            {  0  "we have a restart or its the start of a new batch"
            {  0  IF(({P4}-1)-1000*(({P4}-1)/1000)~=0)[
            {  0  "make what was the buffer flush part of the first record of the restart"
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
            {  0  READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*(I_PHSP-1)+1:32*I_PHSP);
            {  0  ]
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
            {  0  READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
            {  0  STRING_TEMP_OUT({P5})(28*(I_PHSP-1)+1:28*I_PHSP);
            {  0  ]
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ]
            {  0  WRITE_PHSP_SOFAR({P5})=1000*INT(dble({P4}-1)/1000);
            {  0  IF(WRITE_PHSP_SOFAR({P5})>0)[
            {  0  PHSP_RESTART=1;
            {  0  WRITE_PHSP_COUNTER({P5})=({P4}-1)-1000*(({P4}-1)/1000);
            {  0  ]
            {  0  ELSE[
            {  0  WRITE_PHSP_COUNTER({P5})=({P4}-2)-1000*(({P4}-2)/1000);
            {  0  ]
            {  0  ]
            {  0
            {  0  $SET_NEGATIVE_E({P5},{P6},{P9});
            {  0
            {  0  $PARSE_TEMP_FOR_WRITE({P1},{P7},{P8},{P9});
            {  0
            {  0  IF({P4}<=1000 & PHSP_RESTART=0)["do not use first 7/8 elements"
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+33:
            {  0  32*WRITE_PHSP_COUNTER({P5})+64)=REC_TEMP_OUT(1:32);
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+29:
            {  0  28*WRITE_PHSP_COUNTER({P5})+56)=REC_TEMP_OUT(1:28);
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  IF({P1}~=0)[
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+1:
            {  0  32*WRITE_PHSP_COUNTER({P5})+32)=REC_TEMP_OUT(1:32);
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+1:
            {  0  28*WRITE_PHSP_COUNTER({P5})+28)=REC_TEMP_OUT(1:28);
            {  0  ]
            {  0  ]
            {  0
            {  0  WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
            {  0
            {  0  IF({P4}=1000|WRITE_PHSP_COUNTER({P5})=1000)[
            {  0  IF({P1}~=0 & PHSP_RECL=$RECL-FACTOR*8)[
            {  0  CLOSE({P2});
            {  0  PHSP_RECL_OLD=PHSP_RECL;
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ELSEIF({P1}=0 & PHSP_RECL=$RECL-FACTOR*7)[
            {  0  PHSP_RECL_OLD=PHSP_RECL;
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  IF({P1}~=0)[
            {  0  WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_ZLAST_OUT({P5});
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_OUT({P5});
            {  0  ]
            {  0  IF(PHSP_RECL_OLD~=0)[
            {  0  "have to do this in case the output file=input file"
            {  0  PHSP_RECL=PHSP_RECL_OLD;
            {  0  CLOSE({P2});
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  WRITE_PHSP_COUNTER({P5})=0;
            {  0  WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+1000;
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PHSP_BUFFER_FLUSH(#,#,#,#,#);} WITH {;
            {  0  "This macro outputs the data for the M (M<1000) remaining particles still"
            {  0  "stored in STRING_TEMP(_ZLAST)_OUT after all calls to $WRITE_PHSP_RECORD."
            {  0  "The macro does not flush all of the data at once, but in blocks that"
            {  0  "divide exactly into the number of particles already in the phase space"
            {  0  "file.  For each block that is flushed, the phase space file is re-opened"
            {  0  "with a record length (RECL) equal to the size of the block.  Since RECL"
            {  0  "divides exactly into the number of particles already in the file, the"
            {  0  "block to be flushed can be appended onto the data that already exists in"
            {  0  "the file with no overwrites and/or blank space."
            {  0  "The other alternative was to flush STRING_TEMP(_ZLAST)_OUT one particle at"
            {  0  "a time, which is more time-consuming."
            {  0  "$PHSP_BUFFER_FLUSH must exist in a code that uses $WRITE_PHSP or"
            {  0  "$WRITE_PHSP_RECORD.  It should be placed on its own outside the loop in which"
            {  0  "phase space data is output.  In the case of BEAM, it is placed at the end"
            {  0  "of each batch, so that, if the simulation crashes, phase space information"
            {  0  "from the last batch is not lost."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number for phase space file"
            {  0  "{P3}=file name"
            {  0  "{P4}=particle number +1"
            {  0  "{P5}=scoring plane number"
            {  0  TEMP_PHSP_COUNTER=0;
            {  0  NUM_PHSP_TOFLUSH=WRITE_PHSP_COUNTER({P5});
            {  0  IF(NUM_PHSP_TOFLUSH>0)[
            {  0  IF(WRITE_PHSP_SOFAR({P5})=0)[
            {  0  WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
            {  0  NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH+1; "account for header"
            {  0  ]
            {  0  LOOP[
            {  0  TEMP_PHSP_COUNTER=NUM_PHSP_TOFLUSH+1;
            {  0  LOOP[
            {  0  TEMP_PHSP_COUNTER=TEMP_PHSP_COUNTER-1;
            {  0  REM_PHSP=MOD(WRITE_PHSP_SOFAR({P5}),TEMP_PHSP_COUNTER);
            {  0  ]UNTIL(REM_PHSP=0);
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["write ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8*TEMP_PHSP_COUNTER;
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
            {  0  ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
            {  0  STRING_TEMP_ZLAST_OUT({P5})
            {  0  (32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
            {  0  32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7*TEMP_PHSP_COUNTER;
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
            {  0  ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
            {  0  STRING_TEMP_OUT({P5})
            {  0  (28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
            {  0  28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
            {  0  ]
            {  0  WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+TEMP_PHSP_COUNTER;
            {  0  NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH-TEMP_PHSP_COUNTER;
            {  0  ] UNTIL(NUM_PHSP_TOFLUSH=0);
            {  0  WRITE_PHSP_COUNTER({P5})=0;
            {  0  WRITE_PHSP_SOFAR({P5})=0;
            {  0  ]
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$WRITE_PHSP(#:#,#,#,#,#,#,#:#);} WITH {;
            {  0  "Note that colons     ^             ^  are required between the first and"
            {  0  "second input parameters (5th and 6th input variables) and the"
            {  0  "8th and 9th input parameters (13th and 14th input variables)"
            {  0
            {  0  "This outputs phase space data in blocks of 1000 particles at a time."
            {  0  "In preparation for output, LATCH is modified to hold NPASS and IQ,"
            {  0  "energy (E) is placed into a single precision variable, ESHORT, and"
            {  0  "weight (WT) is given the sign of W.  If this is the first particle"
            {  0  "scored from a new primary (non-phase space source) history, then"
            {  0  "ESHORT is set to -ESHORT and IHSTRY_PHSP is set to IHSTRY."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST,unit number for phase space file,name of phase space file,"
            {  0  "     record number writing to, scoring plane number"
            {  0  "{P2}=IHSTRY"
            {  0  "{P3}=NPASS"
            {  0  "{P4}=IQ"
            {  0  "{P5}=W"
            {  0  "{P6}=ZLAST"
            {  0  "{P7}=LATCH"
            {  0  "{P8}=E,WT"
            {  0  "{P9}=X,Y,U,V"
            {  0
            {  0  $GET_LATCHTMP_ESHORT_WEIGHTTMP({P3},{P4},{P5},{P7},{P8});
            {  0
            {  0  $WRITE_PHSP_RECORD({P1}:{P2},{P6},LATCHTMP,ESHORT,WEIGHTTMP,{P9});
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_HEADER(#,#,#,#,#,#,#);} WITH {;
            {  0  "This macro reads the info from the header of a phase space file."
            {  0  "It is called from $OPEN_PHSP_FILE_FOR_WRITE, but can also be used"
            {  0  "as a stand-alone macro."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=unit number"
            {  0  "{P2}=MODE0 or MODE2"
            {  0  "{P3}=total number of particles"
            {  0  "{P4}=no. of photons"
            {  0  "{P5}=max k.e. of particles"
            {  0  "{P6}=min. k.e. of electrons"
            {  0  "{P7}=no. of particles incident from original source"
            {  0
            {  0  READ({P1},REC=1,IOSTAT=IERR_PHSP){P2},NUM_PHSP_TOT,PHOT_PHSP_TOT,
            {  0  EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
            {  0  {P3}=NUM_PHSP_TOT;
            {  0  {P4}=PHOT_PHSP_TOT;
            {  0  {P5}=EKMAX_PHSP_SHORT;
            {  0  {P6}=EKMINE_PHSP_SHORT;
            {  0  {P7}=NINC_PHSP_SHORT;
            {  0
            {  0  IF(IERR_PHSP~=0)[
            {  0  OUTPUT;(//' ***ERROR READING HEADER OF PHASE SPACE FILE*** '//);
            {  0  STOP;
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$OPEN_PHSP_FOR_READ(#,#,#,#,#);} WITH {;
            {  0  "Macro to open a phase space file in preparation for reading it."
            {  0  "The macro opens the file in one of 3 modes, as a file that is known"
            {  0  "to have ZLAST (IZLAST>0), as a file that is known not to have ZLAST"
            {  0  "(IZLAST=0), or with no prior knowledge of whether the file has"
            {  0  "ZLAST or not (IZLAST<0)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE0 or MODE2"
            {  0  "{P5}=total number of particles, no. of photons, max k.e. of particles,"
            {  0  "      min. k.e. of electrons, no. of particles incident from original source"
            {  0
            {  0  IF({P1}>0)["with ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  "error above on file opening when assumed it was MODE2"
            {  0  OUTPUT;(/' ***error opening file as MODE2 ****'
            {  0  /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE2 FILE) ***'/
            {  0  /' *** WE NOW TRY TO OPEN IT AS A MODE3 FILE ***'//);
            {  0  OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
            {  0  FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
            {  0  "if on error, cannot find file/directory, then stop"
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  STOP;
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE3')[
            {  0  OUTPUT;(//' That file does not start with MODE3,',
            {  0  ' as all old compressed files (with ZLAST) must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ELSE[
            {  0  OUTPUT;(//' This is a MODE3 file! '/
            {  0  ' Please convert it into a MODE2 file using [readphsp] ',
            {  0  ' and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSEIF({P1}=0)["without ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  "$RECL-FACTOR = 4 for SUN SPARC and =1 for SILICON GRAPHICS "
            {  0  "this factor is machine-dependent and stored in machine.mortran"
            {  0  "check file is MODE0 -ie standard compressed"
            {  0  IF(IERR_PHSP~=0)[
            {  0  "come here if error opening file assumed MODE0"
            {  0  OUTPUT;(/' ***ERROR opening file as MODE0****'
            {  0  /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE0 FILE) ***'/
            {  0  /' *** WE NOW TRY TO OPEN IT AS A MODE1 FILE ***'//);
            {  0  OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
            {  0  FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
            {  0  "if on error, cannot find file/directory, then stop"
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  STOP;
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE1')[
            {  0  OUTPUT;(//' That file does not start with MODE1,',
            {  0  ' as all old compressed files must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ELSE[
            {  0  OUTPUT;(//' This is a MODE1 file! '/
            {  0  ' Please convert it into a MODE0 file using [readphsp] ',
            {  0  'and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE0')[
            {  0  OUTPUT;
            {  0  (/' Does not start with MODE0 as files without ZLAST must'/
            {  0  '  Try again!'//);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSEIF({P1}<0)["open with no assumptions about whether ZLAST is there or not"
            {  0  OUTPUT;(/' First, try to open it as a MODE0 file');
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  OUTPUT;(/' Now try to open it as a MODE2 file');
            {  0  {P1}=1;
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4}~='MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  CLOSE({P2});
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  {P1}=0;
            {  0  IF({P4}~='MODE0')[
            {  0  OUTPUT;(/' The file does not start with MODE0 as it supposed to');
            {  0  CLOSE({P2});
            {  0  OUTPUT;(/' Now try to open it as a MODE2 file');
            {  0  {P1}=1;
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE OPENED. ***');
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4}~='MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  CLOSE({P2});
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_PHSP_HEADER_FOR_WRITE(#,#,#,#,#);} WITH {;
            {  0  "Puts max ke of particles, min ke of electrons, and no. of particles"
            {  0  "incident from original source--all of which may be double precision"
            {  0  "into real*4 variables"
            {  0  "{P1}=tot. no. of particles"
            {  0  "{P2}=no. of photons"
            {  0  "{P3}=max ke of particles"
            {  0  "{P4}=min ke of electrons"
            {  0  "{P5}=no. of particles incident from primary source"
            {  0  IF({P1}>2147483647)[
            {  0  write(*,*)' Warning while writing phase space file:';
            {  0  write(*,*)' No. of particles > 2^31-1.';
            {  0  write(*,*)' Total no. of particles (and photons) written';
            {  0  write(*,*)' to header may be nonsense.';
            {  0  ]
            {  0  NUM_PHSP_TOT={P1};
            {  0  PHOT_PHSP_TOT={P2};
            {  0  EKMAX_PHSP_SHORT={P3};
            {  0  EKMINE_PHSP_SHORT={P4};
            {  0  NINC_PHSP_SHORT={P5};
            {  0  }
               0
               0  REPLACE {$WRITE_PHSP_HEADER(#,#,#,#,#);} WITH {;
            {  0  "Macro to write the header information into a phase space file."
            {  0  "Files must be closed and re-opened with record length (RECL) for"
            {  0  "a single particle in order to prevent over-writing any particle data."
            {  0  "Once the header info is written, the file is closed again and re-opened"
            {  0  "with the RECL for 1000 particles."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE0 or MODE2"
            {  0  "{P5}=total number of particles, no. of photons, max k.e. of particles,"
            {  0  "      min. k.e. of electrons, no. of particles incident from original source"
            {  0
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  $PARSE_PHSP_HEADER_FOR_WRITE({P5});
            {  0  WRITE({P2},REC=1){P4},NUM_PHSP_TOT,PHOT_PHSP_TOT,EKMAX_PHSP_SHORT,
            {  0  EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  }
               0  ;
               0
               0
               0  REPLACE {$OPEN_PHSP_FOR_WRITE(#,#,#,#);} WITH {;
            {  0  "This macro opens a phase space file for writing.  The file is opened with"
            {  0  "a record length that will hold phase space data for 1000 particles in 1"
            {  0  "record.  This is to to enable writing phase space data for 1000 particles"
            {  0  "at a time (see the $WRITE_PHSP_RECORD macro above).  The macro also uses"
            {  0  "$WRITE_PHSP_HEADER to output a dummy header to the file."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE_RW"
            {  0  IF({P1}~=0)["with ZLAST"
            {  0  {P4}='MODE2';
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  {P4}='MODE0';
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  $WRITE_PHSP_HEADER({P1},{P2},{P3},{P4},0,0,0,0,0);
            {  0  }
               0  ;
               0
               0  REPLACE {$CLOSE_PHSP(#);} WITH {;
            {  0  "Macro to close a phase space file."
            {  0
            {  0  "Input parameter:"
            {  0  "{P1}=the unit number of the phase space file"
            {  0
            {  0  CLOSE(UNIT={P1});
            {  0  }
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;
            {  0
            {  0  OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
            {  0  ' space handling macros.'//);
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;
            {  0
            {  0  OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
            {  0  ' space handling macros.'//);
            {  0  }
               0  ;
               0  REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;}
               0
               0  REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;}
               0
               0  REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;}
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$BEAM_OPEN_PHSP_FOR_WRITE;} WITH {;
            {  0  IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
            {  0  ELSE                  [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
            {  0  "AUNIT is a character variable"
            {  0  "construct phase space file name."
            {  0  "part of this--the part that determines the directory and"
            {  0  "file prefix--is done in beam"
            {  0  IF(IO_OPT=4)[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
            {  0  Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            {  0  IZLAST,0,Z_SCORE_SHORT,I_MU_PHSP,0);
            {  0  ]
            {  0  ELSE[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0  $OPEN_PHSP_FOR_WRITE(IZLAST,IOUTFLU(I),$cstring(phsp_fn),MODE_RW);
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_OPEN_PHSP_FOR_READ;} WITH {;
            {  0  OUTPUT;
            {  0  (/' Restarting after previous run, will read old data & phase-space',
            {  0  ' files');
            {  0  DO I=1,NSC_PLANES [
            {  0  OUTPUT IOUTFLU(I);(//' Checking ph-sp file on logical unit ',I4);
            {  0  :OPEN_MODE0:;
            {  0  IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
            {  0  ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
            {  0  IF(IO_OPT=4)[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
            {  0  Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            {  0  IZLAST,1,Z_SCORE_SHORT,I_MU_PHSP,0);
            {  0  ]
            {  0  ELSE[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0
            {  0  $OPEN_PHSP_FOR_READ(IZLAST,IOUTFLU(I),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
            {  0
            {  0  NPPHSP(I)=NPPHSPSP;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_WRITE_PHSP;} WITH {;
            {  0  IF(IOUTFLU(ISCORE)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(ISCORE)-43;]
            {  0  ELSE                       [WRITE(AUNIT,'(I1)') IOUTFLU(ISCORE)-43;]
            {  0
            {  0  "output directory and file prefix are defined in beam.mortran"
            {  0
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_WRITE_PHSP_RECORD(IOUTFLU(ISCORE),NPASS(NP,ISCORE),
            {  0  ISCORE,NHSTRY,LATCH(NP),IQ(NP),E(NP),WT(NP),
            {  0  X(NP),Y(NP),Z(NP),U(NP),V(NP),W(NP),ZLAST(NP),
            {  0  BEAM_MU_INDEX);
            {  0  ]
            {  0
            {  0  ELSE[
            {  0
            {  0  IF( i_parallel > 0 ) ["add an _w"
            {  0  phsp_fn=$cstring(phsp_fn)// '_w';
            {  0  call egs_itostring(phsp_fn,i_parallel,.false.);
            {  0  ]
            {  0  phsp_fn=$cstring(phsp_fn)// '.egsphsp'//AUNIT;
            {  0  $WRITE_PHSP(IZLAST,IOUTFLU(ISCORE),$cstring(phsp_fn),NPPHSP(ISCORE)+1,
            {  0  ISCORE:NHSTRY,NPASS(NP,ISCORE),IQ(NP),W(NP),ZLAST(NP),
            {  0  LATCH(NP),E(NP),WT(NP):X(NP),Y(NP),U(NP),V(NP));
            {  0  ]
            {  0  IF(IZLAST = 2)[
            {  0  WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
            {  0  JHSTRY=JHSTRY+1;
            {  0  WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) NP,IQ(NP),0,
            {  0  XLAST(NP),YLAST(NP),ZLAST(NP),0;
            {  0  :GRAPHICS_FORMAT2:FORMAT(3I4,4G15.8,I12);
            {  0  ]
            {  0  "Check only needed when actually writting to a phsp file"
            {  0  IF(NPPHSP(ISCORE)=phsp_upper_limit)[
            {  0  $egs_fatal('(//a,i19,4(a/))',
            {  0  ' *** WHILE WRITING PHASE SPACE FILE:',
            {  0  NPPHSP(ISCORE), ' particles in file.',
            {  0  ' Due to the fact that the counter for the number',
            {  0  ' of particles in the file cannot be larger than this,',
            {  0  ' no more particles will be written to the phsp file.'
            {  0  );
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_PHSP_BUFFER_FLUSH;} WITH {;
            {  0  IF(IO_OPT=4)["update no. of primary histories in header"
            {  0  DO I1=1,NSC_PLANES[
            {  0  NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
            {  0  $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(IOUTFLU(I1),NINCPHSP);
            {  0  $IAEA_UPDATE_PHSP_HEADER(IOUTFLU(I1));
            {  0  ]
            {  0  ]
            {  0  ELSE["standard BEAMnrc format"
            {  0  IF(MODE_RW='MODE0' | MODE_RW='MODE2')[
            {  0  NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
            {  0  DO I1=1,NSC_PLANES[
            {  0  NPPHSPSP=NPPHSP(I1);
            {  0  IF(IOUTFLU(I1)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I1)-43;]
            {  0  ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I1)-43;]
            {  0
            {  0  "output directory and file prefix defined in beam.mortran"
            {  0
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0  $PHSP_BUFFER_FLUSH(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),NPPHSPSP,I1);
            {  0  IF(NPPHSPSP=NPHOTPHSP(I1))[
            {  0  "no electrons"
            {  0  $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
            {  0  EKMAXPHSP(I1), 0.0, NINCPHSP);
            {  0  ]
            {  0  ELSE[
            {  0  $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
            {  0  EKMAXPHSP(I1), EKMINPHSPE(I1), NINCPHSP);
            {  0  ]
            {  0  ]
            {  0  "we store the total particle number in the 1st record of the ph-sp file"
            {  0  ]
            {  0  ]"end of standard BEAMnrc format"
            {  0  };
               0
               0  REPLACE {$BEAM_READ_PHSP_FOR_RESTART;} WITH {;
            {  0  DO I=1,NSC_PLANES[
            {  0  OUTPUT I,NPPHSP(I);
            {  0  (//' PH-SP FILE',I4,': '/
            {  0  '               TOTAL NO. OF PARTICLES =',I12);
            {  0  IF(IO_OPT=0 | IO_OPT=3)["check to see that the user has not"
            {  0  "added phase space files before restarting"
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_READ_PHSP_HEADER(IOUTFLU(I),NPPHSP(I),NPHOTPHSP(I),
            {  0  EKMAXPHSP(I),NINCPHSP,Z_SCORE,IZLAST1,I_MU_PHSP,IZSCORE);
            {  0  EKMINPHSPE(I)=99999.; "info unavailable"
            {  0  IF(IZLAST=0 & IZLAST1=1)[
            {  0  OUTPUT;
            {  0  (//' Error: Phase space file was scored with ZLAST in previous run '/
            {  0  ' but you have restarted this run with IZLAST=0.  Restart with'/
            {  0  ' IZLAST=1.'//);
            {  0  STOP;
            {  0  ]
            {  0  ELSEIF(IZLAST=1 & IZLAST1=0)[
            {  0  OUTPUT;
            {  0  (//' Error: Phase space file was scored  without ZLAST in previous run '/
            {  0  ' but you have restarted this run with IZLAST=1.  Restart with'/
            {  0  ' IZLAST=0.'//);
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER(IOUTFLU(I),MODE_RW,NPPHSPSP,
            {  0  NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
            {  0  NPPHSP(I)=NPPHSPSP;
            {  0  ]
            {  0  IF(NINCPHSP>
            {  0  NINCSRC*(NCASEO+(NRCYCL+1)*(NPASS_ph_spO+NFAT_ph_spO))/NNPHSP)[
            {  0  "files have been added"
            {  0  OUTPUT I;(//' ***ERROR:'/
            {  0  ' Phase space file',I4,' has been added to (using beamdp?) before restarting.'/
            {  0  ' The code currently does not support this.  Please add phase space'/
            {  0  ' files only after all runs, including restarts, are complete.'//);
            {  0  "STOP;"
            {  0  ]
            {  0  ]
            {  0  IF(NPPHSP(I) > 0)[
            {  0  CALL DATETIME(1);
            {  0  OUTPUT TIMEN;(/' READ PH-SP FILE AT ',$TIMEN_FORMAT);
            {  0  "Read last particles to check whether it is right"
            {  0  IF(IO_OPT=4)[
            {  0  "just check that file size=checksum"
            {  0  $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(IOUTFLU(I));
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_RECORD(IZLAST,IOUTFLU(I),NPPHSP(I)+1:
            {  0  NHSTRYM,ZLAST(1),LATCHM,EINM,WTM,XINM,YINM,UINM,VINM);
            {  0  "binary read"
            {  0  OUTPUT NPPHSP(I),LATCHM,EINM,XINM,YINM,UINM,VINM,WTM;(//
            {  0  ' (LATCHM,EINM,XINM,YINM,UINM,VINM,WTM) FOR PARTICLE No.',
            {  0  I12,' IN THIS FILE:'/' ',I12,6F12.5);
            {  0  "CALL TIME(TIMEN);"
            {  0  "OUTPUT TIMEN;"
            {  0  "(/' FINISHED READING PH-SP FILE AT ',$TIMEN_FORMAT);"
            {  0  ]
            {  0  OUTPUT; (/' FINISHED READING PH-SP FILE AT ',$);
            {  0  call egs_time(6); OUTPUT; (' ');
            {  0  ]
            {  0  ]"end of loop over planes"
            {  0  };
               0
               0  REPLACE {$BEAM_CLOSE_PHSP;} WITH {;
            {  0  IF(n_parallel=0 | ~is_finished) [
            {  0  "do not close phsp files that have already been closed"
            {  0  "after individual parallel jobs have ended"
            {  0  IF (IO_OPT =  0)|((IO_OPT =  3)&(IHSTRY <= 100000))|(IO_OPT=4) [
            {  0  "phase-space output"
            {  0  DO I=1,NSC_PLANES [
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_DESTROY_PHSP_FILE(IOUTFLU(I));
            {  0  ]
            {  0  ELSE[
            {  0  CLOSE(IOUTFLU(I));
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$DOSXYZ_OPEN_PHSP_FOR_WRITE;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps."
            {  0  "Some mods by BW."
            {  0  IF(IRESTART=0) [
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            {  0  0,0,z_score_tmp,i_muidx_out,1);
            {  0  ]
            {  0  ELSEIF(IRESTART=1) [
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            {  0  0,1,z_score_tmp,i_muidx_out,1);
            {  0  ]
            {  0  };
               0
               0  REPLACE {$DOSXYZ_WRITE_PHSP;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps"
            {  0  $IAEA_WRITE_PHSP_RECORD(i_unit_out,0,
            {  0  1,nhist,latch(np),iq(np),e(np),
            {  0  wt(np), x(np),y(np),z(np),u(np),v(np),w(np),zlast_tmp,
            {  0  frMU_indx); "added MU index (JL 2013)"
            {  0  "zlast not used in dosxyz so this is a dummy variable"
            {  0
            {  0  };
               0
               0  REPLACE {$DOSXYZ_SET_OUT_PHSP_HEADER;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps"
            {  0  IF(isource = 0 |  isource = 1 | isource = 3 | isource = 7)[
            {  0  ainflu=dble(IHSTRY+ncaseold-nsmiss-nmissm);
            {  0  ]
            {  0  ELSEIF(isource = 2 | isource = 8 )[
            {  0  ainflu=dble(IHSTRY+ncaseold+nsmiss+
            {  0  (NRCYCL+1)*(nsrjct+nsoutside+ndbsrjct))/float(nshist)*NINCSRC;
            {  0  ]
            {  0  ELSEIF(isource=4)[
            {  0  ainflu=dble(IHSTRY+ncaseold-nsmiss);
            {  0  ]
            {  0  ELSEIF(isource=6)[
            {  0  ainflu=dble(IHSTRY+ncaseold);
            {  0  ]
            {  0  ELSEIF(isource=9|isource=10|isource=21)[
            {  0  ainflu=dble(nhist);
            {  0  ]
            {  0  ELSEIF(isource=20)[
            {  0  ainflu = dble((NRCYCL+1)*(nnread))/dble(nshist)*NINCSRC;
            {  0  ]
            {  0  $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(i_unit_out,ainflu);
            {  0  $IAEA_UPDATE_PHSP_HEADER(i_unit_out);
            {  0
            {  0  };
               0
               0  " The following are null macros that will be overwritten by the library "
               0  " version of BEAM "
               0  REPLACE {$DECLARE-PARTICLE-CONTAINER;} WITH {;};
               0
               0  "End of phsp_macros.mortran"
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc addphsp utility                                                     "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Blake Walters, 2004                                       "
               0  "                                                                             "
               0  "  Contributors:    Ernesto Mainegra-Hing                                     "
               0  "                   Iwan Kawrakow                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code is part of the BEAMnrc code system for Monte Carlo simulation of "
               0  "  radiotherapy treatments units. BEAM was originally developed at the        "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin, and was originally      "
               0  "  described in:                                                              "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The addphsp utility concatenate phase space files from parallel BEAM       "
               0  "  simulations. Naming scheme of phase space files is assumed to be:          "
               0  "                                                                             "
               0  "  infile_w(i).egsphsp?, infile_w(i+1).egsphsp?, ...                          "
               0  "                                                                             "
               0  "  Carries out the same task as the old addphsp script, but it does not use   "
               0  "  BEAMDP and it can run on Windows.                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  !INDENT F 2;
               0  %L                                                                             ;
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  %I4                                                                            ;
1              0  %E
               0  %B132                                                                          ;
               0
               0  REPLACE {$MAX_SC_PLANES} WITH {1};
               0  "a dummy replacement needed for new write macros"
               0
               0  CHARACTER*80 infile,outfile,arg,istart,iscore,iend,inum,tempinfile,resp,
               0  i_iaea;
               0  INTEGER i,j,k,iipar,iargc,numarg,lnblnk1,iistart,iiscore,iiend,ndigits,
               0  sumerr,ifirst,i_iaea_in;
               0  $LOGICAL ex,append;
               0
               0  "sumerr=error code passed back from subroutine add_files, can take on"
               0  "the following values:"
               0  "sumerr=0--no error"
               0  "sumerr=1--file type mismatch or error opening file to be added: Nonfatal"
               0  "sumerr=2--error opening output file or total no. of particles will"
               0  "          exceed 2^32-1: Fatal"
               0  "sumerr=3--error opening first file to be added: Nonfatal
               0
               0  numarg=iargc();
               0  " where phsp files to be added have naming scheme:"
               0  "infile_w(istart).egsphsp(iscore),...,infile_w(istart+ipar-1).egsphsp(iscore)"
               0  " Summed phsp data will be stored in outfile.egsphsp(iscore)."
               0
               0  IF(numarg<3)[
               1      OUTPUT;(/' Usage: '//
               1      ' addphsp infile(no ext.) outfile(no ext.) ipar [istart] [iscore] [i_iaea]'//
               1      ' infile  = phsp file base name (excluding the trailing _w*.*)'/
               1      ' outfile = output file for summed phsp data.  Extension .egsphsp(iscore)'/
               1      '           gets added automatically.'/
               1      ' ipar    = no. of parallel runs to be added'/
               1      ' istart  = starting index of parallel runs to be added (defaults to 1)'/
               1      ' iscore  = scoring plane number (defaults to 1)--input 0 for no scoring plane'/
               1      ' i_iaea  = set to 1 if files are in IAEA format (defaults to 0)'//
               1      ' Note: phsp files to be added have naming scheme:'/
               1      ' infile_w(istart).egsphsp(iscore),...,',
               1      'infile_w(istart+ipar-1).egsphsp(iscore)'/
               1      ' or:'/
               1      ' infile_w(istart).iscore.IAEAphsp,...,',
               1      'infile_w(istart+ipar-1).iscore.IAEAphsp'/);
               1      stop;
               1      ]
               0
               0
               0  call getarg(1,arg);
               0  infile=$cstring(arg);
               0  call getarg(2,arg);
               0  outfile=$cstring(arg);
               0  "now get iipar"
               0  call getarg(3,arg);
               0  iipar=0;
               0  DO i=1,lnblnk1(arg)[
               1      iipar=iipar+(ichar(arg(i:i))-48)*10**(lnblnk1(arg)-i);
               1      ]
               0  IF(numarg>3)[
               1      call getarg(4,arg);
               1      istart=$cstring(arg);
               1      IF(numarg>4)[
               2          call getarg(5,arg);
               2          iscore=$cstring(arg);
               2          IF(numarg>5)[
               3              call getarg(6,arg);
               3              i_iaea=$cstring(arg);
               3              ]
               2          ELSE[
               3              i_iaea='0';
               3              ]
               2          ]
               1      ELSE [
               2          iscore='1';
               2          i_iaea='0';
               2          ]
               1      ]
               0  ELSE [
               1      istart='1';
               1      iscore='1';
               1      i_iaea='0';
               1      ]
               0
               0  "get integer versions of istart,iscore and i_iaea"
               0  iistart=0;
               0  iiscore=0;
               0  i_iaea_in=0;
               0  DO i=1,lnblnk1(istart)[
               1      iistart=iistart+(ichar(istart(i:i))-48)*10**(lnblnk1(istart)-i);
               1      ]
               0  DO i=1,lnblnk1(iscore)[
               1      iiscore=iiscore+(ichar(iscore(i:i))-48)*10**(lnblnk1(iscore)-i);
               1      ]
               0  IF(i_iaea='1')i_iaea_in=1;
               0  iiend=iistart+iipar-1;
               0  "convert iiend to a string version"
               0  "how many digits in iiend"
               0  DO i=1,80[
               1      IF(mod(iiend,10**i)=iiend)[
               2          ndigits=i;
               2          EXIT;
               2          ]
               1      ]
               0  DO i=1,ndigits[
               1      IF(i=1)[
               2          iend=char(iiend/(10**(ndigits-i))+48);
               2          ]
               1      ELSE[
               2          iend=iend(:lnblnk1(iend))//char(iiend/(10**(ndigits-i))+48);
               2          ]
               1      iiend=mod(iiend,10**(ndigits-i));
               1      ]
               0
               0  IF(i_iaea_in=1)[
               1      IF($cstring(iscore)~='0') outfile=$cstring(outfile)//'.'//$cstring(iscore);
               1      IF($cstring(iscore)~='0')[
               2          OUTPUT $cstring(infile)//'_w'//$cstring(istart)//'.'//$cstring(iscore)//
               2          '.IAEAphsp', $cstring(infile)//'_w'//$cstring(iend)//
               2          '.'//$cstring(iscore)//'.IAEAphsp', $cstring(outfile)//'.IAEAphsp';
               2          (/' Will sum from phsp file ',A/' to ',A/
               2          ' And output result to ',A/);
               2          ]
               1      ELSE[
               2          OUTPUT $cstring(infile)//'_w'//$cstring(istart)//
               2          '.IAEAphsp', $cstring(infile)//'_w'//$cstring(iend)//
               2          '.'//$cstring(iscore)//'.IAEAphsp', $cstring(outfile)//'.IAEAphsp';
               2          (/' Will sum from phsp file ',A/' to ',A/
               2          ' And output result to ',A/);
               2          ]
               1      ]
               0  ELSE[
               1      outfile=$cstring(outfile)//'.egsphsp'//$cstring(iscore);
               1      OUTPUT $cstring(infile)//'_w'//$cstring(istart)//'.egsphsp'//$cstring(iscore),
               1      $cstring(infile)//'_w'//$cstring(iend)//'.egsphsp'//$cstring(iscore),
               1      $cstring(outfile);
               1      (/' Will sum from phsp file ',A/' to ',A/
               1      ' And output result to ',A/);
               1      ]
               0
               0  append=.false.;
               0  "first, see if the output file already exists"
               0  IF(i_iaea_in=1)[
               1      inquire(file=$cstring(outfile)//'.IAEAphsp',exist=ex);
               1      ]
               0  ELSE[
               1      inquire(file=outfile,exist=ex);
               1      ]
               0  IF(ex)[
               1      OUTPUT $cstring(outfile);
               1      (/' Output file ',A,' exists.'/
               1      ' Add to it [add], overwrite it [ow], or quit [q--default]:',$);
               1      READ(5,'(A)')resp;
               1      IF($cstring(resp)='add')[
               2          OUTPUT;(/' Will append phsp data to existing phsp file.'/);
               2          append=.true.;
               2          ]
               1      ELSEIF($cstring(resp)='ow')[
               2          OUTPUT;(/' Will overwrite existing file.'/);
               2          ]
               1      ELSE[
               2          OUTPUT;(/' Quitting.'/);
               2          stop;
               2          ]
               1      ]
               0
               0  DO i=iistart,iistart+iipar-1[
               1      k=i;
               1      DO j=1,80[
               2          IF(mod(k,10**j)=k)[
               3              ndigits=j;
               3              EXIT;
               3              ]
               2          ]
               1      DO j=1,ndigits[
               2          IF(j=1)[
               3              inum=char(k/(10**(ndigits-j))+48);
               3              ]
               2          ELSE[
               3              inum=inum(:lnblnk1(inum))//char(k/(10**(ndigits-j))+48);
               3              ]
               2          k=mod(k,10**(ndigits-j));
               2          ]
               1      IF(i_iaea_in=1)[
               2          tempinfile=$cstring(infile)//'_w'//$cstring(inum);
               2          IF($cstring(iscore)~='0')tempinfile=$cstring(tempinfile)//
               2          '.'//$cstring(iscore);
               2          ]
               1      ELSE[
               2          tempinfile=$cstring(infile)//'_w'//$cstring(inum)//'.egsphsp'//
               2          $cstring(iscore);
               2          ]
               1      IF((i=iistart | sumerr=3) & ~append)[
               2          call add_files($cstring(tempinfile),$cstring(outfile),1,sumerr,i_iaea_in);
               2          ]
               1      ELSEIF(sumerr=2)[
               2          EXIT;
               2          ]
               1      ELSE [
               2          call add_files($cstring(tempinfile),$cstring(outfile),0,sumerr,i_iaea_in);
               2          ]
               1      ]
               0
               0  OUTPUT;(/' Done.'/);
               0
               0  stop;
               0  end;
               0
               0
               0  SUBROUTINE ADD_FILES(infile,outfile,ifirst,sumerr,i_iaea_in);
               0  "
               0  " A modified version of ADD_PHSP found in beamdp.mortran
               0  "
               0  "*************************************************************************
               0
               0  "**VARIABLES**"
               0
               0  IMPLICIT NONE;
               0
               0  COMIN/RWPHSP/;
               0  character*80 infile,outfile;
               0  integer ifirst,sumerr,IZLAST1,IMUPHSP1,IMUPHSP2,
               0  LATCHI,lnblnk1,i_iaea_in,i_log,
               0  i_unit_in,i_unit_out,IZLAST2,NPASSI,IQ,IZSCORE1,IZSCORE2;
               0  $LONG_INT PARANOT,PARANOT1,PARANOP1,PARANOT2,PARANOP2,
               0  IPARANOT1,IPARANOT2,LPARANINC1,LPARANINC2,LNINC,NHSTRY,
               0  max_total_particle_no;
               0  real PARAEMAX1,PARAEMNE1,PARANINC1,PARAEMAX2,PARAEMNE2,PARANINC2,NINC,
               0  ZLAST,EREAD,WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,Z_SCORE,MU_IDX;
               0  character*5 MODE_RW1,MODE_RW2;
               0  integer itmp;
               0
               0
               0  $INITIALIZE_PHSP_VARIABLES;
               0
               0  $INIT_PHSP_COUNTERS;
               0  sumerr=0;
               0  max_total_particle_no = 2147483647;
               0
               0  i_log=6;
               0  IF(i_iaea_in=1)[
               1      OUTPUT $cstring(INFILE)//'.IAEAphsp',$cstring(OUTFILE)//'.IAEAphsp';
               1      (/' Adding ',A,' to ',A,': '/);
               1      ]
               0  ELSE[
               1      OUTPUT $cstring(INFILE),$cstring(OUTFILE);
               1      (/' Adding ',A,' to ',A,': '/);
               1      ]
               0  ;/PARANOT1,PARANOP1/=0;/PARAEMAX1,PARAEMNE1,PARANINC1/=0.;
               0  MODE_RW1=' ';
               0
               0  IF(i_iaea_in=1)[
               1      OUTPUT $cstring(INFILE)//'.IAEAphsp'; (/' Header information for ',A,':'/);
               1      i_unit_in=2;
               1      IERR_PHSP=0;
               1      $IAEA_OPEN_PHSP_FOR_READ(i_unit_in,INFILE);
               1      IF(iaea_result<0)[
               2          IF(ifirst=1) [
               3              sumerr=3;
               3              ]
               2          ELSE[
               3              sumerr=1;
               3              ]
               2          GOTO :RRR1:;
               2          ]
               1      $IAEA_READ_PHSP_HEADER(i_unit_in,PARANOT1,PARANOP1,PARAEMAX1,LPARANINC1,
               1      Z_SCORE,IZLAST1,IMUPHSP1,IZSCORE1);
               1      OUTPUT PARANOT1,PARANOP1,PARAEMAX1,LPARANINC1;
               1      (/'            TOTAL NUMBER OF PARTICLES IN FILE:',I13/
               1      '                      TOTAL NUMBER OF PHOTONS:',I13/
               1      '             THE REST ARE ELECTRONS/POSITRONS.'/
               1      ' '/
               1      '      MAXIMUM KINETIC ENERGY OF THE PARTICLES:',F13.3,' MeV'/
               1      ' # OF INCIDENT PARTICLES FROM ORIGINAL SOURCE:',I13/);
               1      IF(IZSCORE1=0)[
               2          OUTPUT Z_SCORE;
               2          ('                       Z AT WHICH PHSP SCORED:',F13.3,' cm'/);
               2          ]
               1      PARANOT=PARANOT1;
               1      ]
               0  ELSE[
               1      OUTPUT $cstring(INFILE); (/' Header information for ',A,':'/);
               1      itmp=-1;
               1      $OPEN_PHSP_FOR_READ(itmp,2,INFILE,MODE_RW1,PARANOT1,
               1      PARANOP1,PARAEMAX1,PARAEMNE1,PARANINC1);
               1      IF(IERR_PHSP~=0)[
               2          IF(ifirst=1) [
               3              sumerr=3;
               3              ]
               2          ELSE[
               3              sumerr=1;
               3              ]
               2          GOTO :RRR1:;
               2          ]
               1
               1      IZLAST1=0;
               1      IF(MODE_RW1='MODE2') IZLAST1=1;
               1
               1      PARANOT=PARANOT1; "store total for later"
               1
               1      OUTPUT PARANOT1,PARANOP1,PARAEMAX1,PARAEMNE1,PARANINC1;
               1      (/'            TOTAL NUMBER OF PARTICLES IN FILE:',I13/
               1      '                      TOTAL NUMBER OF PHOTONS:',I13/
               1      '             THE REST ARE ELECTRONS/POSITRONS.'/
               1      ' '/
               1      '      MAXIMUM KINETIC ENERGY OF THE PARTICLES:',F13.3,' MeV'/
               1      '      MINIMUM KINETIC ENERGY OF THE ELECTRONS:',F13.3,' MeV'/
               1      ' # OF INCIDENT PARTICLES FROM ORIGINAL SOURCE:',F13.1);
               1      ]
               0
               0  IF(i_iaea_in=1)[
               1      OUTPUT $cstring(OUTFILE)//'.IAEAphsp';
               1      (//' Header information for ',A,':'/);
               1      ]
               0  ELSE[
               1      OUTPUT $cstring(OUTFILE);(//' Header information for ',A,':'/);
               1      ]
               0
               0  /PARANOT2,PARANOP2,LPARANINC2/=0;/PARAEMAX2,PARAEMNE2,PARANINC2/=0.;
               0  MODE_RW2=' ';
               0
               0  IF(ifirst=0)["not the first time we are adding to this file"
               1
               1      IF(i_iaea_in=1)[
               2          i_unit_out=3;
               2          $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,OUTFILE,IZLAST2,1,Z_SCORE,
               2          IMUPHSP2,IZSCORE2);
               2          IF(iaea_result<0)[
               3              sumerr=2;
               3              GOTO :RRR2:;
               3              ]
               2          $IAEA_READ_PHSP_HEADER(i_unit_out,PARANOT2,PARANOP2,PARAEMAX2,LPARANINC2,
               2          Z_SCORE,IZLAST2,IMUPHSP2,IZSCORE2);
               2          OUTPUT PARANOT2,PARANOP2,PARAEMAX2,LPARANINC2;
               2          (/'            TOTAL NUMBER OF PARTICLES IN FILE:',I13/
               2          '                      TOTAL NUMBER OF PHOTONS:',I13/
               2          '             THE REST ARE ELECTRONS/POSITRONS.'/
               2          ' '/
               2          '      MAXIMUM KINETIC ENERGY OF THE PARTICLES:',F13.3,' MeV'/
               2          ' # OF INCIDENT PARTICLES FROM ORIGINAL SOURCE:',I13/);
               2          IF(IZSCORE2=1)[
               3              OUTPUT Z_SCORE;
               3              ('                       Z AT WHICH PHSP SCORED:',F13.3,' cm'/);
               3              ]
               2          IF(IZLAST1 ~= IZLAST2)["FILES OF DIFFERENT MODES"
               3              OUTPUT;
               3              (/' FILE TO BE ADDED HAS A DIFFERENT MODE THAN SUMMED FILE!!! '/);
               3              OUTPUT;
               3              (/' WILL MOVE ON TO THE NEXT FILE TO BE ADDED.'/);
               3              $IAEA_DESTROY_PHSP_FILE(i_unit_in);
               3              $IAEA_DESTROY_PHSP_FILE(i_unit_out);
               3              sumerr=1;
               3              RETURN;
               3              ]
               2          IF(IZSCORE1 ~= IZSCORE2)["one file scores Z, the other does not"
               3              OUTPUT;(/' Error: File mismatch in scoring of particle Z position.'/
               3              ' Will move on to the next file to be added.'/);
               3              $IAEA_DESTROY_PHSP_FILE(i_unit_in);
               3              $IAEA_DESTROY_PHSP_FILE(i_unit_out);
               3              sumerr=1;
               3              RETURN;
               3              ]
               2          IF(IMUPHSP1~=IMUPHSP2)["one file scores MU index, one does not"
               3              OUTPUT;(/' Error: File mismatch in scoring of fractional MU index.'/
               3              ' Will move on to the next file to be added.'/);
               3              $IAEA_DESTROY_PHSP_FILE(i_unit_in);
               3              $IAEA_DESTROY_PHSP_FILE(i_unit_out);
               3              sumerr=1;
               3              RETURN;
               3              ]
               2          NHSTRY=LPARANINC2;
               2          ]
               1      ELSE[
               2
               2          itmp=-1;
               2          $OPEN_PHSP_FOR_READ(itmp,3,OUTFILE,MODE_RW2,
               2          PARANOT2,PARANOP2,PARAEMAX2,PARAEMNE2,PARANINC2);
               2          IF(IERR_PHSP~=0)[
               3              sumerr=2;
               3              GOTO :RRR2:;
               3              ]
               2
               2          OUTPUT PARANOT2,PARANOP2,PARAEMAX2,PARAEMNE2,PARANINC2;
               2          (/'            TOTAL NUMBER OF PARTICLES IN FILE:',I13/
               2          '                      TOTAL NUMBER OF PHOTONS:',I13/
               2          '             THE REST ARE ELECTRONS/POSITRONS.'/
               2          ' '/
               2          '      MAXIMUM KINETIC ENERGY OF THE PARTICLES:',F13.3,' MeV'/
               2          '      MINIMUM KINETIC ENERGY OF THE ELECTRONS:',F13.3,' MeV'/
               2          ' # OF INCIDENT PARTICLES FROM ORIGINAL SOURCE:',F13.1);
               2
               2          IF(MODE_RW2 ~= MODE_RW1)["FILES OF DIFFERENT MODES"
               3              OUTPUT;
               3              (/' FILE TO BE ADDED HAS A DIFFERENT MODE THAN SUMMED FILE!!! '/);
               3              OUTPUT;
               3              (/' WILL MOVE ON TO THE NEXT FILE TO BE ADDED.'/);
               3              CLOSE(UNIT=2);
               3              CLOSE(UNIT=3);
               3              sumerr=1;
               3              RETURN;
               3              ]
               2          NHSTRY=PARANINC2;
               2          ]
               1      ]
               0  ELSE["first time we are adding to this file--no header"
               1
               1      NHSTRY=0;
               1      OUTPUT;(/' First time writing to this file.'/
               1      ' No header data to display.'/);
               1      IF(i_iaea_in=1)[
               2          i_unit_out=3;
               2          $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,OUTFILE,IZLAST1,0,Z_SCORE,IMUPHSP1,
               2          IZSCORE1);
               2          ]
               1      ELSE[
               2          $OPEN_PHSP_FOR_WRITE(IZLAST1,3,OUTFILE,MODE_RW2);
               2          ]
               1      ]
               0
               0
               0  OUTPUT;(/' BEGIN READING/WRITING PH-SP DATA .....'/);
               0
               0  IPARANOT2=PARANOT2+1;
               0
               0  "check that summed files will not go over 2.147483648 GByte limit"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "But we do want to check that the total no. of particles does not exceed"
               0  "2^32-1 and, thus, cannot be written to the header"
               0  "Note: Only for EGSnrc format"
               0  IF(i_iaea_in=0 & PARANOT1+PARANOT2>max_total_particle_no)[
               1      OUTPUT; (//' ***WARNING***'/
               1      ' Total no. of particles in combined ',
               1      ' file will exceed 2^32-1.'/
               1      ' This number cannot be stored in the header.'/
               1      ' Exiting now.'//);
               1      sumerr=2;
               1      return;
               1      ]
               0
               0  IF(i_iaea_in=1)[
               1      DO IPARANOT1=1,PARANOT1["read phase-space data from the data file 1"
               2          $IAEA_READ_PHSP_RECORD(i_unit_in,NPASSI,NHSTRY,LATCHI,IQ,EREAD,
               2          WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MU_IDX);
               2          $IAEA_WRITE_PHSP_RECORD(i_unit_out,NPASSI,1,NHSTRY,LATCHI,IQ,EREAD,
               2          WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MU_IDX);
               2          ]
               1      LNINC = LPARANINC1 + LPARANINC2;
               1      $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(i_unit_out,LNINC);
               1      $IAEA_UPDATE_PHSP_HEADER(i_unit_out);
               1      $IAEA_DESTROY_PHSP_FILE(i_unit_in);
               1      $IAEA_DESTROY_PHSP_FILE(i_unit_out);
               1      ]
               0  ELSE["standard BEAMnrc format"
               1      PARANOP1=0; "only count photons as read in case we are not adding a full"
               1      "file"
               1      DO IPARANOT1=2,PARANOT1+1["read phase-space data from the data file 1"
               2          "NOTE THE SECOND RECORD STORES THE FIRST PARTICLE"
               2          $READ_PHSP_RECORD(IZLAST1,2,IPARANOT1:NHSTRY,ZLAST,LATCHI,EREAD,
               2          WEIGHT,XIN,YIN,UIN,VIN);
               2          IPARANOT2=IPARANOT2+1;
               2          PARANOP1=PARANOP1+1-IBITS(LATCHI,29,1)-IBITS(LATCHI,30,1);
               2          "bit 29 is set if electron, bit 30 if positron"
               2          $WRITE_PHSP_RECORD(IZLAST1,3,OUTFILE,IPARANOT2,1:NHSTRY,ZLAST,LATCHI,EREAD,
               2          WEIGHT,XIN,YIN,UIN,VIN);
               2          "write to file2"
               2          ]
               1      :end-of-file1-read:;
               1      $PHSP_BUFFER_FLUSH(IZLAST1,3,OUTFILE,IPARANOT2,1);
               1      "Re-write the first line of file 2"
               1      PARANOT2 = PARANOT2 + PARANOT1;
               1      PARANOP2 = PARANOP2 + PARANOP1;
               1      IF(PARANOT1>0 & PARAEMAX2 < PARAEMAX1)[PARAEMAX2=PARAEMAX1;]
               1      IF(PARANOT1>0 & PARAEMNE2 > PARAEMNE1)[PARAEMNE2=PARAEMNE1;]
               1      "COMPUTE NINC"
               1      NINC = (PARANOT1/PARANOT)*PARANINC1 + PARANINC2;
               1      $WRITE_PHSP_HEADER(IZLAST1,3,OUTFILE,MODE_RW2,PARANOT2,PARANOP2,
               1      PARAEMAX2,PARAEMNE2,NINC);
               1      CLOSE(UNIT=2);
               1      CLOSE(UNIT=3);
               1      ]
               0  OUTPUT;(/' Finished reading/writing ph-sp data .....'/);
               0
               0  RETURN;
               0
               0  :RRR1: OUTPUT;(//' CANNOT FIND/OPEN THE PH-SP FILE TO BE ADDED!!!'/
               0  ' WILL MOVE ON TO THE NEXT ONE IN THE SERIES.'///);
               0  "ask the user whether a different ph-sp file to be used"
               0
               0  RETURN;
               0
               0  :RRR2: OUTPUT;(//' CANNOT FIND/OPEN THE FILE CONTAINING SUMMED PHSP DATA!!!'/
               0  ' PROGRAM WILL TERMINATE.'///);
               0  RETURN;
               0  END;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc function to get index of last non-blank character in a string       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2004                                       "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  $INTEGER function lnblnk1(string);
               0
               0  "Function to return index of last non-blank character in a string"
               0  "We use this instead of lnblnk because there are compilers"
               0  "that do not have lnblnk"
               0
               0  "******************************************************************************
               0  character*(*) string;
               0  DO i=len(string),1,-1 [
               1      j = ichar(string(i:i));
               1      IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
               1      "0-terminated C-strings"
               1      IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
               2          lnblnk1 = i; return;
               2          ]
               1      ]
               0  lnblnk1 = 0; return; end;
               0
          END OF MORTRAN INPUT
  70      PERCENT RULE CAPACITY REMAINING
          NO MORTRAN ERRORS DETECTED
