Mortran 3.2 Tue Aug 19 15:59:53 2025
               0  %L                                                                     ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros                                                              "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                   Victor Malkov                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0              "but this DOES NOT apply withing macro definitions!!
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  %L          "Turn on listing                                                   ;
               0
               0
               0  "=================================================================="
               0  " Macros to implement implicit data types                          "
               0  "=================================================================="
               0
               0  REPLACE {$LOGICAL} WITH {;logical}
               0  REPLACE {$REAL}    WITH {;real*8}
               0  REPLACE {$INTEGER} WITH {;integer*4}
               0  REPLACE {$LONG_INT} WITH {;integer*8} "change this to integer*4 for compilers"
               0                                        "that do not support integer*8"
               0  REPLACE {$SHORT_INT} WITH {;integer*2} "change this to integer*4 for compilers"
               0                                        "that do not support integer*2"
               0  "the above is not used in EGSnrc but is used in the NRC user codes,
               0  "especially related to number of histories"
               0  "Note that the HP compiler does not support *8 integers so the above"
               0  " should be changed for HP"
               0
               0  REPLACE {$IMPLICIT-NONE;} WITH {;}
               0  REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}
               0
               0  "=================================================================="
               0  "SELECT THE FORTRAN STANDARD TO BE USED (1966 OR 1977)             "
               0  REPLACE {$FORTVER} WITH {1977}
               0  "=================================================================="
               0
               0  "******************************************************************"
               0  REPLACE {$TYPE} WITH {
            {  0    {SETR F=$FORTVER}
            {  0     [IF] {COPY F}=1977 [CHARACTER*4] [ELSE] [INTEGER*4]
            {  0    }
               0  "******************************************************************"
               0
               0  "******************************************************************"
               0  SPECIFY ALPHA    AS (0...$);
               0  SPECIFY SYMBOL   AS (0...?);
               0  SPECIFY NAME     AS LETTER(0,5)[ALPHA];
               0  SPECIFY <COMMA>  AS [','|''];
               0  SPECIFY <NAME>   AS [NAME|''];
               0  SPECIFY LABEL    AS ':'NAME':';
               0  SPECIFY <LABEL>  AS [LABEL|''];
               0  SPECIFY <*>      AS ['*'|''];
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {NEWLABEL} WITH {@LG}
               0  REPLACE {%'{ARB}'={<*>}'{ARB}'}
               0     WITH {[IF] '{P2}'='*' [APPEND'{P3}'TO'{P1}']
            {  0              [ELSE] [ REPLACE {{P1}}WITH{{P3}}]}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0      "RULES TO GENERALIZE MORTRAN'S INPUT AND OUTPUT"
               0  REPLACE {;$UINPUT(#)#;}
               0     WITH {;{SETR A=NEWLABEL}
            {  0              READ({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$UOUTPUT(#)#;}
               0     WITH {;{SETR A=NEWLABEL}
            {  0              WRITE({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$ECHO#({NAME}{<COMMA>}#)#;}
               0   WITH {;{SETR X=NEWLABEL}
            {  0   WRITE(IUECHO,{COPY X});{COPY X}FORMAT(' ECHO {P1}:{P5}');
            {  0   [IF] {EXIST 3} [{P1}({P2},{P4}){P5};
            {  0   WRITE(IUECHO,{P4}){P5};]
            {  0   [ELSE] [{SETR Y=NEWLABEL}{P1}({P2},{COPY Y}){P4};
            {  0   WRITE(IUECHO,{COPY Y}){P5};{COPY Y}FORMAT]
            {  0   }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  REPLACE {;IUECHO=#;} WITH { REPLACE {IUECHO} WITH {{P1}};}
               0  "INITALIZE" ;IUECHO=6;
               0
               0  "MACRO TO SPLIT STRING INTO A LIST SEPARATED BY COMMAS"
               0  REPLACE {$S'{SYMBOL}#'}
               0    WITH {'{P1}'[IF]{EXIST 2}[,$S'{P2}']}
               0
               0  "SOME DEBUGGING MACROS"
               0  REPLACE {$LIST#/#/#;} WITH
               0     {;OUTPUT {P3};('LIST/{P2}/{P3}:'/(1X,{P1}));}
               0  APPEND{;COMMON/QDEBUG/QDEBUG;LOGICAL QDEBUG;} TO {;COMIN/DEBUG/;}
               0
               0  REPLACE {$TRACE#;} WITH
               0    {REPLACE {;{P1}={WAIT {ARB}};}  WITH
            {  0    {{EMIT;{P1}}={WAIT {P1}};
            {  0    IF QDEBUG [OUTPUT{P1};
            {  0    (' {P1} ASSIGNED {WAIT {P1}} ',G25.18);] }; }
               0  REPLACE {$S1TRACE#;} WITH
               0    {{SETR A=NEWLABEL}
            {  0      REPLACE {;{P1}({WAIT {ARB}})={WAIT {ARB}};}
            {  0         WITH {{EMIT ;{P1}({WAIT {P1}})}={WAIT {P2}};
            {  0             IF QDEBUG [I{COPY A}={WAIT {P1}};
            {  0                  OUTPUT I{COPY A},{P1}(I{COPY A});
            {  0                      (' {P1}(',I6,') ASSIGNED {WAIT {P2}} ' ,
            {  0                         G25.18);] } ;}
               0
               0  REPLACE {$TRACE#,#;} WITH {$TRACE{P1};$TRACE{P2};}
               0  REPLACE {$S1TRACE#,#;} WITH {$S1TRACE{P1};$S1TRACE{P2};}
               0
               0  SPECIFY DELIM AS ['('|';'];
               0  REPLACE {$CALLTRACE;} WITH
               0    {REPLACE {;CALL{NAME}{DELIM}} WITH
            {  0    {;IF (QDEBUG)[OUTPUT;
            {  0      (' SUBROUTINE {WAIT {P1}} CALLED.');]
            {  0           {WAIT {EMIT CALL} {P1}{P2}} };}
               0
               0  REPLACE {$DUMP#,#;} WITH
               0      {;{SETR A=NEWLABEL}
            {  0           V{COPY A}={P1};OUTPUT V{COPY A};(' {P1}=',1PG15.7);
            {  0           [IF] {EXIST 2} [$DUMP{P2};] ;}
               0     "NOTICE: THE LIST OF VARIABLES MUST BE FOLLOWED BY A COMMA"
               0     "FOR EXAMPLE $DUMP S,T(U,V),W,; OR $DUMP A,;"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MORTRAN MACRO DEFINITIONS FOR EGS."
               0
               0  REPLACE {$CONFIG_TIME} WITH {'unknown'}
               0
               0  "FIRST SOME PARAMETERS"
               0  REPLACE {PARAMETER #=#;} WITH
               0     { REPLACE {{P1}} WITH {{P2}}}
               0
               0  PARAMETER $MXMED=10;      "MAX. NO. OF DIFFERENT MEDIA (EXCL. VAC.)"
               0  PARAMETER $MXREG=2000;    "MAXIMUM NO. OF REGIONS ALLOCATED"
               0  PARAMETER $MXSTACK=40;    "STACK SIZE"
               0  PARAMETER $MXVRT1=1000;   "NO. OF REPRESENTATIVE ANGLES IN VERT1"
               0  PARAMETER $FMXVRT1=1000.; "FLOATING $MXVRT1"
               0  PARAMETER $MXPWR2I=50;    "SIZE OF TABLE OF INVERSE POWERS OF TWO"
               0  PARAMETER $MXJREFF=200;   "SIZE OF MULTIPLE SCATTERING JREFF MAP"
               0  PARAMETER $MSSTEPS=16;    "NO. OF MULTIPLE SCATTERING STEP SIZES"
               0  PARAMETER $MXVRT2=100;    "DISTRBTN OF NONOVERLAPPING PARTS OF VERT"
               0
               0  ;
               0  "FOLLOWING DEFINE MAX. NO. OF INTERVALS FOR FIT TO FUNCTIONS"
               0  PARAMETER $MXSGE=400;     "GAMMA SMALL ENERGY INTERVALS"
               0  PARAMETER $MXGE=2000;     "GAMMA MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXSEKE=300;    "ELECTRON SMALL ENERGY INTERVALS"
               0  PARAMETER $MXEKE=500;     "ELECTRON MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXEL=50;       "MAXIMUM # OF ELEMENTS IN A MEDIUM"
               0  PARAMETER $MXLEKE=100;    "ELECTRON ENERGY INTERVALS BELOW EKELIM"
               0  PARAMETER $MXCMFP=100;    "CUMULATIVE ELECTRON MEAN-FREE-PATH"
               0  PARAMETER $MXRANGE=100;   "ELECTRON RANGE"
               0  PARAMETER $MXBLC=20;      "MOLIERE'S LOWER CASE B"
               0  PARAMETER $MXRNTH=20;     "RANDOM NUMBER FOR SUBMEDIAN ANGLES"
               0  PARAMETER $MXRNTHI=20;    "RANDOM NUMBER FOR SUPERMEDIAN ANGLES"
               0  PARAMETER $MXRAYFF=100;   "RAYLEIGH ATOMIC FORM FACTOR"
               0  PARAMETER $RAYCDFSIZE=100;"CDF from RAYLEIGH FORM FACTOR SQUARED"
               0  PARAMETER $MXSINC=1002;   "ANGLE INTERVALS IN (0,5*PI/2) FOR SINE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE PARAMETERS FOR AUSGAB CALLS:"
               0  PARAMETER $MXAUS=35;       "CHANGE IF MORE AUSGAB CALLS ARE ADDED"
               0  PARAMETER $MXAUSM5=30;     "SET THIS TO $MXAUS VALUE LESS 5"
               0
               0  "FIRST FIVE AUSGAB CALLS BELOW TURNED ON IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSB=0;    "BEFORE TRANSPORT"
               0  PARAMETER $EGSCUTAUS=1;   "ENERGY BELOW ECUT OR PCUT"
               0  PARAMETER $PEGSCUTAUS=2;  "ENERGY BELOW AE OR AP"
               0  PARAMETER $USERDAUS=3;    "USER REQUESTED DISCARD"
               0  PARAMETER $PHOTXAUS=4;    "FLUORESCENT PHOTON DISCARD"
               0
               0  "THE REMAINING 23 ARE TURNED OFF IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSA=5;    "AFTER TRANSPORT"
               0  PARAMETER $BREMAUSB=6;    "BEFORE BREMS CALL"
               0  PARAMETER $BREMAUSA=7;    "AFTER BREMS CALL"
               0  PARAMETER $MOLLAUSB=8;    "BEFORE MOLLER CALL"
               0  PARAMETER $MOLLAUSA=9;    "AFTER MOLLER CALL"
               0  PARAMETER $BHABAUSB=10;   "BEFORE BHABHA CALL"
               0  PARAMETER $BHABAUSA=11;   "AFTER BHABHA CALL"
               0  PARAMETER $ANNIHFAUSB=12; "BEFORE ANNIH CALL"
               0  PARAMETER $ANNIHFAUSA=13; "AFTER ANNIH CALL"
               0  PARAMETER $ANNIHRAUSB=28; "BEFORE POSITRON ANNIH AT REST"
               0  PARAMETER $ANNIHRAUSA=14; "POSITRON ANNIHILATED AT REST"
               0  PARAMETER $PAIRAUSB=15;   "BEFORE PAIR CALL"
               0  PARAMETER $PAIRAUSA=16;   "AFTER PAIR CALL"
               0  PARAMETER $COMPAUSB=17;   "BEFORE COMPT CALL"
               0  PARAMETER $COMPAUSA=18;   "AFTER COMPT CALL"
               0  PARAMETER $PHOTOAUSB=19;  "BEFORE PHOTO CALL"
               0  PARAMETER $PHOTOAUSA=20;  "AFTER PHOTO CALL"
               0  PARAMETER $UPHIAUSB=21;   "ENTERED UPHI"
               0  PARAMETER $UPHIAUSA=22;   "LEFT UPHI"
               0  PARAMETER $RAYLAUSB=23;   "BEFORE RAYLEIGH EVENT"
               0  PARAMETER $RAYLAUSA=24;   "AFTER RAYLEIGH EVENT"
               0  PARAMETER $FLUORTRA=25;   "A fluorescent transition just occurred"
               0  PARAMETER $COSKROTRA=26;  "A Coster-Kronig transition just occurred"
               0  PARAMETER $AUGERTRA=27;   "An Auger transition just occurred"
               0  "Ali:photonuc, 2 lines"
               0  " note that 28 is already used for positron annih at rest - see above"
               0  PARAMETER $PHOTONUCAUSB=29; "BEFORE PHOTONUCLEAR EVENT"
               0  PARAMETER $PHOTONUCAUSA=30; "AFTER PHOTONUCLEAR EVENT"
               0  PARAMETER $EIIB=31;   "Before EII"
               0  PARAMETER $EIIA=32;   "After EII"
               0  PARAMETER $SPHOTONA=33;   "After sub-threshold photon energy deposition"
               0  PARAMETER $SELECTRONA=34;   "After sub-threshold electron energy deposition"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$AUSCALL(#);} WITH
               0     {IARG={P1} ;  IF (IAUSFL(IARG+1).NE.0) [CALL AUSGAB(IARG);]} ;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "TEMPORARY OVER-RIDES FOR SOME OF THE ABOVE"
               0  PARAMETER $MXSGE=1;
               0  PARAMETER $MXSEKE=1;
               0  PARAMETER $MXLEKE=1;
               0  PARAMETER $MXCMFP=1;
               0  PARAMETER $MXRANGE=1;
               0  PARAMETER $MXBLC=1;
               0  PARAMETER $MXRNTH=1;
               0  PARAMETER $MXRNTHI=1;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING DEFINE PRECISION USED IN ENERGY COMPUTATIONS"
               0  "THE LATTER OF THE TWO WILL BE IN EFFECT"
               0  REPLACE {$ENERGYPRECISION} WITH {;REAL }"SINGLE PRECISION"
               0  REPLACE {$ENERGYPRECISION} WITH {;DOUBLE PRECISION }
               0  REPLACE {$MAX_INT} WITH {2147483647} "2^31-1"
               0  "^--- limits number of particles and hence phase space file size"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS TO MAKE CHANGES IN THE DEGREE OF FIT EASIER"
               0  "ALSO USEFUL FOR ABBREVIATING LISTS OF SUBSCRIPTED VARIABLES"
               0  "$LGN STANDS FOR 'LIST GENERATOR'"
               0  "$RSC MEANS THAT THE EXPANDED LIST SHOULD RESCANNED FOR FURTHER"
               0  "OPERATIONS.  MACROS EXPECTING TO DO RESCANS SHOULD BE"
               0  "DEFINED AFTER THE FOLLOWING MACRO"
               0  REPLACE {$RSC(#)} WITH {{P1}}
               0  "IF NOT MATCHED BY ANYTHING ELSE, REMOVE $RSC()"
               0  REPLACE {$RSC(#),#$LSCALEBY#;} WITH
               0     {{P1}={P1}*{P3};{P2}$LSCALEBY{P3};}
               0  REPLACE {$RSC(#)$LSCALEBY#;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$LGN(#/#/)} WITH {$RSC({P1}{P2})}
               0  REPLACE {$LGN(#(#)/#/)} WITH {$RSC({P1}{P3}({P2}))}
               0  REPLACE {$LGN(#(#))} WITH {$RSC({P1}({P2}))}
               0  REPLACE {$LGN(#/#,#/)} WITH
               0      {$LGN({P1}/{P2}/),$LGN({P1}/{P3}/)}
               0  REPLACE {$LGN(#,#/#/)} WITH
               0      {$LGN({P1}/{P3}/),$LGN({P2}/{P3}/)}
               0  REPLACE {$LGN(#(#)/#,#/)} WITH
               0      {$LGN({P1}({P2})/{P3}/),$LGN({P1}({P2})/{P4}/)}
               0  REPLACE {$LGN(#,#(#)#)} WITH
               0      {$LGN({P1}({P3}){P4}),$LGN({P2}({P3}){P4})}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR SCALING REQUIRED BY CHANGE IN DISTANCE UNIT"
               0  REPLACE {$SCALE# BY #;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$SCALE#,# BY #;} WITH
               0      {{P1}={P1}*{P3};$SCALE{P2} BY {P3};}
               0  REPLACE {$SCALE$LGN(#) BY #;} WITH
               0      {$LGN({P1})$LSCALE BY {P2};}
               0  REPLACE {$SCALE$LGN(#),# BY #;} WITH
               0              {$LGN({P1})$LSCALE BY {P3};$SCALE{P2} BY {P3};}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------
               0  " Macros related to bit setting
               0  "------------------------------------------------------------------
               0  ""
               0  "Macro to set bit {P2} in {P1}  to 1
               0  REPLACE {$IBSET(#,#);} WITH {ibset({P1},{P2});}
               0
               0  "Macro to set test bit {P2} in {P1}
               0  "Note this may require a LOGICAL declaration wherever used
               0  REPLACE {$BTEST(#,#)} WITH {btest({P1}, {P2})}
               0
               0  "Macro to set bit {P2} in {P1}  to 0
               0  REPLACE {$IBCLR(#,#);} WITH {ibclr({P1},{P2});}
               0  "Above used by RW_PH_SP routine - (read_write_phase_space for BEAM)
               0
               0
               0  "COMMON BLOCK INSERTION MACROS"
               0  REPLACE {;COMIN/#,#/;} WITH {;COMIN/{P1}/;COMIN/{P2}/;}
               0
               0  "NOW FOR SOME SPECIFIC COMMON BLOCKS"
               0
               0  "------------------------------------------------------------------"
               0  "*** BOUNDS--CUTOFF ENERGIES & VACUUM TRANSPORT DISTANCE           "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/BOUNDS/;} WITH
               0  {
            {  0      ;COMMON/BOUNDS/ECUT($MXREG),PCUT($MXREG),VACDST;
            {  0       $REAL         ECUT,   "Minimum electron transport energy"
            {  0                     PCUT,   "Minimum photon transport energy"
            {  0                     VACDST; "Infinity (1E8)"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** BREMPR--BREMSSTRAHLUNG AND PAIR PRODUCTION DATA               "
               0  "------------------------------------------------------------------"
               0
               0  ;
               0  REPLACE {$MXBREN} WITH {57}
               0  REPLACE {$MXBRXX} WITH {54}
               0  REPLACE {$MXBREL} WITH {100}
               0  REPLACE {$MXGAUSS} WITH {64}
               0  REPLACE {$MXBRES} WITH {100}
               0  REPLACE {$MXBRXS} WITH {50}
               0  REPLACE {$NIST-ENERGY-SCALE} WITH {1.0}
               0
               0  REPLACE {$NIST-DATA-UNIT} WITH {i_nist_data}
               0  ;
               0
               0  REPLACE {$COMIN-INIT-NIST-BREMS;} WITH {;
            {  0      ;COMIN/MEDIA,BREMPR,ELECIN,THRESH,USEFUL,NIST-BREMS,Spin-Data,EGS-IO/;
            {  0  };
               0
               0  REPLACE {;COMIN/BREMPR/;} WITH
               0  {
            {  0    ;COMMON/BREMPR/
            {  0               $LGN(DL(8,$MXMED)/1,2,3,4,5,6/),
            {  0               $LGN(ALPHI,BPAR,DELPOS(2,$MXMED)),
            {  0               $LGN(WA,PZ,ZELEM,RHOZ($MXMED,$MXEL)),
            {  0               PWR2I($MXPWR2I),
            {  0               $LGN(DELCM,ZBRANG,LZBRANG,NNE($MXMED)),
            {  0               IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet,
            {  0               ASYM($MXMED,$MXEL,2);
            {  0     $TYPE     ASYM;
            {  0     $REAL     $LGN(DL/1,2,3,4,5,6/), "Parameter for the fit of the screening"
            {  0                                      "rejection function, eq. (2.7.14 and 15)"
            {  0               ALPHI,  "Prob. for the (1-BR)/BR part in BREMS, eq. (2.7.64)"
            {  0               BPAR,   "Prob. for the 12*(BR-1/2)**2 part in PAIR, eq. (2.7.105)"
            {  0               DELPOS, "maximum delta, eq. (2.7.31)"
            {  0               WA,     "atomic weight"
            {  0               PZ,     "atomic fraction of an element in a compound"
            {  0               ZELEM,  "Z for a given component"
            {  0               RHOZ,   "density of an element in a compound"
            {  0               PWR2I,  "powers of 1/2 (used for sampling (1-BR)/BR"
            {  0               DELCM,  "136*m*exp(Zg), eq. (2.7.51)"
            {  0               ZBRANG, "composite factor for angular distributions"
            {  0               LZBRANG;"-Log(ZBRANG)"
            {  0     $INTEGER  NNE,    "number of elements/compound"
            {  0               IBRDST, "flag to switch on bremsstrahlung angular distributions"
            {  0               IPRDST, "flag to switch on pair angular distributions"
            {  0               ibr_nist,  "use the NIST bremsstrahlung cross sections"
            {  0               itriplet,  "if set to 1, explicitely simulate triplet events"
            {  0               pair_nrc;  "=0 => use Bethe-Heitler pair cross sections"
            {  0                          "=1 => use the NRC pair cross sections"
            {  0  };
               0
               0  REPLACE {;COMIN/NIST-BREMS/;} WITH {;
            {  0
            {  0    common/nist_brems/ nb_fdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_xdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_wdata($MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_idata($MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_emin($MXMED),nb_emax($MXMED),
            {  0                       nb_lemin($MXMED),nb_lemax($MXMED),
            {  0                       nb_dle($MXMED),nb_dlei($MXMED),
            {  0                       log_ap($MXMED);
            {  0    $REAL    nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lemax,
            {  0             nb_dle,nb_dlei,log_ap;
            {  0    $INTEGER nb_idata;
            {  0  };
               0
               0  REPLACE {$NRC-PAIR-NXX} WITH {65};
               0  REPLACE {$NRC-PAIR-NEE} WITH {84};
               0  REPLACE {$NRC-PAIR-NX-1} WITH {64};
               0  REPLACE {$NRC-PAIR-NE-1} WITH {83};
               0
               0  REPLACE {;COMIN/NRC-PAIR-DATA/;} WITH {;
            {  0      common/nrc_pair/ nrcp_fdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_wdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_idata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_xdata($NRC-PAIR-NXX),
            {  0                       nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0      $REAL            nrcp_fdata,nrcp_wdata,nrcp_xdata,
            {  0                       nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0      $INTEGER         nrcp_idata;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** TRIPLET DATA                                                        "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MAX_TRIPLET} WITH {250}
               0  REPLACE {;COMIN/TRIPLET-DATA/;} WITH {;
            {  0          common/triplet_data/ a_triplet($MAX_TRIPLET,$MXMED),
            {  0                               b_triplet($MAX_TRIPLET,$MXMED),
            {  0                               dl_triplet, dli_triplet, bli_triplet, log_4rm;
            {  0          $REAL                a_triplet,b_triplet,dl_triplet, dli_triplet,
            {  0                               bli_triplet, log_4rm;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** COMPTON-DATA -- Incoherent scattering data                          "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MXTOTSH}   WITH {1538} "Total number of shells for Z=1..100    "
               0  REPLACE {$MXMDSH}    WITH {200}   "Max. number of shells per medium       "
               0  REPLACE {$INCOHUNIT} WITH {i_incoh}   "Unit number for compton data           "
               0
               0  REPLACE {;COMIN/COMPTON-DATA/;} WITH
               0  {
            {  0    ;common/compton_data/ iz_array($MXTOTSH), "Atomic number for each shell"
            {  0                          be_array($MXTOTSH), "Shell binding energies      "
            {  0                          Jo_array($MXTOTSH), "Compton profile parameter   "
            {  0                          erfJo_array($MXTOTSH),"needed for the calculation"
            {  0                                              "of the incoherent scattering"
            {  0                                              "function                    "
            {  0                          ne_array($MXTOTSH), "Occupation number           "
            {  0                          shn_array($MXTOTSH),"shell type                  "
            {  0                                              "(=1     for K,              "
            {  0                                              " =2,3,4 for L1,L2,L3        "
            {  0                                              " =5     for M               "
            {  0                                              " =6     for N               "
            {  0                                              " =7     for all others      "
            {  0                          shell_array($MXMDSH,$MXMED),
            {  0                          eno_array($MXMDSH,$MXMED),
            {  0                          eno_atbin_array($MXMDSH,$MXMED),
            {  0                          n_shell($MXMED),
            {  0                          radc_flag,          "flag for radiative corrections"
            {  0                          ibcmp($MXREG);      "flag to turn on binding effects"
            {  0     $INTEGER             iz_array,ne_array,shn_array,eno_atbin_array,
            {  0                          shell_array,n_shell,radc_flag;
            {  0     $REAL                be_array,Jo_array,erfJo_array,eno_array;
            {  0     $SHORT_INT           ibcmp;
            {  0  }
               0
               0
               0  "------------------------------------------------------------------ "
               0  "*** EDGE -- Containes binding energies for K,L1,L2,L3,             "
               0  "             'average' M and 'average' N shells; photo-absorption  "
               0  "             interaction probabilities with these shells;          "
               0  "             + fluorescence, Auger, Coster-Kronig transition       "
               0  "             probabilities                                         "
               0  "             IEDGFL is a flag for turning on/off atomic relaxations"
               0  "             IPHTER is a flag for turning on/off photo-lectron     "
               0  "                    angular distribution                           "
               0  "             both are left-overs from the previous coding          "
               0  "             Have put now also data to calculate elemental PE      "
               0  "             cross sections needed to sample the element the photon"
               0  "             is interacting with.
               0  "------------------------------------------------------------------ "
               0  REPLACE {$MXELEMENT} WITH {100}  " Number of elements               "
               0  REPLACE {$MXSHXSEC}  WITH {30}   " Number of shells available       "
               0  REPLACE {$MXSHELL}   WITH {6}    " Number of shells treated         "
               0  REPLACE {$MXINTER}   WITH {5}    " $MXSHELL-1                       "
               0  REPLACE {$MXTRANS}   WITH {39}   " Number of possible transitions   "
               0  REPLACE {$MXEDGE}    WITH {16}   " max. number of edges above 1 keV "
               0  REPLACE {$PHOTOUNIT} WITH {i_photo_relax} " unit number for photo_relax.data "
               0  REPLACE {$PHOCSUNIT} WITH {i_photo_cs}   " unit number for photo_cs.data    "
               0
               0  REPLACE {;COMIN/EDGE/;} WITH
               0  {;
            {  0     COMMON/EDGE/binding_energies($MXSHXSEC,$MXELEMENT),
            {  0                 interaction_prob($MXSHELL,$MXELEMENT),
            {  0                 relaxation_prob($MXTRANS,$MXELEMENT),
            {  0                 edge_energies($MXEDGE,$MXELEMENT),
            {  0                 edge_number($MXELEMENT),
            {  0                 edge_a($MXEDGE,$MXELEMENT),
            {  0                 edge_b($MXEDGE,$MXELEMENT),
            {  0                 edge_c($MXEDGE,$MXELEMENT),
            {  0                 edge_d($MXEDGE,$MXELEMENT),
            {  0                 IEDGFL($MXREG),IPHTER($MXREG);
            {  0     $REAL       binding_energies, " K,L1,L2,L3,M,N binding energies  "
            {  0                 interaction_prob, " prob. for interaction with one of"
            {  0                                   " the above shells (provided photon"
            {  0                                   " energy is above be)              "
            {  0                 relaxation_prob,  " relaxation probabilities         "
            {  0                 edge_energies,    " photo-absorption edge energies   "
            {  0                 edge_a,edge_b,edge_c,edge_d;
            {  0                                   " photo cross section fit parameters "
            {  0     $SHORT_INT  IEDGFL,  "flag for switching on fluorscent emission"
            {  0                 IPHTER;  "flag for switching on photo-electron angular distr."
            {  0     $INTEGER    edge_number; " number of `edges' for each element"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** ELECIN--ELECTRON TRANSPORT INPUT                              "
               0  "        MODIFIED 1989/12/19 TO INCLUDE IUNRST,EPSTFL AND IAPRIM   "
               0  "        NRC DWOR                                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/ELECIN/;} WITH
               0  {;
            {  0     COMMON/ELECIN/
            {  0     esig_e($MXMED),psig_e($MXMED),
            {  0     esige_max, psige_max,
            {  0     range_ep(0:1,$MXEKE,$MXMED),
            {  0     E_array($MXEKE,$MXMED),
            {  0     $LGN(etae_ms,etap_ms,q1ce_ms,q1cp_ms,q2ce_ms,q2cp_ms,
            {  0          blcce($MXEKE,$MXMED)/0,1/),
            {  0     $LGN(EKE($MXMED)/0,1/),
            {  0     $LGN(XR0,TEFF0,BLCC,XCC($MXMED)),
            {  0     $LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,TMXS($MXEKE,$MXMED)/0,1/),
            {  0     expeke1($MXMED),
            {  0     IUNRST($MXMED),EPSTFL($MXMED),IAPRIM($MXMED),
            {  0     sig_ismonotone(0:1,$MXMED);
            {  0     $REAL    esig_e,        "maximum electron cross section per energy loss"
            {  0                             "for each medium"
            {  0              psig_e,        "maximum positron cross section per energy loss"
            {  0                             "for each medium"
            {  0              esige_max,     "maximum electron cross section per energy loss"
            {  0              psige_max,     "maximum electron cross section per energy loss"
            {  0              range_ep,      "electron (0) or positron (1) range"
            {  0              E_array,       "table energies"
            {  0              etae_ms0,etae_ms1,
            {  0                             "for interpolation of screening parameter (e-)"
            {  0              etap_ms0,etap_ms1,
            {  0                             "for interpolation of screening parameter (e+)"
            {  0              q1ce_ms0,q1ce_ms1,
            {  0                            "for interpolation of q1 correction due to spin (e-)"
            {  0              q1cp_ms0,q1cp_ms1,
            {  0                            "for interpolation of q1 correction due to spin (e+)"
            {  0              q2ce_ms0,q2ce_ms1,
            {  0                            "for interpolation of q2 correction due to spin (e-)"
            {  0              q2cp_ms0,q2cp_ms1,
            {  0                            "for interpolation of q2 correction due to spin (e+)"
            {  0              blcce0,blcce1,"for interpolation of scattering power correction   "
            {  0                            "necessary to account for scattering already taken  "
            {  0                            "into account in discrete Moller/Bhabha             "
            {  0              expeke1,       "Exp(1/eke1)-1"
            {  0              $LGN(EKE/0,1/),"table for kinetic energy indexing"
            {  0              XR0,           "unused, but read in HATCH"
            {  0              TEFF0,         "unused, but read in HATCH"
            {  0              BLCC,          "b lower case sub c"
            {  0              XCC,           "chi sub-c-c"
            {  0              ESIG0,ESIG1,   "used for electron cross section interpolation"
            {  0              PSIG0,PSIG1,   "used for positron cross section interpolation"
            {  0              EDEDX0,EDEDX1, "used for electron dE/dx interpolation"
            {  0              PDEDX0,PDEDX1, "used for positron dE/dx interpolation"
            {  0              EBR10,EBR11,   "used for e- branching into brems interpolation"
            {  0              PBR10,PBR11,   "used for e+ branching into brems interpolation"
            {  0              PBR20,PBR21,   "used for e+ branching into Bhabha interpolation"
            {  0              TMXS0,TMXS1;   "used for maximum step-size interpolation"
            {  0     $INTEGER IUNRST,        "flag for type of stopping power (see PEGS4)"
            {  0              EPSTFL,        "flag for ICRU37 collision stopping powers"
            {  0              IAPRIM;        "flag for ICRU37 radiative stopping powers"
            {  0     $LOGICAL sig_ismonotone;"true, if cross section is an increasing function"
            {  0                             "of energy, false otherwise"
            {  0  }
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common block for EII data -----------------                  "
               0  "
               0  " Added by Iwan Kawrakow, March 20 2004.
               0  "                                                                           "
               0  "****************************************************************************
               0
               0  REPLACE {$MAX_EII_SHELLS} WITH {40};  "Maximum number of shells participating"
               0                                        "in EII in a simulation                "
               0  REPLACE {$N_EII_BINS} WITH {250};     "Number of bins for EII x-section      "
               0                                        "interpolations                        "
               0  REPLACE {$MAX_EII_BINS} WITH {{COMPUTE $N_EII_BINS*$MAX_EII_SHELLS}};
               0  "We store the EII x-section interpolation coefficients in 1D arrays  "
               0  "The above is the dimension of these arrays required to hold the data"
               0  REPLACE {;COMIN/EII-DATA/;} WITH {;
            {  0      common/eii_data/
            {  0          eii_xsection_a($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0          eii_xsection_b($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0          eii_cons($MXMED),
            {  0          eii_a($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0          eii_b($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0          eii_L_factor,                  "L-shell EII xsection scaling factor"
            {  0          eii_z($MAX_EII_SHELLS),        "Z of each shell                   "
            {  0          eii_sh($MAX_EII_SHELLS),       "shell type (1=K, 2=LI, eyc.)      "
            {  0          eii_nshells($MXELEMENT),       "No. of EII shells for each element"
            {  0          eii_nsh($MXMED),               "No. of EII shells for each medium "
            {  0          eii_first($MXMED,$MXEL),       "First EII shell in the list of shells"
            {  0          eii_no($MXMED,$MXEL),          "N. of EII shells                  "
            {  0          eii_flag;                      "EII flag                          "
            {  0                                         "         = 0 => no EII            "
            {  0                                         "         = 1 => simple EII        "
            {  0                                         "         > 1 => future use        "
            {  0      $REAL     eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_factor;
            {  0      $INTEGER  eii_z,eii_sh,eii_nshells;
            {  0      $INTEGER  eii_first,eii_no;
            {  0      $INTEGER  eii_elements,eii_flag,eii_nsh;
            {  0  };
               0
               0  REPLACE {$COMIN-EII-SAMPLE;} WITH {
            {  0      ;COMIN/EPCONT,EII-DATA,EGS-VARIANCE-REDUCTION,RANDOM,STACK,THRESH,
            {  0             UPHIOT,USEFUL,EGS-IO,RELAX-DATA/;
            {  0  };
               0  REPLACE {$COMIN-EII-INIT;} WITH {
            {  0      ;COMIN/BREMPR,EDGE,EGS-IO,EII-DATA,ELECIN,MEDIA,THRESH,USEFUL/;
            {  0  };
               0
               0  REPLACE {;COMIN/EMF-INPUTS/;} WITH {;
            {  0      common/emf_inputs/ExIN,EyIN,EzIN, "E field"
            {  0                       EMLMTIN,         "Ekin, u, E fractional maximum change"
            {  0                       BxIN, ByIN, BzIN,       "B field: initial region"
            {  0                       Bx, By, Bz,             "B field: current region"
            {  0                       Bx_new, By_new, Bz_new, "B field: in new region"
            {  0                       emfield_on;             "true if EM fields not null"
            {  0
            {  0     $REAL    ExIN,EyIN,EzIN,
            {  0              EMLMTIN,
            {  0              BxIN,ByIN,BzIN,
            {  0              Bx,By,Bz,
            {  0              Bx_new,By_new,Bz_new;
            {  0     $LOGICAL emfield_on;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " The following common block is made available to the user so that  "
               0  " he/she knows which shell was being relaxed when the call to ausgab"
               0  " occured                                                           "
               0  " Added by Iwan Kawrakow, March 22 2004.                            "
               0
               0  REPLACE {;COMIN/RELAX-USER/;} WITH {;
            {  0     common/user_relax/ u_relax,ish_relax,iZ_relax;
            {  0     $REAL              u_relax;
            {  0     $INTEGER           ish_relax, iZ_relax;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common blocks for EADL relaxation data -----------------     "
               0  "
               0  " Added by Ernesto Mainegra, June 1st 2011.                                 "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "shell in one long list, avoiding repetition (i.e. if an element is present"
               0  "in different materials, its shell structure and information will be stored"
               0  "only once in the list). The array shell_eadl(Z,i) tells us the position of"
               0  "the i'th shell of element Z in the long shell list.                       "
               0  "***************************************************************************"
               0
               0  REPLACE {$MXESHLL} WITH {30}     "max. number of shells for an element"
               0  REPLACE {$MAXSHELL} WITH {3000}  "max. number of shells"
               0  REPLACE {$MAXRELAX} WITH {10000} "max. number of relaxations channels"
               0  REPLACE {$MAXVAC} WITH {100}     "max. number of vacancies"
               0  REPLACE {$MAXTRANS} WITH {300}   "max. number of transitions per element"
               0  "============================================================"
               0  " Set input key 'Atomic relaxations' to 'simple' to recover original
               0  " implementation which allows photoelectric interactions with <M> and
               0  " <N> shells. See below for details on the shells considered by different
               0  " interactions depending on the value of eadl_relax:
               0  "
               0  "      Interaction        .false.             .true.
               0  "      -----------------------------------------
               0  "      Compton                all available shells
               0  "      EII                K,L1..L3            K,L1..L3
               0  "      Photoeffect        K,L1..L3,<M>,<N>    K,L1..L3
               0  "      Shellwise
               0  "      Photoeffect             N/A      All shells > $RELAX-CUTOFF
               0  "      Relaxation
               0  "        initial vacancy  K,L1..L3,<M>        K,L1..L3
               0  "        (for new photoeffect)                K, L1..L3, M1..M5, N1..N4
               0  "        final vacancy    L1..L3,<M>,<N>      L1..L3,M1..M5,N1..N7...
               0  "
               0  "============================================================"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/SHELL-DATA/;} WITH {;
            {  0
            {  0    common/shell_data/
            {  0      shell_be($MAXSHELL),      "binding energies"
            {  0      shell_type($MAXSHELL),    "shell type according to EADL notation"
            {  0      shell_num($MAXSHELL),     "the shell position in the element"
            {  0      shell_Z($MAXSHELL),       "Z of the element the shell belongs to"
            {  0      shell_eadl($MXELEMENT,$MXESHLL), "global index for a shell of element Z"
            {  0      shell_ntot;               "total number of shells in the list"
            {  0    $REAL    shell_be;
            {  0    $INTEGER shell_type,shell_Z,shell_ntot,shell_num,shell_eadl;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-DATA/;} WITH {;
            {  0
            {  0    common/relax_data/
            {  0      relax_first($MAXSHELL),    "first transition"
            {  0      relax_ntran($MAXSHELL),    "number of transitions"
            {  0      relax_state($MAXRELAX),    "final state of the transition"
            {  0      relax_prob($MAXRELAX),     "probability"
            {  0      relax_atbin($MAXRELAX),    "used for alias sampling"
            {  0      relax_ntot;                "total number of transitions in the list"
            {  0    $REAL     relax_prob;
            {  0    $INTEGER  relax_first, relax_ntran, relax_state, relax_atbin, relax_ntot;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-FOR-USER/;} WITH {;
            {  0      common/relax_for_user/
            {  0       rfu_E0, "binding energy of vacancy that initiated cascade"
            {  0       rfu_E,  "binding energy of current vacancy"
            {  0       rfu_Z,  "Atomic number of the element the relaxing shell belongs to"
            {  0       rfu_j0, "shell numb. of vacancy that initiated cascade in the list"
            {  0       rfu_n0, "same but number is shell number in the element"
            {  0       rfu_t0, "same but number is shell type according to EADL notation"
            {  0       rfu_j,  "shell number of current vacancy"
            {  0       rfu_n,  "same but number is shell number in the element"
            {  0       rfu_t;  "same but number is shell type according to EADL notation"
            {  0      $INTEGER rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t;
            {  0      $REAL    rfu_E0,rfu_E;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0  RELAX-DATA,SHELL-DATA/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-EADL;} WITH {
            {  0  ;COMIN/RELAX-DATA,RELAX-FOR-USER,SHELL-DATA,
            {  0  STACK,THRESH,EPCONT,USEFUL,UPHIOT,RANDOM,BOUNDS,EGS-IO,MISC,MEDIA,
            {  0  X-OPTIONS/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " -------------- shell-wise photoelectric cross section data ------------   "
               0  "
               0  " Cross sections taken from Sabbatucci and Salvat,                          "
               0  " Theory and calculation of the atomic photoeffect                          "
               0  " Radiat. Phys. and Chem., Volume 121, April 2016, Pages 122-140            "
               0  "                                                                           "
               0  "***************************************************************************"
               0  " Shell-wise photoelectric cross sections from 50 eV up to 1 GeV for elements
               0  " from Z=1 up to Z=99. All K, L, M, and N shells are included. One can define
               0  " a threshold energy separating inner from outer shells. By default this
               0  " energy is set to 1 keV, but for accurate calculation of quantities that  "
               0  " require knowledge of which particle deposited the energy, one might need to
               0  " use the a lower threshold.
               0  "***************************************************************************"
               0  "============================================================"
               0  REPLACE {$RELAX-CUTOFF} WITH {0.001D0"threshold energy for outer shells"}
               0  REPLACE {$MXPESHELL} WITH {16} "K,L1..L3,M1..M5,N1..N7 + outer shell"
               0  REPLACE {$MXNE} WITH {500}     "number of energy points per shell "
               0  "============================================================"
               0  REPLACE {;COMIN/PE-SHELL-DATA/;} WITH {;
            {  0
            {  0    common/pe_shell_data/
            {  0      pe_xsection($MXNE,$MXELEMENT,0:$MXPESHELL),  "shellwise cross sections"
            {  0      pe_elem_prob($MXNE,$MXELEMENT,$MXMED), "prob. of interaction with an"
            {  0                                             "element of a medium"
            {  0      pe_energy($MXNE,$MXELEMENT),    "energy grid"
            {  0      pe_zsorted($MXELEMENT,$MXMED),"sorted array of Z for each medium"
            {  0      pe_be($MXELEMENT,$MXPESHELL),      "binding energies"
            {  0      pe_nshell($MXELEMENT),       "number of shells for each element"
            {  0      pe_zpos($MXELEMENT),       "position of each Z element"
            {  0      pe_nge($MXELEMENT),       "number of energy points for each element"
            {  0      pe_ne;                    "number of elements in the simulation"
            {  0    $REAL    pe_be, pe_energy, pe_xsection, pe_elem_prob;
            {  0    $INTEGER pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-SHELLWISE-PE-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0      PE-SHELL-DATA/;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " Some macros for C-style syntax in mortran "
               0  " Unfortunately, /= doesn't work because of /v1,v2,...,vn/=value;"
               0
               0  REPLACE {;#+=#;} WITH { ;{P1} = {P1} + {P2}; }
               0  REPLACE {[#+=#;} WITH { {P1} = {P1} + {P2}; }
               0
               0  REPLACE {;#-=#;} WITH { ;{P1} = {P1} - {P2}; }
               0  REPLACE {[#-=#;} WITH { {P1} = {P1} - {P2}; }
               0
               0  REPLACE {;#*=#;} WITH { ;{P1} = {P1}*{P2}; }
               0  REPLACE {[#*=#;} WITH { {P1} = {P1}*{P2}; }
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/ET-Control/;} WITH  "ET stands for Electron Transport"
               0  {
            {  0    ;common/ET_control/
            {  0                smaxir($MXREG),estepe,ximax,
            {  0                "ximin_for_bca,"
            {  0                skindepth_for_bca,transport_algorithm,
            {  0                bca_algorithm,exact_bca,spin_effects;
            {  0      $REAL     smaxir,             "geom. step-size constrain for each region"
            {  0                estepe,             "global energy loss constrain"
            {  0                ximax,              "max. first GS moment per step"
            {  0                                    "(roughly half the average MS angle squared"
            {  0                "ximin_for_bca,"
            {  0                                    "min. first GS moment per step for boundary"
            {  0                                    "crossing in VMC mode"
            {  0                skindepth_for_bca;  "distance from a boundary (in elastic MFP)"
            {  0                                    "to switch to one of the BCAs "
            {  0      $INTEGER  transport_algorithm,"=$PRESTA-II or $PRESTA--I"
            {  0                bca_algorithm;      "will be used if other inexact BCAs"
            {  0                                    "implemented in the future"
            {  0      $LOGICAL  exact_bca,          "if .true. => BCA in single scattering mode"
            {  0                spin_effects;       "if .true. electron/positron spin effects"
            {  0                                    "are taken into account in the single and"
            {  0                                    "multiple elasting scattering routines"
            {  0  }
               0  ;
               0
               0  " ======================== multiple scattering commons ================= "
               0
               0  " Screened Rutherford MS data "
               0
               0  REPLACE {$MAXL_MS}    WITH {63}
               0  REPLACE {$MAXQ_MS}    WITH {7}
               0  REPLACE {$MAXU_MS}    WITH {31}
               0  REPLACE {$0-MAXL_MS}  WITH {0:63}
               0  REPLACE {$0-MAXQ_MS}  WITH {0:7}
               0  REPLACE {$0-MAXU_MS}  WITH {0:31}
               0  REPLACE {$LAMBMIN_MS} WITH {1.}
               0  REPLACE {$LAMBMAX_MS} WITH {1e5}
               0  REPLACE {$QMIN_MS}    WITH {1e-3}
               0  REPLACE {$QMAX_MS}    WITH {0.5}
               0
               0  REPLACE {COMIN/MS-Data/;} WITH {
            {  0    common/ms_data/
            {  0                ums_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                fms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                wms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                ims_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0    real*4      ums_array,fms_array,wms_array,
            {  0                llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0    $SHORT_INT  ims_array;
            {  0  }
               0  ;
               0
               0  " spin effect data used in an additional rejection loop "
               0
               0  REPLACE {$MAXE_SPIN}   WITH {15}
               0  REPLACE {$MAXE_SPI1}   WITH {{COMPUTE 2*$MAXE_SPIN+1}}
               0  REPLACE {$MAXQ_SPIN}   WITH {15}
               0  REPLACE {$MAXU_SPIN}   WITH {31}
               0  REPLACE {$0-MAXE_SPI1} WITH {0:$MAXE_SPI1}
               0  REPLACE {$0-MAXQ_SPIN} WITH {0:$MAXQ_SPIN}
               0  REPLACE {$0-MAXU_SPIN} WITH {0:$MAXU_SPIN}
               0
               0  REPLACE {COMIN/Spin-Data/;} WITH {
            {  0    common/spin_data/
            {  0                spin_rej($MXMED,0:1,$0-MAXE_SPI1,$0-MAXQ_SPIN,$0-MAXU_SPIN),
            {  0                espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0                dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i,
            {  0                fool_intel_optimizer;
            {  0    real*4      spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0                dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i;
            {  0    $LOGICAL    fool_intel_optimizer;
            {  0  }
               0  ;
               0
               0  REPLACE {COMIN/CH-Steps/;} WITH
               0  {
            {  0    common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step;
            {  0    real*8           count_pII_steps,count_all_steps;
            {  0    $LOGICAL         is_ch_step;
            {  0  }
               0  ;
               0  "------------------------------------------------------------------"
               0  "*** EPCONT--ELECTRON-PHOTON CONTROL VARIABLES                     "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/EPCONT/;} WITH
               0  {;
            {  0    COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP,
            {  0                  RHOF,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE,
            {  0                  x_final,y_final,z_final,
            {  0                  u_final,v_final,w_final,
            {  0                  IDISC,IROLD,IRNEW,IAUSFL($MXAUS);
            {  0      $ENERGY PRECISION EDEP,   "energy deposition in MeV"
            {  0                        EDEP_LOCAL; "local energy deposition in MeV"
            {  0      $REAL             TSTEP,  "distance to a discrete interaction"
            {  0                        TUSTEP, "intended step length, befor check with geometry"
            {  0                        USTEP,  "transport distance calculated from TUSTEP"
            {  0                        VSTEP,  "transport distance after truncation by HOWFAR"
            {  0                        TVSTEP, "curved path-length calculated from TVSTEP"
            {  0                        RHOF,   "mass density ratio"
            {  0                        EOLD,   "energy before deduction of energy loss"
            {  0                        ENEW,   "energy after  deduction of energy loss"
            {  0                        EKE,    "kinetic energy"
            {  0                        ELKE,   "Log(EKE)"
            {  0                        GLE,    "Log(energy) in PHOTON"
            {  0                        E_RANGE,"range of electron before an iarg=0 ausgab call"
            {  0                        x_final,y_final,z_final, "position at end of step"
            {  0                        u_final,v_final,w_final; "direction at end of step"
            {  0                                                 "only set (and relevant) "
            {  0                                                 "for electrons"
            {  0      $INTEGER          IDISC,  "flag indicating user discard"
            {  0                        IROLD,  "region before transport"
            {  0                        IRNEW,  "region after transport"
            {  0                        IAUSFL; "flags for AUSGAB calls"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MEDIA--NAMES OF MEDIA CURRENTLY BEING USED                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MEDIA/;} WITH
               0  {;
            {  0     COMMON/MEDIA/
            {  0  "Ali:photonuc, 4 lines (order matters because of padding issues)"
            {  0         $LGN(RLC,RLDU,RHO,MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,
            {  0              IRAYLM,IPHOTONUCM($MXMED)),
            {  0              MEDIA(24,$MXMED), photon_xsections, comp_xsections,
            {  0              photonuc_xsections,eii_xfile,IPHOTONUC,NMED;
            {  0     $TYPE    MEDIA;"media names"
            {  0     $REAL    RLC,  "radiation length in centimeters for a given medium"
            {  0              RLDU, "radiation length after user scaling over-ride"
            {  0              RHO,  "mass density of a given medium"
            {  0              apx, upx;"new photon xsection data thresholds"
            {  0     $INTEGER MSGE, "??? "
            {  0              MGE,  "number of photon mapped energy intervals for a given medium"
            {  0              MSEKE,"??? "
            {  0              MEKE, "number of e mapped energy intervals for a given medium"
            {  0              MLEKE,"??? "
            {  0              MCMFP,"??? "
            {  0              MRANGE,"??? "
            {  0              IRAYLM,"Rayleigh switch for a given medium"
            {  0  "Ali:photonuc, 2 lines"
            {  0              IPHOTONUCM,"photonuclear switch for a given medium"
            {  0              IPHOTONUC,"set to 1 if any IPHOTONUCM is set to 1"
            {  0              NMED;  "number of media"
            {  0     character*16 eii_xfile;
            {  0              "Defaults to eii_ik.data if On or Off options selected"
            {  0              "which is the EII implemented by Iwan for EGSnrc"
            {  0              "else, following options available: "
            {  0              "  eii_'casnati'.data    "
            {  0              "  eii_'kolbenstvedt'.data "
            {  0              "  eii_'gryzinski'.data"
            {  0              "these must be in $HEN_HOUSE/data"
            {  0     character*16 photon_xsections;
            {  0              "If photon_xsections is not empty, photon cross sections will be"
            {  0              "re-initialized using data files  "
            {  0              "  'photon_xsection'_photo.data   "
            {  0              "  'photon_xsection'_pair.data    "
            {  0              "  'photon_xsection'_triplet.data "
            {  0              "  'photon_xsection'_rayleigh.data"
            {  0              "that must be placed in $HEN_HOUSE/data"
            {  0     character*16 comp_xsections;
            {  0              "If comp_xsections is not empty or not set to 'default' and"
            {  0              "bound Compton scattering is On, then total Compton cross sections"
            {  0              "will be taken from 'comp_xsections'_compton.data"
            {  0              "instead of being computed from the theoretical expressions"
            {  0  "Ali:photonuc, 5 lines"
            {  0     character*16 photonuc_xsections;
            {  0              "If photonuc_xsections is not empty or not set to 'default',"
            {  0              "the photonuclear cross sections will be taken from"
            {  0              "'photonuc_xsections'_photonuc.data instead of using the data"
            {  0              "in the default file iaea_photonuc.data."
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MISC--MISCELLANEOUS COMMON                                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MISC/;} WITH
               0  {;
            {  0    COMMON/MISC/
            {  0  "Ali:photonuc, 1 line"
            {  0             DUNIT,KMPI,KMPO,$LGN(RHOR,MED,IRAYLR,IPHOTONUCR($MXREG));
            {  0    $REAL    DUNIT,   "unit scaling factor"
            {  0             RHOR;    "density of a given region"
            {  0    $INTEGER KMPI,    "fortran unit number of the pegs4 datafile"
            {  0             KMPO;    "fortran unit number of pegs4 echo file"
            {  0    $SHORT_INT MED,   "medium number for a given region"
            {  0               IRAYLR,"Rayleigh switch for a given region"
            {  0  "Ali:photonuc, 1 line"
            {  0               IPHOTONUCR;"photonuclear switch for a given region"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** PHOTIN--PHOTON TRANSPORT DATA                                 "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/PHOTIN/;} WITH
               0  {;
            {  0      COMMON/PHOTIN/
            {  0         EBINDA($MXMED),
            {  0         $LGN(GE($MXMED)/0,1/),
            {  0         $LGN(GMFP,GBR1,GBR2($MXGE,$MXMED)/0,1/),
            {  0         $LGN(RCO($MXMED)/0,1/),
            {  0         $LGN(RSCT($MXRAYFF,$MXMED)/0,1/),
            {  0         $LGN(COHE($MXGE,$MXMED)/0,1/),
            {  0  "Ali:photonuc, 1 line"
            {  0         $LGN(PHOTONUC($MXGE,$MXMED)/0,1/),
            {  0         DPMFP,
            {  0         MPGEM($MXSGE,$MXMED),
            {  0         NGR($MXMED);
            {  0      $REAL
            {  0         EBINDA,      "energy of the K-edge for a given medium"
            {  0         GE0,GE1,     "used for indexing in logarithmic interpolations"
            {  0         GMFP0,GMFP1, "used for gamma MFP interpolation"
            {  0         GBR10,GBR11, "used for branching into pair interpolation"
            {  0         GBR20,GBR21, "used for branching into Compton interpolation"
            {  0         RCO0,RCO1,   "used for indexing in momentum trans. sampling in Rayleigh"
            {  0         RSCT0,RSCT1, "used for interpolation of momentum trans. func. in R"
            {  0         COHE0,COHE1, "used for Rayleigh modification interpolation"
            {  0  "Ali:photonuc, 1 line"
            {  0         PHOTONUC0,PHOTONUC1, "used for photonuclear modification interpolation"
            {  0         DPMFP;       "number of MFP's to go to the next interaction"
            {  0      $INTEGER
            {  0         MPGEM,       "??? "
            {  0         NGR;         "array size for Rayleigh scattering data"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** RANDOM - DECLARATIONS FOR RANDOM NUMBER GENERATOR             "
               0  "------------------------------------------------------------------"
               0
               0  " Note that the definition of the COMIN/RANDOM/ was taken out of   "
               0  " the egsnrc.macros file. The current philosophy is that the user  "
               0  " has to provide a random number generator in a separate file.     "
               0  " Two commonly used RNGs are provided in separate files:           "
               0  "  RANLUX: ranlux.macros and ranlux.mortran                        "
               0  "  RANMAR: ranmar.macros and ranmar.mortran                        "
               0
               0
               0  "------------------------------------------------------------------"
               0  "*** STACK--INFORMATION KEPT ABOUT CURRENT PARTICLES               "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/STACK/;} WITH
               0  {;
            {  0     COMMON/STACK/
            {  0         $LGN(E,X,Y,Z,U,V,W,DNEAR,WT,IQ,IR,LATCH($MXSTACK)),
            {  0         LATCHI,NP,NPold;
            {  0     $ENERGY PRECISION
            {  0         E;     "total particle energy"
            {  0     $REAL
            {  0         X,Y,Z, "particle co-ordinates"
            {  0         U,V,W, "particle direction cosines"
            {  0         DNEAR, "perpendicular distance to nearest boundary"
            {  0         WT;    "particle weight"
            {  0     $INTEGER
            {  0         IQ,    "charge, -1 for electrons, 0 for photons, 1 for positrons"
            {  0         IR,    "current region"
            {  0         LATCH, "extra phase space variable"
            {  0         LATCHI,"needed because shower does not pass latch-BLOCK DATA sets 0"
            {  0         NP,    "stack pointer"
            {  0         NPold; "stack pointer before an interaction"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** THRESH--THRESHOLD (AND OTHER) ENERGIES                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/THRESH/;} WITH
               0  {;
            {  0     COMMON/THRESH/RMT2,RMSQ,
            {  0                   $LGN(AP,AE,UP,UE,TE,THMOLL($MXMED));
            {  0     $REAL         RMT2,  "2*electron mass in MeV"
            {  0                   RMSQ,  "electron mass squared in MeV**2"
            {  0                   AP,    "photon creation threshold energy"
            {  0                   AE,    "electron creation threshold energy (total)"
            {  0                   UP,    "upper photon energy in PEGS4 data set"
            {  0                   UE,    "upper electron energy in PEGS4 data set"
            {  0                   TE,    "electron creation threshold energy (kinetic)"
            {  0                   THMOLL;"Moller threshold = AE + TE"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIIN--SINE TABLES FOR UPHI                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIIN/;} WITH
               0  {;
            {  0     COMMON/UPHIIN/SINC0,SINC1,$LGN(SIN($MXSINC)/0,1/);
            {  0     $REAL         SINC0,SINC1,SIN0,SIN1;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIOT--UPHI'S INPUT/OUTPUT WITH ITS USERS                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIOT/;} WITH
               0  {;
            {  0     COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI,
            {  0                   COSPHI,PI,TWOPI,PI5D2;
            {  0     $REAL         THETA,  "polar scattering angle"
            {  0                   SINTHE, "sin(THETA)"
            {  0                   COSTHE, "cos(THETA)"
            {  0                   SINPHI, "sine of the azimuthal scattering angle"
            {  0                   COSPHI, "cosine of the azimuthal scattering angle"
            {  0                   PI,TWOPI,PI5D2;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USEFUL--HEAVILY USED VARIABLES                                "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USEFUL/;} WITH
               0  {;
            {  0     COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD;
            {  0     $ENERGY PRECISION PZERO,   "precise zero"
            {  0                       PRM,     "precise electron mass in MeV"
            {  0                       PRMT2;   "2*PRM"
            {  0     $REAL             RM;      "electron mass in MeV"
            {  0     $INTEGER          MEDIUM,  "medium index of current region"
            {  0                       MEDOLD;  "medium index of previous region"
            {  0     " The rest mass value is as recommended by CODATA 2014"
            {  0     " http://physics.nist.gov/cgi-bin/cuu/Value?mec2mev"
            {  0     DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D0/;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USER--A COMMON FOR THE 'USER' TO 'USE'                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USER/;} WITH {
            {  0           ;}  "DEFAULT IS NULL"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/X-OPTIONS/;} WITH {
            {  0      ;
            {  0    common/x_options/eadl_relax,       "Use EADL relaxation"
            {  0                     mcdf_pe_xsections;"Use Sabbatucci and Salvat PE xsections"
            {  0    $LOGICAL  eadl_relax, mcdf_pe_xsections;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** MACROS TO DEFINE THE COMMONS USED IN EACH SUBPROGRAM.         "
               0  "------------------------------------------------------------------"
               0  REPLACE {$COMIN-ANNIH;} WITH {
            {  0       ;COMIN/DEBUG,STACK, UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-ANNIH-ATREST;} WITH {
            {  0      ;COMIN/DEBUG,STACK,RANDOM,USEFUL,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-BHABHA;} WITH {
            {  0      ;COMIN/DEBUG,STACK, THRESH,UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,
            {  0             EGS-IO/;}
               0  REPLACE {$COMIN-BREMS;} WITH {
            {  0      ;COMIN/DEBUG,BREMPR,EPCONT,NIST-BREMS,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0             EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-COMPT;} WITH {
            {  0     ;COMIN/COMPTON-DATA,DEBUG,EPCONT,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0            EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;}
               0  REPLACE {$COMIN-ELECTR;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,ELECIN,EPCONT,MEDIA,MISC,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,CH-Steps,EGS-IO,
            {  0            EGS-VARIANCE-REDUCTION,EMF-INPUTS/;}
               0  REPLACE {$COMIN-HATCH;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,BREMPR,ELECIN,MEDIA,MISC,PHOTIN,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,EGS-IO,X-OPTIONS,
            {  0            EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-MOLLER;} WITH {
            {  0     ;COMIN/DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM,EGS-IO,
            {  0            EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-PAIR;} WITH {
            {  0     ;COMIN/DEBUG,BREMPR,NRC-PAIR-DATA,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0            EPCONT,TRIPLET-DATA,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-PHOTO;} WITH {
            {  0     ;COMIN/BOUNDS,BREMPR,DEBUG,EDGE,EPCONT,MEDIA,PHOTIN,RANDOM,
            {  0            STACK,UPHIOT,USEFUL,EGS-IO,X-OPTIONS,
            {  0            EGS-VARIANCE-REDUCTION,RELAX-DATA/;}
               0  REPLACE {$COMIN-PHOTON;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,UPHIOT,
            {  0  USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-SHOWER;} WITH {
            {  0    ;COMIN/DEBUG,STACK,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-UPHI;} WITH {
            {  0    ;COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-BLOCK;} WITH {
            {  0    ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,
            {  0    EPCONT,CH-Steps,ET-Control,MEDIA,MISC,PHOTIN,RANDOM,STACK,
            {  0    THRESH, UPHIIN,UPHIOT,USEFUL,EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-RELAX;} WITH {
            {  0    ;COMIN/EPCONT,STACK,BOUNDS,USEFUL,RANDOM,EDGE,EGS-IO,RELAX-DATA,X-OPTIONS/;}
               0  REPLACE {$COMIN-SET-DEFAULTS;} WITH {
            {  0    ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,EPCONT,CH-Steps,ET-Control,
            {  0         MEDIA,MISC,PHOTIN,RANDOM,STACK,THRESH, UPHIIN,UPHIOT,USEFUL,
            {  0         EGS-VARIANCE-REDUCTION,EGS-IO,Spin-Data,EII-DATA,rayleigh_inputs,
            {  0         EMF-INPUTS,X-OPTIONS/;};
               0  REPLACE {$COMIN-INIT-COMPT;} WITH {
            {  0    ;COMIN/COMPTON-DATA,BREMPR,EDGE,MEDIA,MISC,USEFUL,EGS-IO,X-OPTIONS/;};
               0  REPLACE {$COMIN-MSCATI;} WITH {
            {  0    ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL,EGS-IO/;};
               0  REPLACE {$COMIN-INIT-TRIPLET;} WITH {
            {  0    ;COMIN/BREMPR,EGS-IO,MEDIA,TRIPLET-DATA,USEFUL/;};
               0  REPLACE {$COMIN-GET-TRANSPORTP;} WITH {
            {  0    ;COMIN/GetInput,BOUNDS,ET-Control,EDGE,COMPTON-DATA,MEDIA,MISC,
            {  0           BREMPR,EII-DATA,EGS-IO,rayleigh_inputs,EMF-INPUTS,X-OPTIONS/;};
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$COMIN-PHOTONUC;} WITH {;COMIN/STACK,EPCONT,USEFUL/;};
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {ILOG2(#)} WITH {
            {  0      IFIX(1.44269*LOG({P1}))} "1.44269=1/LN(2)"
               0
               0  REPLACE {$SETINTERVAL#,#;} WITH {
            {  0      [IF] '{P2}'=SNAME  [L{P1}={P2}1*{P1}+{P2}0;]
            {  0      [ELSE]  [L{P1}={P2}1(MEDIUM)*{P1}+{P2}0(MEDIUM);]}
               0  "TWO ARGUMENT SET INTERVAL CALL (ABOVE) CURRENTLY MEANS"
               0  "INTERVAL INDEX IS LINEAR FUNCTION OF THE LINEAR VARIABLE,"
               0  "WITH NO MAPPING.  {P1} IS THE LINEAR VARIABLE AND {P2} IS"
               0  "THE NAME OF THE INTERVAL(WHICH IS USED TO CONSTRUCT THE"
               0  "COEFFICIENTS USED IN COMPUTING THE INTERVAL INDEX)."
               0  "BUT, IF {P2} IS SINC OR BLC OR RTHR OR RTHRI, IT DOES"
               0  "NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#);} WITH {
            {  0    [IF] '{P2}'=SNAME1
            {  0    [{P1}={P2}1(L{P3})*{P3}+{P2}0(L{P3});] [ELSE]
            {  0    [{P1}={P2}1(L{P3},MEDIUM)*{P3}+{P2}0(L{P3},MEDIUM);]}
               0  "{P1} IS VARIABLE TO BE ASSIGNED VALUE."
               0  "{P2} IS THE FUNCTION BEING APPROXIMATED."
               0  "{P3} IS THE ARGUMENT OF THE FUNCTION. IN THE CURRENT"
               0  "PWLF METHOD, THE ARGUMENT DETERMINES AN INTERVAL USING THE"
               0  "$SET INTERVAL MACROS.   WITH IN THIS INTERVAL THE"
               0  "FUNCTION IS APPROXIMATED AS A LINEAR FUNCTION OF"
               0  "THE ARGUMENT. BUT"
               0  "IF {P2}=SIN IT DOES NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#,#);} WITH {
            {  0    {P1}={P2}0(L{P3},L{P4})+{P2}1(L{P3},L{P4})*{P3}+
            {  0    {P2}2(L{P3},L{P4})*
            {  0    {P4};}"2-D APPROXIMATION INDEPENDENT OF MEDIUM"
               0  SPECIFY SNAME AS ['sinc'|'blc'|'rthr'|'rthri'|'SINC'|'BLC'|'RTHR'|'RTHRI'];
               0  SPECIFY SNAME1 AS ['sin'|'SIN'];
               0
               0  "The following circumvent the above table look up method for sin"
               0  "functions.  Modern machines do sines very quickly so the large saving"
               0  "in time from the above no longer exists for sines (was 40% on some"
               0  "machines for the overall computing time! (for example it makes a
               0  "20% effect on an SGI R4400)"
               0  "To recover the use of tables, just comment out the following two"
               0  "macros"
               0
               0  REPLACE {$EVALUATE#USING SIN(#);} WITH {{P1}=sin({P2});}
               0  REPLACE {$SET INTERVAL#,SINC;} WITH {;}
               0
               0
               0  "MACRO TO ALLOW USER TO ADD TO PROPERTIES THAT ARE"
               0  "PASSED TO NEW PARTICLES"
               0  REPLACE {$TRANSFERPROPERTIESTO#FROM#;} WITH {
            {  0      X{P1}=X{P2};Y{P1}=Y{P2};Z{P1}=Z{P2};IR{P1}=IR{P2};
            {  0      WT{P1}=WT{P2};DNEAR{P1}=DNEAR{P2};LATCH{P1}=LATCH{P2};}
               0     "IN THE USAGE OF THE ABOVE MACRO, '(IP)' WILL REFER TO THE"
               0     "PARTICLE WHOSE STACK INDEX IS 'IP'. 'NP' IS THE TOP OF THE STACK."
               0     "JUST PLAIN 'I' WILL REFER TO THE INITIAL VALUES SUPPLIED"
               0     "AS ARGUMENTS TO SHOWER, OR SUPPLIED IN COMMON BLOCKS OR"
               0     "DATA STATEMENTS IN SHOWER."
               0
               0  "Macro to check that the stack size is not exceeded"
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
            {  0        $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
            {  0            ' Increase $MXSTACK and try again ');
            {  0    ]
            {  0  };
               0
               0
               0
               0
               0
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0        $egs_fatal('(//,3a,/,2(a,i9))',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MAXSTACK = ',$MXSTACK,' np = ',{P1});
            {  0    ]
            {  0  };
               0
               0  "MACRO FOR RE-EVALUATING DEDX IN SUBROUTINE ELECTR"
               0  REPLACE {$DEDX-RE-EVALUATION;} WITH {
            {  0  ;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING MACROS ARE USED IN SUBROUTINE ELECTR IN ORDER TO MAKE"
               0  "PATH LENGTH CORRECTIONS AND RESTRICTIONS:"
               0  REPLACE {$SET-USTEP;} WITH
               0  {
            {  0    ekems = eke - 0.5*tustep*dedx; "Use mid-point energy to calculate"
            {  0                                    "energy dependent quantities"
            {  0    $CALCULATE-XI(tustep);
            {  0    IF ( xi < 0.1 )
            {  0      [
            {  0        ustep = tustep*(1 - xi*(0.5 - xi*0.166667));
            {  0      ]
            {  0      ELSE
            {  0      [
            {  0        ustep = tustep*(1 - Exp(-xi))/xi;
            {  0      ]
            {  0  }
               0  ;
               0
               0  REPLACE {$CALCULATE-XI(#);} WITH
               0  {
            {  0    p2 = ekems*(ekems+rmt2); beta2 = p2/(p2 + rmsq);
            {  0    chia2 = xccl/(4*blccl*p2);
            {  0                                  "Note that our chia2 is Moliere chia2/4"
            {  0                                  "Note also that xcc is now old egs xcc**2"
            {  0    xi = 0.5*xccl/p2/beta2*{P1};
            {  0    IF( spin_effects ) [
            {  0        elkems = Log(ekems);
            {  0        $SET INTERVAL elkems,eke;
            {  0        IF(lelec < 0) [
            {  0            $EVALUATE etap USING etae_ms(elkems);
            {  0            $EVALUATE xi_corr USING q1ce_ms(elkems);
            {  0        ]
            {  0        ELSE          [
            {  0            $EVALUATE etap USING etap_ms(elkems);
            {  0            $EVALUATE xi_corr USING q1cp_ms(elkems);
            {  0        ]
            {  0        chia2 = chia2*etap; xi = xi*xi_corr;
            {  0        $EVALUATE ms_corr USING blcce(elkems);
            {  0        blccl = blccl*ms_corr;
            {  0    ]
            {  0    ELSE [ xi_corr = 1; etap = 1; ]
            {  0    xi = xi*(Log(1+1./chia2)-1/(1+chia2));
            {  0  }
               0
               0  REPLACE {$SET-TVSTEP;} WITH
               0  "        ===========                 "
               0  {
            {  0      ;IF ( vstep < ustep0 )
            {  0      [
            {  0        ekems = eke - 0.5*tustep*vstep/ustep0*dedx;
            {  0           "This estimates the energy loss to the boundary."
            {  0           "tustep was the intended curved path-length,"
            {  0           "ustep0 is the average transport distance in the initial direction"
            {  0           "       resulting from tustep"
            {  0           "vstep = ustep is the reduced average transport distance in the "
            {  0           "              initial direction due to boundary crossing"
            {  0        $CALCULATE-XI(vstep);
            {  0        IF ( xi < 0.1 )
            {  0        [
            {  0          tvstep = vstep*(1 + xi*(0.5 + xi*0.333333));
            {  0        ]
            {  0        ELSE
            {  0        [
            {  0
            {  0          IF ( xi < 0.999999 )
            {  0          [
            {  0             tvstep = -vstep*Log(1 - xi)/xi;
            {  0          ]
            {  0          ELSE
            {  0          [
            {  0             "This is an error condition because the average transition "
            {  0             "in the initial direction of motion is always smaller than 1/Q1"
            {  0             $egs_info(*,' Stoped in SET-TVSTEP because xi > 1! ');
            {  0             $egs_info(*,' Medium: ',medium);
            {  0             $egs_info(*,' Initial energy: ',eke);
            {  0             $egs_info(*,' Average step energy: ',ekems);
            {  0             $egs_info(*,' tustep: ',tustep);
            {  0             $egs_info(*,' ustep0: ',ustep0);
            {  0             $egs_info(*,' vstep:  ',vstep);
            {  0             $egs_info(*,' ==> xi = ',xi);
            {  0             $egs_fatal(*,'This is a fatal error condition');
            {  0          ]
            {  0        ]
            {  0      ]
            {  0      ELSE
            {  0      [
            {  0        tvstep = tustep;
            {  0      ]
            {  0  }
               0  ;
               0
               0  REPLACE {$ENEPS} WITH {0.0001}
               0              "DIFFERENCE BETWEEN ECUT AND END POINT ENERGY FOR"
               0              "RANGE CALCULATION"
               0
               0  REPLACE {$EPSEMFP} WITH {1.E-8}  "SMALLEST ELECTRON MFP VALUE"
               0  REPLACE {$EPSGMFP} WITH {1.E-8}  "SMALLEST GAMMA MFP VALUE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE UTILITY AND OTHER MACROS FOR THE USER"
               0
               0  "ETALY1---COMMON BLOCK FOR ENERGY CONSERVATION PURPOSES"
               0  REPLACE {;COMIN/ETALY1/;} WITH {
            {  0      ;COMMON/ETALY1/ESUM(4,$MXREG,5);
            {  0      $ENERGY PRECISION ESUM;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "NTALY1---COMMON BLOCK FOR KEEPING COUNT OF ETALY1-EVENTS"
               0  REPLACE {;COMIN/NTALY1/;} WITH {
            {  0     ;COMMON/NTALY1/NSUM(4,$MXREG,5);
            {  0     $INTEGER NSUM;
            {  0  }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACRO TO ALLOW USER TO INITIALIZE IN SUBROUTINE HATCH"
               0  REPLACE {$HATCH-USER-INPUT-INIT;} WITH {;
            {  0  " $RNG-INITIALIZATION; "
            {  0  " Have taken this out, (IK, Jan 2000). If the user does not initilize the"
            {  0  " rng before the first call to shower, the rng will initialize itself    "
            {  0  " using the default seed and the default luxury level (which is defined  "
            {  0  " via $DEFAULT-LL).                                                      "
            {  0
            {  0  DO J=1,$MXREG [
            {  0    IF(SMAXIR(J)<=0.0) [SMAXIR(J)=1E10;]
            {  0  ]
            {  0  ;}
               0
               0  "MACRO FOR CONTROLLING NEGATIVE USTEP"
               0  REPLACE {$USER-CONTROLS-NEGATIVE-USTEP;} WITH {
            {  0  "         ============================"
            {  0     ;IF(USTEP<-1.E-4)[ IERUST=IERUST+1;OUTPUT IERUST,USTEP,IR(NP),IRNEW,
            {  0     IROLD,X(NP),Y(NP),Z(NP),SQRT(X(NP)**2+Y(NP)**2);
            {  0     (I6,' NEGATIVE USTEP=',E14.6,' IR,IRNEW,IROLD=',3I4,' X,Y,Z,R=',
            {  0     4E14.6);
            {  0     IF(IERUST>10)[OUTPUT;(///'0STOP, TOO MANY USTEP ERRORS'///); STOP;]]
            {  0     USTEP=0.0;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$CHECK-NEGATIVE-USTEP;} WITH {;
            {  0      IF(ustep <= 0) [
            {  0          "Negative ustep---probable truncation problem at a"
            {  0          "boundary, which means we are not in the region we think"
            {  0          "we are in.  The default macro assumes that user has set"
            {  0          "irnew to the region we are really most likely to be"
            {  0          "in.  A message is written out whenever ustep is less than -1.e-4"
            {  0          IF(ustep < -1e-4) [
            {  0              ierust = ierust + 1;
            {  0              OUTPUT ierust,ustep,dedx,e(np)-prm,
            {  0                     ir(np),irnew,irold,x(np),y(np),z(np);
            {  0              (i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=',F8.4,
            {  0               ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3);
            {  0              IF(ierust > 1000) [
            {  0                  OUTPUT;(////' Called exit---too many ustep errors'///);
            {  0                  $CALL_EXIT(1);
            {  0              ]
            {  0          ]
            {  0          ustep = 0;
            {  0      ]
            {  0  };
               0
               0  "MACRO FOR INTRODUCING FLUCTUATIONS IN THE ENERGY LOSS BY"
               0  "CHARGED PARTICLES (E.G., 'LANDAU FLUCTUATIONS')---DEFAULT IS NULL"
               0  REPLACE {$DE-FLUCTUATION;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "Macro for production of annihilation quanta whenever"
               0  "the energy is greater than AE but less than or equal to ECUT."
               0  "photons are always produced in EGSnrc."
               0
               0  REPLACE {$POSITRON-ECUT-DISCARD;} WITH {EDEP=PEIE-PRM;}
               0  "NOTE: TO GET THE EGS3 VERSION SIMPLY USE EDEP=PEIE+PRM"
               0  "      AS THE REPLACEMENT PART OF THE MACRO."
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR PARTICLE SELECTION (E.G., LEADING PARTICLE,"
               0  "SPLITTING, ETC.).  DEFAULT IS ULTIMATELY 'NULL'"
               0  "     -----IN SUBROUTINE ELECTR-----                 "
               0  REPLACE {$PARTICLE-SELECTION-ELECTR;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIH;} WITH {
            {  0           $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIHREST;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BHABHA;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BREMS;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-MOLLER;}
               0     WITH {$PARTICLE-SELECTION-ELECTR;}
               0  "     -----IN SUBROUTINE PHOTON-----                 "
               0  REPLACE {$PARTICLE-SELECTION-PHOTON;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-COMPT;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PAIR;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PHOTO;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0
               0  "MACRO FOR SELECTION OF THE ELECTRON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-ELECTRON-MFP;} WITH {
            {  0          $RANDOMSET RNNE1; IF(RNNE1.EQ.0.0) [RNNE1=1.E-30;]
            {  0           DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);}
               0
               0  "MACRO FOR SELECTION OF THE PHOTON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-PHOTON-MFP;} WITH {
            {  0         $RANDOMSET RNNO35; IF(RNNO35.EQ.0.0) [RNNO35=1.E-30;]
            {  0           DPMFP=-LOG(RNNO35);}
               0
               0  "MACRO to do range rejection on a region by region basis"
               0  "      if the user requests it.  The variables e_max_rr and i_do_rr"
               0  "      are in COMIN ET-CONTROL.  This macro is called immediately"
               0  "      after $USER-RANGE-DISCARD in ELECTR and everytime called"
               0  "      the electrons current range has been computed and stored in"
               0  "      range and the distance to the nearest boundary has just been"
               0  "      computed and is in tperp.  e_max_rr and i_do_rr are initialized"
               0  "      to zero in BLOCK DATA so range rejection is not done unless"
               0  "      Since option must be turned on by the user, it is considered a"
               0  "      USER-ELECTRON-DISCARD."
               0  "      Note this technique implies an approximation because the particle"
               0  "      is not allowed to create a brem particle which might escape"
               0  "      the region.  This is why  e_max_rr is used, to allow high"
               0  "      energy electrons to be tracked in case they give off brem."
               0
               0  REPLACE {$RANGE-DISCARD;} WITH {
            {  0    ;IF( i_do_rr(irl) = 1 & e(np) < e_max_rr(irl) ) [
            {  0        IF(tperp >= range) ["particle cannot escape local region"
            {  0            idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
            {  0            go to :USER-ELECTRON-DISCARD: ;
            {  0        ]
            {  0    ]
            {  0  };
               0
               0
               0  "MACRO TO ALLOW USER TO DISCARD IF AT OR NEAR END OF RANGE"
               0  REPLACE {$USER-RANGE-DISCARD;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "RAYLEIGH (COHERENT) SCATTERING MACROS"
               0
               0  "custom form factor file names"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {COMIN/rayleigh_inputs/;} WITH
               0  "        ================"
               0  {
            {  0  ;COMMON/rayleigh_inputs/iray_ff_media($MXMED),iray_ff_file($MXMED);
            {  0  ;character*24 iray_ff_media;
            {  0  ;character*128 iray_ff_file;
            {  0  }
               0
               0  REPLACE {COMIN/rayleigh_sampling/;} WITH
               0  "        ================"
               0  {;COMMON/rayleigh_sampling/xgrid($MXRAYFF,$MXMED),
            {  0                              fcum($MXRAYFF,$MXMED),
            {  0                             b_array($MXRAYFF,$MXMED),
            {  0                             c_array($MXRAYFF,$MXMED),
            {  0                             i_array($RAYCDFSIZE,$MXMED),
            {  0                             $LGN(pmax($MXGE,$MXMED)/0,1/);
            {  0  $REAL xgrid, fcum, b_array, c_array,pmax0, pmax1;
            {  0  $INTEGER i_array;
            {  0  }
               0
               0  REPLACE {$RAYLEIGH-CORRECTION;} WITH {
            {  0       ;IF(IRAYLR(IRL).EQ.1) [$EVALUATE COHFAC USING COHE(GLE);
            {  0      GMFP=GMFP*COHFAC];}
               0
               0  REPLACE {$OLD_RAYLEIGH-SCATTERING;} WITH {
            {  0        ;IF(IRAYLR(IRL).EQ.1) [
            {  0     $RANDOMSET RNNO37;
            {  0     IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0     $AUSCALL($RAYLAUSB);
            {  0     NPold = NP;
            {  0     :SAMPLING-LOOP: LOOP [$RANDOMSET XXX;
            {  0     $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
            {  0     Q2=X2*RMSQ/(20.60744*20.60744);
            {  0     COSTHE=1.-Q2/(2.*E(NP)*E(NP));
            {  0     IF (ABS(COSTHE).GT.1.0) GO TO :SAMPLING-LOOP:;
            {  0     CSQTHE=COSTHE*COSTHE;
            {  0     REJF=(1.0+CSQTHE)/2.0;
            {  0     $RANDOMSET RNNORJ;
            {  0     ] UNTIL (RNNORJ <= REJF);
            {  0     SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
            {  0     $AUSCALL($RAYLAUSA);
            {  0     GOTO :PNEWENERGY:;]]
            {  0    }
               0  REPLACE {$RAYLEIGH-SCATTERING;} WITH {
            {  0     ;IF(IRAYLR(IRL).EQ.1) [
            {  0     $RANDOMSET RNNO37;
            {  0     IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0     $AUSCALL($RAYLAUSB);
            {  0     NPold = NP;
            {  0     call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINTHE);
            {  0     CALL UPHI(2,1);
            {  0     $AUSCALL($RAYLAUSA);
            {  0     GOTO :PNEWENERGY:;]]
            {  0  }
               0
               0  "Ali:photonuc, 2 blocks"
               0  REPLACE {$PHOTONUC-CORRECTION;} WITH {
            {  0       ;IF(IPHOTONUCR(IRL).EQ.1) [$EVALUATE PHOTONUCFAC USING PHOTONUC(GLE);
            {  0      GMFP=GMFP*PHOTONUCFAC];}
               0
               0  REPLACE {$PHOTONUCLEAR;} WITH {
            {  0     ;IF(IPHOTONUCR(IRL).EQ.1) [
            {  0        $RANDOMSET RNNO39;
            {  0        IF (RNNO39.LE.(1.0-PHOTONUCFAC)) [
            {  0          $AUSCALL($PHOTONUCAUSB);
            {  0          call PHOTONUC;
            {  0          $AUSCALL($PHOTONUCAUSA);
            {  0          GOTO :PNEWENERGY:;
            {  0        ]
            {  0      ]
            {  0  }
               0
               0  "DENSITY RATIO SCALING MACRO (TO OVER-RIDE DENSITY IN A PARTICULAR"
               0  "REGION)  NOTE: THIS MACRO REPLACES SUBROUTINE RHOSET OF EGS3"
               0
               0  REPLACE {$SET-RHOF;} WITH {RHOF=RHOR(IRL)/RHO(MEDIUM);}  "DEFAULT"
               0
               0  "TEMPLATES FOR PERFORMING CHARGED PARTICLE TRANSPORT IN EM FIELD"
               0  REPLACE {$SET-TUSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-USTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$VACUUM-ADD-WORK-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-ANGLES-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-TVSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$ADD-WORK-EM-FIELD;} WITH {;}
               0  REPLACE {$EMFIELD_INITIATE_SET_TUSTEP;} WITH {;}
               0  REPLACE {;COMIN/EM/;} WITH {;}
               0  REPLACE {$EMFIELD_PII;} WITH {;}
               0  REPLACE{$EMFIELD_PI;}WITH{;}
               0  REPLACE{$EM_FIELD_SS;}WITH{;}
               0  REPLACE{$ADD_WORK_EM_FIELD;}WITH{;}
               0  REPLACE{$EMFieldInVacuum;}WITH{;}
               0  REPLACE{$EM_MACROS_ACTIVE}WITH{.false.}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        EGS4/EGSnrc GEOMETRY MACROS: AN EXTENSION TO EGS MACROS   "
               0  "------------------------------------------------------------------"
               0
               0  "   NOTE1: CYLNDR IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/80-78, 25 NOV. 1980)"
               0
               0  "   NOTE2: CONE IS A NEW MACRO BY H.HIRAYAMA OF KEK. "
               0  "          MACRO REPLACEMENT OF CERN VERSION SUBROUTINE CONE"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE3: SPHERE IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE4: $PLAN2X AND $PLAN2P ARE TWO NEW MACROS BY W.R.NELSON."
               0  "          $PLAN2P WAS FORMERLY CALLED $PLANE2 AND IS STILL THE"
               0  "          SAME (CALLS TO $PLANE2 WILL AUTOMATICALLY DEFAULT TO"
               0  "          TO $PLAN2P).  $PLAN2X, HOWEVER, WILL CORRECTLY HANDLE"
               0  "          THE CASE OF TWO, NON-PARALLEL PLANES."
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINES FOR PLANE GEOMETRY  (SLAC VERSION)         "
               0  "------------------------------------------------------------------"
               0  ;
               0  PARAMETER $MXPLNS=100;     "MAX. NO. OF PLANES"
               0
               0  "PLADTA---COMMON BLOCK FOR $PLANE1 AND $PLANE2 MACROS"
               0  REPLACE {;COMIN/PLADTA/;} WITH {
            {  0        ;COMMON/PLADTA/PCOORD(3,$MXPLNS),PNORM(3,$MXPLNS);
            {  0        $REAL PCOORD, PNORM;
            {  0  }
               0
               0  "$PLANE1---MACRO REPLACEMENT FOR SUBROUTINE PLANE1"
               0  REPLACE {$PLANE1(#,#,#,#);} WITH {
            {  0   UDOTA=PNORM(1,{P1})*U(NP)+PNORM(2,{P1})*
            {  0   V(NP)+PNORM(3,{P1})*W(NP); UDOTAP={P2}*UDOTA;
            {  0   IF(UDOTA.EQ.0.0)[{P3}=2;]ELSEIF(UDOTAP.LT.0.0)
            {  0   [{P3}=0;] ELSE [{P3}=1;{P4}=(PNORM(1,{P1})*
            {  0   (PCOORD(1,{P1})-X(NP))+ PNORM(2,{P1})*
            {  0   (PCOORD(2,{P1})-Y(NP))+PNORM(3,{P1})*
            {  0   (PCOORD(3,{P1})-Z(NP)))/UDOTA;]}
               0  "NOTE:   EVERYWHERE $PLANE1 IS USED ONE MUST"
               0  "        INCLUDE COMIN/PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLANE2---MACRO REPLACEMENT FOR SUBROUTINE PLANE2"
               0  "          NOTE: $PLANE2 HAS BEEN SUPERCEDED BY $PLAN2P (BELOW),"
               0  "                WHICH IS AUTOMATICALLY TAKEN CARE OF BY THE"
               0  "                FOLLOWING MACRO STATEMENT."
               0  REPLACE {$PLANE2} WITH {$PLAN2P}
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2P---MACRO REPLACEMENT FOR SUBROUTINE PLAN2P (OR $PLANE2)"
               0  "          (I.E., TWO PARALLEL PLANES)"
               0  REPLACE {$PLAN2P(#,#,#,#,#,#);} WITH {
            {  0    $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1)
            {  0   [ $CHGTR(TVAL,{P2});] ELSEIF(IHIT.EQ.0)
            {  0   [$PLANE1({P4},{P6},IHIT,TVAL);$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2P ($PLANE2) IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2X---MACRO REPLACEMENT FOR SUBROUTINE PLAN2X"
               0  "          (I.E., TWO, NON-PARALLEL (CROSSING) PLANES)"
               0  REPLACE {$PLAN2X(#,#,#,#,#,#);} WITH {
            {  0      $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1) [
            {  0     $CHGTR(TVAL,{P2});]   $PLANE1({P4},{P6},IHIT,TVAL);
            {  0     IF(IHIT.EQ.1) [$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2X IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "      MACRO-ROUTINE FOR CYLINRICAL GEOMETRY  (CERN VERSION)       "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCYLS=75;      "MAX. NO. OF CYLINDERS"
               0  PARAMETER $DELCYL=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CYLDTA---COMMON BLOCK FOR $CYLNDR MACRO"
               0  REPLACE {;COMIN/CYLDTA/;} WITH {
            {  0     ;COMMON/CYLDTA/CYRAD2($MXCYLS);
            {  0     $REAL CYRAD2;
            {  0  }
               0
               0  "$CYLNDR---MACRO REPLACEMENT FOR SUB CYLNDR GRS VERSION 14 11 80"
               0  REPLACE {$CYLNDR(#,#,#,#);} WITH {
            {  0     {P3}=1;{P4}=0.0;ACYL=SQRT(U(NP)*U(NP)+V(NP)*V(NP));
            {  0     IF(ACYL.EQ.0.0)[{P3}=0;]  ELSE [
            {  0     BCYL=(X(NP)*U(NP)+Y(NP)*V(NP))/ACYL;CCYL=X(NP)*X(NP)+Y(NP)*Y(NP)
            {  0     -CYRAD2({P1});  ARGCY=BCYL*BCYL-CCYL;
            {  0     IF(ARGCY.LT.0.0) [{P3}=0;]   ELSE [
            {  0     IF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.0.AND.BCYL.GE.0.0)[{P3}=0;]
            {  0     ELSEIF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.1.AND.BCYL.LT.0.0)[
            {  0     {P4}=-2.0*BCYL/ACYL;]
            {  0     ELSE [ IF({P2}.EQ.1.AND.CCYL.GE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0     ELSEIF({P2}.EQ.0.AND.CCYL.LE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0     ELSE  [  ROOTCY=SQRT(ARGCY); IF(CCYL.LT.0.0)
            {  0     [{P4}=(-BCYL+ROOTCY)/ACYL;]
            {  0     ELSEIF(BCYL.LT.0.0) [{P4}=(-BCYL-ROOTCY)/ACYL;]
            {  0     ELSE [{P3}=0;]]]]]}
               0  "NOTE:   EVERYWHERE $CYLNDR IS USED ONE MUST"
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  "$CYL2--MACRO EQUIVALENT FOR CYLNDR OF $PLANE2  GRS 17.11.80"
               0  REPLACE {$CYL2(#,#,#,#);} WITH {
            {  0   $CYLNDR({P1},0,IHIT,TCYL);IF(IHIT.EQ.1)[
            {  0   $CHGTR(TCYL,{P2});]ELSE[$CYLNDR({P3},1,IHIT,TCYL);
            {  0   IF(IHIT.EQ.1)[ $CHGTR(TCYL,{P4});]]}
               0  "NOTE:   EVERYWHERE $CYL2 IS USED ONE MUST
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE FOR CERN CONICAL GEOMETRY  (SLAC VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCONES=75;     "MAXIMUM NUMBER OF CONES"
               0  PARAMETER $DELCON=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CONDTA---COMMON BLOCK FOR $CONE MACRO"
               0  REPLACE {;COMIN/CONDTA/;} WITH {
            {  0     ;COMMON/CONDTA/COTAL2($MXCONES),SMALLL($MXCONES);
            {  0     $REAL COTAL2, SMALLL;
            {  0  }
               0
               0  "$CONE---MACRO REPLACEMENT FOR CERN VERSION SUBROUTINE CONE"
               0  REPLACE {$CONE(#,#,#,#);} WITH {
            {  0     {P3}=0;ITWOPR=0;CPCON=COTAL2({P1});SGNCON=SIGN(1.0,CPCON);
            {  0     CPCON=ABS(CPCON);ZNP=SGNCON*(Z(NP)-SMALLL({P1}));
            {  0     WNP=SGNCON*W(NP);CPCON1=1.0+CPCON;
            {  0     CPCON2=SQRT(CPCON1);DCON1=X(NP)*X(NP)+Y(NP)*Y(NP);
            {  0     DCON2=SQRT(DCON1); IF((ZNP.GE.0.0).OR.(WNP.GE.0.0)) [
            {  0     ACON=(U(NP)*U(NP)+V(NP)*V(NP))*CPCON-WNP*WNP;
            {  0     BCON1=(X(NP)*U(NP)+Y(NP)*V(NP))*CPCON;BCON=BCON1-ZNP*WNP;
            {  0     CCON=DCON1*CPCON-ZNP*ZNP;
            {  0     IF(ACON.EQ.0.0)[IF(BCON.NE.0.0)
            {  0     [IF(ABS(CCON).LT.$DELCON.AND.ZNP.GE.0.0)[
            {  0     IF(({P2}.EQ.1.AND.BCON.GE.0.0).OR.({P2}.EQ.0.AND.BCON.LE.0.0))[
            {  0     TCON1=-CCON/(2*BCON);IF(TCON1.GE.0.0)[IF((ZNP+TCON1*WNP).GE.0.0)
            {  0     [{P4}=TCON1;{P3}=1;]]]]]
            {  0     ELSE[TCON1=CPCON2*ZNP*SIGN(1.0,-WNP);
            {  0     IF(TCON1.GE.0.0)[{P4}=TCON1;{P3}=1;]]]
            {  0     ELSEIF((ABS(CCON).LT.$DELCON).AND.(ZNP.GE.0.0))
            {  0     [BPRIM=BCON1-WNP*DCON2;
            {  0     IF({P2}.EQ.1.AND.BPRIM.LT.0.0)[TCON1=-2*BCON/ACON;
            {  0     IF(TCON1.GE.0.0) [{P4}=TCON1;{P3}=1;]]]
            {  0     ELSEIF({P2}.EQ.1.AND.CCON.GT.0.0) [{P4}=$DELCON;{P3}=1;]
            {  0     ELSEIF({P2}.EQ.0.AND.CCON.LT.0.0.AND.ZNP.GE.0.0)
            {  0     [{P4}=$DELCON;{P3}=1;] ELSE[CCON1=BCON*BCON-ACON*CCON;
            {  0     IF(CCON1.GE.0.0)[ROOT=SQRT(CCON1);
            {  0     IF(BCON.GT.0.0)[TCON11=-(BCON+ROOT)/ACON;]
            {  0     ELSE[TCON11=-CCON/(BCON-ROOT);]
            {  0     IF(BCON.LT.0.0)[TCON22=-(BCON-ROOT)/ACON;]
            {  0     ELSE[TCON22=-CCON/(BCON+ROOT);]
            {  0     IF((TCON11.GE.0.0).OR.(TCON22.GE.0.0))[
            {  0     IF(TCON11.LT.0.0)[TCON1=TCON22;]
            {  0     ELSE[IF(TCON22.LT.0.0)[TCON1=TCON11;] ELSE[ITWOPR=1;
            {  0     TCON1=min(TCON11,TCON22);TCON2=max(TCON11,TCON22);]]
            {  0     IF((ZNP+TCON1*WNP).GE.0.0)[{P4}=TCON1;{P3}=1;]
            {  0     ELSEIF((ITWOPR.EQ.1).AND.((ZNP+TCON2*WNP).GE.0.0))
            {  0     [{P4}=TCON2;{P3}=1;]]]]]}
               0  "NOTE:   EVERYWHERE $CONE IS USED ONE MUST
               0  "         INCLUDE COMIN/CONDTA,STACK/"
               0
               0  "$CON2--MACRO EQUIVALENT FOR CONE OF $PLANE2            "
               0  REPLACE {$CON2(#,#,#,#);} WITH {
            {  0     $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P2});]ELSE[$CONE({P3},1,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P4});]]}
               0
               0  "$CON21--MACRO EQUIVALENT FOR CONE OF $PLANE2 (IN THE CASE  "
               0  "OF OUTSIDE TWO CONE SURFACE)                               "
               0  REPLACE {$CON21(#,#,#,#);} WITH {
            {  0     $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P2});]ELSE[$CONE({P3},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P4});]]}
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR SPHERICAL GEOMETRY  (CERN VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXSPHE=75;      "MAX. NO. OF SPHERES"
               0  PARAMETER $DELSPH=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "SPHDTA------COMMON BLOCK FOR $SPHERE MACRO"
               0  REPLACE {;COMIN/SPHDTA/;} WITH {
            {  0     ;COMMON/SPHDTA/SPRAD2($MXSPHE);
            {  0     $REAL SPRAD2;
            {  0  }
               0
               0  "$SPHERE---MACRO REPLACEMENT FOR SUB SPHERE GRS VERSION 08 12 80"
               0  REPLACE {$SPHERE(#,#,#,#);} WITH {
            {  0     {P3}=1;{P4}=0.0;ASPH=1.0;
            {  0     BSPH=(X(NP)*U(NP)+Y(NP)*V(NP)+Z(NP)*W(NP))/ASPH;CSPH=X(NP)*X(NP)
            {  0     +Y(NP)*Y(NP)+Z(NP)*Z(NP)  -SPRAD2({P1});  ARGSP=BSPH*BSPH-CSPH;
            {  0     IF(ARGSP.LT.0.0) [{P3}=0;]   ELSE [
            {  0     IF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.0.AND.BSPH.GE.0.0)[{P3}=0;]
            {  0     ELSEIF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.1.AND.BSPH.LT.0.0)[
            {  0     {P4}=-2.0*BSPH/ASPH;]
            {  0     ELSE [ IF({P2}.EQ.1.AND.CSPH.GE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0     ELSEIF({P2}.EQ.0.AND.CSPH.LE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0     ELSE [ROOTSP=SQRT(ARGSP); IF(CSPH.LT.0.0)
            {  0     [{P4}=(-BSPH+ROOTSP)/ASPH;] ELSEIF(BSPH.LT.0.0)
            {  0     [{P4}=(-BSPH-ROOTSP)/ASPH;] ELSE [{P3}=0;]]]]}
               0  "NOTE:   EVERYWHERE $SPHERE IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  "$SPH2--MACRO EQUIVALENT FOR SPHERE OF $PLANE2  GRS 08.12.80"
               0  REPLACE {$SPH2(#,#,#,#);} WITH {
            {  0   $SPHERE({P1},0,IHIT,TSPH);IF(IHIT.EQ.1)[
            {  0   $CHGTR(TSPH,{P2});]ELSE[$SPHERE({P3},1,IHIT,TSPH);
            {  0   IF(IHIT.EQ.1)[ $CHGTR(TSPH,{P4});]]}
               0  "NOTE:   EVERYWHERE $SPH2 IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR CHANGING REGIONS  (SLAC VERSION)        "
               0  "------------------------------------------------------------------"
               0
               0  "$CHGTR---MACRO REPLACEMENT FOR SUBROUTINE CHGTR"
               0  REPLACE {$CHGTR(#,#);} WITH {
            {  0      ;IF({P1}.LE.USTEP) [USTEP={P1}; IRNEW={P2};]}
               0  "NOTE:   EVERYWHERE $CHGTR IS USED ONE MUST
               0  "         INCLUDE COMIN/EPCONT/"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE TO OBTAIN FINAL COORDINATES (SLAC VERSION)     "
               0  "------------------------------------------------------------------"
               0
               0  "$FINVAL---MACRO REPLACEMENT FOR SUBROUTINE FINVAL"
               0  REPLACE {$FINVAL(#,#,#,#);} WITH {
            {  0     {P2}=X(NP)+{P1}*U(NP); {P3}=Y(NP)+{P1}*V(NP);
            {  0     {P4}=Z(NP)+{P1}*W(NP);}
               0  "NOTE:   EVERYWHERE $FINVAL IS USED ONE MUST
               0  "         INCLUDE COMIN/STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "                 END OF GEMOETRY MACRO EXTENSION                  "
               0  "------------------------------------------------------------------"
               0
               0  "******************************************************************"
               0  "                                                                  "
               0  "                    NRC EXTENSIONS                                "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  ; "BUFFER FLUSH"
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           PHOTOELECTRON ANGLE SELECTION                      "
               0  "           =============================                      "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to select the photoelectron direction  "
               0
               0  REPLACE {$SELECT-PHOTOELECTRON-DIRECTION;} WITH {
            {  0  "        ================================"
            {  0  ;IF(IPHTER(IR(NP)).EQ.1)[
            {  0    EELEC=E(NP);
            {  0    IF(EELEC.GT.ECUT(IR(NP)))[
            {  0      BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC;
            {  0      GAMMA=EELEC/RM;
            {  0      ALPHA=0.5*GAMMA-0.5+1./GAMMA;
            {  0      RATIO=BETA/ALPHA;
            {  0      LOOP[
            {  0        $RANDOMSET RNPHT;RNPHT=2.*RNPHT-1.;
            {  0        IF(RATIO.LE.0.2)[
            {  0          FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT);
            {  0          IF( gamma < 100 ) [
            {  0              COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA);
            {  0          ]
            {  0          ELSE [
            {  0              IF( fkappa > 0 ) [
            {  0                  costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gamma-1)**3);
            {  0              ]
            {  0              ELSE [ COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA); ]
            {  0          ]
            {  0          "XI=1./(1.-BETA*COSTHE); <-- this numerically problematic "
            {  0          "                            at high energies, IK"
            {  0          xi = (1+beta*fkappa)*gamma*gamma;
            {  0        ]
            {  0        ELSE[
            {  0          XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO))-1.));
            {  0          COSTHE=(1.-1./XI)/BETA;
            {  0        ]
            {  0        SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE));
            {  0        $RANDOMSET RNPHT2;
            {  0        ]WHILE(RNPHT2.GT.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA);
            {  0      SINTHE=SQRT(SINTH2);
            {  0      CALL UPHI(2,1);]]
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           TSTEP RECURSION IN ELECTR                          "
               0  "           =========================                          "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to control TSTEP recursion in ELECTR   "
               0
               0  REPLACE {$USER_CONTROLS_TSTEP_RECURSION;} WITH {;}
               0
               0  ; "BUFFER FLUSH"
               0
               0  %C80                                                                           ;
               0  "------------------------------------------------------------------"
               0  "  BREMSSTRAHLUNG ANGLE SELECTION MACROS                           "
               0  "------------------------------------------------------------------"
               0
               0
               0  "These macros are explained in NRCC REPORT #PIRS0203"
               0  "by Bielajew, Mohan and Chui                        "
               0
               0  "Macro to initialize data for bremsstrahlung production               "
               0  "The quantity ZBRANG is ( (1/111)*Zeff**(1/3) )**2                    "
               0  "where Zeff is defined in equation (7) OF PIRS0203                    "
               0  "This macro goes in SUBROUTINE HATCH                                  "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-BREMS-ANGLE;} WITH {
            {  0  ; IF(IBRDST.EQ.1)[
            {  0          DO IM=1,NMED[
            {  0              ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0              DO IE=1,NNE(IM)[
            {  0                  ZBRANG(IM)=
            {  0                    ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0                  PZNORM=PZNORM+PZ(IM,IE);
            {  0                  ]
            {  0                  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0                  LZBRANG(IM)=-log(ZBRANG(IM));
            {  0              ]
            {  0          ]
            {  0  }
               0  ;
               0
               0  ;
               0
               0  " Following is associated with the selection of bremsstrahlung photon"
               0  " angle.  This has been implemented directly into the BREMS subroutine"
               0  " and changed slightly. Nonetheless, this macro is still used."
               0
               0  "This is the function G(X) of PIRS0203               "
               0  "The result is returned in {P1} as a function of {P2}"
               0  "i.e. {P1}=G({P2}) where {P2}=X                      "
               0  "                                                    "
               0  REPLACE {$SET-BREM-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; Y2TST1=(1.+{P2})**2;
            {  0  {P1}= (4.+LOG(RJARG3+ZTARG/Y2TST1))*(4.*ESEDEI*{P2}/Y2TST1-RJARG1)+RJARG2;
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "  PAIR ANGLE SELECTION MACROS                                     "
               0  "------------------------------------------------------------------"
               0
               0  "These macros are explained in NRCC REPORT # PIRS0287 by Bielajew     "
               0
               0  ;
               0  "Macro to initialize data for PAIR PRODUCTION                         "
               0  "THE QUANTITY ZBRANG IS ( (1/111)*Zeff**(1/3) )**2                    "
               0  "WHERE Zeff IS DEFINED IN EQUATION (7) OF PIRS0287                    "
               0  "THIS MACRO GOES IN SUBROUTINE HATCH                                  "
               0  "THIS MACRO IS IDENTICAL TO THE $INITIALIZE-BREMS-ANGLE DEFINED ABOVE "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-PAIR-ANGLE;} WITH {
            {  0  ;    IF(IPRDST.GT.0)[
            {  0          DO IM=1,NMED[
            {  0              ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0              DO IE=1,NNE(IM)[
            {  0                  ZBRANG(IM)=
            {  0                    ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0                  PZNORM=PZNORM+PZ(IM,IE);
            {  0                  ]
            {  0                  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0              ]
            {  0          ]
            {  0  }
               0  ;
               0  "THRESHOLD BELOW WHICH ONLY LOWEST ORDER ANGULAR DISTRIBUTION OF THE  "
               0  "PAIR ANGLE IS EMPLOYED. SCALE IS ENERGY (MeV).                       "
               0  "USERS MAY OVERRIDE THIS WITH A HIGHER VALUE BUT A LOWER VALUE WILL   "
               0  "CAUSE NON-PHYSICAL SAMPLING                                          "
               0  "                                                                     "
               0  REPLACE {$BHPAIR} WITH {4.14}
               0  ;
               0  "THIS MACRO ENABLES VERY SMALL ANGLE SAMPLING TO BE     "
               0  "ACCUMULATED. THE LIMIT OF 1.0E-10 BREAKS DOWN AROUND   "
               0  "50 GEV OR SO (THETA=RM/E, FOR BOTH PAIR AND BREM).     "
               0  "THIS MACRO REPLACES CODE IN UPHI AND IN THE PRESTA     "
               0  "MACROS FOR THE LATERAL CORRELATION PART $PRESTA-LCDV.  "
               0  ;
               0  REPLACE {(SINPS2.LT.1.0E-10)} WITH {(SINPS2.LT.1.0E-20)}
               0  ;
               0  "THE FOLLOWING REPLACES THE EGS4 DEFAULT $SET-PAIR-ANGLE MACRO    "
               0  "IT'S USE REQUIRES AN ASSOCIATE MACRO $SET-PAIR-REJECTION-FUNCTION"
               0  "DEFINED BELOW                                                    "
               0  "                                                                 "
               0  "USAGE: IPRDST=0 => EGS4 DEFAULT ANGLE SELECTION                  "
               0  "       IPRDST=1 => LOWEST ORDER ANGULAR DISTRIBUTION             "
               0  "                                                                 "
               0  "              d(Probability)            sin(theta)               "
               0  "              -------------- = -------------------------------   "
               0  "                 d(theta)      2*P*[E_total - P*cos(theta)]**2   "
               0  "                                                                 "
               0  "       IPRDST=2 => MOTZ, OLSEN AND KOCH (1969) EQ. 3D-2003       "
               0  "                   IF IPRDST IS NON-ZERO AND E_PHOTON < $BHPAIR  "
               0  "                   THE IPRDST=1 DISTRIBUTION IS USED             "
               0  "                                                                 "
               0  REPLACE {$SET-PAIR-ANGLE;} WITH {;
            {  0      IF( iprdst > 0 ) [
            {  0          IF( iprdst = 4 ) [
            {  0              $RANDOMSET rtest;
            {  0              "gbeta = (1-rmt2/eig)**8;"
            {  0              gbeta = PESE1/(PESE1+10);
            {  0              IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0              ELSE [ iprdst_use = 4; ]
            {  0          ]
            {  0          ELSEIF ( iprdst = 2 & eig < $BHPAIR ) [ iprdst_use = 1; ]
            {  0          ELSE [ iprdst_use = iprdst; ]
            {  0          DO ichrg = 1,2 [
            {  0              IF(ICHRG.EQ.1)[ESE=PESE1;]ELSE[
            {  0                  ESE=ESE2;
            {  0                  IF( iprdst = 4 ) [
            {  0                      gbeta = ESE/(ESE+10);
            {  0                      $RANDOMSET rtest;
            {  0                      IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0                      ELSE [ iprdst_use = 4; ]
            {  0                  ]
            {  0              ]
            {  0              IF( iprdst_use = 1 ) [
            {  0                  PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)));
            {  0                  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0                  SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE);
            {  0                  COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE);
            {  0              ]
            {  0              ELSE IF( iprdst_use = 2 ) [
            {  0                  "ZBRANG=( (1/111)*Zeff**(1/3) )**2"
            {  0                  ZTARG=ZBRANG(MEDIUM);
            {  0                  "TTEIG=TOTAL INITIAL PHOTON ENERGY IN ELECTRON REST MASS UNITS"
            {  0                  TTEIG=EIG/RM;
            {  0                  "TTESE=TOTAL FINAL ELECTRON ENERGY IN ELECTRON REST MASS UNITS"
            {  0                  TTESE=ESE/RM;
            {  0                  "TTPSE=TOTAL FINAL ELECTRON MOMENTUM IN rm UNITS"
            {  0                  TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0));
            {  0                  "THIS IS THE RATIO (r IN PIRS0287)"
            {  0                  ESEDEI=TTESE/(TTEIG-TTESE);
            {  0                  ESEDER=1.0/ESEDEI;
            {  0                  "DETERMINE THE NORMALIZATION "
            {  0                  XIMIN=1.0/(1.0+(3.141593*TTESE)**2);
            {  0                  $SET-PAIR-REJECTION-FUNCTION(REJMIN,XIMIN);
            {  0                  YA=(2.0/TTEIG)**2;
            {  0                  XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))));
            {  0                  GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2);
            {  0                  GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2);
            {  0                  GALPHA=GALPHA-GBETA*(XITRY-0.5);
            {  0                  XIMID=GALPHA/(3.0*GBETA);
            {  0                  IF(GALPHA.GE.0.0)[
            {  0                      XIMID=0.5-XIMID+SQRT(XIMID**2+0.25);
            {  0                  ]
            {  0                  ELSE[
            {  0                      XIMID=0.5-XIMID-SQRT(XIMID**2+0.25);
            {  0                  ]
            {  0                  XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)));
            {  0                  $SET-PAIR-REJECTION-FUNCTION(REJMID,XIMID);
            {  0                  "ESTIMATE MAXIMUM OF THE REJECTION FUNCTION"
            {  0                  "FOR LATER USE BY THE REJECTION TECHNIQUE  "
            {  0                  REJTOP=1.02*MAX(REJMIN,REJMID);
            {  0                  LOOP[
            {  0                      $RANDOMSET XITST;
            {  0                      $SET-PAIR-REJECTION-FUNCTION(REJTST,XITST);
            {  0                      $RANDOMSET RTEST;
            {  0                      "CONVERT THE SUCCESSFUL CANDIDATE XITST TO AN ANGLE"
            {  0                      THETA=SQRT(1.0/XITST-1.0)/TTESE;
            {  0                      "LOOP UNTIL REJECTION TECHNIQUE ACCEPTS XITST"
            {  0                      REJTST_on_REJTOP   = REJTST/REJTOP;
            {  0                  ]UNTIL((RTEST <= REJTST_on_REJTOP) & (THETA < PI) );
            {  0                  SINTHE=SIN(THETA);COSTHE=COS(THETA);
            {  0              ]
            {  0              ELSE IF( iprdst_use = 3 ) [
            {  0                  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0                  sinthe=(1-costhe)*(1+costhe);
            {  0                  IF( sinthe > 0 ) [ sinthe = sqrt(sinthe); ] ELSE [ sinthe = 0; ]
            {  0              ]
            {  0              ELSE [
            {  0                  "PSE=SQRT(MAX(1e-10,(ESE-RM)*(ESE+RM)));"
            {  0                  "$RANDOMSET costhe;"
            {  0                  "costhe=(ese-(ese+pse)*exp(-2*costhe*log((ese+pse)/rm)))/pse;"
            {  0                  $RANDOMSET costhe;
            {  0                  costhe=1-2*sqrt(costhe);
            {  0                  sinthe=(1-costhe)*(1+costhe);
            {  0                  IF( sinthe > 0 ) [ sinthe=sqrt(sinthe); ] ELSE [ sinthe=0; ]
            {  0              ]
            {  0              IF( ichrg = 1 ) [CALL UPHI(2,1);]
            {  0              ELSE [ sinthe=-sinthe; NP=NP+1; CALL UPHI(3,2); ]
            {  0          ]
            {  0          iq(np) = iq2; iq(np-1) = iq1; return;
            {  0      ]
            {  0      ELSE[
            {  0          THETA=0; "THETA=RM/EIG; "
            {  0      ]
            {  0  }
               0  ;
               0  "THIS IS THE FUNCTION d[G(XI)]/(d XI) OF PIRS0287    "
               0  "THE RESULT IS RETURNED IN {P1} AS A FUNCTION OF {P2}"
               0  "I.E. {P1}=G({P2}) WHERE {P2}=XI                     "
               0  "                                                    "
               0  REPLACE {$SET-PAIR-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; {P1} = 2.0+3.0*(ESEDEI+ESEDER) -
            {  0          4.00*(ESEDEI+ESEDER+1.0-4.0*({P2}-0.5)**2)*(
            {  0              1.0+0.25*LOG(
            {  0                  ((1.0+ESEDER)*(1.0+ESEDEI)/(2.*TTEIG))**2+ZTARG*{P2}**2
            {  0                  )
            {  0              )
            {  0          ;
            {  0  }
               0  ;
               0
               0  REPLACE {$SELECT-LOW-ENERGY-PAIR-PRODICTION;} WITH
               0  {
            {  0    $RANDOMSET RNNO30; $RANDOMSET rnno34;
            {  0    PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM); PESE1 = PEIG - PESE2;
            {  0    IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
            {  0  }
               0  " IK introduced this macro because uniform energy distribution"
               0  " is probably a better approximation than a zero energy 'electron'"
               0  " for low energy pair production"
               0
               0  ;
               0
               0  "THIS MACRO EXCHANGES TWO POSITIONS ON THE STACK"
               0  "NB: LATCH IS A NON-STANDARD STACK VARIABLE     "
               0  "    REMOVE IT IF IT CAUSES PROBLEMS            "
               0  "                                               "
               0  REPLACE {$EXCHANGE-STACK(#,#);} WITH {
            {  0  ;
            {  0  FDUMMY = U({P2});     U({P2})     = U({P1});     U({P1})     = FDUMMY;
            {  0  FDUMMY = V({P2});     V({P2})     = V({P1});     V({P1})     = FDUMMY;
            {  0  FDUMMY = W({P2});     W({P2})     = W({P1});     W({P1})     = FDUMMY;
            {  0  FDUMMY = E({P2});     E({P2})     = E({P1});     E({P1})     = FDUMMY;
            {  0  FDUMMY = WT({P2});    WT({P2})    = WT({P1});    WT({P1})    = FDUMMY;
            {  0  IDUMMY = IQ({P2});    IQ({P2})    = IQ({P1});    IQ({P1})    = IDUMMY;
            {  0  "LATCH IS NOW STANDARD"
            {  0  IDUMMY = LATCH({P2}); LATCH({P2}) = LATCH({P1}); LATCH({P1}) = IDUMMY;
            {  0  }
               0  ;
               0
               0  REPLACE {;OUTPUT61#;#;} WITH {
            {  0  "       ==============="
            {  0  ;{SETR A=@LG}
            {  0  WRITE(6,{COPY A}){P1};WRITE(1,{COPY A}){P1};{COPY A}FORMAT{P2};}
               0  ;
               0
               0  " The following macro provides a second order evaluation of the   "
               0  " stopping power. The parameter is half of the initial estimate of"
               0  " the energy loss fraction. IK Oct 97                             "
               0  REPLACE {$RE-EVALUATE-DEDX(#);} WITH
               0  {
            {  0  ;
            {  0    elktmp = elke + Log(1 - {P1});
            {  0    $SET INTERVAL elktmp,eke;
            {  0    lelktmp = max(1,lelktmp);
            {  0    IF(lelec < 0)[$EVALUATE dedxmid USING ededx(elktmp);]
            {  0    ELSE         [$EVALUATE dedxmid USING pdedx(elktmp);]
            {  0    dedx = rhof*dedxmid*(1+0.17408298*({P1}/(1-{P1})/(eke+PRM))**2);
            {  0                     "0.17408298 is 2/3*m**2"
            {  0    {P1} = 2*{P1};
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0
1              0  %E    "egsnrc.macros"
               0  "******************************************************************"
               0  "                                                                  "
               0  "       transport algorithm related stuff                          "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  "Macros to denote the various transport algorithms"
               0  "These numbers just have to be distinct"
               0  "Note that the distributed version of EGSnrc does not include the VMC option"
               0  REPLACE {$PRESTA-II} WITH {0}
               0  REPLACE {$PRESTA--I} WITH {1}
               0  REPLACE {$VMC}       WITH {2}
               0
               0  REPLACE {$CALL-USER-ELECTRON} WITH {;}
               0
               0  ;
               0  REPLACE {$MSCAT-DATAFILE} WITH {i_mscat}
               0    "Fortran unit number used to read in new MS"
               0  ;
               0  REPLACE {$RANDOMIZE-TUSTEP} WITH {.false.}
               0    "Switches tustep randomization off"
               0  ;
               0  REPLACE {$SKIN-DEPTH-FOR-BCA} WITH {3}
               0  ;
               0  REPLACE {$PRESTA-DEBUG} WITH {.false.}
               0  ;
               0  REPLACE {$EXACT-BCA-XIMAX} WITH {0.5}
               0  ;
               0  REPLACE {$INEXACT-BCA-XIMAX} WITH {0.5} "this is not realy neccessary, "
               0                                          "it remained from Alex's coding"
               0  ;
               0  REPLACE {$MAX-ELOSS} WITH {0.25}
               0  ;
               0  REPLACE {$SUBSTEP-ELOSS-EVALUATION} WITH {.false.}
               0  ;
               0  REPLACE {$MAX-SMAX} WITH {1e10}
               0  ;
               0  REPLACE {$GLOBAL-ECUT} WITH {0.}
               0  ;
               0  REPLACE {$GLOBAL-PCUT} WITH {0.}
               0  ;
               0  REPLACE {$IBRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBR-NIST-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PAIR-NRC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$TRIPLET-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$IPRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBCMP-DEFAULT} WITH {3} "set to norej"
               0  ;
               0  REPLACE {$IEDGFL-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IPHTER-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$TRANSPORT-ALGORITHM-DEFAULT} WITH {$PRESTA-II}
               0  ;
               0  REPLACE {$BCA-ALGORITHM-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$EXACT-BCA-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$SPIN-EFFECTS-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$IRAYLR-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$AP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$UP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$XSEC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$XDATA-DEFAULT} WITH {'xcom'}
               0  ;
               0  REPLACE {$COMP-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EADL relaxation is now the default"
               0  REPLACE {$EADL-RELAX-DEFAULT} WITH {.true.}
               0  ;
               0  "Uniform Run Control (URC) is false by default"
               0  REPLACE {$URC-DEFAULT} WITH {.false.}
               0  ;
               0  "SLEEP INTERVAL for URC (1 s by default)"
               0  "Time to wait for jobs to complete after last job finished"
               0  REPLACE {$URC-SLEEP} WITH {1}
               0  "Times to check for jobs to complete after last job finished"
               0  REPLACE {$URC-INTERVALS} WITH {1}
               0  ;
               0  "Sabbatucci and Salvat PE xsections not the default yet"
               0  REPLACE {$MCDF-PE-DEFAULT} WITH {.false.}
               0  ;
               0  "Ali:photonuc, 2 lines"
               0  REPLACE {$IPHOTONUCR-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PHOTONUC-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EMH:emf, 7 lines"
               0  REPLACE {$ExDEF} WITH {0}
               0  ;
               0  REPLACE {$EyDEF} WITH {0}
               0  ;
               0  REPLACE {$EzDEF} WITH {0}
               0  ;
               0  REPLACE {$BxDEF} WITH {0}
               0  ;
               0  REPLACE {$ByDEF} WITH {0}
               0  ;
               0  REPLACE {$BzDEF} WITH {0}
               0  ;
               0  REPLACE {$EMLMTDEF} WITH {0.02}
               0  ;
               0
               0              "This macro sets the minimum step size for a condensed"
               0              "history (CH) step. When the exact BCA is used, the minimum"
               0              "CH step is determined by efficiency considerations only"
               0              "At about 3 elastic MFP's single scattering becomes more"
               0              "efficient than CH and so the algorithm switches off CH"
               0              "If one of the various inexact BCA's is invoked, this macro"
               0              "provides a simple way to include more sophisticated"
               0              "decisions about the maximum acceptable approximated CH step"
               0
               0  "The parameters passed to the macro in ELECTR are  eke and elke "
               0
               0  REPLACE {$SET-SKINDEPTH(#,#);} WITH
               0  "        =================                  "
               0  {
            {  0     $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});
            {  0     skindepth = skindepth_for_bca*ssmfp;
            {  0  }
               0  ;
               0
               0  "This macro calculates the elastic scattering MFP"
               0  "If spin_effects is .false., the screened Rutherford cross section"
               0  "is used, else the the elastic MFP is based on PWA cross sections"
               0
               0  REPLACE {$CALCULATE-ELASTIC-SCATTERING-MFP(#,#,#);} WITH
               0  "        =======================================           "
               0  {
            {  0      blccl = rhof*blcc(medium);
            {  0      xccl  = rhof*xcc(medium);
            {  0      p2 = {P2}*({P2}+rmt2); beta2 = p2/(p2 + rmsq);
            {  0      IF ( spin_effects ) [
            {  0        IF(lelec < 0) [ $EVALUATE etap USING etae_ms({P3}); ]
            {  0        ELSE          [ $EVALUATE etap USING etap_ms({P3}); ]
            {  0        $EVALUATE ms_corr USING blcce({P3});
            {  0        blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr;
            {  0      ]
            {  0      {P1}=beta2/blccl;
            {  0  }
               0  ;
               0
               0  REPLACE {$SINGLE-SCATTERING(#);} WITH
               0  "        ======================                     "
               0  {
            {  0      $SET-SCREENING-ANGLE({P1});
            {  0      call sscat(chia2,costhe,sinthe);
            {  0  }
               0  ;
               0
               0  "The following macro will allow the use of better single scattering"
               0  "cross sections (PWA) and/or to take into account double counting  "
               0  "of the contribution of atomic electrons to the scattering power   "
               0
               0  REPLACE {$SET-SCREENING-ANGLE(#);} WITH
               0  "        ========================                   "
               0  {
            {  0      chia2   = xcc(medium)/(4*{P1}*({P1} + rmt2)*blcc(medium));
            {  0  }
               0  ;
               0
               0  REPLACE {$HARD-SCATTERING;} WITH {;}
               0  ;
               0
               0  REPLACE {$TURN_OFF_SCATTERING} WITH {;}
               0  ;
               0  "If the above is redefined in a user code or uncommented here                 "
               0  "REPLACE {$TURN_OFF_SCATTERING} WITH {;cost = 1.000; sint = 0.000; return;}   "
               0  "this will turn off all single and multiple scattering                        "
               0  "DR April 2012   see corresponding 2 additions to egsnrc,mortran in           "
               0  "                subroutines sscat and mscat
               0
1              0  %E "egsnrc.macros"
               0
               0  REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;
            {  0    IF(callhowfar | wt(np) <= 0) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
            {  0    IF( ustep > dnear(np) | wt(np) <= 0 ) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWNEAR(#);} WITH
               0  {
            {  0      OUTPUT 35; "35 in decimal is ascii code for the pound sign"
            {  0      (
            {  0          ' '/
            {  0          ' '/
            {  0          ' ***************************************************************'/
            {  0          ' ***************************************************************'/
            {  0          ' '/
            {  0          ' PRESTA-II is aborting execution because you have not defined   '/
            {  0          ' the HOWNEAR macro for your geometry.                           '/
            {  0          ' '/
            {  0          ' You MUST either do so or employ a limited form of PRESTA-II    '/
            {  0          ' which does not attempt the refined boundary crossing or lateral'/
            {  0          ' correlation features of the algorithm.                         '/
            {  0          ' '/
            {  0          ' If you include the following macro in your usercode:           '/
            {  0          ' '/
            {  0          ' REPLACE {$CALL-HOWNEAR(',a,');} WITH {;}                       '/
            {  0          ' '/
            {  0          ' you can choose between single scattering mode (very slow) and  '/
            {  0          ' standard EGS4 mode (no PRESTA enhancments) by the appropriate  '/
            {  0          ' choice of the parameters in your input file (see the PRESTA-II '/
            {  0          ' manual)                                                        '/
            {  0          ' '/
            {  0          ' ***************************************************************'/
            {  0          ' ***************************************************************'/
            {  0          ' '/
            {  0          ' '/
            {  0      );
            {  0      stop;
            {  0  }
               0
               0  "For compability with user codes with PRESTA-I implemented"
               0  REPLACE {$PRESTA-INPUT-SUMMARY;} WITH {;}
               0  REPLACE {$PRESTA-INPUTS;}        WITH {;}
               0
               0  "If you want to read P-II inputs using the get_input() routine by "
               0  "A. Merovitz and D.W.O.R. you need to either place the following  "
               0  "three macros at the top of your user code, or after the default"
               0  "definitions given below"
               0
               0  ;
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.true.} "To not use get_input replace this "
               0                                          "with .false.                      "
               0
               0  "The following are the ones used by default"
               0
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.false.}
               0
               0
               0  ;
1              0  %E    "egsnrc.macros"
               0
               0  "Macro for azimuthal angle selection
               0  "using a sampling within a box method
               0  "Choose a point randomly within a box such that
               0  "-1 <= x <= 1 and 0 <= y < = 1
               0  "Reject the set if it lies without the inscribed unit semicircle centered
               0  "at (x,y) = (0,0)
               0  "once out of the loop, use the trigonimetric relations (TeX notation)
               0  "\cos 2\phi = (x^2 - y^2)/(x^2 + y^2)
               0  "\sin 2\phi = 2xy/(x^2 + y^2)
               0  REPLACE {$SELECT-AZIMUTHAL-ANGLE(#,#);} WITH
               0  {
            {  0  ;
            {  0  LOOP
            {  0  [
            {  0      $RANDOMSET xphi;
            {  0      xphi  = 2*xphi - 1;
            {  0      xphi2 = xphi*xphi;
            {  0      $RANDOMSET yphi;
            {  0      yphi2  = yphi*yphi;
            {  0      rhophi2 = xphi2 + yphi2;
            {  0  ]WHILE(rhophi2 > 1);
            {  0  rhophi2 = 1/rhophi2;
            {  0  {P1}  = (xphi2 - yphi2)*rhophi2;
            {  0  {P2}  = 2*xphi*yphi*rhophi2;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;} WITH {;
            {  0    $REAL xphi,xphi2,yphi,yphi2,rhophi2;
            {  0  };
               0
1              0  %E     "egsnrc.macros"
               0  "************************************************************************"
               0  "                                                                        "
               0  "                 Definitions of local variables                         "
               0  "                                                                        "
               0  "************************************************************************"
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ANNIH;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PAVIP,    "precise total energy in the laboratory frame"
            {  0        PESG1,    "precise energy of 1st annihilation photon"
            {  0        PESG2;    "precise energy of 2nd annihilation photon"
            {  0  $REAL AVIP,     "total energy in the laboratory frame"
            {  0        A,        "total energy in units of the electron's rest energy"
            {  0        G,T,P,    "energy, kinetic energy and momentum in units of RM"
            {  0        POT,      "P/T"
            {  0        EP0,      "minimum fractional energy"
            {  0        WSAMP,    "to avoid un-necessary calc. of Log((1-ep0)/ep0)"
            {  0        RNNO01,   "random numbers"
            {  0        RNNO02,
            {  0        EP,       "fractional energy of the more energetic photon"
            {  0        REJF,     "rejection function"
            {  0        ESG1,     "energy of the more energetic photon"
            {  0        ESG2,     "energy of the less energetic photon"
            {  0        aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi;
            {  0                  "for inline rotations"
            {  0  $INTEGER
            {  0        ibr;
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BHABHA;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIP,     "precise total energy of incident positron"
            {  0        PEKIN,    "precise kinetic energy of incident positron"
            {  0        PEKSE2,   "precise kinetic energy of second 'electron'"
            {  0        PESE1,    "precise total energy of first 'electron'"
            {  0        PESE2,    "precise total energy of second 'electron'"
            {  0        H1,       "used in direction cosine calculations"
            {  0        DCOSTH;   "polar scattering angle for more energetic 'electron'"
            {  0  $REAL EIP,      "total energy of incident positron"
            {  0        EKIN,     "kinetic energy of incident positron"
            {  0        T0,       "kinetic energy of incident positron in units of RM"
            {  0        E0,       "total energy of incident positron in units of RM"
            {  0        E02,      "E0**2"
            {  0        YY,       "1/(T0+2)"
            {  0        Y2,YP,YP2,"various functions of YY"
            {  0        BETA2,    "incident positron velocity in units of c"
            {  0        EP0,      "minimum fractional energy of a secondary 'electron'"
            {  0        EP0C,     "1-EP0"
            {  0        B1,B2,B3,B4,  "used in rejection function calculation"
            {  0        RNNO03,RNNO04,"random numbers"
            {  0        BR,       "kinetic energy fraction of the 2nd 'electron'"
            {  0        REJF2,    "rejection function"
            {  0        ESE1,     "total energy of 1st 'electron'"
            {  0        ESE2;     "total energy of 2nd 'electron'"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BREMS;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0    PEIE,   "precise incident electron energy"
            {  0    PESG,   "presice energy of emitted photon"
            {  0    PESE;   "precise total energy of scattered electron"
            {  0  $REAL
            {  0    EIE,    "total incident electron energy"
            {  0    EKIN,   "kinetic incident energy"
            {  0    brmin,  " ap(medium)/ekin"
            {  0    waux,   "for faster sampling of 1/br"
            {  0    aux,    "ese/eie"
            {  0    r1,     "a random number"
            {  0    ajj,    "for energy bin determination if alias sampling is employed"
            {  0    alias_sample1,
            {  0    RNNO06, "random number"
            {  0    RNNO07, "random number"
            {  0    BR,     "energy fraction of secondary photon"
            {  0    ESG,    "energy of secondary photon"
            {  0    ESE,    "total energy of secondary electron"
            {  0    DELTA,  "scaled momentum transfer"
            {  0    phi1,   "screening function"
            {  0    phi2,   "screening function"
            {  0    REJF;   "screening rejection function"
            {  0
            {  0  "Brems angle selection variables"
            {  0  $REAL
            {  0    a,b,c,  "direction cosines of incident `electron'"
            {  0    sinpsi, sindel, cosdel, us, vs,
            {  0            "all used for rotations"
            {  0    ztarg,  "(Zeff**1/3/111)**2, used for 2BS angle sampling"
            {  0    tteie,  "total energy in units of rest energy"
            {  0    beta,   "electron velocity in units of speed of light"
            {  0    y2max,  "maximum possible scaled angle"
            {  0    y2maxi, "inverse of the above"
            {  0    ttese,  "new electron energy in units of rm"
            {  0    rjarg1,rjarg2,rjarg3,rejmin,rejmid,rejmax,rejtop,rejtst,
            {  0            "all of them used for angle rejection function calcs"
            {  0    esedei, "new total energy over old total energy"
            {  0    y2tst,  "scaled angle, costhe = 1 - 2*y2tst/y2max"
            {  0    y2tst1,
            {  0    rtest,  "random number for rejection"
            {  0    xphi,yphi,xphi2,yphi2,rhophi2,cphi,sphi;
            {  0            "all of the above is for azimuthal angle sampling"
            {  0
            {  0  $INTEGER
            {  0    L,L1,ibr,jj,j;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-BREMS-ANGLE;} WITH
               0  {;
            {  0  "Local variables for photon angle selection"
            {  0  $REAL ZTARG,  "( (1/111)*Zeff**(1/3) )**2"
            {  0        TTEIE,  "total incident electron energy in units of RM"
            {  0        TTESE,  "total scattered electron energy in units of RM"
            {  0        ESEDEI, "TTESE/TTEIE"
            {  0        beta,   "electron speed in units of c"
            {  0        Y2MAX,  "maximum value of the scaled angle"
            {  0        RJARG1,RJARG2,RJARG3,
            {  0                "arguments for which the rejection function is calculated"
            {  0        REJMIN,REJMID,REJMAX,
            {  0                "corresponding values of the rejection function"
            {  0        REJTOP, "max(REJMIN,REJMID,REJMAX)"
            {  0        Y2TST,  "random number and candidate for a scaled angle"
            {  0        REJTST, "rejection function at Y2TST"
            {  0        Y2TST1, "aux. variable for rejection function calculation"
            {  0        REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0        RTEST;  "random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,   "precise energy of incident photon"
            {  0        PESG,   "precise energy of scattered photon"
            {  0        PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0        broi,   "1+2*ko"
            {  0        broi2,  "broi*broi"
            {  0        bro,    "1/broi"
            {  0        bro1,   "1-bro"
            {  0        alph1,  "probability for the 1/BR part"
            {  0        alph2,  "probability for the BR part"
            {  0        alpha,  "alpha1/(alph1+alph2)"
            {  0        rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0                "random numbers"
            {  0        br,     "scattered photon energy fraction"
            {  0        temp,   "aux. variable for polar angle calculation"
            {  0        rejf3,  "rejection function"
            {  0        rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0        Uj,     "binding energy of the selected shell"
            {  0        Jo,     "the Compton profile parameter"
            {  0        br2,    "br*br"
            {  0        fpz,fpz1,"used for limited pz-range rejection"
            {  0        qc,     "momentum transfer corresponding to the Compton line energy"
            {  0        qc2,    "qc squared"
            {  0        af,     "for calculating F"
            {  0        Fmax,   "maximum of F"
            {  0        frej,   "used for F-rejection"
            {  0        eta_incoh, eta, "random numbers"
            {  0        aux,aux1,aux2,aux3,aux4, "aux. variables"
            {  0        pzmax,  "max. possible z-component of the initial electron momentum"
            {  0        pz,     "initial electron momentum projection"
            {  0        pz2,    "pz*pz"
            {  0        rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0        irl,    "local region number"
            {  0        i,      "loop variable for shell sampling (and then shell sampled)"
            {  0        j,      "pointer to the shell in the shell data list"
            {  0        iarg,   "argument for ausgab call"
            {  0        ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT-old;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,   "precise energy of incident photon"
            {  0        PESG,   "precise energy of scattered photon"
            {  0        PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0        broi,   "1+2*ko"
            {  0        broi2,  "broi*broi"
            {  0        bro,    "1/broi"
            {  0        bro1,   "1-bro"
            {  0        alph1,  "probability for the 1/BR part"
            {  0        alph2,  "probability for the BR part"
            {  0        alpha,  "alpha1/(alph1+alph2)"
            {  0        rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0                "random numbers"
            {  0        br,     "scattered photon energy fraction"
            {  0        temp,   "aux. variable for polar angle calculation"
            {  0        rejf3,  "rejection function"
            {  0        rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0        Uj,     "binding energy of the selected shell"
            {  0        br2,    "br*br"
            {  0        aux,aux1,aux2,"aux. variables"
            {  0        pzmax2, "max. possible momentum transfer squared"
            {  0        pz,     "momentum transfer prejection"
            {  0        pz2,    "pz*pz"
            {  0        rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0        irl,    "local region number"
            {  0        i,      "loop variable for shell sampling (and then shell sampled)"
            {  0        j,      "pointer to the shell in the shell data list"
            {  0        iarg,   "argument for ausgab call"
            {  0        ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ELECTR;} WITH
               0  {;
            {  0  " Local ELECTR variables"
            {  0  $ENERGY PRECISION "($ENERGY PRECISION means double precision)"
            {  0      demfp,        "differential electron mean free path"
            {  0      peie,         "precise energy of incident electron"
            {  0      total_tstep,  "total path-length to next discrete interaction"
            {  0      total_de      "total energy loss to next discrete interaction"
            {  0  ;
            {  0  $REAL
            {  0      ekems,      "kinetic energy used to sample MS angle (normally midpoint)"
            {  0      elkems,     "Log(ekems)"
            {  0      chia2,      "Multiple scattering screening angle"
            {  0      etap,       "correction to Moliere screening angle from PWA cross sections"
            {  0      lambda,     "number of mean free paths (elastic scattering cross section)"
            {  0      blccl,      "blcc(medium)*rhof"
            {  0      xccl,       "xcc(medium)*rhof"
            {  0      xi,         "used for PLC calculations (first GS moment times path-length)"
            {  0      xi_corr,    "correction to xi due to spin effects"
            {  0      ms_corr,
            {  0      p2,         "electron momentum times c, squared"
            {  0      beta2,      "electron speed in units of c, squared"
            {  0      de,         "energy loss to dedx"
            {  0      save_de,    "de saved before $DE-FLUCTUATION"
            {  0      dedx,       "stopping power after density scaling"
            {  0      dedx0,      "stopping power before density scaling"
            {  0      dedxmid,    "stopping power at mid-step before density scaling"
            {  0      ekei,       "used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0      elkei,      "Log(ekei), used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0      aux,        "aux. variable"
            {  0      ebr1,       "e- branching ratio into brem"
            {  0      eie,        "energy of incident electron"
            {  0      ekef,       "kinetic energy after a step"
            {  0      elkef,      "Log(ekef)"
            {  0      ekeold,     "kinetic energy before a step"
            {  0      eketmp,     "used to evaluate average kinetic energy of a step"
            {  0      elktmp,     "log(eketmp)"
            {  0      fedep,      "fractional energy loss used in stopping power calculation"
            {  0      tuss,       "sampled path-length to a single scattering event"
            {  0      pbr1,       "e+ branching ratio into brem"
            {  0      pbr2,       "e+ branching ratio into brem or Bhabha"
            {  0      range,      "electron range"
            {  0      rfict,      "rejection function for fictitious cross section"
            {  0      rnne1,      "random number"
            {  0      rnno24,     "random number"
            {  0      rnno25,     "random number"
            {  0      rnnotu,     "random number"
            {  0      rnnoss,     "random number"
            {  0      sig,        "cross section after density scaling but before a step"
            {  0      sig0,       "cross section before density scaling but before a step"
            {  0      sigf,       "cross section before density scaling but after a step"
            {  0      skindepth,  "skin depth employed for PRESTA-II boundary crossing"
            {  0      ssmfp,      "distance of one single elastic scattering mean free path"
            {  0      tmxs,       "electron step-size restriction"
            {  0      tperp,      "perpendicular distance to the closest boundary"
            {  0      ustep0,     "temporary storage for ustep"
            {  0      uscat,      "x-axis direction cosine for scattering"
            {  0      vscat,      "y-axis direction cosine for scattering"
            {  0      wscat,      "z-axis direction cosine for scattering"
            {  0      xtrans,     "final x-axis position after transport"
            {  0      ytrans,     "final y-axis position after transport"
            {  0      ztrans,     "final z-axis position after transport"
            {  0      cphi,sphi;  "for azimuthal angle selection for annih at rest"
            {  0
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0
            {  0  $INTEGER
            {  0      iarg,      "calling code for ausgab"
            {  0      idr,       "calling code for ausgab"
            {  0      ierust,    "error counter for negative ustep errors"
            {  0      irl,       "region number"
            {  0      lelec,     "charge of electron"
            {  0      qel,       " = 0 for electrons, = 1 for positrons "
            {  0      lelke,     "index into the energy grid of tabulated functions"
            {  0      lelkems,   "index into the energy grid of tabulated functions"
            {  0      lelkef,    "index into the energy grid of tabulated functions"
            {  0      lelktmp,   "index into the energy grid of tabulated functions"
            {  0      ibr;       "a loop variable"
            {  0
            {  0  $LOGICAL
            {  0      "BCA = boundary crossing algorithm"
            {  0      callhowfar, "= .true.  => BCA requires a call to howfar"
            {  0                  "= .false. => BCA does not require a call to howfar"
            {  0      domultiple, "= .true.  => inexact BCA requires multiple scattering"
            {  0      dosingle,   "= .true.  => exact BCA requires single scattering"
            {  0                  "= .false. => exact BCA requires no single scattering"
            {  0      callmsdist, "= .true.  => normal condensed-history transport"
            {  0                  "= .false. => one of the BCA's will be invoked"
            {  0      findindex,  "used for mscat"
            {  0      spin_index, "used for mscat with spin effects"
            {  0      compute_tstep
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-HATCH;} WITH
               0  {;
            {  0  "Local HATCH variables in alphabetical order"
            {  0
            {  0  $TYPE MBUF(72),MDLABL(8);
            {  0
            {  0  $REAL
            {  0      ACD   , "used to test goodness of sine-table look-up"
            {  0      ADEV  , "absolute deviation in sine-table look-up"
            {  0      ASD   , "used to test goodness of sine-table look-up"
            {  0      COST  , "cos(theta) from instrinsic library function"
            {  0      CTHET , "use to calculate cos(theta) according to look-up tables"
            {  0      DEL   , "leat squares delta for sine-table look-up"
            {  0      DFACT , "converts rl to dunits"
            {  0      DFACTI, "converts rl**-1 to dunits**-1"
            {  0      DUNITO, "units scaling varable"
            {  0      DUNITR, "saved value of dunit"
            {  0      FNSSS , "real form of integer nsinss"
            {  0      P     , "counter used in the pwr2i(i) = 1/2**(i - 1) construction"
            {  0      PZNORM, "used in $INITIALIZE-BREMS-ANGLE"
            {  0      RDEV  , "relative deviation in sine-table look-up"
            {  0      S2C2  , "sinthe**2 + costhe**2, used to test look-up table"
            {  0      S2C2MN, "min(s2c2)"
            {  0      S2C2MX, "max(s2c2)"
            {  0      SINT  , "sin(theta) from instrinsic library function"
            {  0      SX    , "sum of angles for least squared analysis of look-up table errors"
            {  0      SXX   , "sum**2 of angles for least square analysis of look-up table errors"
            {  0      SXY   , "sum of angle*sin(angle) for least squared analysis of look-up"
            {  0              "table errors"
            {  0      SY    , "sum of sin(angle) for least squared analysis of look-up table "
            {  0              "errors"
            {  0      WID   , "width of sine-table mesh sub-interval (sine-table algorithm)"
            {  0      XS    , "angle value in a sub-sub-interval (sine-table algorithm)"
            {  0      XS0   , "lower limit of a sub-sub-interval (sine-table algorithm)"
            {  0      XS1   , "upwer limit of a sub-sub-interval (sine-table algorithm)"
            {  0      XSI   , "beginning angle of a sun-interval (sine-table algorithm)"
            {  0      WSS   , "width of a sub-sub-interval (sine-table algorithm)"
            {  0      YS    , "sin(angle) for least squared analysis of look-up table errors"
            {  0      ZEROS(3); "zeros of sine, 0,pi,twopi"
            {  0
            {  0  $INTEGER
            {  0      I     , "generic do-loop variable"
            {  0      I1ST  , "flag = 0 on first pass"
            {  0      IB    , "do-loop variable used for reading the medium type"
            {  0      ID    , "integer value of -dunit, when dunit is negative"
            {  0      IE    , "do-loop variable for reading over elements in a compound/mixture"
            {  0      IL    , "do-loop variable used for reading the medium type"
            {  0      IM    , "do-loop variable looping over nmed, number of media"
            {  0      IRAYL , "Rayleigh switch read in from PEGS"
            {  0      IRN   , "do-loop variable over random set of sine-table look-ups"
            {  0      ISTEST, "flag that switches on test of sine function fit"
            {  0      ISUB  , "do-loop variable over sub-intervals of the sine look-up table"
            {  0      ISS   , "do-loop variable over sub-sub-intervals of the sine look-up table"
            {  0      IZ    , "used to locate an exact zero of a sun-interval mesh point in the"
            {  0              "sine-table look-up"
            {  0      IZZ   , "do-loop variable over the exact zeros of the sine-table look-up"
            {  0      J     , "do-loop variable looping over nmed, number of media"
            {  0      JR    , "do-loop variable looping over number of regions"
            {  0      LCTHET, "$SET INTERVAL index for cos(theta) from look-up table"
            {  0      LMDL  , "character width of medium header ' MEDIUM='"
            {  0      LMDN  , "character width of medium description"
            {  0      LTHETA, "$SET INTERVAL index for sin(theta) from look-up table"
            {  0      MD    , "temporary storage for the medium number"
            {  0      MXSINC, "number of intervals approximating the sine function"
            {  0      NCMFP , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be cumulative electron mean free path. Presently unused."
            {  0      NEKE  , "array size input from PEGS."
            {  0              "Number of electron mapped energy intervals."
            {  0      NGE   , "array size input from PEGS."
            {  0              "Number of photon mapped energy intervals."
            {  0      NGRIM , "Rayleigh cross section array size."
            {  0      NISUB , "mxsinc - 2. Size of array with endpoints removed."
            {  0      NLEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of electron energy intervals below threshold."
            {  0              "Presently unused."
            {  0      NM    , "number of media found in the "
            {  0      NRANGE, "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of intervals in an array giving the electron range."
            {  0              "Presently unused."
            {  0      NRNA  , "number of random angles testing sine function fit"
            {  0      NSEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of electron small energy intervals. Presently unused."
            {  0      NSGE  , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of gamma small energy intervals. Presently unused."
            {  0      NSINSS, "number of sub-intervals for each sine function interval"
            {  0      LOK($MXMED); "flag indicating that medium has been found in the PEGS "
            {  0                   "datafile"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-MOLLER;} WITH
               0  {;
            {  0  "Local MOLLER variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0       PEIE,   "precise total energy of incident electron"
            {  0       PEKSE2, "precise kinetic energy of 2nd secondary electron"
            {  0       PESE1,  "precise total energy of 1st secondary electron"
            {  0       PESE2,  "precise total energy of 2nd secondary electron"
            {  0       PEKIN,  "precise kinetic energy of incident electron"
            {  0       H1,     "used for polar scattering angle calculation"
            {  0       DCOSTH; "polar scattering angle squared"
            {  0  $REAL EIE,    "total energy of incident electron"
            {  0       EKIN,   "kinetic energy of incident electron"
            {  0       T0,     "kinetic energy of incident electron in units of RM"
            {  0       E0,     "total energy of incident electron in units of RM"
            {  0       EXTRAE, "energy above the Moller threshold"
            {  0       E02,    "E0**2"
            {  0       EP0,    "minimum alowed kinetic energy fraction"
            {  0       G2,G3,  "used for rejection function calculation"
            {  0       GMAX,   "maximum value of the rejection function"
            {  0       BR,     "kinetic energy fraction to lowew energy electron"
            {  0       R,      "(1-BR)/BR"
            {  0       REJF4,  "rejection function"
            {  0       RNNO27, "random number for BR sampling"
            {  0       RNNO28, "random number for rejection"
            {  0       ESE1,   "energy of 1st secondary electron"
            {  0       ESE2;   "energy of 2nd secondary electron"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PAIR;} WITH
               0  {;
            {  0  "Local PAIR variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,      "precise energy of incident photon"
            {  0        PESE1,     "precise energy of 1st 'electron'"
            {  0        PESE2;     "precise energy of 2nd 'electron'"
            {  0
            {  0  $REAL EIG,       "energy of incident photon"
            {  0        ESE2,      "total energy of lower energy 'electron'"
            {  0        RNNO30,RNNO31,rnno32,rnno33,rnno34,
            {  0                   "random numbers"
            {  0        DELTA,     "scaled momentum transfer"
            {  0        REJF,      "screening rejection function"
            {  0        rejmax,    "the maximum of rejf"
            {  0        aux1,aux2, "auxilary variables"
            {  0        Amax,      "Maximum of the screening function used with (br-1/2)**2"
            {  0        Bmax,      "Maximum of the screening function used with the uniform part"
            {  0        del0,      "delcm*eig"
            {  0        br,        "fraction of the available energy (eig-rmt2) going to the"
            {  0                   "lower energy `electron'"
            {  0        Eminus,Eplus,Eavail,rnno_RR;
            {  0
            {  0  $INTEGER
            {  0        L,L1;  "flags for high/low energy distributions"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;} WITH
               0  {;
            {  0  $REAL ESE,   "total energy of one of the 'electrons'"
            {  0        PSE,   "momentum corresponding to ESE"
            {  0        ZTARG, "( (1/111)*Zeff**(1/3) )**2"
            {  0        TTEIG, "incident photon energy in units of RM"
            {  0        TTESE, "energy of one of the 'electrons' in units of RM"
            {  0        TTPSE, "momentum of one of the 'electrons' in units of RM"
            {  0        ESEDEI,"TTESE/(TTEIG-TTESE) = ratio of secondary electron energies"
            {  0        ESEDER,"1/ESEDEI"
            {  0        XIMIN, "1st argument where rejection function might have a maximum"
            {  0        XIMID, "2nd argument where rejection function might have a maximum"
            {  0        REJMIN,"rejection function at XIMIN"
            {  0        REJMID,"rejection function at XIMID"
            {  0        REJTOP,"max(REJMIN,REJMID)"
            {  0        YA,XITRY,GALPHA,GBETA,
            {  0               "aux. variables for XIMID calculation"
            {  0        XITST, "random number for pair angle sampling"
            {  0        REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0        REJTST,"rejection function at XITST"
            {  0        RTEST; "random number for rejection"
            {  0  $INTEGER
            {  0        ICHRG; "loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTO;} WITH
               0  {;
            {  0  "Local PHOTO variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0        PEIG;         "precise energy of incident photon"
            {  0  $REAL BR,           "random number"
            {  0        sigma,        "elemental cross section"
            {  0        aux,aux1,     "aux. variables"
            {  0        probs($MXEL), "probability for an interaction with a given element"
            {  0        sigtot,       "total cross section"
            {  0        e_vac,        "shell binding energy"
            {  0        rnno_RR;      "for playing Russian Roulette"
            {  0  $INTEGER
            {  0        IARG,         "AUSGAB calling switch"
            {  0        iZ,           "Atomic number of the element the photon is "
            {  0                      "interactiong with"
            {  0        irl,          "local region number"
            {  0        ints($MXEL),  "energy interval number for a given element"
            {  0        j,ip,         "loop variables"
            {  0        n_warning,    "a warning counter"
            {  0        k;            "shell number"
            {  0
            {  0  $LOGICAL
            {  0        do_relax;
            {  0  save  n_warning;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;} WITH
               0  {;
            {  0  "Photo-electron angle selection variables"
            {  0  $REAL EELEC, "total energy of photo-electron"
            {  0        BETA,  "velocity of electron in units of c"
            {  0        GAMMA, "total energy of photo-electron in units of RM"
            {  0        ALPHA, "kinematic factor"
            {  0        RATIO, "=BETA/ALPHA"
            {  0        RNPHT, "random number"
            {  0        FKAPPA,"aux. variable for COSTHE calculation"
            {  0        XI,    "used in rejection function calculation"
            {  0        SINTH2,"SINTHE**2"
            {  0        RNPHT2;"random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-EDGSET;} WITH
               0  {;
            {  0  "Local EDGSET variables in order of their appearance"
            {  0  $REAL EALF(100),EBET(100),OMEG(100),PHOTOK(100),PKA(100);
            {  0        "see the data statements in EDGSETfor definition of these arrays"
            {  0  $INTEGER JJ,IZ,IMED,I;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTON;} WITH
               0  {;
            {  0  "Local PHOTON variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0      PEIG;   "precise photon energy"
            {  0  ;
            {  0  $REAL
            {  0      EIG,    "photon energy"
            {  0      RNNO35, "random number for default MFP selection"
            {  0      GMFPR0, "photon MFP before density scaling and coherent correction"
            {  0      GMFP,   "photon MFP after density scaling"
            {  0      COHFAC, "Rayleigh scattering correction"
            {  0      RNNO37, "random number for Rayleigh scattering selection"
            {  0      XXX,    "random number for momentum transfer sampling in Rayleigh"
            {  0      X2,     "scaled momentum transfer in Rayleigh scattering event"
            {  0      Q2,     "momentum transfer squared in Rayleigh scattering event"
            {  0      CSQTHE, "COSTHE**2"
            {  0      REJF,   "Rayleigh scattering rejection function"
            {  0      RNNORJ, "random number for rejection in Rayleigh scattering"
            {  0      RNNO36, "random number for interaction branching"
            {  0      GBR1,   "probability for pair production"
            {  0      GBR2,   "probability for pair + compton"
            {  0      T,      "used for particle exchange on the stack"
            {  0  "Ali:photonuc, 2 lines"
            {  0      PHOTONUCFAC, "photonuclear correction"
            {  0      RNNO39; "random number for photonuclear selection (RNNO38 is taken)"
            {  0  ;
            {  0  $INTEGER
            {  0      IARG,   "parameter for AUSGAB"
            {  0      IDR,    "parameter for AUSGAB"
            {  0      IRL,    "region number"
            {  0      LGLE,   "index for GMFP interpolation"
            {  0      LXXX;   "index for Rayleigh scattering cummulative distribution int."
            {  0  }
               0  ;
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTONUC;} WITH {;}
               0  ;
               0
               0  " Handling track-ends "
               0  " By default, just call AUSGAB and drop energy on the spot"
               0
               0  REPLACE {$ELECTRON-TRACK-END;} WITH {; $AUSCALL(idr); }
               0  REPLACE {$PHOTON-TRACK-END;}   WITH {; $AUSCALL(IDR); }
               0  ;
               0
               0  " Macros for the fictitious method  "
               0  "==================================="
               0
               0  " The following version uses sub-threshold energy loss "
               0  " as a measure of path-length => cross section is actual "
               0  " cross section divided by restricted stopping power "
               0  " The global maximum of this quantity called esig_e (electrons) or "
               0  " psig_e (positrons) and is determined in HATCH "
               0
               0  REPLACE {$EVALUATE-SIG0;} WITH
               0  "        ==============="
               0  {;
            {  0     IF( sig_ismonotone(qel,medium) ) [
            {  0         $EVALUATE-SIGF; sig0 = sigf;
            {  0     ]
            {  0     ELSE [
            {  0         IF( lelec < 0 ) [sig0 = esig_e(medium);]
            {  0         ELSE            [sig0 = psig_e(medium);]
            {  0     ]
            {  0  }
               0
               0  REPLACE {$EVALUATE-SIGF;} WITH
               0  "        ==============="
               0  {;
            {  0    IF(lelec < 0)
            {  0    [
            {  0        $EVALUATE sigf USING esig(elke);
            {  0        $EVALUATE dedx0 USING ededx(elke);
            {  0        sigf = sigf/dedx0;
            {  0    ]
            {  0    ELSE
            {  0    [
            {  0        $EVALUATE sigf USING psig(elke);
            {  0        $EVALUATE dedx0 USING pdedx(elke);
            {  0        sigf = sigf/dedx0;
            {  0    ]
            {  0  }
               0  ;
               0
               0  REPLACE {$EVALUATE-EBREM-FRACTION;} WITH {
            {  0      $EVALUATE ebr1 USING ebr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-PBREM-FRACTION;} WITH {
            {  0      $EVALUATE pbr1 USING pbr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-BHABHA-FRACTION;} WITH {
            {  0      $EVALUATE pbr2 USING pbr2(elke);
            {  0  };
               0
               0
               0  " Because the cross section is interactions per energy loss, no "
               0  " rhof-scaling is required "
               0  REPLACE {$SCALE-SIG0;} WITH
               0  "        ============"
               0  {
            {  0     sig = sig0;
            {  0  }
               0  ;
               0
               0  " Once the sub-threshold processes energy loss to the next discrete "
               0  " interaction is determined, the corresponding path-length has to be"
               0  " calculated. This is done by the macro below. This macro           "
               0  " assumes the energy at the begining to be eke, the logarithm of it "
               0  " elke, lelke - the corresponding interpolation index and makes     "
               0  " use of $COMPUTE-DRANGE(#,#,#,#,#,#)                               "
               0
               0  REPLACE {$CALCULATE-TSTEP-FROM-DEMFP;} WITH
               0  "        ============================"
               0  {;
            {  0    IF( compute_tstep ) [
            {  0      total_de = demfp/sig; fedep = total_de;
            {  0      ekef  = eke - fedep;
            {  0      IF( ekef <= E_array(1,medium) ) [ tstep = vacdst; ]
            {  0      ELSE
            {  0      [
            {  0        elkef = Log(ekef);
            {  0        $SET INTERVAL elkef,eke;
            {  0        IF( lelkef = lelke )
            {  0        [       " initial and final energy are in the same interpolation bin "
            {  0            $COMPUTE-DRANGE(eke,ekef,lelke,elke,elkef,tstep);
            {  0        ]
            {  0        ELSE
            {  0        [   " initial and final energy are in different interpolation bins, "
            {  0            " calc range from ekef to E(lelkef+1) and from E(lelke) to eke  "
            {  0            " and add the pre-calculated range from E(lelkef+1) to E(lelke) "
            {  0            ekei = E_array(lelke,medium);
            {  0            elkei = (lelke - eke0(medium))/eke1(medium);
            {  0            $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,tuss);
            {  0            ekei = E_array(lelkef+1,medium);
            {  0            elkei = (lelkef + 1 - eke0(medium))/eke1(medium);
            {  0            $COMPUTE-DRANGE(ekei,ekef,lelkef,elkei,elkef,tstep);
            {  0            tstep=tstep+tuss+
            {  0                    range_ep(qel,lelke,medium)-range_ep(qel,lelkef+1,medium);
            {  0        ]
            {  0      ]
            {  0      total_tstep = tstep;
            {  0      compute_tstep = .false.;
            {  0    ]
            {  0    tstep = total_tstep/rhof;  " non-default density scaling "
            {  0  }
               0  ;
               0
               0  " The following macro computes the path-length traveled while going from  "
               0  " energy {P1} to energy {P2}, both energies being in the same             "
               0  " interpolation bin, given by {P3}. {P4} and {P5} are the logarithms of   "
               0  " {P1} and {P2}. The expression is based on logarithmic interpolation as  "
               0  " used in EGSnrc (i.e. dedx = a + b*Log(E) ) and a power series expansion "
               0  " of the ExpIntegralEi function that is the result of the integration.    "
               0  " The result is returned in {P6}.                                         "
               0
               0  REPLACE {$COMPUTE-DRANGE(#,#,#,#,#,#);} WITH
               0  "        ============================="
               0  {
            {  0    fedep = 1 - {P2}/{P1};
            {  0    elktmp = 0.5*({P4}+{P5}+0.25*fedep*fedep*(1+fedep*(1+0.875*fedep)));
            {  0             " the above evaluates the logarithm of the midpoint energy"
            {  0    lelktmp = {P3};
            {  0    IF(lelec < 0) [
            {  0        $EVALUATE dedxmid USING ededx(elktmp);
            {  0        dedxmid = 1/dedxmid;
            {  0        aux = ededx1(lelktmp,medium)*dedxmid;
            {  0        "aux = ededx1(lelktmp,medium)/dedxmid;"
            {  0    ]
            {  0    ELSE [
            {  0        $EVALUATE dedxmid USING pdedx(elktmp);
            {  0        dedxmid = 1/dedxmid;
            {  0        aux = pdedx1(lelktmp,medium)*dedxmid;
            {  0        "aux = pdedx1(lelktmp,medium)/dedxmid;"
            {  0    ]
            {  0    aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6;
            {  0    "{P6} = fedep*{P1}/dedxmid*(1+aux);"
            {  0    {P6} = fedep*{P1}*dedxmid*(1+aux);
            {  0  }
               0  ;
               0
               0  " The following macro computes the range to the minimum table energy "
               0  " It uses $COMPUTE-DRANGE                                            "
               0  " Note that range_ep array is precomputed in subroutine mscati and   "
               0  " gives the range from the energy interval end points to AE for each "
               0  " medium.
               0
               0  REPLACE {$COMPUTE-RANGE;} WITH
               0  "        ==============="
               0  {
            {  0  ;
            {  0    ekei = E_array(lelke,medium);
            {  0    elkei = (lelke - eke0(medium))/eke1(medium);
            {  0    $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
            {  0    range = (range + range_ep(qel,lelke,medium))/rhof;
            {  0  }
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  " The following macro updates demfp. As energy loss is used as the  "
               0  " 'path-length' variable (see above), it just substracts the energy "
               0  " loss for the step.                                                "
               0  REPLACE {$UPDATE-DEMFP;} WITH
               0  "        =============="
               0  {
            {  0    demfp = demfp - save_de*sig;
            {  0    total_de = total_de - save_de;
            {  0    total_tstep = total_tstep - tvstep*rhof;
            {  0    IF( total_tstep < 1e-9 ) [ demfp = 0; ]
            {  0  }
               0  ;
               0
               0  " The following macro computes the energy loss due to sub-threshold "
               0  " processes for a path-length {P1}. The energy at the beginning of  "
               0  " the step is {P2}, {P3}=Log({P2}), {P4} is the interpolation index "
               0  " The formulae are based on the logarithmic interpolation for dedx  "
               0  " used in EGSnrc. The result is returned in {P5}. Assumes that      "
               0  " initial and final energy are in the same interpolation bin.       "
               0
               0  REPLACE {$COMPUTE-ELOSS(#,#,#,#,#);} WITH
               0  "        =========================="
               0  {;
            {  0    IF( lelec < 0 ) [
            {  0        $EVALUATE dedxmid USING ededx({P3});
            {  0        aux = ededx1({P4},medium)/dedxmid;
            {  0    ]
            {  0    ELSE [
            {  0        $EVALUATE dedxmid USING pdedx({P3});
            {  0        aux = pdedx1({P4},medium)/dedxmid;
            {  0    ]
            {  0
            {  0
            {  0
            {  0    {P5} = dedxmid*{P1}*rhof; "IK: rhof scaling bug, June 9 2006"
            {  0                              "rhof scaling must be done here and NOT in "
            {  0                              "$COMPUTE-ELOSS-G below!"
            {  0    fedep = {P5}/{P2};
            {  0    {P5} = {P5}*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1-
            {  0               0.25*fedep*(2-aux*(4-aux)))));
            {  0  }
               0  ;
               0
               0  " The following is a generalized version of $COMPUTE-ELOSS.        "
               0
               0  REPLACE {$COMPUTE-ELOSS-G(#,#,#,#,#);} WITH
               0  "        ============================"
               0  {
            {  0    tuss = range - range_ep(qel,{P4},medium)/rhof;
            {  0      " here tuss is the range between the initial energy and the next lower "
            {  0      " energy on the interpolation grid "
            {  0    IF( tuss >= {P1} ) [  " Final energy is in the same interpolation bin "
            {  0        $COMPUTE-ELOSS({P1},{P2},{P3},{P4},{P5});
            {  0
            {  0        "IK: rhof scaling bug, June 9 2006. rhof scaling is done in "
            {  0        "    $COMPUTE-ELOSS above!                                  "
            {  0    ]
            {  0    ELSE [ " Must find first the table index where the step ends using "
            {  0           " pre-calculated ranges                                     "
            {  0        lelktmp = {P4};
            {  0        tuss = (range - {P1})*rhof;
            {  0           " now tuss is the range of the final energy electron "
            {  0           " scaled to the default mass density from PEGS4      "
            {  0        IF( tuss <= 0 ) [ {P5} = {P2} - TE(medium)*0.99; ]
            {  0          " i.e., if the step we intend to take is longer than the particle "
            {  0          " range, the particle energy goes down to the threshold "
            {  0          "({P2} is the initial particle energy)  "
            {  0          "originally the entire energy was lost, but msdist_xxx is not prepared"
            {  0          "to deal with such large eloss fractions => changed July 2005."
            {  0        ELSE [
            {  0            WHILE ( tuss < range_ep(qel,lelktmp,medium) ) [
            {  0                lelktmp = lelktmp - 1; ]
            {  0            elktmp = (lelktmp+1-eke0(medium))/eke1(medium);
            {  0            eketmp = E_array(lelktmp+1,medium);
            {  0            "tuss = range_ep(qel,lelktmp+1,medium) - tuss;"
            {  0            "IK: rhof scaling bug, June 9 2006: because of the change in "
            {  0            "    $COMPUTE-ELOSS above, we must scale tuss by rhof        "
            {  0            tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof;
            {  0            $COMPUTE-ELOSS(tuss,eketmp,elktmp,lelktmp,{P5});
            {  0            {P5} = {P5} + {P2} - eketmp;
            {  0        ]
            {  0    ]
            {  0  }
               0  ;
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "
               0  "   The following is related to use of the NRC auxilliary get_inputs
               0  "   routine which is part of the standard NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "
               0  "============================================================================"
               0  "
               0  " Input stuff for the get_inputs() routine.                                  "
               0  " As the expirience has shown that get_inputs() is frequently used in several"
               0  " subroutines, I changed the parameter passed to get_inputs() to a common    "
               0  " block. Otherwise, the parameters have to be defined in each subroutine using"
               0  " get_inputs() and, with static variables, this lead to a memory use         "
               0  " explosion (e.g. 8 MB for CAVRZ vs. 0.8 MB without get_inputs()!)           "
               0  " IK, Dec. 1998                                                              "
               0
               0  REPLACE {$NMAX} WITH {100};
               0  REPLACE {$NVALUE} WITH {100};
               0  REPLACE {$STRING80} WITH {80};
               0  REPLACE {$STRING32} WITH {64};
               0  REPLACE {$STRING40} WITH {40};
               0  REPLACE {$STRING256} WITH {256};
               0  REPLACE {$MXALINP} WITH {5};
               0
               0  REPLACE {COMIN/GetInput/;} WITH
               0  "        ================"
               0  {
            {  0    ;COMMON/GetInput/
            {  0          ALLOWED_INPUTS($NMAX,0:$MXALINP), "Associates a name with each second "
            {  0                                     "array index(0:4) for a value sought"
            {  0          VALUES_SOUGHT($NMAX),      "Name of each input                 "
            {  0          CHAR_VALUE($NMAX,$NVALUE), "For returning character inputs     "
            {  0          VALUE($NMAX,$NVALUE),      "For returning int. or real inputs  "
            {  0          DEFAULT($NMAX),            "Default value, only for type 0 & 1 "
            {  0          VALUE_MIN($NMAX),          "Min and max value defining         "
            {  0          VALUE_MAX($NMAX),          "the acceptable input range         "
            {  0          NVALUE($NMAX),             "Number of values per value sought  "
            {  0          TYPE($NMAX),               "Type of the value sought           "
            {  0                                     "0 for integer                      "
            {  0                                     "1 for real                         "
            {  0                                     "2 for character                    "
            {  0                                     "3 for character with allowed_inputs"
            {  0          ERROR_FLAGS($NMAX),        "An error flag for each of the      "
            {  0                                     "attempted inputs                   "
            {  0          i_errors,                  "Unit no. for .errors output file   "
            {  0          NMIN, NMAX,                "Minimum and maximum index number of"
            {  0                                     "the values sought                  "
            {  0          ERROR_FLAG,                "0 for no errors, 1 for errors      "
            {  0          DELIMETER;                 "Name of the delimeter              "
            {  0     character ALLOWED_INPUTS*$STRING32,VALUES_SOUGHT*$STRING32,
            {  0               CHAR_VALUE*$STRING256,DELIMETER*$STRING32;
            {  0     $REAL     VALUE,DEFAULT,VALUE_MIN,VALUE_MAX;
            {  0     $INTEGER  NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors;
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_INPUT(#);} WITH { NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT; }
               0  ;
               0
               0  REPLACE {$GET_INPUTS(#,#);} WITH { NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT; }
               0  ;
               0
               0  "The following macro is used in the egs_init1 subroutine (in the file
               0  "egs_utilities.mortran.  Here it is replaced by null so that we insist that
               0  "the .egsinp file be opened with unit=5 (standard input) and the .egslog
               0  "file (if required) be opened with unit=6 (standard output).  This is
               0  "replaced by a search for available units in beamnrc_lib.mortran to avoid
               0  "unit collisions with BEAM shared library sources
               0
               0  REPLACE {$AVAILABLE_UNIT(#,#)} WITH {;}
               0
               0  " The following two macros are defined so that if the nrcaux.mortran file
               0  " is included in the configuration file these are defined at least.
               0  " If the NRC statistics routine  SIGMA is to be used these must have realistic
               0  " definitions in the user-code.
               0
               0  REPLACE {$MXDATA} WITH {1};
               0  REPLACE {$STAT} WITH {2};
               0
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "   The following is related to use of the NRC auxilliary
               0  "   routine xvgrplot which is called from some of the standard
               0  "   NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "============================================================================"
               0  REPLACE{$PLTDIM} WITH {300};"Unique array dimension for XVGRPLOT and PLOTSN"
               0                          "Suppresses warnings from Intel compiler on Windows"
               0                     "when arrays have different dimensions in diff. routines"
               0
1              0  %E   "egsnrc.macros"
               0  "***************************************************************************"
               0  "                                                                           "
               0  "         EGSnrc internal Variance Reduction Macros                         "
               0  "                                                                           "
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/EGS-VARIANCE-REDUCTION/;} WITH {;
            {  0
            {  0    common/egs_vr/
            {  0      e_max_rr($MXREG), "max energy at which to do range rejection (RR)"
            {  0      prob_RR,          "probability for survival in R. Roulette"
            {  0      nbr_split,        "do brems splitting if > 1"
            {  0      i_play_RR,        "0=>don't play Russian Roulette,1=>play Russian Roulette"
            {  0      i_survived_RR,    "0=> all particles survive RR, n=> n partilces were"
            {  0                        "eliminated by RR in this interaction"
            {  0      n_RR_warning,     "a counter for user errors"
            {  0      i_do_rr($MXREG);  "0=>no RR, region by region, 1=>there is RR"
            {  0    $REAL          e_max_rr,prob_RR;
            {  0    $INTEGER       nbr_split,i_play_RR,i_survived_RR,n_RR_warning;
            {  0    $SHORT_INT     i_do_rr;
            {  0  };
               0
               0  REPLACE {$MAX-RR-WARNING} WITH {50}
               0
               0  "This macro implements Russian Roulette (most useful  with brems splitting)"
               0  "It is more efficient than having the user do it via AUSGAB since it avoids"
               0  "considerable handling of the particles by ELECTR"
               0  "The user must set i_play_RR (defaults to 0) and prob_RR"
               0  "Both are in COMIN EGS-VARIANCE-REDUCTION"
               0  ""
               0  "Note that this macro is called as $PLAY RUSSIAN ROULETTE WITH ELECTRONS..."
               0  "Note also that subroutine pair has its own, internal version"
               0
               0  REPLACE {$PLAYRUSSIANROULETTEWITHELECTRONSFROM#;} WITH {;
            {  0
            {  0    i_survived_RR = 0;   "flag all survive"
            {  0    ;IF( i_play_RR = 1 ) [
            {  0        IF( prob_RR <= 0 ) [
            {  0            IF( n_RR_warning < $MAX-RR-WARNING ) [
            {  0              n_RR_warning = n_RR_warning + 1;
            {  0              OUTPUT prob_RR;
            {  0    ('**** Warning, attempt to play Roussian Roulette with prob_RR<=0! ',g14.6);
            {  0            ]
            {  0        ]
            {  0        ELSE [
            {  0            ip = {P1};
            {  0            LOOP [     "handle all particles from p1 to np"
            {  0                IF( iq(ip) ~= 0 ) [   "i.e. charged particles"
            {  0                    $RANDOMSET rnno_RR;
            {  0                    IF( rnno_RR < prob_RR ) [ "particle survives"
            {  0                        wt(ip) = wt(ip)/prob_RR;
            {  0                        ip = ip + 1; "increase local pointer"
            {  0                    ]
            {  0                    ELSE [                    "particle killed"
            {  0                        ;i_survived_RR = i_survived_RR + 1;
            {  0                        ;IF(ip < np) [
            {  0                            "=>replace it with last particle on stack"
            {  0                            e(ip) = e(np); iq(ip) = iq(np); wt(ip) = wt(np);
            {  0                            u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
            {  0                        ]
            {  0                        np = np-1; "reduce stack by one=> particle gone"
            {  0                    ] "end of kill particle block"
            {  0                ] ELSE [ "this is a photon, leave it. Change pointer" ip = ip+1; ]
            {  0            ] UNTIL (ip > np);
            {  0            "loops until either np is decreased to ip, or ip increased to np"
            {  0            IF( np = 0 ) [ " we need at least one particle on the stack "
            {  0                           " so that the transport routines can exit properly"
            {  0                np = 1; e(np) = 0; iq(np) = 0; wt(np) = 0;
            {  0            ]
            {  0        ] "end of russian roulette block"
            {  0    ] "end of flag set block"
            {  0  };
               0
               0  "*********************************************************************"
               0  "  Stuff related to radiative corrections for Compton scattering      "
               0  "                                                                     "
               0  "  For now we exclude such corrections by default. They can be        "
               0  "  included by adding the file rad_compton.mortran to the list of     "
               0  "  files used to build EGSnrc just before egsnrc.mortran              "
               0  "  The reason is that there is a fairly large amount of data needed   "
               0  "  and this would be wasteful if the effect turns out to be small     "
               0  "*********************************************************************"
               0
               0  REPLACE {$RADC_CHECK;} WITH {;}
               0  REPLACE {$RADC_REJECTION;} WITH {;}
               0  REPLACE {$RADC_WARNING;} WITH {;
            {  0      IF( radc_flag = 1 ) [
            {  0          $egs_warning(*,'You are trying to use radiative Compton corrections');
            {  0          $egs_info(*,'without having included rad_compton1.mortran');
            {  0          $egs_info('(a//)','Turning radiative Compton corrections OFF ...');
            {  0          radc_flag = 0;
            {  0      ]
            {  0  };
               0  REPLACE {$RADC_HATCH;} WITH {$RADC_WARNING;}
               0  REPLACE {$COMIN-RADC-INIT;} WITH {
            {  0          ;COMIN/RAD_COMPTON,EGS-IO,COMPTON-DATA,MEDIA,PHOTIN,USEFUL/;
            {  0  };
               0  REPLACE {$COMIN-RADC-SAMPLE;} WITH {
            {  0          ;COMIN/RAD_COMPTON,RANDOM,STACK,USEFUL,EGS-IO/;
            {  0  };
               0
               0
               0  "*********************************************************************"
               0  "  I/O, parallel processing, string manipulations, etc.
               0  "*********************************************************************"
               0
               0  "how many chunks do we want to split the parallel run into
               0  REPLACE {$N_CHUNKS} WITH {10};
               0
               0  " String manipulations, error messages, etc. "
               0  REPLACE {$cstring(#)} WITH {{P1}(:lnblnk1({P1}))};
               0  REPLACE {$set_string(#,#);} WITH {;
            {  0    DO i=1,len({P1}) [ {P1}(i:i) = {P2}; ] ;
            {  0  };
               0
               0  REPLACE {$egs_debug(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_fatal(#,#,#);} WITH {
            {  0    $warning('(/a)','***************** Error: ');
            {  0    $warning({P1},{P2});
            {  0    $warning('(/a)','***************** Quiting now.');
            {  0    $CALL_EXIT({P3});
            {  0  };
               0  REPLACE {$egs_fatal(#,#);} WITH {
            {  0    $warning('(/a)','***************** Error: ');
            {  0    $warning({P1},{P2});
            {  0    $warning('(/a)','***************** Quiting now.');
            {  0    $CALL_EXIT(1);
            {  0  };
               0  REPLACE {$egs_warning(#,#);} WITH {
            {  0    $warning('(/a)','***************** Warning: ');
            {  0    $warning({P1},{P2});
            {  0  };
               0  REPLACE {$warning(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_info(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$declare_write_buffer;} WITH {;};
               0  "****************************************************************"
               0  " Useful output macros that do not rely on standard output unit. "
               0  " Useful for debugging code after egs_finish call which closes   "
               0  " all open units (for instance after a parallel job finishes).   "
               0  "****************************************************************"
               0  REPLACE {$egs_track2(#,#,#,#);} WITH {
            {  0        open({P1},file={P2},action='write',position='append');
            {  0        write({P1},{P3}) {P4};
            {  0        $FLUSH_UNIT({P1});
            {  0        close({P1});
            {  0  };
               0  REPLACE {$egs_track1(#,#,#);} WITH {
            {  0        open(666,file={P1},action='write',position='append');
            {  0        write(666,{P2}) {P3};
            {  0        $FLUSH_UNIT(666);
            {  0        close(666);
            {  0  };
               0  REPLACE {$egs_track0(#,#);} WITH {
            {  0        open(666,file='track.log',action='write',position='append');
            {  0        write(666,{P1}) {P2};
            {  0        $FLUSH_UNIT(666);
            {  0        close(666);
            {  0  };
               0  "************************************************************"
               0
               0  " Common block containing various directories, file names, etc. "
               0  REPLACE {$mx_units} WITH {20};
               0  REPLACE {$max_extension_length} WITH {10};
               0  REPLACE {;COMIN/EGS-IO/;} WITH {;
            {  0    common /egs_io/ file_extensions($mx_units),
            {  0                    file_units($mx_units),
            {  0                    user_code,  "The name of the user code"
            {  0                    input_file, "The input file name with path but no extension"
            {  0                    output_file,"Same as above but for output"
            {  0                    pegs_file,  "The pegs file name with path and extension"
            {  0                    hen_house,  "The HEN_HOUSE directory"
            {  0                    egs_home,   "The EGS_HOME directory"
            {  0                    work_dir,   "The working directory within the user code dir."
            {  0                    host_name,  "The name of the host"
            {  0                    n_parallel, "if >0, number of parallel jobs"
            {  0                    i_parallel, "if >0, parallel job number"
            {  0                    first_parallel,"first parallel job (default is 1)"
            {  0                    n_max_parallel,"if parallel run, max. number of running jobs"
            {  0                    n_chunk,    "Histories per calculation chunk"
            {  0                    n_files,
            {  0                    i_input,    "unit no. for .egsinp if required"
            {  0                    i_log,      "unit no. for .egslog if required"
            {  0                    i_incoh,    "unit no. for Compton data"
            {  0                    i_nist_data, "unit no. for NIST data"
            {  0                    i_mscat,     "unit no. for multiple scattering data"
            {  0                    i_photo_cs,  "unit no. for photon cross-section data"
            {  0                    i_photo_relax,  "unit no. for photon relaxation data"
            {  0                    xsec_out,       "switches on/off xsection file output"
            {  0                    is_batch,       "True for batch mode"
            {  0                    is_uniform_run, "True for uniform parallel run control"
            {  0                    is_pegsless;    "true if you are running without pegs file"
            {  0    character input_file*256, output_file*256, pegs_file*256,
            {  0              file_extensions*$max_extension_length,
            {  0              hen_house*128, egs_home*128, work_dir*128, user_code*64,
            {  0              host_name*64;
            {  0    $INTEGER  n_parallel, i_parallel, first_parallel,n_max_parallel,
            {  0              n_chunk, file_units, n_files,i_input,i_log,i_incoh,
            {  0              i_nist_data,i_mscat,i_photo_cs,i_photo_relax, xsec_out;
            {  0    $LOGICAL  is_batch, is_pegsless, is_uniform_run;
            {  0  };
               0
               0  "The following macro sets the EGS_HOME directory               "
               0  "The defualt implementation is to use the environment variable "
               0  "EGS_HOME. But at the NRC EGS_HOME is set using the macro      "
               0  "$EGS_HOME defined in machine.macros.                          "
               0  REPLACE {$set_egs_home;} WITH {;
            {  0    $set_string(egs_home,' ');
            {  0    call getenv('EGS_HOME',egs_home);
            {  0  };
               0
               0
               0  " Initialization of various variables on a region-by-region basis "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$set-region-by-region-defaults;} WITH {;
            {  0  DO i=1,$MXREG [
            {  0      ecut(i) = $GLOBAL-ECUT; pcut(i) = $GLOBAL-PCUT; "cut-off energies"
            {  0      ibcmp(i) = $IBCMP-DEFAULT;    "Compton "
            {  0      iedgfl(i) = $IEDGFL-DEFAULT;  "Relaxations"
            {  0      iphter(i) = $IPHTER-DEFAULT;  "photo-electron angular distribution"
            {  0      smaxir(i) = $MAX-SMAX;        "maximum step size"
            {  0      i_do_rr(i) = 0;               "range rejection flag"
            {  0      e_max_rr(i) = 0;              "`save' energy for range rejection"
            {  0      med(i) = 1;                   "default medium"
            {  0      rhor(i) = 0;                  "default mass density"
            {  0      iraylr(i) = $IRAYLR-DEFAULT;  "Rayleigh flag"
            {  0  "Ali:photonuc, 1 line"
            {  0      iphotonucr(i) = $IPHOTONUCR-DEFAULT;  "photonuclear flag per region"]
            {  0  };
               0
               0  " Make sure ecut and pcut are at least ae/ap and set default densities "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$adjust_rhor_ecut_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0      MD=MED(JR);
            {  0      IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0          ECUT(JR)=max(ECUT(JR),AE(MD));
            {  0          PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0          "   USE STANDARD DENSITY FOR REGIONS NOT SPECIALLY SET UP"
            {  0          IF (RHOR(JR).EQ.0.0)[RHOR(JR)=RHO(MD);]
            {  0      ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$adjust_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0      MD=MED(JR);
            {  0      IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0          PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0      ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$start_new_particle;} WITH { medium = med(irl); };
               0
               0  REPLACE {$electron_region_change;} WITH {
            {  0      ir(np) = irnew; irl = irnew; medium = med(irl);
            {  0  };
               0  REPLACE {$photon_region_change;} WITH { $electron_region_change; }
               0
               0  REPLACE {$declare_max_medium;} WITH {;};
               0
               0  REPLACE {$need_bound_compton_data(#);} WITH {
            {  0    {P1} = .false.;
            {  0    DO j=1,$MXREG [
            {  0        medium = med(j);
            {  0        IF( medium > 0 & medium <= nmed) [
            {  0            IF( ibcmp(j) > 0 ) [ {P1} = .true.; EXIT; ]
            {  0        ]
            {  0    ]
            {  0  };
               0
               0  REPLACE {$need_relaxation_data(#);} WITH {
            {  0    {P1} = .false.;
            {  0    DO j=1,$MXREG [
            {  0        IF( iedgfl(j) > 0 & iedgfl(j) <= $MXELEMENT ) [ {P1} = .true.; EXIT; ]
            {  0    ]
            {  0  };
               0
               0  REPLACE {$need_rayleigh_data;} WITH {;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS:  DO I=1,$MXREG [
            {  0  IF(IRAYLR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT RAYLEIGH SCATTERING, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IRAYLM(J)=1; EXIT :LOOP-OVER-REGIONS:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$need_photonuc_data;} WITH {;
            {  0  IPHOTONUC=0;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS-PHOTONUC: DO I=1,$MXREG [
            {  0  IF(IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT PHOTONUCLEAR, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IPHOTONUCM(J)=1; IPHOTONUC=1; EXIT :LOOP-OVER-REGIONS-PHOTONUC:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  REPLACE {$set_ecutmn;} WITH {
            {  0    ecutmn = 1e30;
            {  0    DO i=1,$MXREG [
            {  0        IF( med(i) > 0 & med(i) <= nmed ) [
            {  0                  ecutmn = Min(ecutmn,ecut(i));
            {  0        ]
            {  0    ]
            {  0  };
               0
               0  " default numer of media. "
               0  REPLACE {$default_nmed} WITH {1}
               0
               0  REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH {;
            {  0  $egs_fatal('(a/a)',' Code cannot be run in pegsless mode.',
            {  0  ' Compile with required files and try again.');
            {  0  ;
            {  0  }
               0
               0  REPLACE {$INIT-PEGS4-VARIABLES;} WITH {;}
               0
               0  REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {;}
               0
               0  " The following macro is defined to fool the Intel Fortran compiler "
               0  " version 8.0, which miscompiles init_spin when certain optimizations"
               0  " are turned on and the code is run on an Athlon CPU. "
               0  REPLACE {$FOOL-INTEL-OPTIMIZER(#) #;} WITH {;
            {  0      IF( fool_intel_optimizer ) [ write({P1},*) {P2}; ]
            {  0  }
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc BEAMnrc user macros                                                 "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Blake Walters, 1995                                       "
               0  "                                                                             "
               0  "  Contributors:    Daryoush Sheikh-Bagheri                                   "
               0  "                   Dave Rogers                                               "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  A set of MORTRAN replacement macros for BEAMnrc that are available for     "
               0  "  modification.                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  !INDENT F4;
               0  !INDENT M4;
               0  ;
               0  REPLACE {$USER_MACROS_VERSION}
               0  WITH {' '}
               0  " **********************
               0  " Array size definition:
               0  " **********************
               0  REPLACE {$MAX_CMs} WITH {25}       "maximum number of CMs allowed"
               0  REPLACE {$MAX_CMsP1} WITH {{COMPUTE $MAX_CMs+1}}  "MAX_CMs+1"
               0  REPLACE {$NCASEMIN} WITH {100}     "min no. of cases in 1 run
               0  REPLACE {$NBATCH} WITH {10}        "no. of batches run is divided up into
               0  REPLACE {$COVMIN} WITH {10}        "min. no. of particles crossing a scoring"
               0  "zone for which covariance will be"
               0  "included in uncertainty estimate (for"
               0  "average energy/angle only)"
               0  REPLACE {$MXMED} WITH {12}         "max # of media
               0  REPLACE {$MXREG} WITH {3000}       "maximum number of regions (absolute)
               0  REPLACE {$MXSTACK} WITH {900000}   "maximum stack (much less if no brem split)
               0  REPLACE {$MAXBRSPLIT} WITH {2000}  "maximum number of bremsstrahlung splits
               0  "note that $MXSTACK must be adjusted too
               0  REPLACE {$MAX_DOSE_ZONE} WITH {1500} "maximum number of dose-scoring zones
               0  REPLACE {$MAXIT} WITH {12}         "maximum number of dose components to score
               0  REPLACE {$MAX_SC_PLANES} WITH {3}  "maximum number of fluence scoring planes
               0  REPLACE {$MAX_SC_ZONES} WITH {5}   "no. of radial scoring zones on each fluence
               0  "                                   scoring plane, minimum 2
               0  REPLACE {$MAX_SC_PARAMETERS} WITH {8} "number of parameters scored
               0  "Index 1 through 4 in scoring array - 1st crossing of scoring plane
               0  "Index 4 through 8 - particle or ancestors crossed scoring plane at least once
               0  "Index 1 & 5-number, 2 & 6-fluence, 3 & 7-energy, 4 & 8-angle wrt z-axis"
               0  REPLACE {$MAXPTS_SRC9} WITH {10}   "no of discrete points for source 9"
               0  REPLACE {$MXRDIST} WITH {1000}"no of POINTS IN RADIAL DISTRIBUTION FIT--src 15"
               0
               0  "$MXSTACK=2000 and $MAXBRSPLIT=250 are settings which allow selective
               0  "bremsstrahlung spltting
               0
               0  ;
               0  " *****************************
               0  " Parameter replacement macros:
               0  " *****************************
               0  REPLACE {$BDY_TOL} WITH {1.E-5}    "boundary tolerance for HOWFAR_$CMNAME
               0  "to account for round-off error
               0  REPLACE {$MIN_GAP} WITH {1.E-5}    "minimum air gap allowed between CM's
               0  REPLACE {$ONE-EPS} WITH {0.9999}   "used to keep the source inside target
               0  ;
               0  ;
               0  "                               LATCH MACROS ""toc:
               0  "                               ***********
               0  "
               0  REPLACE {$LATCH_NUMBER_OF_BITS} WITH {5}
               0  "$LATCH_NUMBER_OF_BITS is the number of bits used to record the region number,
               0  "when a secondary is created, using LATCH. If $LATCH_NUMBER_OF_BITS is set to
               0  "5, for example, bits 1 - 23 will be used for region bit set, bit 0 is used
               0  "to record whether the particle is a descendant of a brem photon while bits
               0  "24 - 28 (5 bits) will be used to record the region number. Bits 29 -31 are
               0  "reserved for rw-ph-sp. However, during a run bit 30 will be used for
               0  "contamination calculations.
               0  "
               0  " ***************************************
               0  " macros related to bit setting for LATCH
               0  " ***************************************
               0  "
               0  "   note BTEST etc are standard F77 extensions because of US military
               0  "   contract requirements
               0
               0  "Macro to set bit {P2} in {P1}  to 1
               0  REPLACE {$IBSET(#,#);} WITH {IBSET({P1},{P2});}
               0
               0  "Macro to set test bit {P2} in {P1}
               0  "      Note this may require a LOGICAL declaration wherever used"
               0  REPLACE {$BTEST(#,#)} WITH {BTEST({P1}, {P2}) }
               0
               0  "Macro to set bit {P2} in {P1}  to 0   "
               0  REPLACE {$IBCLR(#,#);} WITH {IBCLR({P1},{P2});}
               0  "note that above macros are defined in nrcc4mac.mortran, but may not
               0  "     be in earlier versions and so are included here.
               0  ;
               0  "******************************
               0  "V>BEAM CHARACTERIZATION MODELS
               0  "******************************
               0  "V>The following are the defaults for beam characterization models;
               0
               0  REPLACE {;COMIN/BMODEL/;} WITH {;}
               0  ;
               0  REPLACE {$BEAMMODEL_SOURCE_INPUT} WITH {
            {  0  OUTPUT;(///' SORRY, BEAM CHARACTERIZATION MODELS NOT IMPLEMENTED'//
            {  0  ' PLEASE START AGAIN WITH OTHER SOURCES'///);
            {  0  STOP; }
               0  ;
               0  REPLACE {$LOCAL-VARIABLES-SOURCE31} WITH {;}
               0  REPLACE {$BEAMMODEL_SOURCE_OUTPUT} WITH {;}
               0  REPLACE {$BEAMMODEL_INITIAL_ENERGY} WITH {;}
               0  REPLACE {$BEAMMODEL_SOURCE_SAMPLING} WITH {
            {  0  OUTPUT; (///' BEAM CHARACTERIZATION MODELS NOT IMPLEMENTED'///);}
               0  REPLACE {$BEAMMODEL_INPUT_OPTION} WITH {
            {  0  ;IF(IO_OPT > 1 & IO_OPT<4)[
            {  0  OUTPUT;(///' BEAM CHARACTERIZATION MODELS NOT IMPLEMENTED'//
            {  0  ' PLEASE USE OPTION 0 OR 1 FOR IO_OPT INSTEAD'///);
            {  0  STOP;];
            {  0  }
               0  REPLACE {$BEAMMODEL_READ_FILE} WITH {;}
               0  REPLACE {$BEAMMODEL_OSUMRY} WITH {;}
               0  REPLACE {$BEAMMODEL_DATA_ANALYSIS} WITH {;}
               0  REPLACE {$BEAMMODEL_DATA_OUTPUT} WITH {;}
               0  REPLACE {$BEAMMODEL_SRCOUT} WITH {;}
               0  REPLACE {$BEAMMODEL_PASSING_VARIABLES} WITH {;}
               0  ;
               0
               0  "If this is a beam shared library source that uses a phase space"
               0  "source and it is running in parallel, then the following macro"
               0  "gets replaced by code that specifies the portion of the phase"
               0  "space source to use"
               0  REPLACE {$SET_INPHSP_BEAM_SOURCE_PARALLEL;} WITH {;}
               0
               0  ;
               0
               0  "****************************************
               0  "   Phase-space output macros
               0  "****************************************
               0  "
               0  "   note:Use one of these macros if you
               0  "        want your phase space file
               0  "        stored in different location
               0  "        (change requires recompilation)
               0  "
               0  " The following is the default which is the standard way of
               0  " doing it, the phase space file is stored on local user code
               0  " directory
               0  REPLACE {$DIRECTORY-FOR-PHSP} WITH {$cstring(egs_home)//$cstring(user_code)};
               0  "
               0  " The following is to enable storing file at some other location.
               0  " for example, at location '/data/data005/somedir'
               0  "REPLACE {$DIRECTORY-FOR-PHSP} WITH {'/data/data005/somedir'};"
               0
               0  "******************************************************************************
               0  ;
               0  "                        CUSTOM USER MACROS FOR BEAM
               0  "                        ***************************
               0  "
               0  "  User replacement macros can be changed here or else in a separate file
               0  "  (to be concatenated with the code by modifying the sources.make file
               0  "   in your accelerator directory) to perform user-specified functions.
               0  ;
               0  "user macro executed in AUSGAB.  Executed before anything else in AUSGAB."
               0  REPLACE {$USER-AUSGAB;} WITH {;}
               0
               0  "macro for inputting/initializing custom variables"
               0  REPLACE {$USER-INIT;} WITH {;}
               0
               0  "tasks to be performed at the end of the run (eg data analysis, output)"
               0  REPLACE {$USER-FINISH;} WITH {;}
               0
               0  "extra data to be written to .egsdat file for restarts, recombination"
               0  "after parallel.  {P1} is the unit number of the file."
               0  REPLACE {$USER-WRITE-DAT(#);} WITH {;}
               0
               0  "extra data to be from .egsdat file for restarts, recombination"
               0  "after parallel.  {P1} is the unit number of the file."
               0  REPLACE {$USER-READ-DAT(#);} WITH {;}
               0
               0  "allow definition of custom user variables to add to USER common blocks"
               0  REPLACE {;COMIN/USER-CUSTOM-VARIABLES/;} WITH {;}
               0
               0  "macro in subroutine combine_results which will allow user to recombine"
               0  "their own data after a parallel run"
               0  REPLACE {$USER-COMBINE-RESULTS;} WITH {;}
               0  REPLACE {$USER-ADD-DATA(#);} WITH {;}
               0  REPLACE {$USER-RESET-DATA;} WITH {;}
               0
               0  "macro at the top of subroutine kill_the_photons to allow user to modify"
               0  "how this is done."
               0  REPLACE {$USER-KILL-PHOTONS;} WITH {;}
               0
               0  "macro for user to do things just before a call to shower"
               0  REPLACE {$USER-BEFORE-SHOWER;} WITH {;}
               0
               0  "macro for user to do things just after a call to shower"
               0  REPLACE {$USER-AFTER-SHOWER;} WITH {;}
               0
               0  " end of beamnrc_user_macros.mortran"
               0  ;
1              0  %E
               0  %I4                                                                            ;
               0  !INDENT F2;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  "#############################################################################"
               0  "                                                                             "
               0  " EGSnrc machine dependent macro file for linux                               "
               0  "                                                                             "
               0  " Created by configure version 2.0 on mar 19 ago 2025 15:59:50 -03            "
               0  "                                                                             "
               0  " You may add your own machine dependent macros to this file,                 "
               0  " but be carefull to not overwrite it if you re-run configure.                "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0  REPLACE {$MACHINE} WITH
               0  {,'linux',};
               0  REPLACE {$HEN_HOUSE} WITH
               0  {'/home/usuario/EGSnrc_CLRP/HEN_HOUSE/'};
               0  REPLACE {$CANONICAL_SYSTEM} WITH
               0  {'x86_64-unknown-linux-gnu'};
               0  REPLACE {$CONFIGURATION_NAME} WITH
               0  {'linux'};
               0  REPLACE {$EGS_CONFIG} WITH
               0  {'/home/usuario/EGSnrc_CLRP/HEN_HOUSE/specs/linux.conf'};
               0
               0  REPLACE {$CONFIG_TIME} WITH
               0  {'2025-08-19 18:59:50 UTC'};
               0
               0  " System dependent stuff "
               0  "========================================"
               0  " Unfortunately, there appears to be no reliable way of copying files "
               0  " under Fortran => we use a system call for this"
               0  REPLACE {$copy_file} WITH {'cp '};
               0
               0  " Although one can move files using Fortran's intrinsic rename, "
               0  " we don't know whether the user has not created additional files in "
               0  " the temporary working directory => it is easiest to use a system call "
               0  " to move all files from the temporary working directory to the user-code "
               0  " directory. "
               0  REPLACE {$move_file} WITH {'mv -f '};
               0
               0  " There appears to be no way of removing a directory from Fortran "
               0  " => we use a system call for this. "
               0  REPLACE {$remove_directory} WITH {'rm -rf '};
               0
               0  " The directory separator "
               0  REPLACE {$file_sep} WITH {'/'};
               0
               0  REPLACE {$LONG_INT} WITH { integer*8 };
               0  REPLACE {$SHORT_INT} WITH { integer*2 };
               0  "$MAX_INT SET TO 2^63-1 in egsnrc.macros"
               0  "The machine byte order"
               0  REPLACE {$BYTE_ORDER} WITH {'1234'};
               0  ;
               0  REPLACE {$RECL-FACTOR} WITH {4};
               0  ;
               0  REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
               0  ;
               0  " If you want your user-code to return an exit status, use the "
               0  " following macro to terminate execution"
               0  REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
               0  ;
               0  " mortran3 gets confused by the # char => we need to pass it as an "
               0  " argument to the macro. "
               0  REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
               0  ;
               0  REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc function to get index of last non-blank character in a string       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2004                                       "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  $INTEGER function lnblnk1(string);
               0
               0  "Function to return index of last non-blank character in a string"
               0  "We use this instead of lnblnk because there are compilers"
               0  "that do not have lnblnk"
               0
               0  "******************************************************************************
               0  character*(*) string;
               0  DO i=len(string),1,-1 [
               1      j = ichar(string(i:i));
               1      IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
               1      "0-terminated C-strings"
               1      IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
               2          lnblnk1 = i; return;
               2          ]
               1      ]
               0  lnblnk1 = 0; return; end;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc program to build a BEAMnrc accelerator                              "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Blake Walters, 2004                                       "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  This program takes as argument the name of a spec_module file (with no     "
               0  "  '.module' extension). It then reads the file                               "
               0  "                                                                             "
               0  "  $EGS_HOME/beamnrc/spec_modules/spec_module.module                          "
               0  "                                                                             "
               0  "  to obtain the CM types and identifiers (user given names) of the modules   "
               0  "  that make up the accelerator and creates the following files:              "
               0  "                                                                             "
               0  "  1. $EGS_HOME/beamnrc/BEAM_spec_module/BEAM_spec_module_cm.mortran          "
               0  "  2. $EGS_HOME/beamnrc/BEAM_spec_module/BEAM_spec_module_macros.mortran      "
               0  "  3. $EGS_HOME/beamnrc/BEAM_spec_module/modules.make                         "
               0  "  4. $EGS_HOME/beamnrc/BEAM_spec_module/sources.make                         "
               0  "  5. $EGS_HOME/beamnrc/BEAM_spec_module/Makefile                             "
               0  "                                                                             "
               0  "  Files 4 and 5 are only created if they don't exist, i.e., the named        "
               0  "  accelerator is being created for the first time (file  4 is actually an    "
               0  "  empty file but it must be there because the Makefile looks for it). Files  "
               0  "  1, 2, and 3 are always created. While creating files 1 and 2, all          "
               0  "  occurrences of $CM in $CM_cm.mortran and $CM_macros.mortran are replaced   "
               0  "  by the identifying name of the $CM in question.                            "
               0  "                                                                             "
               0  "  This little tool is used to                                                "
               0  "                                                                             "
               0  "  a) create a new BEAMnrc user code from a spec_module file                  "
               0  "                                                                             "
               0  "  b) re-create the macros and mortran files if there have been any           "
               0  "     changes in the CM source files or in the spec_module file. This         "
               0  "     is done from within the Makefile using the dependencies rules.          "
               0  "                                                                             "
               0  "  Initial version: Blake Walters, Jan 18 - Jan 23 2004.                      "
               0  "                                                                             "
               0  "  Iwan Kawrakow, 2004:                                                       "
               0  "                                                                             "
               0  "  - create the modules.make file                                             "
               0  "  - create the sources.make file                                             "
               0  "  - create the Makefile                                                      "
               0  "  - use directory names that come from machine.macros                        "
               0  "    (HEN_HOUSE) and from the environment (EGS_HOME).                         "
               0  "  - return a proper exit status (0 on success,                               "
               0  "    1 on failure) so that make does not get confused                         "
               0  "    when using this tool.                                                    "
               0  "                                                                             "
               0  "  Iwan Kawrakow, 2005:                                                       "
               0  "                                                                             "
               0  "  read the list of files from beamnrc.spec and write it to sources.make so   "
               0  "  that it is easier to make changes.                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "useful macros"
               0  REPLACE {$SKIP LEADING BLANKS IN #;} WITH
               0  {;
            {  0  length = lnblnk1({P1});
            {  0  WHILE ( index({P1},blank) = 1 ) [
            {  0  IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
            {  0  length = length - 1;
            {  0  ]
            {  0  }
               0
               0  REPLACE {$cstring(#)} WITH {{P1}(:lnblnk1({P1}))};
               0
               0  program beam_build;
               0
               0  character*120 spec_module;
               0
               0  call getarg(1,spec_module);
               0
               0  IF(lnblnk1(spec_module)=0)[ "no spec_module specified"
               1      write(6,'(/a)')'**** Error: ';
               1      write(6,'(a)')'You have to provide the name of a spec_module (no extension)';
               1      write(6,'(a)')'on the command line.';
               1      write(6,'(/a)')'**** Quitting now.';
               1      $CALL_EXIT(1);
               1      ]
               0
               0  call build_accel($cstring(spec_module));
               0
               0  end;
               0
               0  subroutine build_accel(spec_module);
               0
               0  "Subroutine which actually does the work.  Note that this subroutine
               0  "assumes a very specific format for the spec_module.module file.
               0
               0  character*120 spec_module,omega_home,cm_home,spec_home,accel_home,
               0  accel_name,file_name,egs_home,beam_home,spec_file;
               0  character*10 cmtype($MAX_CMs),cmid($MAX_CMs);
               0  character*30 the_file;
               0  "$MAX_CMs is defined in beamnrc_user_macros.mortran"
               0  character*20 vname; "the variable name in the spec_module.module file"
               0  character*300 text; "used to store each line of the input file"
               0  character*1 blank;
               0  $INTEGER iindex,length,num_cms,num_ids,i,istat,egs_system,line,j;
               0  $INTEGER lnblnk1;
               0  logical fileexist,egs_isdir,first_time;
               0  character file_sep;
               0  "egs_isdir and egs_system are in $HEN_HOUSE/"
               0
               0  data blank/' '/;
               0
               0  file_sep = char(92);
               0
               0  "this stuff will have to be passed in somehow"
               0  call getenv('EGS_HOME',egs_home);
               0  IF( lnblnk1(egs_home) < 1 ) [
               1      write(6,*) '*** Error: Environment variable EGS_HOME is not set';
               1      write(6,*) '           quitting now';
               1      $CALL_EXIT(1);
               1      ]
               0  omega_home=$HEN_HOUSE // 'omega';
               0  spec_file=$HEN_HOUSE // 'specs' // $file_sep // 'beamnrc.spec';
               0  beam_home=$cstring(omega_home) // $file_sep // 'beamnrc';
               0  cm_home=$cstring(beam_home) // $file_sep // 'CMs' // $file_sep;
               0  spec_home=$cstring(egs_home) // 'beamnrc' // $file_sep // 'spec_modules'
               0  // $file_sep;
               0  accel_home=$cstring(egs_home) // 'BEAM_' // $cstring(spec_module)
               0  // $file_sep;
               0  accel_name=$cstring(accel_home)//'BEAM_'//$cstring(spec_module);
               0
               0  file_name=$cstring(spec_home)//$cstring(spec_module)//'.module';
               0  open(8,file=$cstring(file_name),status='old',err=:file_open_error:);
               0
               0  write(6,*)' Now reading CMs and identifiers from ',$cstring(file_name);
               0  read(8,end=:spec_text_end:,err=:text_err:,fmt='(A)') text;
               0  text=$cstring(text);
               0  vname='CM names';
               0  iindex=index(text,$cstring(vname));
               0  iindex=iindex+lnblnk1(vname)+1;
               0  text=text(iindex:); "strip off CM names text "
               0  iindex=index(text,':');
               0  text=text(iindex+1:); "strip off colon"
               0
               0  write(*,*)' text: ',text;
               0
               0  "now, loop through text and strip out all of the CM types"
               0  "assume types are already in upper case and no more than 8 characters long"
               0  num_cms=0;
               0  LOOP[
               1      IF(lnblnk1(text)=0) EXIT; "read all the text"
               1      $SKIP LEADING BLANKS IN text;
               1      num_cms=num_cms+1;
               1      cmtype(num_cms)=text(:index(text,blank)-1); "assume blanks between names"
               1      text=text(index(text,blank):);
               1      ]
               0
               0  read(8,end=:spec_text_end:,err=:text_err:,fmt='(A)') text;
               0  text=$cstring(text);
               0  vname='Identifiers';
               0  iindex=index(text,$cstring(vname));
               0  iindex=iindex+lnblnk1(vname)+1;
               0  text=text(iindex:); "strip off CM names text "
               0  iindex=index(text,':');
               0  text=text(iindex+1:); "strip off colon"
               0
               0  write(*,*)' text: ',text;
               0
               0  "now, loop through text and strip out all of the CM ids"
               0  "assume ids are no more than 8 characters long"
               0  num_ids=0;
               0  LOOP[
               1      IF(lnblnk1(text)=0) EXIT; "read all the text"
               1      $SKIP LEADING BLANKS IN text;
               1      num_ids=num_ids+1;
               1      cmid(num_ids)=text(:index(text,blank)-1); "assume blanks between names"
               1      text=text(index(text,blank):);
               1      ]
               0
               0  "finished reading CM types and identifiers and putting them into variables"
               0
               0  IF(num_ids ~= num_cms)[
               1      write(6,'(/a)')'**** Error: ';
               1      write(6,*)'Number of CM types and identifiers do not match';
               1      write(6,*)'in ',$cstring(spec_home)//$cstring(spec_module)//'.module';
               1      write(6,*)'Check the file and try again.';
               1      write(6,'(/a)')'**** Quitting now.';
               1      GOTO :abrupt_end:;
               1      ]
               0
               0  write(6,'(/a)')'Will use the following CM types and identifiers:';
               0  write(6,'(a,$)')' CM Names: ';
               0  do i=1,num_cms[
               1      write(6,'(a,'' '',$)') $cstring(cmtype(i));
               1      ]
               0  write(6,'(/a,$)')' Identifiers: ';
               0  do i=1,num_cms[
               1      write(6,'(a,'' '',$)') $cstring(cmid(i));
               1      ]
               0
               0  "now go to $OMEGA_HOME/beamnrc/CMs and get the _macros.mortran and"
               0  "_cm.mortran files and recopy them into"
               0  "$HOME/egsnrc/beamnrc/BEAM_spec_module/BEAM_spec_module_cm.mortran"
               0  "and $HOME/egsnrc/beamnrc/BEAM_spec_module/BEAM_spec_module_macros.mortran"
               0  "replacing $CM with the appropriate cmid as we do so"
               0
               0  "but first make sure the accelerator directory is there and, if not, create it"
               0  IF(~egs_isdir($cstring(accel_home)))[
               1      write(6,'(/a)')'Directory ',$cstring(accel_home);
               1      write(6,'(a)')'does not exist.  Creating it.';
               1      istat=egs_system('mkdir '//$cstring(accel_home));
               1      IF (istat~=0)[
               2          write(6,'(/a)')'**** Error creating directory ',$cstring(accel_home);
               2          write(6,'(a)')'**** Quitting now.';
               2          $CALL_EXIT(1);
               2          ]
               1      ]
               0
               0  write(6,'(//a)')'(Re)creating/checking files:';
               0  write(6,'(2x,a)')$cstring(accel_name)//'_cm.mortran and';
               0  write(6,'(2x,a)')$cstring(accel_name)//'_macros.mortran';
               0  write(6,'(2x,a)')$cstring(accel_home)//'Makefile';
               0  write(6,'(2x,a)')$cstring(accel_home)//'modules.make';
               0  write(6,'(2x,a)')$cstring(accel_home)//'sources.make';
               0  write(6,'(2x,a)')$cstring(accel_name)//'.io';
               0
               0  "See if the files are already there"
               0  inquire(file=$cstring(accel_name)//'_cm.mortran',exist=fileexist);
               0  IF (fileexist)[
               1      write(6,'(/a)')$cstring(accel_name)//'_cm.mortran already exists.';
               1      write(6,'(a)')' Will overwrite.';
               1      ]
               0  inquire(file=$cstring(accel_name)//'_macros.mortran',exist=fileexist);
               0  IF (fileexist)[
               1      write(6,'(a)')$cstring(accel_name)//'_macros.mortran already exists.';
               1      write(6,'(a)')' Will overwrite.';
               1      ]
               0  inquire(file=$cstring(accel_home)//'modules.make',exist=fileexist);
               0  IF (fileexist)[
               1      write(6,'(a)')$cstring(accel_home)//'modules.make already exists.';
               1      write(6,'(a)')' Will overwrite.';
               1      ]
               0
               0  "open the output files"
               0  file_name=$cstring(accel_name)//'_cm.mortran';
               0  open(9,file=$cstring(file_name),status='unknown',err=:file_open_error:);
               0  file_name=$cstring(accel_name)//'_macros.mortran';
               0  open(10,file=$cstring(file_name),status='unknown',err=:file_open_error:);
               0  file_name=$cstring(accel_home)//'modules.make';
               0  open(14,file=$cstring(file_name),status='unknown',err=:file_open_error:);
               0
               0  file_name=$cstring(accel_home)//'sources.make';
               0  inquire(file=$cstring(file_name),exist=fileexist);
               0  IF (fileexist)[
               1      write(6,'(/a)') 'File sources.make already exists. Leaving it untouched';
               1      ]
               0  ELSE [
               1      write(6,'(/a)') 'Creating sources.make ';
               1      open(15,file=$cstring(file_name),status='unknown',err=:file_open_error:);
               1      write(15,'(a)') '# Generated by beam_build ';
               1      write(15,'(a)') '#';
               1      write(15,'(a)')
               1      '# You may change the list of sources used to build this accelerator';
               1      write(15,'(a)') '# by adjusting the list of source files below';
               1      write(15,'(a)') '#';
               1      open(27,file=spec_file,status='old',err=:no_beam_specs:);
               1      iindex = 1;
               1      LOOP [
               2          read(27,'(a256)',err=:spec_error:,end=:spec_error:) text;
               2          i = index(text,'SOURCES =');
               2          IF( i = 1 ) [
               3              LOOP [
               4                  l = lnblnk1(text);
               4                  write(15,'(a)') text(:l);
               4                  IF( text(l:l) ~= char(92) ) goto :sources_ok:;
               4                  read(27,'(a256)',err=:spec_error:,end=:spec_error:) text;
               4                  ]
               3              ]
               2          ]
               1      :sources_ok:;
               1      rewind(27);
               1      write(15,*); iindex = 2;
               1      LOOP [
               2          read(27,'(a256)',err=:spec_error:,end=:spec_error:) text;
               2          i = index(text,'LIB_SOURCES =');
               2          IF( i = 1 ) [
               3              LOOP [
               4                  l = lnblnk1(text);
               4                  write(15,'(a)') text(:l);
               4                  IF( text(l:l) ~= char(92) ) goto :lib_sources_ok:;
               4                  read(27,'(a256)',err=:spec_error:,end=:spec_error:) text;
               4                  ]
               3              ]
               2          ]
               1      :lib_sources_ok:;
               1      close(15); close(27);
               1      ]
               0
               0
               0  file_name=$cstring(accel_home)//'Makefile';
               0  inquire(file=$cstring(file_name),exist=fileexist);
               0  IF (fileexist)[
               1      write(6,'(a)') 'A Makefile already exists. Leaving it untouched';
               1      ]
               0  ELSE [
               1      write(6,'(a)') 'Creating Makefile';
               1      open(15,file=$cstring(file_name),status='unknown',err=:file_open_error:);
               1      write(15,'(a)') '# Automatically created by beam_build.exe';
               1      write(15,'(a)') '#';
               1      write(15,'(a)') 'include $(EGS_CONFIG)';
               1      write(15,'(a)') 'include $(SPEC_DIR)beamnrc.spec';
               1      write(15,'(/a,a)') 'accelerator = ',$cstring(spec_module);
               1      write(15,'(/a)') 'include $(BEAM_MAKEFILE)';
               1      close(15);
               1      ]
               0  file_name=$cstring(accel_name)//'.io';
               0  inquire(file=$cstring(file_name),exist=fileexist);
               0  IF (fileexist)[
               1      write(6,'(a)') 'A .io file already exists. Leaving it untouched';
               1      ]
               0  ELSE [
               1      write(6,'(a)') 'Creating .io file';
               1      open(15,file=$cstring(file_name),status='unknown',err=:file_open_error:);
               1      file_name=$cstring(beam_home) // $file_sep // 'default_beam.io';
               1      open(16,file=$cstring(file_name),status='old',err=:file_open_error:);
               1      LOOP [
               2          read(16,end=:io_end:,err=:text_err:,fmt='(A)') text;
               2          write(15,'(a)') $cstring(text);
               2          ]
               1      :io_end:
               1      close(16); close(15);
               1      ]
               0
               0  " Write a header for the .make file "
               0  write(14,'(a,a)')
               0  '#  modules.make file for BEAM_',$cstring(spec_module);
               0  write(14,'(a)') '#';
               0  write(14,'(a)')
               0  '# Automatically generated by beam_build.exe';
               0  write(14,'(a)')
               0  '# Do not edit this file, all changes will be lost!';
               0  write(14,'(a)') '#';
               0
               0
               0
               0
               0
               0
               0  write(14,*);
               0
               0  " Write the macros files "
               0  write(14,'(a,a)') 'CM_MACRO_FILES = ',file_sep;
               0  DO i=1,num_cms [
               1      write(14,'(a,a,$)')
               1      '      $(CM_HOME)',$cstring(cmtype(i))//'_macros.mortran';
               1      IF( i < num_cms ) write(14,'(a)') file_sep;
               1      ]
               0  write(14,*); write(14,*);
               0  " Write the mortran files "
               0  write(14,'(a,a)') 'CM_MORTRAN_FILES = ',file_sep;
               0  DO i=1,num_cms [
               1      write(14,'(a,a,$)')
               1      '      $(CM_HOME)',$cstring(cmtype(i))//'_cm.mortran';
               1      IF( i < num_cms ) write(14,'(a)') file_sep;
               1      ]
               0  write(14,*);
               0
               0
               0  "Put stuff from $OMEGA_HOME/beamnrc/beamnrc_cm_macros.hdr into"
               0  "BEAM_spec_module_macros.mortran"
               0  file_name=$cstring(beam_home)//$file_sep//'beamnrc_cm_macros.hdr';
               0  open(11,file=$cstring(file_name),status='old',err=:file_open_error:);
               0  LOOP[
               1      read(11,end=:hdr_text_end:,err=:text_err:,fmt='(A)') text;
               1      write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               1      ]
               0  :hdr_text_end:
               0
               0  "Now, output the $CM_LIST and $CM_TYPE replacement macros into"
               0  "BEAM_spec_module_macros.mortran"
               0
               0  text='REPLACE{$CM_LIST} WITH {CMLIST(';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0  DO i=1,num_cms[
               1      text='      '//$cstring(cmid(i));
               1      IF(i<num_cms) text=$cstring(text)//',';
               1      write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               1      ]
               0  text='   )}';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0
               0  text='REPLACE{$CM_TYPE} WITH {CMTYPE(';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0  DO i=1,num_cms[
               1      text='      '//$cstring(cmtype(i));
               1      IF(i<num_cms) text=$cstring(text)//',';
               1      write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               1      ]
               0  text='   )}';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0
               0  "Now output a macro that lists the synchronized (SYNC) CM"
               0  "names and types in this accelerator"
               0
               0  text='REPLACE{$SYNC_CM_LIST} WITH {SYNCCMLIST(';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0  DO i=1,num_cms[
               1      IF(cmtype(i)='SYNCJAWS' | cmtype(i)='SYNCVMLC' | cmtype(i)='SYNCMLCE' |
               1      cmtype(i)='SYNCHDMLC') [
               2          text='      '//$cstring(cmid(i))//',';
               2          write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               2          ]
               1      ]
               0  "always terminate the list with a termination string"
               0  text='      END_SYNC_CMS';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0  text='   )}';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0
               0  text='REPLACE{$DYN_CM_LIST} WITH {DYNCMLIST(';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0  DO i=1,num_cms[
               1      IF(cmtype(i)='DYNJAWS' | cmtype(i)='DYNVMLC') [
               2          text='      '//$cstring(cmid(i))//',';
               2          write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               2          ]
               1      ]
               0  "always terminate the list with a termination string"
               0  text='      END_DYN_CMS';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0  text='   )}';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0
               0  text='REPLACE{$CM_TYPE} WITH {CMTYPE(';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0  DO i=1,num_cms[
               1      text='      '//$cstring(cmtype(i));
               1      IF(i<num_cms) text=$cstring(text)//',';
               1      write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               1      ]
               0  text='   )}';
               0  write(10,err=:text_write_err:,fmt='(A)') $cstring(text);
               0
               0  "now open the $CM_cm.mortran and $CM_macros.mortran files in cm_home"
               0  "read them line-by-line and output lines (with $CM replaced by $ID)"
               0  "in the appropriate files"
               0  DO i=1,num_cms[
               1      DO j=1,2["once for each output file"
               2
               2          IF(j=1)[
               3              the_file=$cstring(cmtype(i))//'_cm.mortran';
               3              ]
               2          ELSE[
               3              the_file=$cstring(cmtype(i))//'_macros.mortran';
               3              ]
               2          file_name=$cstring(cm_home)//$cstring(the_file);
               2          open(11,file=$cstring(file_name),status='old',err=:file_open_error:);
               2
               2          line=0;
               2          LOOP[
               3              read(11,end=:text_end:,err=:text_err:,fmt='(A)') text;
               3              line=line+1;
               3              LOOP["replace occurrence of $CM"
               4                  iindex=index(text,'$'//$cstring(cmtype(i)));
               4                  IF(iindex=0) EXIT; "no mor occurrences of string"
               4                  text=text(:iindex-1)//$cstring(cmid(i))//
               4                  text(iindex+lnblnk1(cmtype(i))+1:);
               4                  ]
               3              IF(lnblnk1(text)>80)[
               4                  write(6,'(/a)')'**** Warning: ';
               4                  write(6,*)'In file ',$cstring(file_name);
               4                  write(6,*)'Line ',line,' is >80 characters long after replacing $CM';
               4                  write(6,'(a)')'with $CMID.  This may cause problems during compile.';
               4                  ]
               3              "now output the text into the appropriate file"
               3              write(8+j,err=:text_write_err:,fmt='(A)') $cstring(text);
               3              ]
               2          :text_end:
               2          close(11);
               2          ]
               1      ]
               0
               0  "output the last line into BEAM_spec_module_cm.mortran"
               0  text='%N "Turn off MORTRAN listing';
               0  write(9,err=:text_write_err:,fmt='(A)') $cstring(text);
               0
               0  "now close the units we were just writing to"
               0  close(9);
               0  close(10);
               0
               0  $CALL_EXIT(0);
               0
               0  :no_beam_specs:;
               0  write(6,'(/a)') '**** Error: beamnrc.spec does not exist';
               0  GOTO :abrupt_end:;
               0
               0  :spec_error:;
               0  write(6,'(/a)') '**** Error:';
               0  IF( iindex = 1 ) [
               1      write(6,*) ' Failed to find SOURCES definition in beamnrc.spec';
               1      ]
               0  ELSE [
               1      write(6,*) ' Failed to find LIB_SOURCES definition in beamnrc.spec';
               1      ]
               0  GOTO :abrupt_end:;
               0
               0  :spec_text_end:
               0  write(6,'(/a)')'**** Error: ';
               0  write(6,*)'Something is wrong with the format';
               0  write(6,*)'of ',$cstring(spec_home)//$cstring(spec_module)//'.module';
               0  write(6,'(/a)')'**** Quitting now.';
               0  GOTO :abrupt_end:;
               0
               0  :text_err:
               0  write(6,'(/a)')'**** Error: ';
               0  write(6,*)'Error reading text ',text;
               0  write(6,*)'in ',$cstring(file_name);
               0  write(6,'(/a)')'**** Quitting now.';
               0  GOTO :abrupt_end:;
               0
               0  :file_open_error:
               0  write(6,'(/a)')'**** Error: ';
               0  write(6,*)'Could not open ',$cstring(file_name);
               0  write(6,'(/a)')'**** Quitting now.';
               0  GOTO :abrupt_end:;
               0
               0  :text_write_err:
               0  write(6,'(/a)')'**** Error: ';
               0  write(6,*)'Error writing text ',$cstring(text);
               0  write(6,*)'in file ',$cstring(file_name);
               0  write(6,'(/a)')'**** Quitting now.';
               0  GOTO :abrupt_end:;
               0
               0  :abrupt_end:
               0  $CALL_EXIT(1);
               0
               0  return; end;
               0  ;
               0  C##############################################################################
               0  C
               0  C   This file was automatically generated by configure version 2.0
               0  C   It contains various subroutines and functions for date, time,
               0  C   CPU time, host name, etc.
               0  C
               0  C   Attention: all changes will be lost the next time you run configure!
               0  C
               0  C##############################################################################
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_system subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C egs_system(command)  runs a system command and returns the status
               0  C                      command must be null-terminated
               0  C*****************************************************************************
               0  integer function egs_system(command)
               0  character*(*) command
               0  integer system, istat
               0  istat = system(command)
               0  egs_system = istat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_isdir subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C  egs_isdir(file_name)  Returns .true., if the string file_name points to
               0  C                        an existing directory. This version uses the lstat
               0  C                        intrinsic and then tests for bit 14 being set in
               0  C                        the mode element. This works on all Unix systems
               0  C                        that I have access to (Linux, Aix, HP-UX, OSF1,
               0  C                        Solaris, IRIX)
               0  C
               0  C*****************************************************************************
               0
               0  logical function egs_isdir(file_name)
               0  implicit none
               0  character*(*) file_name
               0  integer*4 lnblnk1, res, array(13), l, lstat
               0  logical btest
               0  egs_isdir = .false.
               0  l = lnblnk1(file_name)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
               0  ! On some systems lstat only works if the string is 0-terminated
               0  res = lstat(file_name,array)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
               0  if( res.eq.0 ) then
               0  ! Amost all compilers that have the lstat intrinsic return the
               0  ! file mode in the 3rd array element. But the PGI compiler has
               0  ! its own opinion on the subject and returns it in the 5th element
               0  ! That's why the relevant element is written as 3
               0  ! here, 3 gets replaced by the appropriate element
               0  ! by the configure script.
               0  if( btest(array(3),14) ) egs_isdir = .true.
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C***************************************************************************
               0  C
               0  C   egs_fdate(out):  print a 24 char date and time string in the form
               0  C                         'Tue Mar 18 08:16:42 2003'
               0  C                    to the unit specified by out without end of line
               0  C                    i.e. the sequence
               0  C                    write(6,'(a,$)') 'Today is '
               0  C                    call egs_fdate(6)
               0  C                    write(6,'(a)') '. Have a nice date'
               0  C                    should result in something like
               0  C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
               0  C                    printed to unit 6.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_fdate(ounit)
               0  integer ounit
               0  character*24 string
               0  call fdate(string)
               0  write(ounit,'(a,$)') string
               0  end
               0
               0  C***************************************************************************
               0  C
               0  C   egs_get_fdate(string) assignes a 24 char date and time string to string
               0  C                         string must be at least 24 chars long, otherwise
               0  C                         this subroutine has no effect.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_get_fdate(string)
               0  character*(*) string
               0  if( len(string).ge.24 ) call fdate(string)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date_and_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  subroutine egs_date_and_time(vnow)
               0  integer vnow(8)
               0  character dat*8,tim*10,zon*5
               0  call date_and_time(dat,tim,zon,vnow)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*************************************************************************
               0  C
               0  C egs_date(ounit): print a 11 char string in the form
               0  C                     '18-Mar-2003'
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_date(ounit)
               0  integer ounit
               0  character string*24, dat*11
               0  call fdate(string)
               0  dat(1:2) = string(9:10)
               0  dat(3:3) = '-'
               0  dat(4:6) = string(5:7)
               0  dat(7:7) = '-'
               0  dat(8:11) = string(21:24)
               0  write(ounit,'(a,$)') dat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
               0  C*************************************************************************
               0  C
               0  C egs_time(ounit): print a 8 char string in the form hh:mm:ss
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_time(ounit)
               0  integer ounit
               0  character string*24
               0  call fdate(string)
               0  write(ounit,'(a,$)') string(12:19)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc seconds timing subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_secnds(t0): returns seconds passed since midnight minus t0
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_secnds(t0)
               0  real t0,t1
               0  character dat*8,tim*10,zon*5
               0  integer values(8)
               0  call date_and_time(dat,tim,zon,values)
               0  t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
               0  egs_secnds = t1 - t0
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_tot_time()
               0  C
               0  C   On first call returns seconds passed since 1/1/1970
               0  C   On subsequent calls returns
               0  C     - seconds since last call, if flag = 0
               0  C     - seconds since first call, else
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_tot_time(flag)
               0  integer flag
               0  character dat*8,tim*10,zon*5
               0  integer vnow(8), vlast(8),i
               0  real t,egs_time_diff,t0
               0  data vlast/1970,1,1,5*0/,t0/-1/
               0  save vlast,t0
               0  call date_and_time(dat,tim,zon,vnow)
               0  t = egs_time_diff(vlast,vnow)
               0  do i=1,8
               0  vlast(i)=vnow(i)
               0  end do
               0  if( t0.lt.0 ) then
               0  t0 = 0
               0  egs_tot_time = t
               0  else
               0  t0 = t0 + t
               0  if(flag.eq.0) then
               0  egs_tot_time = t
               0  else
               0  egs_tot_time = t0
               0  end if
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date and time subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C****************************************************************************
               0  C
               0  C Returns the time difference between vstart and vend
               0  C vstart and vend are integer arrays of dimension 8 with elements
               0  C corresponding to the specification of the data_and_time routine, i.e.
               0  C   array(1) = year
               0  C   array(2) = month of the year   (1...12)
               0  C   array(3) = day of the month    (1...31)
               0  C   array(4) = difference in minutes from UTC
               0  C   array(5) = hour of the day     (1...23)
               0  C   array(6) = minute of the hour  (1...59)
               0  C   array(7) = seconds of the minute (1...59)
               0  C   array(8) = miliseconds of the second (1...999)
               0  C
               0  C Note: this implementation ignores the time difference from UTC field
               0  C
               0  C*****************************************************************************
               0  real function egs_time_diff(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  real       egs_time_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_time_diff = -egs_time_diff_o(vend,vstart)
               0  else
               0  egs_time_diff = egs_time_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C day difference between the dates specified by the integer arrays vstart and
               0  C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
               0  C
               0  C******************************************************************************
               0  integer function egs_day_diff(vstart,vend)
               0  integer vstart(3),vend(3),egs_day_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_day_diff = -egs_day_diff_o(vend,vstart)
               0  else
               0  egs_day_diff = egs_day_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns a 3-letter abreviation of the day of the week in the string day,
               0  C given a day specified by the integer array values
               0  C   values(1)=year, values(2)=month, values(3)=day
               0  C
               0  C******************************************************************************
               0  subroutine egs_weekday(values,day)
               0  character*(*) day
               0  integer       values(3)
               0  integer       days,vtmp(3),egs_day_diff,aux
               0  character*3   wdays(7)
               0  data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
               0  vtmp(1) = 1970
               0  vtmp(2) = 1
               0  vtmp(3) = 1
               0  days = egs_day_diff(vtmp,values)
               0  aux = mod(days,7)
               0  days = 4 + aux
               0  if( days.gt.7 ) days = days - 7
               0  day(:len(day)) = ' '
               0  aux = min(len(day),3)
               0  day(:aux) = wdays(days)(:aux)
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Same as egs_day_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C*****************************************************************************
               0  integer function egs_day_diff_o(vstart,vend)
               0  integer vstart(3),vend(3)
               0  integer    days
               0  logical    next_month
               0  integer    tm,m,ty,y
               0  integer    mdays(12)
               0  data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
               0  days = 0
               0  ty = vstart(1)
               0  y  = vend(1)
               0  tm = vstart(2)
               0  m  = vend(2)
               0  next_month = .true.
               0  do while(next_month)
               0  if( tm.eq.m.and.ty.eq.y ) then
               0  next_month = .false.
               0  else
               0  days = days + mdays(tm)
               0  if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
               0  tm = tm + 1
               0  if( tm.gt.12 ) then
               0  ty = ty + 1
               0  tm = 1
               0  end if
               0  end if
               0  end do
               0  days = days + vend(3) - vstart(3)
               0  egs_day_diff_o = days
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Same as egs_time_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C******************************************************************************
               0  real function egs_time_diff_o(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  integer    days,hours,minutes,secs,msecs
               0  integer    egs_day_diff_o
               0  days = egs_day_diff_o(vstart,vend)
               0  hours = vend(5) - vstart(5)
               0  minutes = vend(6) - vstart(6)
               0  secs = vend(7) - vstart(7)
               0  msecs = vend(8) - vstart(8)
               0  egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
               0  &                  0.001*msecs
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns in month a 3-letter abreviation of the month specified by mo, if
               0  C mo is between 1 and 12, or an empty string otherwise.
               0  C
               0  C******************************************************************************
               0  subroutine egs_month(mo,month)
               0  integer mo
               0  character*(*) month
               0  integer iaux
               0  character*3   months(12)
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  iaux = min(len(month),3)
               0  month(:len(month)) = ' '
               0  if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Converts a 3-letter abreviation of a month to its corresponding integer
               0  C value, if the string month is a valid month, or -1 otherwise.
               0  C
               0  C******************************************************************************
               0  integer function egs_conver_month(month)
               0  character*3 month
               0  character*3 months(12)
               0  integer i
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  do i=1,12
               0  if( month.eq.months(i) ) then
               0  egs_conver_month = i
               0  return
               0  end if
               0  end do
               0  egs_conver_month = -1
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_etime subroutine
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_etime(): returns CPU time consumed since the start of
               0  C                            the program
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_etime()
               0  real tarray(2),etime
               0  egs_etime = etime(tarray)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc canonical system name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_canonical_system(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_canonical_system(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('x86_64-unknown-linux-gnu')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'x86_64-unknown-linux-gnu'
               0  else
               0  res(:l2) = 'x86_64-unknown-linux-gnu'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc configuration name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the configuration name as specified suring the configuration
               0  C process to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_configuration_name(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'linux'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the configuration name as specified suring the configuration
               0  C process to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_configuration_name(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('linux')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'linux'
               0  else
               0  res(:l2) = 'linux'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc hostname subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C Print the host name to the unit specified by ounit without inserting
               0  C a new line character.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_hostnm(ounit)
               0  integer ounit
               0  character*256 string
               0  integer res,hostnm,lnblnk1
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  write(ounit,'(a,$)') string(:lnblnk1(string))
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Assign the host name to the string pointed to be hname.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_get_hostnm(hname)
               0  character*(*) hname
               0  character*256 string
               0  integer res,hostnm,lnblnk1,l1,l2,l
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  l1 = lnblnk1(string)
               0  l2 = len(hname)
               0  hname(:l2) = ' '
               0  l = min(l1,l2)
               0  hname(:l) = string(:l)
               0  return
               0  end
               0
               0
          END OF MORTRAN INPUT
  78      PERCENT RULE CAPACITY REMAINING
          NO MORTRAN ERRORS DETECTED
